{"id": "63360f3f588a4a30d2d2e43ee6ec3f724d38b546", "code": [{"0": "guava-gwt/pom.xml", "added": {"1": ["                    <contains text=\"@GwtCompatible\"/>\n", "                    <contains text=\"@GwtCompatible\"/>\n"]}, "removed": {"1": ["                    <and>\n", "                      <contains text=\"@GwtCompatible\"/>\n", "                      <not><contains text=\"emulated = true\"/></not>\n", "                    </and>\n", "                    <and>\n", "                      <contains text=\"@GwtCompatible\"/>\n", "                      <not><contains text=\"emulated = true\"/></not>\n", "                    </and>\n"]}, "added_lines": {"1": [229, 235]}, "removed_lines": {"1": [229, 230, 231, 232, 238, 239, 240, 241]}}, {"1": "guava-gwt/src-super/com/google/common/base/super/com/google/common/base/CharMatcher.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkPositionIndex;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "\n", "import java.util.Arrays;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "\n", "/**\n", " * Determines a true or false value for any Java {@code char} value, just as {@link Predicate} does\n", " * for any {@link Object}. Also offers basic text processing methods based on this function.\n", " * Implementations are strongly encouraged to be side-effect-free and immutable.\n", " *\n", " * <p>Throughout the documentation of this class, the phrase \"matching character\" is used to mean\n", " * \"any character {@code c} for which {@code this.matches(c)} returns {@code true}\".\n", " *\n", " * <p><b>Note:</b> This class deals only with {@code char} values; it does not understand\n", " * supplementary Unicode code points in the range {@code 0x10000} to {@code 0x10FFFF}. Such logical\n", " * characters are encoded into a {@code String} using surrogate pairs, and a {@code CharMatcher}\n", " * treats these just as two separate characters.\n", " *\n", " * <p>Example usages: <pre>\n", " *   String trimmed = {@link #whitespace() whitespace()}.{@link #trimFrom trimFrom}(userInput);\n", " *   if ({@link #ascii() ascii()}.{@link #matchesAllOf matchesAllOf}(s)) { ... }</pre>\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/StringsExplained#charmatcher\">\n", " * {@code CharMatcher}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 1.0\n", " */\n", "@Beta // Possibly change from chars to code points; decide constants vs. methods\n", "@GwtCompatible(emulated = true)\n", "public abstract class CharMatcher implements Predicate<Character> {\n", "\n", "  // Constant matcher factory methods\n", "\n", "  /**\n", "   * Matches any character.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code ANY})\n", "   */\n", "  public static CharMatcher any() {\n", "    return Any.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Matches no characters.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code NONE})\n", "   */\n", "  public static CharMatcher none() {\n", "    return None.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is whitespace according to the latest Unicode standard, as\n", "   * illustrated <a href=\"http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D\">here</a>.\n", "   * This is not the same definition used by other Java APIs. (See a <a\n", "   * href=\"http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ\">comparison of several\n", "   * definitions of \"whitespace\"</a>.)\n", "   *\n", "   * <p><b>Note:</b> as the Unicode definition evolves, we will modify this matcher to keep it up\n", "   * to date.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code WHITESPACE})\n", "   */\n", "  public static CharMatcher whitespace() {\n", "    return Whitespace.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is a breaking whitespace (that is, a whitespace which can be\n", "   * interpreted as a break between words for formatting purposes). See {@link #whitespace()} for a\n", "   * discussion of that term.\n", "   *\n", "   * @since 19.0 (since 2.0 as constant {@code BREAKING_WHITESPACE})\n", "   */\n", "  public static CharMatcher breakingWhitespace() {\n", "    return BreakingWhitespace.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is ASCII, meaning that its code point is less than 128.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code ASCII})\n", "   */\n", "  public static CharMatcher ascii() {\n", "    return Ascii.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is a digit according to\n", "   * <a href=\"http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D\">Unicode</a>.\n", "   * If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code DIGIT})\n", "   */\n", "  public static CharMatcher digit() {\n", "    return Digit.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is a digit according to {@linkplain Character#isDigit(char)\n", "   * Java's definition}. If you only care to match ASCII digits, you can use {@code inRange('0',\n", "   * '9')}.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code JAVA_DIGIT})\n", "   */\n", "  public static CharMatcher javaDigit() {\n", "    return JavaDigit.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is a letter according to {@linkplain Character#isLetter(char)\n", "   * Java's definition}. If you only care to match letters of the Latin alphabet, you can use {@code\n", "   * inRange('a', 'z').or(inRange('A', 'Z'))}.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code JAVA_LETTER})\n", "   */\n", "  public static CharMatcher javaLetter() {\n", "    return JavaLetter.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is a letter or digit according to {@linkplain\n", "   * Character#isLetterOrDigit(char) Java's definition}.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code JAVA_LETTER_OR_DIGIT}).\n", "   */\n", "  public static CharMatcher javaLetterOrDigit() {\n", "    return JavaLetterOrDigit.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is upper case according to {@linkplain\n", "   * Character#isUpperCase(char) Java's definition}.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code JAVA_UPPER_CASE})\n", "   */\n", "  public static CharMatcher javaUpperCase() {\n", "    return JavaUpperCase.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is lower case according to {@linkplain\n", "   * Character#isLowerCase(char) Java's definition}.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code JAVA_LOWER_CASE})\n", "   */\n", "  public static CharMatcher javaLowerCase() {\n", "    return JavaLowerCase.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is an ISO control character as specified by {@link\n", "   * Character#isISOControl(char)}.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code JAVA_ISO_CONTROL})\n", "   */\n", "  public static CharMatcher javaIsoControl() {\n", "    return JavaIsoControl.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is invisible; that is, if its Unicode category is any of\n", "   * SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and\n", "   * PRIVATE_USE according to ICU4J.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code INVISIBLE})\n", "   */\n", "  public static CharMatcher invisible() {\n", "    return Invisible.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Determines whether a character is single-width (not double-width). When in doubt, this matcher\n", "   * errs on the side of returning {@code false} (that is, it tends to assume a character is\n", "   * double-width).\n", "   *\n", "   * <p><b>Note:</b> as the reference file evolves, we will modify this matcher to keep it up to\n", "   * date.\n", "   *\n", "   * @since 19.0 (since 1.0 as constant {@code SINGLE_WIDTH})\n", "   */\n", "  public static CharMatcher singleWidth() {\n", "    return SingleWidth.INSTANCE;\n", "  }\n", "\n", "  // Legacy constants\n", "  // TODO(cgdecker): Deprecate these so they can be removed eventually\n", "\n", "  /**\n", "   * Determines whether a character is whitespace according to the latest Unicode standard, as\n", "   * illustrated <a href=\"http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D\">here</a>.\n", "   * This is not the same definition used by other Java APIs. (See a <a\n", "   * href=\"http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ\">comparison of several\n", "   * definitions of \"whitespace\"</a>.)\n", "   *\n", "   * <p><b>Note:</b> as the Unicode definition evolves, we will modify this constant to keep it up\n", "   * to date.\n", "   */\n", "  public static final CharMatcher WHITESPACE = whitespace();\n", "\n", "  /**\n", "   * Determines whether a character is a breaking whitespace (that is, a whitespace which can be\n", "   * interpreted as a break between words for formatting purposes). See {@link #WHITESPACE} for a\n", "   * discussion of that term.\n", "   *\n", "   * @since 2.0\n", "   */\n", "  public static final CharMatcher BREAKING_WHITESPACE = breakingWhitespace();\n", "\n", "  /**\n", "   * Determines whether a character is ASCII, meaning that its code point is less than 128.\n", "   */\n", "  public static final CharMatcher ASCII = ascii();\n", "\n", "  /**\n", "   * Determines whether a character is a digit according to\n", "   * <a href=\"http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D\">Unicode</a>.\n", "   * If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.\n", "   */\n", "  public static final CharMatcher DIGIT = digit();\n", "\n", "  /**\n", "   * Determines whether a character is a digit according to {@linkplain Character#isDigit(char)\n", "   * Java's definition}. If you only care to match ASCII digits, you can use {@code\n", "   * inRange('0', '9')}.\n", "   */\n", "  public static final CharMatcher JAVA_DIGIT = javaDigit();\n", "\n", "  /**\n", "   * Determines whether a character is a letter according to {@linkplain Character#isLetter(char)\n", "   * Java's definition}. If you only care to match letters of the Latin alphabet, you can use {@code\n", "   * inRange('a', 'z').or(inRange('A', 'Z'))}.\n", "   */\n", "  public static final CharMatcher JAVA_LETTER = javaLetter();\n", "\n", "  /**\n", "   * Determines whether a character is a letter or digit according to {@linkplain\n", "   * Character#isLetterOrDigit(char) Java's definition}.\n", "   */\n", "  public static final CharMatcher JAVA_LETTER_OR_DIGIT = javaLetterOrDigit();\n", "\n", "  /**\n", "   * Determines whether a character is upper case according to {@linkplain\n", "   * Character#isUpperCase(char) Java's definition}.\n", "   */\n", "  public static final CharMatcher JAVA_UPPER_CASE = javaUpperCase();\n", "\n", "  /**\n", "   * Determines whether a character is lower case according to {@linkplain\n", "   * Character#isLowerCase(char) Java's definition}.\n", "   */\n", "  public static final CharMatcher JAVA_LOWER_CASE = javaLowerCase();\n", "\n", "  /**\n", "   * Determines whether a character is an ISO control character as specified by {@link\n", "   * Character#isISOControl(char)}.\n", "   */\n", "  public static final CharMatcher JAVA_ISO_CONTROL = javaIsoControl();\n", "\n", "  /**\n", "   * Determines whether a character is invisible; that is, if its Unicode category is any of\n", "   * SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and\n", "   * PRIVATE_USE according to ICU4J.\n", "   */\n", "  public static final CharMatcher INVISIBLE = invisible();\n", "\n", "  /**\n", "   * Determines whether a character is single-width (not double-width). When in doubt, this matcher\n", "   * errs on the side of returning {@code false} (that is, it tends to assume a character is\n", "   * double-width).\n", "   *\n", "   * <p><b>Note:</b> as the reference file evolves, we will modify this constant to keep it up to\n", "   * date.\n", "   */\n", "  public static final CharMatcher SINGLE_WIDTH = singleWidth();\n", "\n", "  /** Matches any character. */\n", "  public static final CharMatcher ANY = any();\n", "\n", "  /** Matches no characters. */\n", "  public static final CharMatcher NONE = none();\n", "\n", "  // Static factories\n", "\n", "  /**\n", "   * Returns a {@code char} matcher that matches only one specified character.\n", "   */\n", "  public static CharMatcher is(final char match) {\n", "    return new Is(match);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code char} matcher that matches any character except the one specified.\n", "   *\n", "   * <p>To negate another {@code CharMatcher}, use {@link #negate()}.\n", "   */\n", "  public static CharMatcher isNot(final char match) {\n", "    return new IsNot(match);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code char} matcher that matches any character present in the given character\n", "   * sequence.\n", "   */\n", "  public static CharMatcher anyOf(final CharSequence sequence) {\n", "    switch (sequence.length()) {\n", "      case 0:\n", "        return none();\n", "      case 1:\n", "        return is(sequence.charAt(0));\n", "      case 2:\n", "        return isEither(sequence.charAt(0), sequence.charAt(1));\n", "      default:\n", "        // TODO(lowasser): is it potentially worth just going ahead and building a precomputed\n", "        // matcher?\n", "        return new AnyOf(sequence);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code char} matcher that matches any character not present in the given character\n", "   * sequence.\n", "   */\n", "  public static CharMatcher noneOf(CharSequence sequence) {\n", "    return anyOf(sequence).negate();\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code char} matcher that matches any character in a given range (both endpoints are\n", "   * inclusive). For example, to match any lowercase letter of the English alphabet, use {@code\n", "   * CharMatcher.inRange('a', 'z')}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code endInclusive < startInclusive}\n", "   */\n", "  public static CharMatcher inRange(final char startInclusive, final char endInclusive) {\n", "    return new InRange(startInclusive, endInclusive);\n", "  }\n", "\n", "  /**\n", "   * Returns a matcher with identical behavior to the given {@link Character}-based predicate, but\n", "   * which operates on primitive {@code char} instances instead.\n", "   */\n", "  public static CharMatcher forPredicate(final Predicate<? super Character> predicate) {\n", "    return predicate instanceof CharMatcher ? (CharMatcher) predicate : new ForPredicate(predicate);\n", "  }\n", "\n", "  // Constructors\n", "\n", "  /**\n", "   * Constructor for use by subclasses. When subclassing, you may want to override\n", "   * {@code toString()} to provide a useful description.\n", "   */\n", "  protected CharMatcher() {}\n", "\n", "  // Abstract methods\n", "\n", "  /** Determines a true or false value for the given character. */\n", "  public abstract boolean matches(char c);\n", "\n", "  // Non-static factories\n", "\n", "  /**\n", "   * Returns a matcher that matches any character not matched by this matcher.\n", "   */\n", "  public CharMatcher negate() {\n", "    return new Negated(this);\n", "  }\n", "\n", "  /**\n", "   * Returns a matcher that matches any character matched by both this matcher and {@code other}.\n", "   */\n", "  public CharMatcher and(CharMatcher other) {\n", "    return new And(this, other);\n", "  }\n", "\n", "  /**\n", "   * Returns a matcher that matches any character matched by either this matcher or {@code other}.\n", "   */\n", "  public CharMatcher or(CharMatcher other) {\n", "    return new Or(this, other);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code char} matcher functionally equivalent to this one, but which may be faster to\n", "   * query than the original; your mileage may vary. Precomputation takes time and is likely to be\n", "   * worthwhile only if the precomputed matcher is queried many thousands of times.\n", "   *\n", "   * <p>This method has no effect (returns {@code this}) when called in GWT: it's unclear whether a\n", "   * precomputed matcher is faster, but it certainly consumes more memory, which doesn't seem like a\n", "   * worthwhile tradeoff in a browser.\n", "   */\n", "  public CharMatcher precomputed() {\n", "    return Platform.precomputeCharMatcher(this);\n", "  }\n", "\n", "  private static final int DISTINCT_CHARS = Character.MAX_VALUE - Character.MIN_VALUE + 1;\n", "\n", "  // Text processing routines\n", "\n", "  /**\n", "   * Returns {@code true} if a character sequence contains at least one matching character.\n", "   * Equivalent to {@code !matchesNoneOf(sequence)}.\n", "   *\n", "   * <p>The default implementation iterates over the sequence, invoking {@link #matches} for each\n", "   * character, until this returns {@code true} or the end is reached.\n", "   *\n", "   * @param sequence the character sequence to examine, possibly empty\n", "   * @return {@code true} if this matcher matches at least one character in the sequence\n", "   * @since 8.0\n", "   */\n", "  public boolean matchesAnyOf(CharSequence sequence) {\n", "    return !matchesNoneOf(sequence);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if a character sequence contains only matching characters.\n", "   *\n", "   * <p>The default implementation iterates over the sequence, invoking {@link #matches} for each\n", "   * character, until this returns {@code false} or the end is reached.\n", "   *\n", "   * @param sequence the character sequence to examine, possibly empty\n", "   * @return {@code true} if this matcher matches every character in the sequence, including when\n", "   *         the sequence is empty\n", "   */\n", "  public boolean matchesAllOf(CharSequence sequence) {\n", "    for (int i = sequence.length() - 1; i >= 0; i--) {\n", "      if (!matches(sequence.charAt(i))) {\n", "        return false;\n", "      }\n", "    }\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if a character sequence contains no matching characters. Equivalent to\n", "   * {@code !matchesAnyOf(sequence)}.\n", "   *\n", "   * <p>The default implementation iterates over the sequence, invoking {@link #matches} for each\n", "   * character, until this returns {@code false} or the end is reached.\n", "   *\n", "   * @param sequence the character sequence to examine, possibly empty\n", "   * @return {@code true} if this matcher matches every character in the sequence, including when\n", "   *         the sequence is empty\n", "   */\n", "  public boolean matchesNoneOf(CharSequence sequence) {\n", "    return indexIn(sequence) == -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the first matching character in a character sequence, or {@code -1} if no\n", "   * matching character is present.\n", "   *\n", "   * <p>The default implementation iterates over the sequence in forward order calling {@link\n", "   * #matches} for each character.\n", "   *\n", "   * @param sequence the character sequence to examine from the beginning\n", "   * @return an index, or {@code -1} if no character matches\n", "   */\n", "  public int indexIn(CharSequence sequence) {\n", "    return indexIn(sequence, 0);\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the first matching character in a character sequence, starting from a\n", "   * given position, or {@code -1} if no character matches after that position.\n", "   *\n", "   * <p>The default implementation iterates over the sequence in forward order, beginning at {@code\n", "   * start}, calling {@link #matches} for each character.\n", "   *\n", "   * @param sequence the character sequence to examine\n", "   * @param start the first index to examine; must be nonnegative and no greater than {@code\n", "   *        sequence.length()}\n", "   * @return the index of the first matching character, guaranteed to be no less than {@code start},\n", "   *         or {@code -1} if no character matches\n", "   * @throws IndexOutOfBoundsException if start is negative or greater than {@code\n", "   *         sequence.length()}\n", "   */\n", "  public int indexIn(CharSequence sequence, int start) {\n", "    int length = sequence.length();\n", "    checkPositionIndex(start, length);\n", "    for (int i = start; i < length; i++) {\n", "      if (matches(sequence.charAt(i))) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the last matching character in a character sequence, or {@code -1} if no\n", "   * matching character is present.\n", "   *\n", "   * <p>The default implementation iterates over the sequence in reverse order calling {@link\n", "   * #matches} for each character.\n", "   *\n", "   * @param sequence the character sequence to examine from the end\n", "   * @return an index, or {@code -1} if no character matches\n", "   */\n", "  public int lastIndexIn(CharSequence sequence) {\n", "    for (int i = sequence.length() - 1; i >= 0; i--) {\n", "      if (matches(sequence.charAt(i))) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the number of matching characters found in a character sequence.\n", "   */\n", "  public int countIn(CharSequence sequence) {\n", "    int count = 0;\n", "    for (int i = 0; i < sequence.length(); i++) {\n", "      if (matches(sequence.charAt(i))) {\n", "        count++;\n", "      }\n", "    }\n", "    return count;\n", "  }\n", "\n", "  /**\n", "   * Returns a string containing all non-matching characters of a character sequence, in order. For\n", "   * example: <pre>   {@code\n", "   *\n", "   *   CharMatcher.is('a').removeFrom(\"bazaar\")}</pre>\n", "   *\n", "   * ... returns {@code \"bzr\"}.\n", "   */\n", "  @CheckReturnValue\n", "  public String removeFrom(CharSequence sequence) {\n", "    String string = sequence.toString();\n", "    int pos = indexIn(string);\n", "    if (pos == -1) {\n", "      return string;\n", "    }\n", "\n", "    char[] chars = string.toCharArray();\n", "    int spread = 1;\n", "\n", "    // This unusual loop comes from extensive benchmarking\n", "    OUT:\n", "    while (true) {\n", "      pos++;\n", "      while (true) {\n", "        if (pos == chars.length) {\n", "          break OUT;\n", "        }\n", "        if (matches(chars[pos])) {\n", "          break;\n", "        }\n", "        chars[pos - spread] = chars[pos];\n", "        pos++;\n", "      }\n", "      spread++;\n", "    }\n", "    return new String(chars, 0, pos - spread);\n", "  }\n", "\n", "  /**\n", "   * Returns a string containing all matching characters of a character sequence, in order. For\n", "   * example: <pre>   {@code\n", "   *\n", "   *   CharMatcher.is('a').retainFrom(\"bazaar\")}</pre>\n", "   *\n", "   * ... returns {@code \"aaa\"}.\n", "   */\n", "  @CheckReturnValue\n", "  public String retainFrom(CharSequence sequence) {\n", "    return negate().removeFrom(sequence);\n", "  }\n", "\n", "  /**\n", "   * Returns a string copy of the input character sequence, with each character that matches this\n", "   * matcher replaced by a given replacement character. For example: <pre>   {@code\n", "   *\n", "   *   CharMatcher.is('a').replaceFrom(\"radar\", 'o')}</pre>\n", "   *\n", "   * ... returns {@code \"rodor\"}.\n", "   *\n", "   * <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching\n", "   * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each\n", "   * character.\n", "   *\n", "   * @param sequence the character sequence to replace matching characters in\n", "   * @param replacement the character to append to the result string in place of each matching\n", "   *        character in {@code sequence}\n", "   * @return the new string\n", "   */\n", "  @CheckReturnValue\n", "  public String replaceFrom(CharSequence sequence, char replacement) {\n", "    String string = sequence.toString();\n", "    int pos = indexIn(string);\n", "    if (pos == -1) {\n", "      return string;\n", "    }\n", "    char[] chars = string.toCharArray();\n", "    chars[pos] = replacement;\n", "    for (int i = pos + 1; i < chars.length; i++) {\n", "      if (matches(chars[i])) {\n", "        chars[i] = replacement;\n", "      }\n", "    }\n", "    return new String(chars);\n", "  }\n", "\n", "  /**\n", "   * Returns a string copy of the input character sequence, with each character that matches this\n", "   * matcher replaced by a given replacement sequence. For example: <pre>   {@code\n", "   *\n", "   *   CharMatcher.is('a').replaceFrom(\"yaha\", \"oo\")}</pre>\n", "   *\n", "   * ... returns {@code \"yoohoo\"}.\n", "   *\n", "   * <p><b>Note:</b> If the replacement is a fixed string with only one character, you are better\n", "   * off calling {@link #replaceFrom(CharSequence, char)} directly.\n", "   *\n", "   * @param sequence the character sequence to replace matching characters in\n", "   * @param replacement the characters to append to the result string in place of each matching\n", "   *        character in {@code sequence}\n", "   * @return the new string\n", "   */\n", "  @CheckReturnValue\n", "  public String replaceFrom(CharSequence sequence, CharSequence replacement) {\n", "    int replacementLen = replacement.length();\n", "    if (replacementLen == 0) {\n", "      return removeFrom(sequence);\n", "    }\n", "    if (replacementLen == 1) {\n", "      return replaceFrom(sequence, replacement.charAt(0));\n", "    }\n", "\n", "    String string = sequence.toString();\n", "    int pos = indexIn(string);\n", "    if (pos == -1) {\n", "      return string;\n", "    }\n", "\n", "    int len = string.length();\n", "    StringBuilder buf = new StringBuilder((len * 3 / 2) + 16);\n", "\n", "    int oldpos = 0;\n", "    do {\n", "      buf.append(string, oldpos, pos);\n", "      buf.append(replacement);\n", "      oldpos = pos + 1;\n", "      pos = indexIn(string, oldpos);\n", "    } while (pos != -1);\n", "\n", "    buf.append(string, oldpos, len);\n", "    return buf.toString();\n", "  }\n", "\n", "  /**\n", "   * Returns a substring of the input character sequence that omits all characters this matcher\n", "   * matches from the beginning and from the end of the string. For example: <pre>   {@code\n", "   *\n", "   *   CharMatcher.anyOf(\"ab\").trimFrom(\"abacatbab\")}</pre>\n", "   *\n", "   * ... returns {@code \"cat\"}.\n", "   *\n", "   * <p>Note that: <pre>   {@code\n", "   *\n", "   *   CharMatcher.inRange('\\0', ' ').trimFrom(str)}</pre>\n", "   *\n", "   * ... is equivalent to {@link String#trim()}.\n", "   */\n", "  @CheckReturnValue\n", "  public String trimFrom(CharSequence sequence) {\n", "    int len = sequence.length();\n", "    int first;\n", "    int last;\n", "\n", "    for (first = 0; first < len; first++) {\n", "      if (!matches(sequence.charAt(first))) {\n", "        break;\n", "      }\n", "    }\n", "    for (last = len - 1; last > first; last--) {\n", "      if (!matches(sequence.charAt(last))) {\n", "        break;\n", "      }\n", "    }\n", "\n", "    return sequence.subSequence(first, last + 1).toString();\n", "  }\n", "\n", "  /**\n", "   * Returns a substring of the input character sequence that omits all characters this matcher\n", "   * matches from the beginning of the string. For example: <pre> {@code\n", "   *\n", "   *   CharMatcher.anyOf(\"ab\").trimLeadingFrom(\"abacatbab\")}</pre>\n", "   *\n", "   * ... returns {@code \"catbab\"}.\n", "   */\n", "  @CheckReturnValue\n", "  public String trimLeadingFrom(CharSequence sequence) {\n", "    int len = sequence.length();\n", "    for (int first = 0; first < len; first++) {\n", "      if (!matches(sequence.charAt(first))) {\n", "        return sequence.subSequence(first, len).toString();\n", "      }\n", "    }\n", "    return \"\";\n", "  }\n", "\n", "  /**\n", "   * Returns a substring of the input character sequence that omits all characters this matcher\n", "   * matches from the end of the string. For example: <pre> {@code\n", "   *\n", "   *   CharMatcher.anyOf(\"ab\").trimTrailingFrom(\"abacatbab\")}</pre>\n", "   *\n", "   * ... returns {@code \"abacat\"}.\n", "   */\n", "  @CheckReturnValue\n", "  public String trimTrailingFrom(CharSequence sequence) {\n", "    int len = sequence.length();\n", "    for (int last = len - 1; last >= 0; last--) {\n", "      if (!matches(sequence.charAt(last))) {\n", "        return sequence.subSequence(0, last + 1).toString();\n", "      }\n", "    }\n", "    return \"\";\n", "  }\n", "\n", "  /**\n", "   * Returns a string copy of the input character sequence, with each group of consecutive\n", "   * characters that match this matcher replaced by a single replacement character. For example:\n", "   * <pre>   {@code\n", "   *\n", "   *   CharMatcher.anyOf(\"eko\").collapseFrom(\"bookkeeper\", '-')}</pre>\n", "   *\n", "   * ... returns {@code \"b-p-r\"}.\n", "   *\n", "   * <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching\n", "   * character, then iterates the remainder of the sequence calling {@link #matches(char)} for each\n", "   * character.\n", "   *\n", "   * @param sequence the character sequence to replace matching groups of characters in\n", "   * @param replacement the character to append to the result string in place of each group of\n", "   *        matching characters in {@code sequence}\n", "   * @return the new string\n", "   */\n", "  @CheckReturnValue\n", "  public String collapseFrom(CharSequence sequence, char replacement) {\n", "    // This implementation avoids unnecessary allocation.\n", "    int len = sequence.length();\n", "    for (int i = 0; i < len; i++) {\n", "      char c = sequence.charAt(i);\n", "      if (matches(c)) {\n", "        if (c == replacement && (i == len - 1 || !matches(sequence.charAt(i + 1)))) {\n", "          // a no-op replacement\n", "          i++;\n", "        } else {\n", "          StringBuilder builder =\n", "              new StringBuilder(len).append(sequence.subSequence(0, i)).append(replacement);\n", "          return finishCollapseFrom(sequence, i + 1, len, replacement, builder, true);\n", "        }\n", "      }\n", "    }\n", "    // no replacement needed\n", "    return sequence.toString();\n", "  }\n", "\n", "  /**\n", "   * Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that\n", "   * groups of matching characters at the start or end of the sequence are removed without\n", "   * replacement.\n", "   */\n", "  @CheckReturnValue\n", "  public String trimAndCollapseFrom(CharSequence sequence, char replacement) {\n", "    // This implementation avoids unnecessary allocation.\n", "    int len = sequence.length();\n", "    int first = 0;\n", "    int last = len - 1;\n", "\n", "    while (first < len && matches(sequence.charAt(first))) {\n", "      first++;\n", "    }\n", "\n", "    while (last > first && matches(sequence.charAt(last))) {\n", "      last--;\n", "    }\n", "\n", "    return (first == 0 && last == len - 1)\n", "        ? collapseFrom(sequence, replacement)\n", "        : finishCollapseFrom(\n", "            sequence, first, last + 1, replacement, new StringBuilder(last + 1 - first), false);\n", "  }\n", "\n", "  private String finishCollapseFrom(\n", "      CharSequence sequence,\n", "      int start,\n", "      int end,\n", "      char replacement,\n", "      StringBuilder builder,\n", "      boolean inMatchingGroup) {\n", "    for (int i = start; i < end; i++) {\n", "      char c = sequence.charAt(i);\n", "      if (matches(c)) {\n", "        if (!inMatchingGroup) {\n", "          builder.append(replacement);\n", "          inMatchingGroup = true;\n", "        }\n", "      } else {\n", "        builder.append(c);\n", "        inMatchingGroup = false;\n", "      }\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  /**\n", "   * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #matches}\n", "   *     instead.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public boolean apply(Character character) {\n", "    return matches(character);\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of this {@code CharMatcher}, such as\n", "   * {@code CharMatcher.or(WHITESPACE, JAVA_DIGIT)}.\n", "   */\n", "  @Override\n", "  public String toString() {\n", "    return super.toString();\n", "  }\n", "\n", "  /**\n", "   * Returns the Java Unicode escape sequence for the given character, in the form \"\\u12AB\" where\n", "   * \"12AB\" is the four hexadecimal digits representing the 16 bits of the UTF-16 character.\n", "   */\n", "  private static String showCharacter(char c) {\n", "    String hex = \"0123456789ABCDEF\";\n", "    char[] tmp = {'\\\\', 'u', '\\0', '\\0', '\\0', '\\0'};\n", "    for (int i = 0; i < 4; i++) {\n", "      tmp[5 - i] = hex.charAt(c & 0xF);\n", "      c = (char) (c >> 4);\n", "    }\n", "    return String.copyValueOf(tmp);\n", "  }\n", "\n", "  // Fast matchers\n", "\n", "  /** A matcher for which precomputation will not yield any significant benefit. */\n", "  abstract static class FastMatcher extends CharMatcher {\n", "\n", "    @Override\n", "    public final CharMatcher precomputed() {\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher negate() {\n", "      return new NegatedFastMatcher(this);\n", "    }\n", "  }\n", "\n", "  /** {@link FastMatcher} which overrides {@code toString()} with a custom name. */\n", "  abstract static class NamedFastMatcher extends FastMatcher {\n", "\n", "    private final String description;\n", "\n", "    NamedFastMatcher(String description) {\n", "      this.description = checkNotNull(description);\n", "    }\n", "\n", "    @Override\n", "    public final String toString() {\n", "      return description;\n", "    }\n", "  }\n", "\n", "  /** Negation of a {@link FastMatcher}. */\n", "  static class NegatedFastMatcher extends Negated {\n", "\n", "    NegatedFastMatcher(CharMatcher original) {\n", "      super(original);\n", "    }\n", "\n", "    @Override\n", "    public final CharMatcher precomputed() {\n", "      return this;\n", "    }\n", "  }\n", "\n", "  // Static constant implementation classes\n", "\n", "  /** Implementation of {@link #any()}. */\n", "  private static final class Any extends NamedFastMatcher {\n", "\n", "    static final Any INSTANCE = new Any();\n", "\n", "    private Any() {\n", "      super(\"CharMatcher.any()\");\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public int indexIn(CharSequence sequence) {\n", "      return (sequence.length() == 0) ? -1 : 0;\n", "    }\n", "\n", "    @Override\n", "    public int indexIn(CharSequence sequence, int start) {\n", "      int length = sequence.length();\n", "      checkPositionIndex(start, length);\n", "      return (start == length) ? -1 : start;\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexIn(CharSequence sequence) {\n", "      return sequence.length() - 1;\n", "    }\n", "\n", "    @Override\n", "    public boolean matchesAllOf(CharSequence sequence) {\n", "      checkNotNull(sequence);\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public boolean matchesNoneOf(CharSequence sequence) {\n", "      return sequence.length() == 0;\n", "    }\n", "\n", "    @Override\n", "    public String removeFrom(CharSequence sequence) {\n", "      checkNotNull(sequence);\n", "      return \"\";\n", "    }\n", "\n", "    @Override\n", "    public String replaceFrom(CharSequence sequence, char replacement) {\n", "      char[] array = new char[sequence.length()];\n", "      Arrays.fill(array, replacement);\n", "      return new String(array);\n", "    }\n", "\n", "    @Override\n", "    public String replaceFrom(CharSequence sequence, CharSequence replacement) {\n", "      StringBuilder result = new StringBuilder(sequence.length() * replacement.length());\n", "      for (int i = 0; i < sequence.length(); i++) {\n", "        result.append(replacement);\n", "      }\n", "      return result.toString();\n", "    }\n", "\n", "    @Override\n", "    public String collapseFrom(CharSequence sequence, char replacement) {\n", "      return (sequence.length() == 0) ? \"\" : String.valueOf(replacement);\n", "    }\n", "\n", "    @Override\n", "    public String trimFrom(CharSequence sequence) {\n", "      checkNotNull(sequence);\n", "      return \"\";\n", "    }\n", "\n", "    @Override\n", "    public int countIn(CharSequence sequence) {\n", "      return sequence.length();\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher and(CharMatcher other) {\n", "      return checkNotNull(other);\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher or(CharMatcher other) {\n", "      checkNotNull(other);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher negate() {\n", "      return none();\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #none()}. */\n", "  private static final class None extends NamedFastMatcher {\n", "\n", "    static final None INSTANCE = new None();\n", "\n", "    private None() {\n", "      super(\"CharMatcher.none()\");\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int indexIn(CharSequence sequence) {\n", "      checkNotNull(sequence);\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public int indexIn(CharSequence sequence, int start) {\n", "      int length = sequence.length();\n", "      checkPositionIndex(start, length);\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexIn(CharSequence sequence) {\n", "      checkNotNull(sequence);\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public boolean matchesAllOf(CharSequence sequence) {\n", "      return sequence.length() == 0;\n", "    }\n", "\n", "    @Override\n", "    public boolean matchesNoneOf(CharSequence sequence) {\n", "      checkNotNull(sequence);\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public String removeFrom(CharSequence sequence) {\n", "      return sequence.toString();\n", "    }\n", "\n", "    @Override\n", "    public String replaceFrom(CharSequence sequence, char replacement) {\n", "      return sequence.toString();\n", "    }\n", "\n", "    @Override\n", "    public String replaceFrom(CharSequence sequence, CharSequence replacement) {\n", "      checkNotNull(replacement);\n", "      return sequence.toString();\n", "    }\n", "\n", "    @Override\n", "    public String collapseFrom(CharSequence sequence, char replacement) {\n", "      return sequence.toString();\n", "    }\n", "\n", "    @Override\n", "    public String trimFrom(CharSequence sequence) {\n", "      return sequence.toString();\n", "    }\n", "\n", "    @Override\n", "    public String trimLeadingFrom(CharSequence sequence) {\n", "      return sequence.toString();\n", "    }\n", "\n", "    @Override\n", "    public String trimTrailingFrom(CharSequence sequence) {\n", "      return sequence.toString();\n", "    }\n", "\n", "    @Override\n", "    public int countIn(CharSequence sequence) {\n", "      checkNotNull(sequence);\n", "      return 0;\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher and(CharMatcher other) {\n", "      checkNotNull(other);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher or(CharMatcher other) {\n", "      return checkNotNull(other);\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher negate() {\n", "      return any();\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #whitespace()}. */\n", "  @VisibleForTesting\n", "  static final class Whitespace extends NamedFastMatcher {\n", "\n", "    static final String TABLE =\n", "        \"\\u2002\\u3000\\r\\u0085\\u200A\\u2005\\u2000\\u3000\"\n", "            + \"\\u2029\\u000B\\u3000\\u2008\\u2003\\u205F\\u3000\\u1680\"\n", "            + \"\\u0009\\u0020\\u2006\\u2001\\u202F\\u00A0\\u000C\\u2009\"\n", "            + \"\\u3000\\u2004\\u3000\\u3000\\u2028\\n\\u2007\\u3000\";\n", "    static final int MULTIPLIER = 1682554634;\n", "    static final int SHIFT = Integer.numberOfLeadingZeros(TABLE.length() - 1);\n", "\n", "    static final Whitespace INSTANCE = new Whitespace();\n", "\n", "    Whitespace() {\n", "      super(\"CharMatcher.whitespace()\");\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return TABLE.charAt((MULTIPLIER * c) >>> SHIFT) == c;\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #breakingWhitespace()}. */\n", "  private static final class BreakingWhitespace extends CharMatcher {\n", "\n", "    static final CharMatcher INSTANCE = new BreakingWhitespace();\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      switch (c) {\n", "        case '\\t':\n", "        case '\\n':\n", "        case '\\013':\n", "        case '\\f':\n", "        case '\\r':\n", "        case ' ':\n", "        case '\\u0085':\n", "        case '\\u1680':\n", "        case '\\u2028':\n", "        case '\\u2029':\n", "        case '\\u205f':\n", "        case '\\u3000':\n", "          return true;\n", "        case '\\u2007':\n", "          return false;\n", "        default:\n", "          return c >= '\\u2000' && c <= '\\u200a';\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.breakingWhitespace()\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #ascii()}. */\n", "  private static final class Ascii extends NamedFastMatcher {\n", "\n", "    static final Ascii INSTANCE = new Ascii();\n", "\n", "    Ascii() {\n", "      super(\"CharMatcher.ascii()\");\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return c <= '\\u007f';\n", "    }\n", "  }\n", "\n", "  /** Implementation that matches characters that fall within multiple ranges. */\n", "  private static class RangesMatcher extends CharMatcher {\n", "\n", "    private final String description;\n", "    private final char[] rangeStarts;\n", "    private final char[] rangeEnds;\n", "\n", "    RangesMatcher(String description, char[] rangeStarts, char[] rangeEnds) {\n", "      this.description = description;\n", "      this.rangeStarts = rangeStarts;\n", "      this.rangeEnds = rangeEnds;\n", "      checkArgument(rangeStarts.length == rangeEnds.length);\n", "      for (int i = 0; i < rangeStarts.length; i++) {\n", "        checkArgument(rangeStarts[i] <= rangeEnds[i]);\n", "        if (i + 1 < rangeStarts.length) {\n", "          checkArgument(rangeEnds[i] < rangeStarts[i + 1]);\n", "        }\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      int index = Arrays.binarySearch(rangeStarts, c);\n", "      if (index >= 0) {\n", "        return true;\n", "      } else {\n", "        index = ~index - 1;\n", "        return index >= 0 && c <= rangeEnds[index];\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return description;\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #digit()}. */\n", "  private static final class Digit extends RangesMatcher {\n", "\n", "    // Must be in ascending order.\n", "    private static final String ZEROES =\n", "        \"0\\u0660\\u06f0\\u07c0\\u0966\\u09e6\\u0a66\\u0ae6\\u0b66\"\n", "            + \"\\u0be6\\u0c66\\u0ce6\\u0d66\\u0e50\\u0ed0\\u0f20\\u1040\\u1090\\u17e0\\u1810\"\n", "            + \"\\u1946\\u19d0\\u1b50\\u1bb0\\u1c40\\u1c50\\ua620\\ua8d0\\ua900\\uaa50\\uff10\";\n", "\n", "    private static char[] zeroes() {\n", "      return ZEROES.toCharArray();\n", "    }\n", "\n", "    private static char[] nines() {\n", "      char[] nines = new char[ZEROES.length()];\n", "      for (int i = 0; i < ZEROES.length(); i++) {\n", "        nines[i] = (char) (ZEROES.charAt(i) + 9);\n", "      }\n", "      return nines;\n", "    }\n", "\n", "    static final Digit INSTANCE = new Digit();\n", "\n", "    private Digit() {\n", "      super(\"CharMatcher.digit()\", zeroes(), nines());\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #javaDigit()}. */\n", "  private static final class JavaDigit extends CharMatcher {\n", "\n", "    static final JavaDigit INSTANCE = new JavaDigit();\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return Character.isDigit(c);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.javaDigit()\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #javaLetter()}. */\n", "  private static final class JavaLetter extends CharMatcher {\n", "\n", "    static final JavaLetter INSTANCE = new JavaLetter();\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return Character.isLetter(c);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.javaLetter()\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #javaLetterOrDigit()}. */\n", "  private static final class JavaLetterOrDigit extends CharMatcher {\n", "\n", "    static final JavaLetterOrDigit INSTANCE = new JavaLetterOrDigit();\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return Character.isLetterOrDigit(c);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.javaLetterOrDigit()\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #javaUpperCase()}. */\n", "  private static final class JavaUpperCase extends CharMatcher {\n", "\n", "    static final JavaUpperCase INSTANCE = new JavaUpperCase();\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return Character.isUpperCase(c);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.javaUpperCase()\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #javaLowerCase()}. */\n", "  private static final class JavaLowerCase extends CharMatcher {\n", "\n", "    static final JavaLowerCase INSTANCE = new JavaLowerCase();\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return Character.isLowerCase(c);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.javaLowerCase()\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #javaIsoControl()}. */\n", "  private static final class JavaIsoControl extends NamedFastMatcher {\n", "\n", "    static final JavaIsoControl INSTANCE = new JavaIsoControl();\n", "\n", "    private JavaIsoControl() {\n", "      super(\"CharMatcher.javaIsoControl()\");\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return c <= '\\u001f' || (c >= '\\u007f' && c <= '\\u009f');\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #invisible()}. */\n", "  private static final class Invisible extends RangesMatcher {\n", "\n", "    private static final String RANGE_STARTS =\n", "      \"\\u0000\\u007f\\u00ad\\u0600\\u061c\\u06dd\\u070f\\u1680\\u180e\\u2000\\u2028\\u205f\\u2066\\u2067\"\n", "          + \"\\u2068\\u2069\\u206a\\u3000\\ud800\\ufeff\\ufff9\\ufffa\";\n", "    private static final String RANGE_ENDS =\n", "      \"\\u0020\\u00a0\\u00ad\\u0604\\u061c\\u06dd\\u070f\\u1680\\u180e\\u200f\\u202f\\u2064\\u2066\\u2067\"\n", "          + \"\\u2068\\u2069\\u206f\\u3000\\uf8ff\\ufeff\\ufff9\\ufffb\";\n", "\n", "    static final Invisible INSTANCE = new Invisible();\n", "\n", "    private Invisible() {\n", "      super(\n", "          \"CharMatcher.invisible()\",\n", "          RANGE_STARTS.toCharArray(),\n", "          RANGE_ENDS.toCharArray());\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #singleWidth()}. */\n", "  private static final class SingleWidth extends RangesMatcher {\n", "\n", "    static final SingleWidth INSTANCE = new SingleWidth();\n", "\n", "    private SingleWidth() {\n", "      super(\n", "          \"CharMatcher.singleWidth()\",\n", "          \"\\u0000\\u05be\\u05d0\\u05f3\\u0600\\u0750\\u0e00\\u1e00\\u2100\\ufb50\\ufe70\\uff61\".toCharArray(),\n", "          \"\\u04f9\\u05be\\u05ea\\u05f4\\u06ff\\u077f\\u0e7f\\u20af\\u213a\\ufdff\\ufeff\\uffdc\".toCharArray());\n", "    }\n", "  }\n", "\n", "  // Non-static factory implementation classes\n", "\n", "  /** Implementation of {@link #negate()}. */\n", "  private static class Negated extends CharMatcher {\n", "\n", "    final CharMatcher original;\n", "\n", "    Negated(CharMatcher original) {\n", "      this.original = checkNotNull(original);\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return !original.matches(c);\n", "    }\n", "\n", "    @Override\n", "    public boolean matchesAllOf(CharSequence sequence) {\n", "      return original.matchesNoneOf(sequence);\n", "    }\n", "\n", "    @Override\n", "    public boolean matchesNoneOf(CharSequence sequence) {\n", "      return original.matchesAllOf(sequence);\n", "    }\n", "\n", "    @Override\n", "    public int countIn(CharSequence sequence) {\n", "      return sequence.length() - original.countIn(sequence);\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher negate() {\n", "      return original;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return original + \".negate()\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #and(CharMatcher)}. */\n", "  private static final class And extends CharMatcher {\n", "\n", "    final CharMatcher first;\n", "    final CharMatcher second;\n", "\n", "    And(CharMatcher a, CharMatcher b) {\n", "      first = checkNotNull(a);\n", "      second = checkNotNull(b);\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return first.matches(c) && second.matches(c);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.and(\" + first + \", \" + second + \")\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #or(CharMatcher)}. */\n", "  private static final class Or extends CharMatcher {\n", "\n", "    final CharMatcher first;\n", "    final CharMatcher second;\n", "\n", "    Or(CharMatcher a, CharMatcher b) {\n", "      first = checkNotNull(a);\n", "      second = checkNotNull(b);\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return first.matches(c) || second.matches(c);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.or(\" + first + \", \" + second + \")\";\n", "    }\n", "  }\n", "\n", "  // Static factory implementations\n", "\n", "  /** Implementation of {@link #is(char)}. */\n", "  private static final class Is extends FastMatcher {\n", "\n", "    private final char match;\n", "\n", "    Is(char match) {\n", "      this.match = match;\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return c == match;\n", "    }\n", "\n", "    @Override\n", "    public String replaceFrom(CharSequence sequence, char replacement) {\n", "      return sequence.toString().replace(match, replacement);\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher and(CharMatcher other) {\n", "      return other.matches(match) ? this : none();\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher or(CharMatcher other) {\n", "      return other.matches(match) ? other : super.or(other);\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher negate() {\n", "      return isNot(match);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.is('\" + showCharacter(match) + \"')\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #isNot(char)}. */\n", "  private static final class IsNot extends FastMatcher {\n", "\n", "    private final char match;\n", "\n", "    IsNot(char match) {\n", "      this.match = match;\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return c != match;\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher and(CharMatcher other) {\n", "      return other.matches(match) ? super.and(other) : other;\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher or(CharMatcher other) {\n", "      return other.matches(match) ? any() : this;\n", "    }\n", "\n", "    @Override\n", "    public CharMatcher negate() {\n", "      return is(match);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.isNot('\" + showCharacter(match) + \"')\";\n", "    }\n", "  }\n", "\n", "  private static CharMatcher.IsEither isEither(char c1, char c2) {\n", "    return new CharMatcher.IsEither(c1, c2);\n", "  }\n", "\n", "  /** Implementation of {@link #anyOf(CharSequence)} for exactly two characters. */\n", "  private static final class IsEither extends FastMatcher {\n", "\n", "    private final char match1;\n", "    private final char match2;\n", "\n", "    IsEither(char match1, char match2) {\n", "      this.match1 = match1;\n", "      this.match2 = match2;\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return c == match1 || c == match2;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.anyOf(\\\"\" + showCharacter(match1) + showCharacter(match2) + \"\\\")\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #anyOf(CharSequence)} for three or more characters. */\n", "  private static final class AnyOf extends CharMatcher {\n", "\n", "    private final char[] chars;\n", "\n", "    public AnyOf(CharSequence chars) {\n", "      this.chars = chars.toString().toCharArray();\n", "      Arrays.sort(this.chars);\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return Arrays.binarySearch(chars, c) >= 0;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      StringBuilder description = new StringBuilder(\"CharMatcher.anyOf(\\\"\");\n", "      for (char c : chars) {\n", "        description.append(showCharacter(c));\n", "      }\n", "      description.append(\"\\\")\");\n", "      return description.toString();\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #inRange(char, char)}. */\n", "  private static final class InRange extends FastMatcher {\n", "\n", "    private final char startInclusive;\n", "    private final char endInclusive;\n", "\n", "    InRange(char startInclusive, char endInclusive) {\n", "      checkArgument(endInclusive >= startInclusive);\n", "      this.startInclusive = startInclusive;\n", "      this.endInclusive = endInclusive;\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return startInclusive <= c && c <= endInclusive;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.inRange('\"\n", "          + showCharacter(startInclusive)\n", "          + \"', '\"\n", "          + showCharacter(endInclusive)\n", "          + \"')\";\n", "    }\n", "  }\n", "\n", "  /** Implementation of {@link #forPredicate(Predicate)}. */\n", "  private static final class ForPredicate extends CharMatcher {\n", "\n", "    private final Predicate<? super Character> predicate;\n", "\n", "    ForPredicate(Predicate<? super Character> predicate) {\n", "      this.predicate = checkNotNull(predicate);\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return predicate.apply(c);\n", "    }\n", "\n", "    @SuppressWarnings(\"deprecation\") // intentional; deprecation is for callers primarily\n", "    @Override\n", "    public boolean apply(Character character) {\n", "      return predicate.apply(checkNotNull(character));\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"CharMatcher.forPredicate(\" + predicate + \")\";\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651]}}, {"2": "guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Charsets.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.nio.charset.Charset;\n", "\n", "/**\n", " * Contains constant definitions for the six standard {@link Charset} instances, which are\n", " * guaranteed to be supported by all Java platform implementations.\n", " *\n", " * <p>Assuming you're free to choose, note that <b>{@link #UTF_8} is widely preferred</b>.\n", " *\n", " * <p>See the Guava User Guide article on <a\n", " * href=\"https://github.com/google/guava/wiki/StringsExplained#charsets\">\n", " * {@code Charsets}</a>.\n", " *\n", " * @author Mike Bostock\n", " * @since 1.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Charsets {\n", "  private Charsets() {}\n", "\n", "  /**\n", "   * UTF-8: eight-bit UCS Transformation Format.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> this constant should be treated as deprecated; use\n", "   * {@link java.nio.charset.StandardCharsets#UTF_8} instead.\n", "   *\n", "   */\n", "  public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n", "\n", "  /*\n", "   * Please do not add new Charset references to this class, unless those character encodings are\n", "   * part of the set required to be supported by all Java platform implementations! Any Charsets\n", "   * initialized here may cause unexpected delays when this class is loaded. See the Charset\n", "   * Javadocs for the list of built-in character encodings.\n", "   */\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55]}}, {"3": "guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Enums.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.io.Serializable;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Utility methods for working with {@link Enum} instances.\n", " *\n", " * @author Steve McKay\n", " *\n", " * @since 9.0\n", " */\n", "@CheckReturnValue\n", "@GwtCompatible(emulated = true)\n", "@Beta\n", "public final class Enums {\n", "\n", "  private Enums() {}\n", "\n", "  /**\n", "   * Returns an optional enum constant for the given type, using {@link Enum#valueOf}. If the\n", "   * constant does not exist, {@link Optional#absent} is returned. A common use case is for parsing\n", "   * user input or falling back to a default enum constant. For example,\n", "   * {@code Enums.getIfPresent(Country.class, countryInput).or(Country.DEFAULT);}\n", "   *\n", "   * @since 12.0\n", "   */\n", "  public static <T extends Enum<T>> Optional<T> getIfPresent(Class<T> enumClass, String value) {\n", "    checkNotNull(enumClass);\n", "    checkNotNull(value);\n", "    return Platform.getEnumIfPresent(enumClass, value);\n", "  }\n", "\n", "  /**\n", "   * Returns a converter that converts between strings and {@code enum} values of type\n", "   * {@code enumClass} using {@link Enum#valueOf(Class, String)} and {@link Enum#name()}. The\n", "   * converter will throw an {@code IllegalArgumentException} if the argument is not the name of\n", "   * any enum constant in the specified enum.\n", "   *\n", "   * @since 16.0\n", "   */\n", "  public static <T extends Enum<T>> Converter<String, T> stringConverter(final Class<T> enumClass) {\n", "    return new StringConverter<T>(enumClass);\n", "  }\n", "\n", "  private static final class StringConverter<T extends Enum<T>> extends Converter<String, T>\n", "      implements Serializable {\n", "\n", "    private final Class<T> enumClass;\n", "\n", "    StringConverter(Class<T> enumClass) {\n", "      this.enumClass = checkNotNull(enumClass);\n", "    }\n", "\n", "    @Override\n", "    protected T doForward(String value) {\n", "      return Enum.valueOf(enumClass, value);\n", "    }\n", "\n", "    @Override\n", "    protected String doBackward(T enumValue) {\n", "      return enumValue.name();\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      if (object instanceof StringConverter) {\n", "        StringConverter<?> that = (StringConverter<?>) object;\n", "        return this.enumClass.equals(that.enumClass);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return enumClass.hashCode();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Enums.stringConverter(\" + enumClass.getName() + \".class)\";\n", "    }\n", "\n", "    private static final long serialVersionUID = 0L;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110]}}, {"4": "guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Predicates.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.io.Serializable;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.List;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to {@code Predicate} instances.\n", " *\n", " * <p>All methods returns serializable predicates as long as they're given\n", " * serializable parameters.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/FunctionalExplained\">the\n", " * use of {@code Predicate}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 2.0\n", " */\n", "@CheckReturnValue\n", "@GwtCompatible(emulated = true)\n", "public final class Predicates {\n", "  private Predicates() {}\n", "\n", "  // TODO(kevinb): considering having these implement a VisitablePredicate\n", "  // interface which specifies an accept(PredicateVisitor) method.\n", "\n", "  /**\n", "   * Returns a predicate that always evaluates to {@code true}.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <T> Predicate<T> alwaysTrue() {\n", "    return ObjectPredicate.ALWAYS_TRUE.withNarrowedType();\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that always evaluates to {@code false}.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <T> Predicate<T> alwaysFalse() {\n", "    return ObjectPredicate.ALWAYS_FALSE.withNarrowedType();\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if the object reference\n", "   * being tested is null.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <T> Predicate<T> isNull() {\n", "    return ObjectPredicate.IS_NULL.withNarrowedType();\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if the object reference\n", "   * being tested is not null.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <T> Predicate<T> notNull() {\n", "    return ObjectPredicate.NOT_NULL.withNarrowedType();\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if the given predicate\n", "   * evaluates to {@code false}.\n", "   */\n", "  public static <T> Predicate<T> not(Predicate<T> predicate) {\n", "    return new NotPredicate<T>(predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if each of its\n", "   * components evaluates to {@code true}. The components are evaluated in\n", "   * order, and evaluation will be \"short-circuited\" as soon as a false\n", "   * predicate is found. It defensively copies the iterable passed in, so future\n", "   * changes to it won't alter the behavior of this predicate. If {@code\n", "   * components} is empty, the returned predicate will always evaluate to {@code\n", "   * true}.\n", "   */\n", "  public static <T> Predicate<T> and(Iterable<? extends Predicate<? super T>> components) {\n", "    return new AndPredicate<T>(defensiveCopy(components));\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if each of its\n", "   * components evaluates to {@code true}. The components are evaluated in\n", "   * order, and evaluation will be \"short-circuited\" as soon as a false\n", "   * predicate is found. It defensively copies the array passed in, so future\n", "   * changes to it won't alter the behavior of this predicate. If {@code\n", "   * components} is empty, the returned predicate will always evaluate to {@code\n", "   * true}.\n", "   */\n", "  public static <T> Predicate<T> and(Predicate<? super T>... components) {\n", "    return new AndPredicate<T>(defensiveCopy(components));\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if both of its\n", "   * components evaluate to {@code true}. The components are evaluated in\n", "   * order, and evaluation will be \"short-circuited\" as soon as a false\n", "   * predicate is found.\n", "   */\n", "  public static <T> Predicate<T> and(Predicate<? super T> first, Predicate<? super T> second) {\n", "    return new AndPredicate<T>(Predicates.<T>asList(checkNotNull(first), checkNotNull(second)));\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if any one of its\n", "   * components evaluates to {@code true}. The components are evaluated in\n", "   * order, and evaluation will be \"short-circuited\" as soon as a\n", "   * true predicate is found. It defensively copies the iterable passed in, so\n", "   * future changes to it won't alter the behavior of this predicate. If {@code\n", "   * components} is empty, the returned predicate will always evaluate to {@code\n", "   * false}.\n", "   */\n", "  public static <T> Predicate<T> or(Iterable<? extends Predicate<? super T>> components) {\n", "    return new OrPredicate<T>(defensiveCopy(components));\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if any one of its\n", "   * components evaluates to {@code true}. The components are evaluated in\n", "   * order, and evaluation will be \"short-circuited\" as soon as a\n", "   * true predicate is found. It defensively copies the array passed in, so\n", "   * future changes to it won't alter the behavior of this predicate. If {@code\n", "   * components} is empty, the returned predicate will always evaluate to {@code\n", "   * false}.\n", "   */\n", "  public static <T> Predicate<T> or(Predicate<? super T>... components) {\n", "    return new OrPredicate<T>(defensiveCopy(components));\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if either of its\n", "   * components evaluates to {@code true}. The components are evaluated in\n", "   * order, and evaluation will be \"short-circuited\" as soon as a\n", "   * true predicate is found.\n", "   */\n", "  public static <T> Predicate<T> or(Predicate<? super T> first, Predicate<? super T> second) {\n", "    return new OrPredicate<T>(Predicates.<T>asList(checkNotNull(first), checkNotNull(second)));\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if the object being\n", "   * tested {@code equals()} the given target or both are null.\n", "   */\n", "  public static <T> Predicate<T> equalTo(@Nullable T target) {\n", "    return (target == null) ? Predicates.<T>isNull() : new IsEqualToPredicate<T>(target);\n", "  }\n", "\n", "  /**\n", "   * Returns a predicate that evaluates to {@code true} if the object reference\n", "   * being tested is a member of the given collection. It does not defensively\n", "   * copy the collection passed in, so future changes to it will alter the\n", "   * behavior of the predicate.\n", "   *\n", "   * <p>This method can technically accept any {@code Collection<?>}, but using\n", "   * a typed collection helps prevent bugs. This approach doesn't block any\n", "   * potential users since it is always possible to use {@code\n", "   * Predicates.<Object>in()}.\n", "   *\n", "   * @param target the collection that may contain the function input\n", "   */\n", "  public static <T> Predicate<T> in(Collection<? extends T> target) {\n", "    return new InPredicate<T>(target);\n", "  }\n", "\n", "  /**\n", "   * Returns the composition of a function and a predicate. For every {@code x},\n", "   * the generated predicate returns {@code predicate(function(x))}.\n", "   *\n", "   * @return the composition of the provided function and predicate\n", "   */\n", "  public static <A, B> Predicate<A> compose(\n", "      Predicate<B> predicate, Function<A, ? extends B> function) {\n", "    return new CompositionPredicate<A, B>(predicate, function);\n", "  }\n", "\n", "  // End public API, begin private implementation classes.\n", "\n", "  // Package private for GWT serialization.\n", "  enum ObjectPredicate implements Predicate<Object> {\n", "    /** @see Predicates#alwaysTrue() */\n", "    ALWAYS_TRUE {\n", "      @Override\n", "      public boolean apply(@Nullable Object o) {\n", "        return true;\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return \"Predicates.alwaysTrue()\";\n", "      }\n", "    },\n", "    /** @see Predicates#alwaysFalse() */\n", "    ALWAYS_FALSE {\n", "      @Override\n", "      public boolean apply(@Nullable Object o) {\n", "        return false;\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return \"Predicates.alwaysFalse()\";\n", "      }\n", "    },\n", "    /** @see Predicates#isNull() */\n", "    IS_NULL {\n", "      @Override\n", "      public boolean apply(@Nullable Object o) {\n", "        return o == null;\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return \"Predicates.isNull()\";\n", "      }\n", "    },\n", "    /** @see Predicates#notNull() */\n", "    NOT_NULL {\n", "      @Override\n", "      public boolean apply(@Nullable Object o) {\n", "        return o != null;\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return \"Predicates.notNull()\";\n", "      }\n", "    };\n", "\n", "    @SuppressWarnings(\"unchecked\") // safe contravariant cast\n", "    <T> Predicate<T> withNarrowedType() {\n", "      return (Predicate<T>) this;\n", "    }\n", "  }\n", "\n", "  /** @see Predicates#not(Predicate) */\n", "  private static class NotPredicate<T> implements Predicate<T>, Serializable {\n", "    final Predicate<T> predicate;\n", "\n", "    NotPredicate(Predicate<T> predicate) {\n", "      this.predicate = checkNotNull(predicate);\n", "    }\n", "\n", "    @Override\n", "    public boolean apply(@Nullable T t) {\n", "      return !predicate.apply(t);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return ~predicate.hashCode();\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object obj) {\n", "      if (obj instanceof NotPredicate) {\n", "        NotPredicate<?> that = (NotPredicate<?>) obj;\n", "        return predicate.equals(that.predicate);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Predicates.not(\" + predicate + \")\";\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static final Joiner COMMA_JOINER = Joiner.on(',');\n", "\n", "  /** @see Predicates#and(Iterable) */\n", "  private static class AndPredicate<T> implements Predicate<T>, Serializable {\n", "    private final List<? extends Predicate<? super T>> components;\n", "\n", "    private AndPredicate(List<? extends Predicate<? super T>> components) {\n", "      this.components = components;\n", "    }\n", "\n", "    @Override\n", "    public boolean apply(@Nullable T t) {\n", "      // Avoid using the Iterator to avoid generating garbage (issue 820).\n", "      for (int i = 0; i < components.size(); i++) {\n", "        if (!components.get(i).apply(t)) {\n", "          return false;\n", "        }\n", "      }\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      // add a random number to avoid collisions with OrPredicate\n", "      return components.hashCode() + 0x12472c2c;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object obj) {\n", "      if (obj instanceof AndPredicate) {\n", "        AndPredicate<?> that = (AndPredicate<?>) obj;\n", "        return components.equals(that.components);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Predicates.and(\" + COMMA_JOINER.join(components) + \")\";\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /** @see Predicates#or(Iterable) */\n", "  private static class OrPredicate<T> implements Predicate<T>, Serializable {\n", "    private final List<? extends Predicate<? super T>> components;\n", "\n", "    private OrPredicate(List<? extends Predicate<? super T>> components) {\n", "      this.components = components;\n", "    }\n", "\n", "    @Override\n", "    public boolean apply(@Nullable T t) {\n", "      // Avoid using the Iterator to avoid generating garbage (issue 820).\n", "      for (int i = 0; i < components.size(); i++) {\n", "        if (components.get(i).apply(t)) {\n", "          return true;\n", "        }\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      // add a random number to avoid collisions with AndPredicate\n", "      return components.hashCode() + 0x053c91cf;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object obj) {\n", "      if (obj instanceof OrPredicate) {\n", "        OrPredicate<?> that = (OrPredicate<?>) obj;\n", "        return components.equals(that.components);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Predicates.or(\" + COMMA_JOINER.join(components) + \")\";\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /** @see Predicates#equalTo(Object) */\n", "  private static class IsEqualToPredicate<T> implements Predicate<T>, Serializable {\n", "    private final T target;\n", "\n", "    private IsEqualToPredicate(T target) {\n", "      this.target = target;\n", "    }\n", "\n", "    @Override\n", "    public boolean apply(T t) {\n", "      return target.equals(t);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return target.hashCode();\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object obj) {\n", "      if (obj instanceof IsEqualToPredicate) {\n", "        IsEqualToPredicate<?> that = (IsEqualToPredicate<?>) obj;\n", "        return target.equals(that.target);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Predicates.equalTo(\" + target + \")\";\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /** @see Predicates#in(Collection) */\n", "  private static class InPredicate<T> implements Predicate<T>, Serializable {\n", "    private final Collection<?> target;\n", "\n", "    private InPredicate(Collection<?> target) {\n", "      this.target = checkNotNull(target);\n", "    }\n", "\n", "    @Override\n", "    public boolean apply(@Nullable T t) {\n", "      try {\n", "        return target.contains(t);\n", "      } catch (NullPointerException e) {\n", "        return false;\n", "      } catch (ClassCastException e) {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object obj) {\n", "      if (obj instanceof InPredicate) {\n", "        InPredicate<?> that = (InPredicate<?>) obj;\n", "        return target.equals(that.target);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return target.hashCode();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Predicates.in(\" + target + \")\";\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /** @see Predicates#compose(Predicate, Function) */\n", "  private static class CompositionPredicate<A, B> implements Predicate<A>, Serializable {\n", "    final Predicate<B> p;\n", "    final Function<A, ? extends B> f;\n", "\n", "    private CompositionPredicate(Predicate<B> p, Function<A, ? extends B> f) {\n", "      this.p = checkNotNull(p);\n", "      this.f = checkNotNull(f);\n", "    }\n", "\n", "    @Override\n", "    public boolean apply(@Nullable A a) {\n", "      return p.apply(f.apply(a));\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object obj) {\n", "      if (obj instanceof CompositionPredicate) {\n", "        CompositionPredicate<?, ?> that = (CompositionPredicate<?, ?>) obj;\n", "        return f.equals(that.f) && p.equals(that.p);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return f.hashCode() ^ p.hashCode();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      // TODO(cpovirk): maybe make this look like the method call does (\"Predicates.compose(...)\")\n", "      return p + \"(\" + f + \")\";\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static <T> List<Predicate<? super T>> asList(\n", "      Predicate<? super T> first, Predicate<? super T> second) {\n", "    // TODO(kevinb): understand why we still get a warning despite @SafeVarargs!\n", "    return Arrays.<Predicate<? super T>>asList(first, second);\n", "  }\n", "\n", "  private static <T> List<T> defensiveCopy(T... array) {\n", "    return defensiveCopy(Arrays.asList(array));\n", "  }\n", "\n", "  static <T> List<T> defensiveCopy(Iterable<T> iterable) {\n", "    ArrayList<T> list = new ArrayList<T>();\n", "    for (T element : iterable) {\n", "      list.add(checkNotNull(element));\n", "    }\n", "    return list;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515]}}, {"5": "guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Splitter.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.ArrayList;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.LinkedHashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "\n", "/**\n", " * Extracts non-overlapping substrings from an input string, typically by\n", " * recognizing appearances of a <i>separator</i> sequence. This separator can be\n", " * specified as a single {@linkplain #on(char) character}, fixed {@linkplain\n", " * #on(String) string}, {@linkplain #onPattern regular expression} or {@link\n", " * #on(CharMatcher) CharMatcher} instance. Or, instead of using a separator at\n", " * all, a splitter can extract adjacent substrings of a given {@linkplain\n", " * #fixedLength fixed length}.\n", " *\n", " * <p>For example, this expression: <pre>   {@code\n", " *\n", " *   Splitter.on(',').split(\"foo,bar,qux\")}</pre>\n", " *\n", " * ... produces an {@code Iterable} containing {@code \"foo\"}, {@code \"bar\"} and\n", " * {@code \"qux\"}, in that order.\n", " *\n", " * <p>By default, {@code Splitter}'s behavior is simplistic and unassuming. The\n", " * following expression: <pre>   {@code\n", " *\n", " *   Splitter.on(',').split(\" foo,,,  bar ,\")}</pre>\n", " *\n", " * ... yields the substrings {@code [\" foo\", \"\", \"\", \"  bar \", \"\"]}. If this\n", " * is not the desired behavior, use configuration methods to obtain a <i>new</i>\n", " * splitter instance with modified behavior: <pre>   {@code\n", " *\n", " *   private static final Splitter MY_SPLITTER = Splitter.on(',')\n", " *       .trimResults()\n", " *       .omitEmptyStrings();}</pre>\n", " *\n", " * <p>Now {@code MY_SPLITTER.split(\"foo,,,  bar ,\")} returns just {@code [\"foo\",\n", " * \"bar\"]}. Note that the order in which these configuration methods are called\n", " * is never significant.\n", " *\n", " * <p><b>Warning:</b> Splitter instances are immutable. Invoking a configuration\n", " * method has no effect on the receiving instance; you must store and use the\n", " * new splitter instance it returns instead. <pre>   {@code\n", " *\n", " *   // Do NOT do this\n", " *   Splitter splitter = Splitter.on('/');\n", " *   splitter.trimResults(); // does nothing!\n", " *   return splitter.split(\"wrong / wrong / wrong\");}</pre>\n", " *\n", " * <p>For separator-based splitters that do not use {@code omitEmptyStrings}, an\n", " * input string containing {@code n} occurrences of the separator naturally\n", " * yields an iterable of size {@code n + 1}. So if the separator does not occur\n", " * anywhere in the input, a single substring is returned containing the entire\n", " * input. Consequently, all splitters split the empty string to {@code [\"\"]}\n", " * (note: even fixed-length splitters).\n", " *\n", " * <p>Splitter instances are thread-safe immutable, and are therefore safe to\n", " * store as {@code static final} constants.\n", " *\n", " * <p>The {@link Joiner} class provides the inverse operation to splitting, but\n", " * note that a round-trip between the two should be assumed to be lossy.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/StringsExplained#splitter\">\n", " * {@code Splitter}</a>.\n", " *\n", " * @author Julien Silland\n", " * @author Jesse Wilson\n", " * @author Kevin Bourrillion\n", " * @author Louis Wasserman\n", " * @since 1.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Splitter {\n", "  private final CharMatcher trimmer;\n", "  private final boolean omitEmptyStrings;\n", "  private final Strategy strategy;\n", "  private final int limit;\n", "\n", "  private Splitter(Strategy strategy) {\n", "    this(strategy, false, CharMatcher.NONE, Integer.MAX_VALUE);\n", "  }\n", "\n", "  private Splitter(Strategy strategy, boolean omitEmptyStrings, CharMatcher trimmer, int limit) {\n", "    this.strategy = strategy;\n", "    this.omitEmptyStrings = omitEmptyStrings;\n", "    this.trimmer = trimmer;\n", "    this.limit = limit;\n", "  }\n", "\n", "  /**\n", "   * Returns a splitter that uses the given single-character separator. For\n", "   * example, {@code Splitter.on(',').split(\"foo,,bar\")} returns an iterable\n", "   * containing {@code [\"foo\", \"\", \"bar\"]}.\n", "   *\n", "   * @param separator the character to recognize as a separator\n", "   * @return a splitter, with default settings, that recognizes that separator\n", "   */\n", "  @CheckReturnValue\n", "  public static Splitter on(char separator) {\n", "    return on(CharMatcher.is(separator));\n", "  }\n", "\n", "  /**\n", "   * Returns a splitter that considers any single character matched by the\n", "   * given {@code CharMatcher} to be a separator. For example, {@code\n", "   * Splitter.on(CharMatcher.anyOf(\";,\")).split(\"foo,;bar,quux\")} returns an\n", "   * iterable containing {@code [\"foo\", \"\", \"bar\", \"quux\"]}.\n", "   *\n", "   * @param separatorMatcher a {@link CharMatcher} that determines whether a\n", "   *     character is a separator\n", "   * @return a splitter, with default settings, that uses this matcher\n", "   */\n", "  @CheckReturnValue\n", "  public static Splitter on(final CharMatcher separatorMatcher) {\n", "    checkNotNull(separatorMatcher);\n", "\n", "    return new Splitter(\n", "        new Strategy() {\n", "          @Override\n", "          public SplittingIterator iterator(Splitter splitter, final CharSequence toSplit) {\n", "            return new SplittingIterator(splitter, toSplit) {\n", "              @Override\n", "              int separatorStart(int start) {\n", "                return separatorMatcher.indexIn(toSplit, start);\n", "              }\n", "\n", "              @Override\n", "              int separatorEnd(int separatorPosition) {\n", "                return separatorPosition + 1;\n", "              }\n", "            };\n", "          }\n", "        });\n", "  }\n", "\n", "  /**\n", "   * Returns a splitter that uses the given fixed string as a separator. For\n", "   * example, {@code Splitter.on(\", \").split(\"foo, bar,baz\")} returns an\n", "   * iterable containing {@code [\"foo\", \"bar,baz\"]}.\n", "   *\n", "   * @param separator the literal, nonempty string to recognize as a separator\n", "   * @return a splitter, with default settings, that recognizes that separator\n", "   */\n", "  @CheckReturnValue\n", "  public static Splitter on(final String separator) {\n", "    checkArgument(separator.length() != 0, \"The separator may not be the empty string.\");\n", "    if (separator.length() == 1) {\n", "      return Splitter.on(separator.charAt(0));\n", "    }\n", "    return new Splitter(\n", "        new Strategy() {\n", "          @Override\n", "          public SplittingIterator iterator(Splitter splitter, CharSequence toSplit) {\n", "            return new SplittingIterator(splitter, toSplit) {\n", "              @Override\n", "              public int separatorStart(int start) {\n", "                int separatorLength = separator.length();\n", "\n", "                positions:\n", "                for (int p = start, last = toSplit.length() - separatorLength; p <= last; p++) {\n", "                  for (int i = 0; i < separatorLength; i++) {\n", "                    if (toSplit.charAt(i + p) != separator.charAt(i)) {\n", "                      continue positions;\n", "                    }\n", "                  }\n", "                  return p;\n", "                }\n", "                return -1;\n", "              }\n", "\n", "              @Override\n", "              public int separatorEnd(int separatorPosition) {\n", "                return separatorPosition + separator.length();\n", "              }\n", "            };\n", "          }\n", "        });\n", "  }\n", "\n", "  /**\n", "   * Returns a splitter that divides strings into pieces of the given length.\n", "   * For example, {@code Splitter.fixedLength(2).split(\"abcde\")} returns an\n", "   * iterable containing {@code [\"ab\", \"cd\", \"e\"]}. The last piece can be\n", "   * smaller than {@code length} but will never be empty.\n", "   *\n", "   * <p><b>Exception:</b> for consistency with separator-based splitters, {@code\n", "   * split(\"\")} does not yield an empty iterable, but an iterable containing\n", "   * {@code \"\"}. This is the only case in which {@code\n", "   * Iterables.size(split(input))} does not equal {@code\n", "   * IntMath.divide(input.length(), length, CEILING)}. To avoid this behavior,\n", "   * use {@code omitEmptyStrings}.\n", "   *\n", "   * @param length the desired length of pieces after splitting, a positive\n", "   *     integer\n", "   * @return a splitter, with default settings, that can split into fixed sized\n", "   *     pieces\n", "   * @throws IllegalArgumentException if {@code length} is zero or negative\n", "   */\n", "  @CheckReturnValue\n", "  public static Splitter fixedLength(final int length) {\n", "    checkArgument(length > 0, \"The length may not be less than 1\");\n", "\n", "    return new Splitter(\n", "        new Strategy() {\n", "          @Override\n", "          public SplittingIterator iterator(final Splitter splitter, CharSequence toSplit) {\n", "            return new SplittingIterator(splitter, toSplit) {\n", "              @Override\n", "              public int separatorStart(int start) {\n", "                int nextChunkStart = start + length;\n", "                return (nextChunkStart < toSplit.length() ? nextChunkStart : -1);\n", "              }\n", "\n", "              @Override\n", "              public int separatorEnd(int separatorPosition) {\n", "                return separatorPosition;\n", "              }\n", "            };\n", "          }\n", "        });\n", "  }\n", "\n", "  /**\n", "   * Returns a splitter that behaves equivalently to {@code this} splitter, but\n", "   * automatically omits empty strings from the results. For example, {@code\n", "   * Splitter.on(',').omitEmptyStrings().split(\",a,,,b,c,,\")} returns an\n", "   * iterable containing only {@code [\"a\", \"b\", \"c\"]}.\n", "   *\n", "   * <p>If either {@code trimResults} option is also specified when creating a\n", "   * splitter, that splitter always trims results first before checking for\n", "   * emptiness. So, for example, {@code\n", "   * Splitter.on(':').omitEmptyStrings().trimResults().split(\": : : \")} returns\n", "   * an empty iterable.\n", "   *\n", "   * <p>Note that it is ordinarily not possible for {@link #split(CharSequence)}\n", "   * to return an empty iterable, but when using this option, it can (if the\n", "   * input sequence consists of nothing but separators).\n", "   *\n", "   * @return a splitter with the desired configuration\n", "   */\n", "  @CheckReturnValue\n", "  public Splitter omitEmptyStrings() {\n", "    return new Splitter(strategy, true, trimmer, limit);\n", "  }\n", "\n", "  /**\n", "   * Returns a splitter that behaves equivalently to {@code this} splitter but\n", "   * stops splitting after it reaches the limit.\n", "   * The limit defines the maximum number of items returned by the iterator, or\n", "   * the maximum size of the list returned by {@link #splitToList}.\n", "   *\n", "   * <p>For example,\n", "   * {@code Splitter.on(',').limit(3).split(\"a,b,c,d\")} returns an iterable\n", "   * containing {@code [\"a\", \"b\", \"c,d\"]}.  When omitting empty strings, the\n", "   * omitted strings do no count.  Hence,\n", "   * {@code Splitter.on(',').limit(3).omitEmptyStrings().split(\"a,,,b,,,c,d\")}\n", "   * returns an iterable containing {@code [\"a\", \"b\", \"c,d\"}.\n", "   * When trim is requested, all entries, including the last are trimmed.  Hence\n", "   * {@code Splitter.on(',').limit(3).trimResults().split(\" a , b , c , d \")}\n", "   * results in {@code [\"a\", \"b\", \"c , d\"]}.\n", "   *\n", "   * @param limit the maximum number of items returned\n", "   * @return a splitter with the desired configuration\n", "   * @since 9.0\n", "   */\n", "  @CheckReturnValue\n", "  public Splitter limit(int limit) {\n", "    checkArgument(limit > 0, \"must be greater than zero: %s\", limit);\n", "    return new Splitter(strategy, omitEmptyStrings, trimmer, limit);\n", "  }\n", "\n", "  /**\n", "   * Returns a splitter that behaves equivalently to {@code this} splitter, but\n", "   * automatically removes leading and trailing {@linkplain\n", "   * CharMatcher#WHITESPACE whitespace} from each returned substring; equivalent\n", "   * to {@code trimResults(CharMatcher.WHITESPACE)}. For example, {@code\n", "   * Splitter.on(',').trimResults().split(\" a, b ,c \")} returns an iterable\n", "   * containing {@code [\"a\", \"b\", \"c\"]}.\n", "   *\n", "   * @return a splitter with the desired configuration\n", "   */\n", "  @CheckReturnValue\n", "  public Splitter trimResults() {\n", "    return trimResults(CharMatcher.WHITESPACE);\n", "  }\n", "\n", "  /**\n", "   * Returns a splitter that behaves equivalently to {@code this} splitter, but\n", "   * removes all leading or trailing characters matching the given {@code\n", "   * CharMatcher} from each returned substring. For example, {@code\n", "   * Splitter.on(',').trimResults(CharMatcher.is('_')).split(\"_a ,_b_ ,c__\")}\n", "   * returns an iterable containing {@code [\"a \", \"b_ \", \"c\"]}.\n", "   *\n", "   * @param trimmer a {@link CharMatcher} that determines whether a character\n", "   *     should be removed from the beginning/end of a subsequence\n", "   * @return a splitter with the desired configuration\n", "   */\n", "  // TODO(kevinb): throw if a trimmer was already specified!\n", "  @CheckReturnValue\n", "  public Splitter trimResults(CharMatcher trimmer) {\n", "    checkNotNull(trimmer);\n", "    return new Splitter(strategy, omitEmptyStrings, trimmer, limit);\n", "  }\n", "\n", "  /**\n", "   * Splits {@code sequence} into string components and makes them available\n", "   * through an {@link Iterator}, which may be lazily evaluated. If you want\n", "   * an eagerly computed {@link List}, use {@link #splitToList(CharSequence)}.\n", "   *\n", "   * @param sequence the sequence of characters to split\n", "   * @return an iteration over the segments split from the parameter.\n", "   */\n", "  @CheckReturnValue\n", "  public Iterable<String> split(final CharSequence sequence) {\n", "    checkNotNull(sequence);\n", "\n", "    return new Iterable<String>() {\n", "      @Override\n", "      public Iterator<String> iterator() {\n", "        return splittingIterator(sequence);\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return Joiner.on(\", \")\n", "            .appendTo(new StringBuilder().append('['), this)\n", "            .append(']')\n", "            .toString();\n", "      }\n", "    };\n", "  }\n", "\n", "  private Iterator<String> splittingIterator(CharSequence sequence) {\n", "    return strategy.iterator(this, sequence);\n", "  }\n", "\n", "  /**\n", "   * Splits {@code sequence} into string components and returns them as\n", "   * an immutable list. If you want an {@link Iterable} which may be lazily\n", "   * evaluated, use {@link #split(CharSequence)}.\n", "   *\n", "   * @param sequence the sequence of characters to split\n", "   * @return an immutable list of the segments split from the parameter\n", "   * @since 15.0\n", "   */\n", "  @CheckReturnValue\n", "  @Beta\n", "  public List<String> splitToList(CharSequence sequence) {\n", "    checkNotNull(sequence);\n", "\n", "    Iterator<String> iterator = splittingIterator(sequence);\n", "    List<String> result = new ArrayList<String>();\n", "\n", "    while (iterator.hasNext()) {\n", "      result.add(iterator.next());\n", "    }\n", "\n", "    return Collections.unmodifiableList(result);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code MapSplitter} which splits entries based on this splitter,\n", "   * and splits entries into keys and values using the specified separator.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  @CheckReturnValue\n", "  @Beta\n", "  public MapSplitter withKeyValueSeparator(String separator) {\n", "    return withKeyValueSeparator(on(separator));\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code MapSplitter} which splits entries based on this splitter,\n", "   * and splits entries into keys and values using the specified separator.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  @Beta\n", "  public MapSplitter withKeyValueSeparator(char separator) {\n", "    return withKeyValueSeparator(on(separator));\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code MapSplitter} which splits entries based on this splitter,\n", "   * and splits entries into keys and values using the specified key-value\n", "   * splitter.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  @CheckReturnValue\n", "  @Beta\n", "  public MapSplitter withKeyValueSeparator(Splitter keyValueSplitter) {\n", "    return new MapSplitter(this, keyValueSplitter);\n", "  }\n", "\n", "  /**\n", "   * An object that splits strings into maps as {@code Splitter} splits\n", "   * iterables and lists. Like {@code Splitter}, it is thread-safe and\n", "   * immutable.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  @Beta\n", "  public static final class MapSplitter {\n", "    private static final String INVALID_ENTRY_MESSAGE = \"Chunk [%s] is not a valid entry\";\n", "    private final Splitter outerSplitter;\n", "    private final Splitter entrySplitter;\n", "\n", "    private MapSplitter(Splitter outerSplitter, Splitter entrySplitter) {\n", "      this.outerSplitter = outerSplitter; // only \"this\" is passed\n", "      this.entrySplitter = checkNotNull(entrySplitter);\n", "    }\n", "\n", "    /**\n", "     * Splits {@code sequence} into substrings, splits each substring into\n", "     * an entry, and returns an unmodifiable map with each of the entries. For\n", "     * example, <code>\n", "     * Splitter.on(';').trimResults().withKeyValueSeparator(\"=>\")\n", "     * .split(\"a=>b ; c=>b\")\n", "     * </code> will return a mapping from {@code \"a\"} to {@code \"b\"} and\n", "     * {@code \"c\"} to {@code b}.\n", "     *\n", "     * <p>The returned map preserves the order of the entries from\n", "     * {@code sequence}.\n", "     *\n", "     * @throws IllegalArgumentException if the specified sequence does not split\n", "     *         into valid map entries, or if there are duplicate keys\n", "     */\n", "    @CheckReturnValue\n", "    public Map<String, String> split(CharSequence sequence) {\n", "      Map<String, String> map = new LinkedHashMap<String, String>();\n", "      for (String entry : outerSplitter.split(sequence)) {\n", "        Iterator<String> entryFields = entrySplitter.splittingIterator(entry);\n", "\n", "        checkArgument(entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n", "        String key = entryFields.next();\n", "        checkArgument(!map.containsKey(key), \"Duplicate key [%s] found.\", key);\n", "\n", "        checkArgument(entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n", "        String value = entryFields.next();\n", "        map.put(key, value);\n", "\n", "        checkArgument(!entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);\n", "      }\n", "      return Collections.unmodifiableMap(map);\n", "    }\n", "  }\n", "\n", "  private interface Strategy {\n", "    Iterator<String> iterator(Splitter splitter, CharSequence toSplit);\n", "  }\n", "\n", "  private abstract static class SplittingIterator extends AbstractIterator<String> {\n", "    final CharSequence toSplit;\n", "    final CharMatcher trimmer;\n", "    final boolean omitEmptyStrings;\n", "\n", "    /**\n", "     * Returns the first index in {@code toSplit} at or after {@code start}\n", "     * that contains the separator.\n", "     */\n", "    abstract int separatorStart(int start);\n", "\n", "    /**\n", "     * Returns the first index in {@code toSplit} after {@code\n", "     * separatorPosition} that does not contain a separator. This method is only\n", "     * invoked after a call to {@code separatorStart}.\n", "     */\n", "    abstract int separatorEnd(int separatorPosition);\n", "\n", "    int offset = 0;\n", "    int limit;\n", "\n", "    protected SplittingIterator(Splitter splitter, CharSequence toSplit) {\n", "      this.trimmer = splitter.trimmer;\n", "      this.omitEmptyStrings = splitter.omitEmptyStrings;\n", "      this.limit = splitter.limit;\n", "      this.toSplit = toSplit;\n", "    }\n", "\n", "    @Override\n", "    protected String computeNext() {\n", "      /*\n", "       * The returned string will be from the end of the last match to the\n", "       * beginning of the next one. nextStart is the start position of the\n", "       * returned substring, while offset is the place to start looking for a\n", "       * separator.\n", "       */\n", "      int nextStart = offset;\n", "      while (offset != -1) {\n", "        int start = nextStart;\n", "        int end;\n", "\n", "        int separatorPosition = separatorStart(offset);\n", "        if (separatorPosition == -1) {\n", "          end = toSplit.length();\n", "          offset = -1;\n", "        } else {\n", "          end = separatorPosition;\n", "          offset = separatorEnd(separatorPosition);\n", "        }\n", "        if (offset == nextStart) {\n", "          /*\n", "           * This occurs when some pattern has an empty match, even if it\n", "           * doesn't match the empty string -- for example, if it requires\n", "           * lookahead or the like. The offset must be increased to look for\n", "           * separators beyond this point, without changing the start position\n", "           * of the next returned substring -- so nextStart stays the same.\n", "           */\n", "          offset++;\n", "          if (offset >= toSplit.length()) {\n", "            offset = -1;\n", "          }\n", "          continue;\n", "        }\n", "\n", "        while (start < end && trimmer.matches(toSplit.charAt(start))) {\n", "          start++;\n", "        }\n", "        while (end > start && trimmer.matches(toSplit.charAt(end - 1))) {\n", "          end--;\n", "        }\n", "\n", "        if (omitEmptyStrings && start == end) {\n", "          // Don't include the (unused) separator in next split string.\n", "          nextStart = offset;\n", "          continue;\n", "        }\n", "\n", "        if (limit == 1) {\n", "          // The limit has been reached, return the rest of the string as the\n", "          // final item.  This is tested after empty string removal so that\n", "          // empty strings do not count towards the limit.\n", "          end = toSplit.length();\n", "          offset = -1;\n", "          // Since we may have changed the end, we need to trim it again.\n", "          while (end > start && trimmer.matches(toSplit.charAt(end - 1))) {\n", "            end--;\n", "          }\n", "        } else {\n", "          limit--;\n", "        }\n", "\n", "        return toSplit.subSequence(start, end).toString();\n", "      }\n", "      return endOfData();\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579]}}, {"6": "guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Stopwatch.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static java.util.concurrent.TimeUnit.DAYS;\n", "import static java.util.concurrent.TimeUnit.HOURS;\n", "import static java.util.concurrent.TimeUnit.MICROSECONDS;\n", "import static java.util.concurrent.TimeUnit.MILLISECONDS;\n", "import static java.util.concurrent.TimeUnit.MINUTES;\n", "import static java.util.concurrent.TimeUnit.NANOSECONDS;\n", "import static java.util.concurrent.TimeUnit.SECONDS;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.concurrent.TimeUnit;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "\n", "/**\n", " * An object that measures elapsed time in nanoseconds. It is useful to measure\n", " * elapsed time using this class instead of direct calls to {@link\n", " * System#nanoTime} for a few reasons:\n", " *\n", " * <ul>\n", " * <li>An alternate time source can be substituted, for testing or performance\n", " *     reasons.\n", " * <li>As documented by {@code nanoTime}, the value returned has no absolute\n", " *     meaning, and can only be interpreted as relative to another timestamp\n", " *     returned by {@code nanoTime} at a different time. {@code Stopwatch} is a\n", " *     more effective abstraction because it exposes only these relative values,\n", " *     not the absolute ones.\n", " * </ul>\n", " *\n", " * <p>Basic usage:\n", " * <pre>\n", " *   Stopwatch stopwatch = Stopwatch.{@link #createStarted createStarted}();\n", " *   doSomething();\n", " *   stopwatch.{@link #stop stop}(); // optional\n", " *\n", " *   long millis = stopwatch.elapsed(MILLISECONDS);\n", " *\n", " *   log.info(\"time: \" + stopwatch); // formatted string like \"12.3 ms\"</pre>\n", " *\n", " * <p>Stopwatch methods are not idempotent; it is an error to start or stop a\n", " * stopwatch that is already in the desired state.\n", " *\n", " * <p>When testing code that uses this class, use\n", " * {@link #createUnstarted(Ticker)} or {@link #createStarted(Ticker)} to\n", " * supply a fake or mock ticker.\n", " * <!-- TODO(kevinb): restore the \"such as\" --> This allows you to\n", " * simulate any valid behavior of the stopwatch.\n", " *\n", " * <p><b>Note:</b> This class is not thread-safe.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 10.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Stopwatch {\n", "  private final Ticker ticker;\n", "  private boolean isRunning;\n", "  private long elapsedNanos;\n", "  private long startTick;\n", "\n", "  /**\n", "   * Creates (but does not start) a new stopwatch using {@link System#nanoTime}\n", "   * as its time source.\n", "   *\n", "   * @since 15.0\n", "   */\n", "  @CheckReturnValue\n", "  public static Stopwatch createUnstarted() {\n", "    return new Stopwatch();\n", "  }\n", "\n", "  /**\n", "   * Creates (but does not start) a new stopwatch, using the specified time\n", "   * source.\n", "   *\n", "   * @since 15.0\n", "   */\n", "  @CheckReturnValue\n", "  public static Stopwatch createUnstarted(Ticker ticker) {\n", "    return new Stopwatch(ticker);\n", "  }\n", "\n", "  /**\n", "   * Creates (and starts) a new stopwatch using {@link System#nanoTime}\n", "   * as its time source.\n", "   *\n", "   * @since 15.0\n", "   */\n", "  @CheckReturnValue\n", "  public static Stopwatch createStarted() {\n", "    return new Stopwatch().start();\n", "  }\n", "\n", "  /**\n", "   * Creates (and starts) a new stopwatch, using the specified time\n", "   * source.\n", "   *\n", "   * @since 15.0\n", "   */\n", "  @CheckReturnValue\n", "  public static Stopwatch createStarted(Ticker ticker) {\n", "    return new Stopwatch(ticker).start();\n", "  }\n", "\n", "  Stopwatch() {\n", "    this.ticker = Ticker.systemTicker();\n", "  }\n", "\n", "  Stopwatch(Ticker ticker) {\n", "    this.ticker = checkNotNull(ticker, \"ticker\");\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@link #start()} has been called on this stopwatch,\n", "   * and {@link #stop()} has not been called since the last call to {@code\n", "   * start()}.\n", "   */\n", "  @CheckReturnValue\n", "  public boolean isRunning() {\n", "    return isRunning;\n", "  }\n", "\n", "  /**\n", "   * Starts the stopwatch.\n", "   *\n", "   * @return this {@code Stopwatch} instance\n", "   * @throws IllegalStateException if the stopwatch is already running.\n", "   */\n", "  public Stopwatch start() {\n", "    checkState(!isRunning, \"This stopwatch is already running.\");\n", "    isRunning = true;\n", "    startTick = ticker.read();\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Stops the stopwatch. Future reads will return the fixed duration that had\n", "   * elapsed up to this point.\n", "   *\n", "   * @return this {@code Stopwatch} instance\n", "   * @throws IllegalStateException if the stopwatch is already stopped.\n", "   */\n", "  public Stopwatch stop() {\n", "    long tick = ticker.read();\n", "    checkState(isRunning, \"This stopwatch is already stopped.\");\n", "    isRunning = false;\n", "    elapsedNanos += tick - startTick;\n", "    return this;\n", "  }\n", "\n", "  /**\n", "   * Sets the elapsed time for this stopwatch to zero,\n", "   * and places it in a stopped state.\n", "   *\n", "   * @return this {@code Stopwatch} instance\n", "   */\n", "  public Stopwatch reset() {\n", "    elapsedNanos = 0;\n", "    isRunning = false;\n", "    return this;\n", "  }\n", "\n", "  private long elapsedNanos() {\n", "    return isRunning ? ticker.read() - startTick + elapsedNanos : elapsedNanos;\n", "  }\n", "\n", "  /**\n", "   * Returns the current elapsed time shown on this stopwatch, expressed\n", "   * in the desired time unit, with any fraction rounded down.\n", "   *\n", "   * <p>Note that the overhead of measurement can be more than a microsecond, so\n", "   * it is generally not useful to specify {@link TimeUnit#NANOSECONDS}\n", "   * precision here.\n", "   *\n", "   * @since 14.0 (since 10.0 as {@code elapsedTime()})\n", "   */\n", "  @CheckReturnValue\n", "  public long elapsed(TimeUnit desiredUnit) {\n", "    return desiredUnit.convert(elapsedNanos(), NANOSECONDS);\n", "  }\n", "\n", "  private static TimeUnit chooseUnit(long nanos) {\n", "    if (DAYS.convert(nanos, NANOSECONDS) > 0) {\n", "      return DAYS;\n", "    }\n", "    if (HOURS.convert(nanos, NANOSECONDS) > 0) {\n", "      return HOURS;\n", "    }\n", "    if (MINUTES.convert(nanos, NANOSECONDS) > 0) {\n", "      return MINUTES;\n", "    }\n", "    if (SECONDS.convert(nanos, NANOSECONDS) > 0) {\n", "      return SECONDS;\n", "    }\n", "    if (MILLISECONDS.convert(nanos, NANOSECONDS) > 0) {\n", "      return MILLISECONDS;\n", "    }\n", "    if (MICROSECONDS.convert(nanos, NANOSECONDS) > 0) {\n", "      return MICROSECONDS;\n", "    }\n", "    return NANOSECONDS;\n", "  }\n", "\n", "  private static String abbreviate(TimeUnit unit) {\n", "    switch (unit) {\n", "      case NANOSECONDS:\n", "        return \"ns\";\n", "      case MICROSECONDS:\n", "        return \"\\u03bcs\"; // \u03bcs\n", "      case MILLISECONDS:\n", "        return \"ms\";\n", "      case SECONDS:\n", "        return \"s\";\n", "      case MINUTES:\n", "        return \"min\";\n", "      case HOURS:\n", "        return \"h\";\n", "      case DAYS:\n", "        return \"d\";\n", "      default:\n", "        throw new AssertionError();\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245]}}, {"7": "guava-gwt/src-super/com/google/common/cache/super/com/google/common/cache/CacheBuilder.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.cache;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkState;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Ascii;\n", "import com.google.common.base.Equivalence;\n", "import com.google.common.base.MoreObjects;\n", "import com.google.common.base.Supplier;\n", "import com.google.common.base.Suppliers;\n", "import com.google.common.base.Ticker;\n", "import com.google.common.cache.AbstractCache.SimpleStatsCounter;\n", "import com.google.common.cache.AbstractCache.StatsCounter;\n", "import com.google.common.cache.LocalCache.Strength;\n", "\n", "import java.util.concurrent.TimeUnit;\n", "import java.util.logging.Level;\n", "import java.util.logging.Logger;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "\n", "/**\n", " * <p>A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the\n", " * following features:\n", " *\n", " * <ul>\n", " * <li>automatic loading of entries into the cache\n", " * <li>least-recently-used eviction when a maximum size is exceeded\n", " * <li>time-based expiration of entries, measured since last access or last write\n", " * <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n", " * <li>values automatically wrapped in {@linkplain WeakReference weak} or\n", " *     {@linkplain SoftReference soft} references\n", " * <li>notification of evicted (or otherwise removed) entries\n", " * <li>accumulation of cache access statistics\n", " * </ul>\n", " *\n", " *\n", " * <p>These features are all optional; caches can be created using all or none of them. By default\n", " * cache instances created by {@code CacheBuilder} will not perform any type of eviction.\n", " *\n", " * <p>Usage example: <pre>   {@code\n", " *\n", " *   LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()\n", " *       .maximumSize(10000)\n", " *       .expireAfterWrite(10, TimeUnit.MINUTES)\n", " *       .removalListener(MY_LISTENER)\n", " *       .build(\n", " *           new CacheLoader<Key, Graph>() {\n", " *             public Graph load(Key key) throws AnyException {\n", " *               return createExpensiveGraph(key);\n", " *             }\n", " *           });}</pre>\n", " *\n", " * <p>Or equivalently, <pre>   {@code\n", " *\n", " *   // In real life this would come from a command-line flag or config file\n", " *   String spec = \"maximumSize=10000,expireAfterWrite=10m\";\n", " *\n", " *   LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)\n", " *       .removalListener(MY_LISTENER)\n", " *       .build(\n", " *           new CacheLoader<Key, Graph>() {\n", " *             public Graph load(Key key) throws AnyException {\n", " *               return createExpensiveGraph(key);\n", " *             }\n", " *           });}</pre>\n", " *\n", " * <p>The returned cache is implemented as a hash table with similar performance characteristics to\n", " * {@link ConcurrentHashMap}. It implements all optional operations of the {@link LoadingCache} and\n", " * {@link Cache} interfaces. The {@code asMap} view (and its collection views) have <i>weakly\n", " * consistent iterators</i>. This means that they are safe for concurrent use, but if other threads\n", " * modify the cache after the iterator is created, it is undefined which of these changes, if any,\n", " * are reflected in that iterator. These iterators never throw {@link\n", " * ConcurrentModificationException}.\n", " *\n", " * <p><b>Note:</b> by default, the returned cache uses equality comparisons (the\n", " * {@link Object#equals equals} method) to determine equality for keys or values. However, if\n", " * {@link #weakKeys} was specified, the cache uses identity ({@code ==})\n", " * comparisons instead for keys. Likewise, if {@link #weakValues} or {@link #softValues} was\n", " * specified, the cache uses identity comparisons for values.\n", " *\n", " * <p>Entries are automatically evicted from the cache when any of\n", " * {@linkplain #maximumSize(long) maximumSize}, {@linkplain #maximumWeight(long) maximumWeight},\n", " * {@linkplain #expireAfterWrite expireAfterWrite},\n", " * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},\n", " * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are requested.\n", " *\n", " * <p>If {@linkplain #maximumSize(long) maximumSize} or\n", " * {@linkplain #maximumWeight(long) maximumWeight} is requested entries may be evicted on each cache\n", " * modification.\n", " *\n", " * <p>If {@linkplain #expireAfterWrite expireAfterWrite} or\n", " * {@linkplain #expireAfterAccess expireAfterAccess} is requested entries may be evicted on each\n", " * cache modification, on occasional cache accesses, or on calls to {@link Cache#cleanUp}. Expired\n", " * entries may be counted by {@link Cache#size}, but will never be visible to read or write\n", " * operations.\n", " *\n", " * <p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or\n", " * {@linkplain #softValues softValues} are requested, it is possible for a key or value present in\n", " * the cache to be reclaimed by the garbage collector. Entries with reclaimed keys or values may be\n", " * removed from the cache on each cache modification, on occasional cache accesses, or on calls to\n", " * {@link Cache#cleanUp}; such entries may be counted in {@link Cache#size}, but will never be\n", " * visible to read or write operations.\n", " *\n", " * <p>Certain cache configurations will result in the accrual of periodic maintenance tasks which\n", " * will be performed during write operations, or during occasional read operations in the absence of\n", " * writes. The {@link Cache#cleanUp} method of the returned cache will also perform maintenance, but\n", " * calling it should not be necessary with a high throughput cache. Only caches built with\n", " * {@linkplain #removalListener removalListener}, {@linkplain #expireAfterWrite expireAfterWrite},\n", " * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},\n", " * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic\n", " * maintenance.\n", " *\n", " * <p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches\n", " * retain all the configuration properties of the original cache. Note that the serialized form does\n", " * <i>not</i> include cache contents, but only configuration.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/CachesExplained\">caching</a> for a higher-level\n", " * explanation.\n", " *\n", " * @param <K> the base key type for all caches created by this builder\n", " * @param <V> the base value type for all caches created by this builder\n", " * @author Charles Fry\n", " * @author Kevin Bourrillion\n", " * @since 10.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class CacheBuilder<K, V> {\n", "  private static final int DEFAULT_INITIAL_CAPACITY = 16;\n", "  private static final int DEFAULT_CONCURRENCY_LEVEL = 4;\n", "  private static final int DEFAULT_EXPIRATION_NANOS = 0;\n", "  private static final int DEFAULT_REFRESH_NANOS = 0;\n", "\n", "  static final Supplier<? extends StatsCounter> NULL_STATS_COUNTER = Suppliers.ofInstance(\n", "      new StatsCounter() {\n", "        @Override\n", "        public void recordHits(int count) {}\n", "\n", "        @Override\n", "        public void recordMisses(int count) {}\n", "\n", "        @Override\n", "        public void recordLoadSuccess(long loadTime) {}\n", "\n", "        @Override\n", "        public void recordLoadException(long loadTime) {}\n", "\n", "        @Override\n", "        public void recordEviction() {}\n", "\n", "        @Override\n", "        public CacheStats snapshot() {\n", "          return EMPTY_STATS;\n", "        }\n", "      });\n", "  static final CacheStats EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);\n", "\n", "  static final Supplier<StatsCounter> CACHE_STATS_COUNTER =\n", "      new Supplier<StatsCounter>() {\n", "    @Override\n", "    public StatsCounter get() {\n", "      return new SimpleStatsCounter();\n", "    }\n", "  };\n", "\n", "  enum NullListener implements RemovalListener<Object, Object> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public void onRemoval(RemovalNotification<Object, Object> notification) {}\n", "  }\n", "\n", "  enum OneWeigher implements Weigher<Object, Object> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public int weigh(Object key, Object value) {\n", "      return 1;\n", "    }\n", "  }\n", "\n", "  static final Ticker NULL_TICKER = new Ticker() {\n", "    @Override\n", "    public long read() {\n", "      return 0;\n", "    }\n", "  };\n", "\n", "  private static final Logger logger = Logger.getLogger(CacheBuilder.class.getName());\n", "\n", "  static final int UNSET_INT = -1;\n", "\n", "  boolean strictParsing = true;\n", "\n", "  int initialCapacity = UNSET_INT;\n", "  int concurrencyLevel = UNSET_INT;\n", "  long maximumSize = UNSET_INT;\n", "  long maximumWeight = UNSET_INT;\n", "  Weigher<? super K, ? super V> weigher;\n", "\n", "  Strength keyStrength;\n", "  Strength valueStrength;\n", "\n", "  long expireAfterWriteNanos = UNSET_INT;\n", "  long expireAfterAccessNanos = UNSET_INT;\n", "  long refreshNanos = UNSET_INT;\n", "\n", "  Equivalence<Object> keyEquivalence;\n", "  Equivalence<Object> valueEquivalence;\n", "\n", "  RemovalListener<? super K, ? super V> removalListener;\n", "  Ticker ticker;\n", "\n", "  Supplier<? extends StatsCounter> statsCounterSupplier = NULL_STATS_COUNTER;\n", "\n", "  // TODO(fry): make constructor private and update tests to use newBuilder\n", "  CacheBuilder() {}\n", "\n", "  /**\n", "   * Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,\n", "   * strong values, and no automatic eviction of any kind.\n", "   */\n", "  public static CacheBuilder<Object, Object> newBuilder() {\n", "    return new CacheBuilder<Object, Object>();\n", "  }\n", "\n", "  Equivalence<Object> getKeyEquivalence() {\n", "    return MoreObjects.firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence());\n", "  }\n", "\n", "  Equivalence<Object> getValueEquivalence() {\n", "    return MoreObjects.firstNonNull(valueEquivalence, getValueStrength().defaultEquivalence());\n", "  }\n", "\n", "  /**\n", "   * Sets the minimum total size for the internal hash tables. For example, if the initial capacity\n", "   * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each\n", "   * having a hash table of size eight. Providing a large enough estimate at construction time\n", "   * avoids the need for expensive resizing operations later, but setting this value unnecessarily\n", "   * high wastes memory.\n", "   *\n", "   * @throws IllegalArgumentException if {@code initialCapacity} is negative\n", "   * @throws IllegalStateException if an initial capacity was already set\n", "   */\n", "  public CacheBuilder<K, V> initialCapacity(int initialCapacity) {\n", "    checkState(this.initialCapacity == UNSET_INT, \"initial capacity was already set to %s\",\n", "        this.initialCapacity);\n", "    checkArgument(initialCapacity >= 0);\n", "    this.initialCapacity = initialCapacity;\n", "    return this;\n", "  }\n", "\n", "  int getInitialCapacity() {\n", "    return (initialCapacity == UNSET_INT) ? DEFAULT_INITIAL_CAPACITY : initialCapacity;\n", "  }\n", "\n", "  /**\n", "   * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The\n", "   * table is internally partitioned to try to permit the indicated number of concurrent updates\n", "   * without contention. Because assignment of entries to these partitions is not necessarily\n", "   * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to\n", "   * accommodate as many threads as will ever concurrently modify the table. Using a significantly\n", "   * higher value than you need can waste space and time, and a significantly lower value can lead\n", "   * to thread contention. But overestimates and underestimates within an order of magnitude do not\n", "   * usually have much noticeable impact. A value of one permits only one thread to modify the cache\n", "   * at a time, but since read operations and cache loading computations can proceed concurrently,\n", "   * this still yields higher concurrency than full synchronization.\n", "   *\n", "   * <p> Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this\n", "   * value, you should always choose it explicitly.\n", "   *\n", "   * <p>The current implementation uses the concurrency level to create a fixed number of hashtable\n", "   * segments, each governed by its own write lock. The segment lock is taken once for each explicit\n", "   * write, and twice for each cache loading computation (once prior to loading the new value,\n", "   * and once after loading completes). Much internal cache management is performed at the segment\n", "   * granularity. For example, access queues and write queues are kept per segment when they are\n", "   * required by the selected eviction algorithm. As such, when writing unit tests it is not\n", "   * uncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction\n", "   * behavior.\n", "   *\n", "   * <p>Note that future implementations may abandon segment locking in favor of more advanced\n", "   * concurrency controls.\n", "   *\n", "   * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive\n", "   * @throws IllegalStateException if a concurrency level was already set\n", "   */\n", "  public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel) {\n", "    checkState(this.concurrencyLevel == UNSET_INT, \"concurrency level was already set to %s\",\n", "        this.concurrencyLevel);\n", "    checkArgument(concurrencyLevel > 0);\n", "    this.concurrencyLevel = concurrencyLevel;\n", "    return this;\n", "  }\n", "\n", "  int getConcurrencyLevel() {\n", "    return (concurrencyLevel == UNSET_INT) ? DEFAULT_CONCURRENCY_LEVEL : concurrencyLevel;\n", "  }\n", "\n", "  /**\n", "   * Specifies the maximum number of entries the cache may contain. Note that the cache <b>may evict\n", "   * an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the\n", "   * cache evicts entries that are less likely to be used again. For example, the cache may evict an\n", "   * entry because it hasn't been used recently or very often.\n", "   *\n", "   * <p>When {@code size} is zero, elements will be evicted immediately after being loaded into the\n", "   * cache. This can be useful in testing, or to disable caching temporarily without a code change.\n", "   *\n", "   * <p>This feature cannot be used in conjunction with {@link #maximumWeight}.\n", "   *\n", "   * @param size the maximum size of the cache\n", "   * @throws IllegalArgumentException if {@code size} is negative\n", "   * @throws IllegalStateException if a maximum size or weight was already set\n", "   */\n", "  public CacheBuilder<K, V> maximumSize(long size) {\n", "    checkState(this.maximumSize == UNSET_INT, \"maximum size was already set to %s\",\n", "        this.maximumSize);\n", "    checkState(this.maximumWeight == UNSET_INT, \"maximum weight was already set to %s\",\n", "        this.maximumWeight);\n", "    checkState(this.weigher == null, \"maximum size can not be combined with weigher\");\n", "    checkArgument(size >= 0, \"maximum size must not be negative\");\n", "    this.maximumSize = size;\n", "    return this;\n", "  }\n", "\n", "  long getMaximumWeight() {\n", "    if (expireAfterWriteNanos == 0 || expireAfterAccessNanos == 0) {\n", "      return 0;\n", "    }\n", "    return (weigher == null) ? maximumSize : maximumWeight;\n", "  }\n", "\n", "  // Make a safe contravariant cast now so we don't have to do it over and over.\n", "  @SuppressWarnings(\"unchecked\")\n", "  <K1 extends K, V1 extends V> Weigher<K1, V1> getWeigher() {\n", "    return (Weigher<K1, V1>) MoreObjects.firstNonNull(weigher, OneWeigher.INSTANCE);\n", "  }\n", "\n", "  CacheBuilder<K, V> setKeyStrength(Strength strength) {\n", "    checkState(keyStrength == null, \"Key strength was already set to %s\", keyStrength);\n", "    keyStrength = checkNotNull(strength);\n", "    return this;\n", "  }\n", "\n", "  Strength getKeyStrength() {\n", "    return MoreObjects.firstNonNull(keyStrength, Strength.STRONG);\n", "  }\n", "\n", "  CacheBuilder<K, V> setValueStrength(Strength strength) {\n", "    checkState(valueStrength == null, \"Value strength was already set to %s\", valueStrength);\n", "    valueStrength = checkNotNull(strength);\n", "    return this;\n", "  }\n", "\n", "  Strength getValueStrength() {\n", "    return MoreObjects.firstNonNull(valueStrength, Strength.STRONG);\n", "  }\n", "\n", "  /**\n", "   * Specifies that each entry should be automatically removed from the cache once a fixed duration\n", "   * has elapsed after the entry's creation, or the most recent replacement of its value.\n", "   *\n", "   * <p>When {@code duration} is zero, this method hands off to\n", "   * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum\n", "   * size or weight. This can be useful in testing, or to disable caching temporarily without a code\n", "   * change.\n", "   *\n", "   * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n", "   * write operations. Expired entries are cleaned up as part of the routine maintenance described\n", "   * in the class javadoc.\n", "   *\n", "   * @param duration the length of time after an entry is created that it should be automatically\n", "   *     removed\n", "   * @param unit the unit that {@code duration} is expressed in\n", "   * @throws IllegalArgumentException if {@code duration} is negative\n", "   * @throws IllegalStateException if the time to live or time to idle was already set\n", "   */\n", "  public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit) {\n", "    checkState(expireAfterWriteNanos == UNSET_INT, \"expireAfterWrite was already set to %s ns\",\n", "        expireAfterWriteNanos);\n", "    checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n", "    this.expireAfterWriteNanos = unit.toNanos(duration);\n", "    return this;\n", "  }\n", "\n", "  long getExpireAfterWriteNanos() {\n", "    return (expireAfterWriteNanos == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos;\n", "  }\n", "\n", "  /**\n", "   * Specifies that each entry should be automatically removed from the cache once a fixed duration\n", "   * has elapsed after the entry's creation, the most recent replacement of its value, or its last\n", "   * access. Access time is reset by all cache read and write operations (including\n", "   * {@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations\n", "   * on the collection-views of {@link Cache#asMap}.\n", "   *\n", "   * <p>When {@code duration} is zero, this method hands off to\n", "   * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum\n", "   * size or weight. This can be useful in testing, or to disable caching temporarily without a code\n", "   * change.\n", "   *\n", "   * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n", "   * write operations. Expired entries are cleaned up as part of the routine maintenance described\n", "   * in the class javadoc.\n", "   *\n", "   * @param duration the length of time after an entry is last accessed that it should be\n", "   *     automatically removed\n", "   * @param unit the unit that {@code duration} is expressed in\n", "   * @throws IllegalArgumentException if {@code duration} is negative\n", "   * @throws IllegalStateException if the time to idle or time to live was already set\n", "   */\n", "  public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit) {\n", "    checkState(expireAfterAccessNanos == UNSET_INT, \"expireAfterAccess was already set to %s ns\",\n", "        expireAfterAccessNanos);\n", "    checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n", "    this.expireAfterAccessNanos = unit.toNanos(duration);\n", "    return this;\n", "  }\n", "\n", "  long getExpireAfterAccessNanos() {\n", "    return (expireAfterAccessNanos == UNSET_INT)\n", "        ? DEFAULT_EXPIRATION_NANOS : expireAfterAccessNanos;\n", "  }\n", "\n", "  long getRefreshNanos() {\n", "    return (refreshNanos == UNSET_INT) ? DEFAULT_REFRESH_NANOS : refreshNanos;\n", "  }\n", "\n", "  /**\n", "   * Specifies a nanosecond-precision time source for this cache. By default,\n", "   * {@link System#nanoTime} is used.\n", "   *\n", "   * <p>The primary intent of this method is to facilitate testing of caches with a fake or mock\n", "   * time source.\n", "   *\n", "   * @throws IllegalStateException if a ticker was already set\n", "   */\n", "  public CacheBuilder<K, V> ticker(Ticker ticker) {\n", "    checkState(this.ticker == null);\n", "    this.ticker = checkNotNull(ticker);\n", "    return this;\n", "  }\n", "\n", "  Ticker getTicker(boolean recordsTime) {\n", "    if (ticker != null) {\n", "      return ticker;\n", "    }\n", "    return recordsTime ? Ticker.systemTicker() : NULL_TICKER;\n", "  }\n", "\n", "  /**\n", "   * Specifies a listener instance that caches should notify each time an entry is removed for any\n", "   * {@linkplain RemovalCause reason}. Each cache created by this builder will invoke this listener\n", "   * as part of the routine maintenance described in the class documentation above.\n", "   *\n", "   * <p><b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache\n", "   * builder reference; instead use the reference this method <i>returns</i>. At runtime, these\n", "   * point to the same instance, but only the returned reference has the correct generic type\n", "   * information so as to ensure type safety. For best results, use the standard method-chaining\n", "   * idiom illustrated in the class documentation above, configuring a builder and building your\n", "   * cache in a single statement. Failure to heed this advice can result in a {@link\n", "   * ClassCastException} being thrown by a cache operation at some <i>undefined</i> point in the\n", "   * future.\n", "   *\n", "   * <p><b>Warning:</b> any exception thrown by {@code listener} will <i>not</i> be propagated to\n", "   * the {@code Cache} user, only logged via a {@link Logger}.\n", "   *\n", "   * @return the cache builder reference that should be used instead of {@code this} for any\n", "   *     remaining configuration and cache building\n", "   * @throws IllegalStateException if a removal listener was already set\n", "   */\n", "  @CheckReturnValue\n", "  public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(\n", "      RemovalListener<? super K1, ? super V1> listener) {\n", "    checkState(this.removalListener == null);\n", "\n", "    // safely limiting the kinds of caches this can produce\n", "    @SuppressWarnings(\"unchecked\")\n", "    CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n", "    me.removalListener = checkNotNull(listener);\n", "    return me;\n", "  }\n", "\n", "  // Make a safe contravariant cast now so we don't have to do it over and over.\n", "  @SuppressWarnings(\"unchecked\")\n", "  <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener() {\n", "    return (RemovalListener<K1, V1>)\n", "        MoreObjects.firstNonNull(removalListener, NullListener.INSTANCE);\n", "  }\n", "\n", "  /**\n", "   * Enable the accumulation of {@link CacheStats} during the operation of the cache. Without this\n", "   * {@link Cache#stats} will return zero for all statistics. Note that recording stats requires\n", "   * bookkeeping to be performed with each operation, and thus imposes a performance penalty on\n", "   * cache operation.\n", "   *\n", "   * @since 12.0 (previously, stats collection was automatic)\n", "   */\n", "  public CacheBuilder<K, V> recordStats() {\n", "    statsCounterSupplier = CACHE_STATS_COUNTER;\n", "    return this;\n", "  }\n", "\n", "  boolean isRecordingStats() {\n", "    return statsCounterSupplier == CACHE_STATS_COUNTER;\n", "  }\n", "\n", "  Supplier<? extends StatsCounter> getStatsCounterSupplier() {\n", "    return statsCounterSupplier;\n", "  }\n", "\n", "  /**\n", "   * Builds a cache, which either returns an already-loaded value for a given key or atomically\n", "   * computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently\n", "   * loading the value for this key, simply waits for that thread to finish and returns its\n", "   * loaded value. Note that multiple threads can concurrently load values for distinct keys.\n", "   *\n", "   * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n", "   * invoked again to create multiple independent caches.\n", "   *\n", "   * @param loader the cache loader used to obtain new values\n", "   * @return a cache having the requested features\n", "   */\n", "  public <K1 extends K, V1 extends V> LoadingCache<K1, V1> build(\n", "          CacheLoader<? super K1, V1> loader) {\n", "    checkWeightWithWeigher();\n", "    return new LocalCache.LocalLoadingCache<K1, V1>(this, loader);\n", "  }\n", "\n", "  /**\n", "   * Builds a cache which does not automatically load values when keys are requested.\n", "   *\n", "   * <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a\n", "   * {@code CacheLoader}.\n", "   *\n", "   * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n", "   * invoked again to create multiple independent caches.\n", "   *\n", "   * @return a cache having the requested features\n", "   * @since 11.0\n", "   */\n", "  public <K1 extends K, V1 extends V> Cache<K1, V1> build() {\n", "    checkWeightWithWeigher();\n", "    checkNonLoadingCache();\n", "    return new LocalCache.LocalManualCache<K1, V1>(this);\n", "  }\n", "\n", "  private void checkNonLoadingCache() {\n", "    checkState(refreshNanos == UNSET_INT, \"refreshAfterWrite requires a LoadingCache\");\n", "  }\n", "\n", "  private void checkWeightWithWeigher() {\n", "    if (weigher == null) {\n", "      checkState(maximumWeight == UNSET_INT, \"maximumWeight requires weigher\");\n", "    } else {\n", "      if (strictParsing) {\n", "        checkState(maximumWeight != UNSET_INT, \"weigher requires maximumWeight\");\n", "      } else {\n", "        if (maximumWeight == UNSET_INT) {\n", "          logger.log(Level.WARNING, \"ignoring weigher specified without maximumWeight\");\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation for this CacheBuilder instance. The exact form of the returned\n", "   * string is not specified.\n", "   */\n", "  @Override\n", "  public String toString() {\n", "    MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\n", "    if (initialCapacity != UNSET_INT) {\n", "      s.add(\"initialCapacity\", initialCapacity);\n", "    }\n", "    if (concurrencyLevel != UNSET_INT) {\n", "      s.add(\"concurrencyLevel\", concurrencyLevel);\n", "    }\n", "    if (maximumSize != UNSET_INT) {\n", "      s.add(\"maximumSize\", maximumSize);\n", "    }\n", "    if (maximumWeight != UNSET_INT) {\n", "      s.add(\"maximumWeight\", maximumWeight);\n", "    }\n", "    if (expireAfterWriteNanos != UNSET_INT) {\n", "      s.add(\"expireAfterWrite\", expireAfterWriteNanos + \"ns\");\n", "    }\n", "    if (expireAfterAccessNanos != UNSET_INT) {\n", "      s.add(\"expireAfterAccess\", expireAfterAccessNanos + \"ns\");\n", "    }\n", "    if (keyStrength != null) {\n", "      s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\n", "    }\n", "    if (valueStrength != null) {\n", "      s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\n", "    }\n", "    if (keyEquivalence != null) {\n", "      s.addValue(\"keyEquivalence\");\n", "    }\n", "    if (valueEquivalence != null) {\n", "      s.addValue(\"valueEquivalence\");\n", "    }\n", "    if (removalListener != null) {\n", "      s.addValue(\"removalListener\");\n", "    }\n", "    return s.toString();\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626]}}, {"8": "guava-gwt/src-super/com/google/common/cache/super/com/google/common/cache/CacheLoader.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.cache;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Supplier;\n", "\n", "import java.io.Serializable;\n", "import java.util.Map;\n", "\n", "/**\n", " * Computes or retrieves values, based on a key, for use in populating a {@link LoadingCache}.\n", " *\n", " * <p>Most implementations will only need to implement {@link #load}. Other methods may be\n", " * overridden as desired.\n", " *\n", " * <p>Usage example: <pre>   {@code\n", " *\n", " *   CacheLoader<Key, Graph> loader = new CacheLoader<Key, Graph>() {\n", " *     public Graph load(Key key) throws AnyException {\n", " *       return createExpensiveGraph(key);\n", " *     }\n", " *   };\n", " *   LoadingCache<Key, Graph> cache = CacheBuilder.newBuilder().build(loader);}</pre>\n", " *\n", " * @author Charles Fry\n", " * @since 10.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public abstract class CacheLoader<K, V> {\n", "  /**\n", "   * Constructor for use by subclasses.\n", "   */\n", "  protected CacheLoader() {}\n", "\n", "  /**\n", "   * Computes or retrieves the value corresponding to {@code key}.\n", "   *\n", "   * @param key the non-null key whose value should be loaded\n", "   * @return the value associated with {@code key}; <b>must not be null</b>\n", "   * @throws Exception if unable to load the result\n", "   * @throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n", "   *     treated like any other {@code Exception} in all respects except that, when it is caught,\n", "   *     the thread's interrupt status is set\n", "   */\n", "  public abstract V load(K key) throws Exception;\n", "\n", "  /**\n", "   * Computes or retrieves the values corresponding to {@code keys}. This method is called by\n", "   * {@link LoadingCache#getAll}.\n", "   *\n", "   * <p>If the returned map doesn't contain all requested {@code keys} then the entries it does\n", "   * contain will be cached, but {@code getAll} will throw an exception. If the returned map\n", "   * contains extra keys not present in {@code keys} then all returned entries will be cached,\n", "   * but only the entries for {@code keys} will be returned from {@code getAll}.\n", "   *\n", "   * <p>This method should be overriden when bulk retrieval is significantly more efficient than\n", "   * many individual lookups. Note that {@link LoadingCache#getAll} will defer to individual calls\n", "   * to {@link LoadingCache#get} if this method is not overriden.\n", "   *\n", "   * @param keys the unique, non-null keys whose values should be loaded\n", "   * @return a map from each key in {@code keys} to the value associated with that key;\n", "   *     <b>may not contain null values</b>\n", "   * @throws Exception if unable to load the result\n", "   * @throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n", "   *     treated like any other {@code Exception} in all respects except that, when it is caught,\n", "   *     the thread's interrupt status is set\n", "   * @since 11.0\n", "   */\n", "  public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {\n", "    // This will be caught by getAll(), causing it to fall back to multiple calls to\n", "    // LoadingCache.get\n", "    throw new UnsupportedLoadingOperationException();\n", "  }\n", "\n", "  /**\n", "   * Returns a cache loader based on an <i>existing</i> function instance. Note that there's no need\n", "   * to create a <i>new</i> function just to pass it in here; just subclass {@code CacheLoader} and\n", "   * implement {@link #load load} instead.\n", "   *\n", "   * @param function the function to be used for loading values; must never return {@code null}\n", "   * @return a cache loader that loads values by passing each key to {@code function}\n", "   */\n", "  public static <K, V> CacheLoader<K, V> from(Function<K, V> function) {\n", "    return new FunctionToCacheLoader<K, V>(function);\n", "  }\n", "\n", "  private static final class FunctionToCacheLoader<K, V>\n", "      extends CacheLoader<K, V> implements Serializable {\n", "    private final Function<K, V> computingFunction;\n", "\n", "    public FunctionToCacheLoader(Function<K, V> computingFunction) {\n", "      this.computingFunction = checkNotNull(computingFunction);\n", "    }\n", "\n", "    @Override\n", "    public V load(K key) {\n", "      return computingFunction.apply(checkNotNull(key));\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Returns a cache loader based on an <i>existing</i> supplier instance. Note that there's no need\n", "   * to create a <i>new</i> supplier just to pass it in here; just subclass {@code CacheLoader} and\n", "   * implement {@link #load load} instead.\n", "   *\n", "   * @param supplier the supplier to be used for loading values; must never return {@code null}\n", "   * @return a cache loader that loads values by calling {@link Supplier#get}, irrespective of the\n", "   *     key\n", "   */\n", "  public static <V> CacheLoader<Object, V> from(Supplier<V> supplier) {\n", "    return new SupplierToCacheLoader<V>(supplier);\n", "  }\n", "\n", "  private static final class SupplierToCacheLoader<V>\n", "      extends CacheLoader<Object, V> implements Serializable {\n", "    private final Supplier<V> computingSupplier;\n", "\n", "    public SupplierToCacheLoader(Supplier<V> computingSupplier) {\n", "      this.computingSupplier = checkNotNull(computingSupplier);\n", "    }\n", "\n", "    @Override\n", "    public V load(Object key) {\n", "      checkNotNull(key);\n", "      return computingSupplier.get();\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Exception thrown by {@code loadAll()} to indicate that it is not supported.\n", "   *\n", "   * @since 19.0\n", "   */\n", "  public static final class UnsupportedLoadingOperationException\n", "      extends UnsupportedOperationException {\n", "    // Package-private because this should only be thrown by loadAll() when it is not overridden.\n", "    // Cache implementors may want to catch it but should not need to be able to throw it.\n", "    UnsupportedLoadingOperationException() {}\n", "  }\n", "\n", "  /**\n", "   * Thrown to indicate that an invalid response was returned from a call to {@link CacheLoader}.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  public static final class InvalidCacheLoadException extends RuntimeException {\n", "    public InvalidCacheLoadException(String message) {\n", "      super(message);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174]}}, {"9": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/AbstractBiMap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Objects;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.io.Serializable;\n", "import java.util.Collection;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A general-purpose bimap implementation using any two backing {@code Map}\n", " * instances.\n", " *\n", " * <p>Note that this class contains {@code equals()} calls that keep it from\n", " * supporting {@code IdentityHashMap} backing maps.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Mike Bostock\n", " */\n", "@GwtCompatible(emulated = true)\n", "abstract class AbstractBiMap<K, V> extends ForwardingMap<K, V>\n", "    implements BiMap<K, V>, Serializable {\n", "\n", "  private transient Map<K, V> delegate;\n", "  transient AbstractBiMap<V, K> inverse;\n", "\n", "  /** Package-private constructor for creating a map-backed bimap. */\n", "  AbstractBiMap(Map<K, V> forward, Map<V, K> backward) {\n", "    setDelegates(forward, backward);\n", "  }\n", "\n", "  /** Private constructor for inverse bimap. */\n", "  private AbstractBiMap(Map<K, V> backward, AbstractBiMap<V, K> forward) {\n", "    delegate = backward;\n", "    inverse = forward;\n", "  }\n", "\n", "  @Override\n", "  protected Map<K, V> delegate() {\n", "    return delegate;\n", "  }\n", "\n", "  /**\n", "   * Returns its input, or throws an exception if this is not a valid key.\n", "   */\n", "  K checkKey(@Nullable K key) {\n", "    return key;\n", "  }\n", "\n", "  /**\n", "   * Returns its input, or throws an exception if this is not a valid value.\n", "   */\n", "  V checkValue(@Nullable V value) {\n", "    return value;\n", "  }\n", "\n", "  /**\n", "   * Specifies the delegate maps going in each direction. Called by the\n", "   * constructor and by subclasses during deserialization.\n", "   */\n", "  void setDelegates(Map<K, V> forward, Map<V, K> backward) {\n", "    checkState(delegate == null);\n", "    checkState(inverse == null);\n", "    checkArgument(forward.isEmpty());\n", "    checkArgument(backward.isEmpty());\n", "    checkArgument(forward != backward);\n", "    delegate = forward;\n", "    inverse = new Inverse<V, K>(backward, this);\n", "  }\n", "\n", "  void setInverse(AbstractBiMap<V, K> inverse) {\n", "    this.inverse = inverse;\n", "  }\n", "\n", "  // Query Operations (optimizations)\n", "\n", "  @Override\n", "  public boolean containsValue(@Nullable Object value) {\n", "    return inverse.containsKey(value);\n", "  }\n", "\n", "  // Modification Operations\n", "\n", "  @Override\n", "  public V put(@Nullable K key, @Nullable V value) {\n", "    return putInBothMaps(key, value, false);\n", "  }\n", "\n", "  @Override\n", "  public V forcePut(@Nullable K key, @Nullable V value) {\n", "    return putInBothMaps(key, value, true);\n", "  }\n", "\n", "  private V putInBothMaps(@Nullable K key, @Nullable V value, boolean force) {\n", "    checkKey(key);\n", "    checkValue(value);\n", "    boolean containedKey = containsKey(key);\n", "    if (containedKey && Objects.equal(value, get(key))) {\n", "      return value;\n", "    }\n", "    if (force) {\n", "      inverse().remove(value);\n", "    } else {\n", "      checkArgument(!containsValue(value), \"value already present: %s\", value);\n", "    }\n", "    V oldValue = delegate.put(key, value);\n", "    updateInverseMap(key, containedKey, oldValue, value);\n", "    return oldValue;\n", "  }\n", "\n", "  private void updateInverseMap(K key, boolean containedKey, V oldValue, V newValue) {\n", "    if (containedKey) {\n", "      removeFromInverseMap(oldValue);\n", "    }\n", "    inverse.delegate.put(newValue, key);\n", "  }\n", "\n", "  @Override\n", "  public V remove(@Nullable Object key) {\n", "    return containsKey(key) ? removeFromBothMaps(key) : null;\n", "  }\n", "\n", "  private V removeFromBothMaps(Object key) {\n", "    V oldValue = delegate.remove(key);\n", "    removeFromInverseMap(oldValue);\n", "    return oldValue;\n", "  }\n", "\n", "  private void removeFromInverseMap(V oldValue) {\n", "    inverse.delegate.remove(oldValue);\n", "  }\n", "\n", "  // Bulk Operations\n", "\n", "  @Override\n", "  public void putAll(Map<? extends K, ? extends V> map) {\n", "    for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n", "      put(entry.getKey(), entry.getValue());\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public void clear() {\n", "    delegate.clear();\n", "    inverse.delegate.clear();\n", "  }\n", "\n", "  // Views\n", "\n", "  @Override\n", "  public BiMap<V, K> inverse() {\n", "    return inverse;\n", "  }\n", "\n", "  private transient Set<K> keySet;\n", "\n", "  @Override\n", "  public Set<K> keySet() {\n", "    Set<K> result = keySet;\n", "    return (result == null) ? keySet = new KeySet() : result;\n", "  }\n", "\n", "  @WeakOuter\n", "  private class KeySet extends ForwardingSet<K> {\n", "    @Override\n", "    protected Set<K> delegate() {\n", "      return delegate.keySet();\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      AbstractBiMap.this.clear();\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object key) {\n", "      if (!contains(key)) {\n", "        return false;\n", "      }\n", "      removeFromBothMaps(key);\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> keysToRemove) {\n", "      return standardRemoveAll(keysToRemove);\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> keysToRetain) {\n", "      return standardRetainAll(keysToRetain);\n", "    }\n", "\n", "    @Override\n", "    public Iterator<K> iterator() {\n", "      return Maps.keyIterator(entrySet().iterator());\n", "    }\n", "  }\n", "\n", "  private transient Set<V> valueSet;\n", "\n", "  @Override\n", "  public Set<V> values() {\n", "    /*\n", "     * We can almost reuse the inverse's keySet, except we have to fix the\n", "     * iteration order so that it is consistent with the forward map.\n", "     */\n", "    Set<V> result = valueSet;\n", "    return (result == null) ? valueSet = new ValueSet() : result;\n", "  }\n", "\n", "  @WeakOuter\n", "  private class ValueSet extends ForwardingSet<V> {\n", "    final Set<V> valuesDelegate = inverse.keySet();\n", "\n", "    @Override\n", "    protected Set<V> delegate() {\n", "      return valuesDelegate;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<V> iterator() {\n", "      return Maps.valueIterator(entrySet().iterator());\n", "    }\n", "\n", "    @Override\n", "    public Object[] toArray() {\n", "      return standardToArray();\n", "    }\n", "\n", "    @Override\n", "    public <T> T[] toArray(T[] array) {\n", "      return standardToArray(array);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return standardToString();\n", "    }\n", "  }\n", "\n", "  private transient Set<Entry<K, V>> entrySet;\n", "\n", "  @Override\n", "  public Set<Entry<K, V>> entrySet() {\n", "    Set<Entry<K, V>> result = entrySet;\n", "    return (result == null) ? entrySet = new EntrySet() : result;\n", "  }\n", "\n", "  @WeakOuter\n", "  private class EntrySet extends ForwardingSet<Entry<K, V>> {\n", "    final Set<Entry<K, V>> esDelegate = delegate.entrySet();\n", "\n", "    @Override\n", "    protected Set<Entry<K, V>> delegate() {\n", "      return esDelegate;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      AbstractBiMap.this.clear();\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object object) {\n", "      if (!esDelegate.contains(object)) {\n", "        return false;\n", "      }\n", "\n", "      // safe because esDelgate.contains(object).\n", "      Entry<?, ?> entry = (Entry<?, ?>) object;\n", "      inverse.delegate.remove(entry.getValue());\n", "      /*\n", "       * Remove the mapping in inverse before removing from esDelegate because\n", "       * if entry is part of esDelegate, entry might be invalidated after the\n", "       * mapping is removed from esDelegate.\n", "       */\n", "      esDelegate.remove(entry);\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<Entry<K, V>> iterator() {\n", "      final Iterator<Entry<K, V>> iterator = esDelegate.iterator();\n", "      return new Iterator<Entry<K, V>>() {\n", "        Entry<K, V> entry;\n", "\n", "        @Override\n", "        public boolean hasNext() {\n", "          return iterator.hasNext();\n", "        }\n", "\n", "        @Override\n", "        public Entry<K, V> next() {\n", "          entry = iterator.next();\n", "          final Entry<K, V> finalEntry = entry;\n", "\n", "          return new ForwardingMapEntry<K, V>() {\n", "            @Override\n", "            protected Entry<K, V> delegate() {\n", "              return finalEntry;\n", "            }\n", "\n", "            @Override\n", "            public V setValue(V value) {\n", "              // Preconditions keep the map and inverse consistent.\n", "              checkState(contains(this), \"entry no longer in map\");\n", "              // similar to putInBothMaps, but set via entry\n", "              if (Objects.equal(value, getValue())) {\n", "                return value;\n", "              }\n", "              checkArgument(!containsValue(value), \"value already present: %s\", value);\n", "              V oldValue = finalEntry.setValue(value);\n", "              checkState(Objects.equal(value, get(getKey())), \"entry no longer in map\");\n", "              updateInverseMap(getKey(), true, oldValue, value);\n", "              return oldValue;\n", "            }\n", "          };\n", "        }\n", "\n", "        @Override\n", "        public void remove() {\n", "          checkRemove(entry != null);\n", "          V value = entry.getValue();\n", "          iterator.remove();\n", "          removeFromInverseMap(value);\n", "        }\n", "      };\n", "    }\n", "\n", "    // See java.util.Collections.CheckedEntrySet for details on attacks.\n", "\n", "    @Override\n", "    public Object[] toArray() {\n", "      return standardToArray();\n", "    }\n", "\n", "    @Override\n", "    public <T> T[] toArray(T[] array) {\n", "      return standardToArray(array);\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object o) {\n", "      return Maps.containsEntryImpl(delegate(), o);\n", "    }\n", "\n", "    @Override\n", "    public boolean containsAll(Collection<?> c) {\n", "      return standardContainsAll(c);\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> c) {\n", "      return standardRemoveAll(c);\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> c) {\n", "      return standardRetainAll(c);\n", "    }\n", "  }\n", "\n", "  /** The inverse of any other {@code AbstractBiMap} subclass. */\n", "  private static class Inverse<K, V> extends AbstractBiMap<K, V> {\n", "    private Inverse(Map<K, V> backward, AbstractBiMap<V, K> forward) {\n", "      super(backward, forward);\n", "    }\n", "\n", "    /*\n", "     * Serialization stores the forward bimap, the inverse of this inverse.\n", "     * Deserialization calls inverse() on the forward bimap and returns that\n", "     * inverse.\n", "     *\n", "     * If a bimap and its inverse are serialized together, the deserialized\n", "     * instances have inverse() methods that return the other.\n", "     */\n", "\n", "    @Override\n", "    K checkKey(K key) {\n", "      return inverse.checkValue(key);\n", "    }\n", "\n", "    @Override\n", "    V checkValue(V value) {\n", "      return inverse.checkKey(value);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415]}}, {"10": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Maps.ViewCachingAbstractMap;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractCollection;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.RandomAccess;\n", "import java.util.Set;\n", "import java.util.SortedMap;\n", "import java.util.SortedSet;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Basic implementation of the {@link Multimap} interface. This class represents\n", " * a multimap as a map that associates each key with a collection of values. All\n", " * methods of {@link Multimap} are supported, including those specified as\n", " * optional in the interface.\n", " *\n", " * <p>To implement a multimap, a subclass must define the method {@link\n", " * #createCollection()}, which creates an empty collection of values for a key.\n", " *\n", " * <p>The multimap constructor takes a map that has a single entry for each\n", " * distinct key. When you insert a key-value pair with a key that isn't already\n", " * in the multimap, {@code AbstractMapBasedMultimap} calls {@link #createCollection()}\n", " * to create the collection of values for that key. The subclass should not call\n", " * {@link #createCollection()} directly, and a new instance should be created\n", " * every time the method is called.\n", " *\n", " * <p>For example, the subclass could pass a {@link java.util.TreeMap} during\n", " * construction, and {@link #createCollection()} could return a {@link\n", " * java.util.TreeSet}, in which case the multimap's iterators would propagate\n", " * through the keys and values in sorted order.\n", " *\n", " * <p>Keys and values may be null, as long as the underlying collection classes\n", " * support null elements.\n", " *\n", " * <p>The collections created by {@link #createCollection()} may or may not\n", " * allow duplicates. If the collection, such as a {@link Set}, does not support\n", " * duplicates, an added key-value pair will replace an existing pair with the\n", " * same key and value, if such a pair is present. With collections like {@link\n", " * List} that allow duplicates, the collection will keep the existing key-value\n", " * pairs while adding a new pair.\n", " *\n", " * <p>This class is not threadsafe when any concurrent operations update the\n", " * multimap, even if the underlying map and {@link #createCollection()} method\n", " * return threadsafe classes. Concurrent read operations will work correctly. To\n", " * allow concurrent update operations, wrap your multimap with a call to {@link\n", " * Multimaps#synchronizedMultimap}.\n", " *\n", " * <p>For serialization to work, the subclass must specify explicit\n", " * {@code readObject} and {@code writeObject} methods.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>\n", "    implements Serializable {\n", "  /*\n", "   * Here's an outline of the overall design.\n", "   *\n", "   * The map variable contains the collection of values associated with each\n", "   * key. When a key-value pair is added to a multimap that didn't previously\n", "   * contain any values for that key, a new collection generated by\n", "   * createCollection is added to the map. That same collection instance\n", "   * remains in the map as long as the multimap has any values for the key. If\n", "   * all values for the key are removed, the key and collection are removed\n", "   * from the map.\n", "   *\n", "   * The get method returns a WrappedCollection, which decorates the collection\n", "   * in the map (if the key is present) or an empty collection (if the key is\n", "   * not present). When the collection delegate in the WrappedCollection is\n", "   * empty, the multimap may contain subsequently added values for that key. To\n", "   * handle that situation, the WrappedCollection checks whether map contains\n", "   * an entry for the provided key, and if so replaces the delegate.\n", "   */\n", "\n", "  private transient Map<K, Collection<V>> map;\n", "  private transient int totalSize;\n", "\n", "  /**\n", "   * Creates a new multimap that uses the provided map.\n", "   *\n", "   * @param map place to store the mapping from each key to its corresponding\n", "   *     values\n", "   * @throws IllegalArgumentException if {@code map} is not empty\n", "   */\n", "  protected AbstractMapBasedMultimap(Map<K, Collection<V>> map) {\n", "    checkArgument(map.isEmpty());\n", "    this.map = map;\n", "  }\n", "\n", "  /** Used during deserialization only. */\n", "  final void setMap(Map<K, Collection<V>> map) {\n", "    this.map = map;\n", "    totalSize = 0;\n", "    for (Collection<V> values : map.values()) {\n", "      checkArgument(!values.isEmpty());\n", "      totalSize += values.size();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Creates an unmodifiable, empty collection of values.\n", "   *\n", "   * <p>This is used in {@link #removeAll} on an empty key.\n", "   */\n", "  Collection<V> createUnmodifiableEmptyCollection() {\n", "    return unmodifiableCollectionSubclass(createCollection());\n", "  }\n", "\n", "  /**\n", "   * Creates the collection of values for a single key.\n", "   *\n", "   * <p>Collections with weak, soft, or phantom references are not supported.\n", "   * Each call to {@code createCollection} should create a new instance.\n", "   *\n", "   * <p>The returned collection class determines whether duplicate key-value\n", "   * pairs are allowed.\n", "   *\n", "   * @return an empty collection of values\n", "   */\n", "  abstract Collection<V> createCollection();\n", "\n", "  /**\n", "   * Creates the collection of values for an explicitly provided key. By\n", "   * default, it simply calls {@link #createCollection()}, which is the correct\n", "   * behavior for most implementations. The {@link LinkedHashMultimap} class\n", "   * overrides it.\n", "   *\n", "   * @param key key to associate with values in the collection\n", "   * @return an empty collection of values\n", "   */\n", "  Collection<V> createCollection(@Nullable K key) {\n", "    return createCollection();\n", "  }\n", "\n", "  Map<K, Collection<V>> backingMap() {\n", "    return map;\n", "  }\n", "\n", "  // Query Operations\n", "\n", "  @Override\n", "  public int size() {\n", "    return totalSize;\n", "  }\n", "\n", "  @Override\n", "  public boolean containsKey(@Nullable Object key) {\n", "    return map.containsKey(key);\n", "  }\n", "\n", "  // Modification Operations\n", "\n", "  @Override\n", "  public boolean put(@Nullable K key, @Nullable V value) {\n", "    Collection<V> collection = map.get(key);\n", "    if (collection == null) {\n", "      collection = createCollection(key);\n", "      if (collection.add(value)) {\n", "        totalSize++;\n", "        map.put(key, collection);\n", "        return true;\n", "      } else {\n", "        throw new AssertionError(\"New Collection violated the Collection spec\");\n", "      }\n", "    } else if (collection.add(value)) {\n", "      totalSize++;\n", "      return true;\n", "    } else {\n", "      return false;\n", "    }\n", "  }\n", "\n", "  private Collection<V> getOrCreateCollection(@Nullable K key) {\n", "    Collection<V> collection = map.get(key);\n", "    if (collection == null) {\n", "      collection = createCollection(key);\n", "      map.put(key, collection);\n", "    }\n", "    return collection;\n", "  }\n", "\n", "  // Bulk Operations\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The returned collection is immutable.\n", "   */\n", "  @Override\n", "  public Collection<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {\n", "    Iterator<? extends V> iterator = values.iterator();\n", "    if (!iterator.hasNext()) {\n", "      return removeAll(key);\n", "    }\n", "\n", "    // TODO(lowasser): investigate atomic failure?\n", "    Collection<V> collection = getOrCreateCollection(key);\n", "    Collection<V> oldValues = createCollection();\n", "    oldValues.addAll(collection);\n", "\n", "    totalSize -= collection.size();\n", "    collection.clear();\n", "\n", "    while (iterator.hasNext()) {\n", "      if (collection.add(iterator.next())) {\n", "        totalSize++;\n", "      }\n", "    }\n", "\n", "    return unmodifiableCollectionSubclass(oldValues);\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The returned collection is immutable.\n", "   */\n", "  @Override\n", "  public Collection<V> removeAll(@Nullable Object key) {\n", "    Collection<V> collection = map.remove(key);\n", "\n", "    if (collection == null) {\n", "      return createUnmodifiableEmptyCollection();\n", "    }\n", "\n", "    Collection<V> output = createCollection();\n", "    output.addAll(collection);\n", "    totalSize -= collection.size();\n", "    collection.clear();\n", "\n", "    return unmodifiableCollectionSubclass(output);\n", "  }\n", "\n", "  Collection<V> unmodifiableCollectionSubclass(Collection<V> collection) {\n", "    // We don't deal with NavigableSet here yet for GWT reasons -- instead,\n", "    // non-GWT TreeMultimap explicitly overrides this and uses NavigableSet.\n", "    if (collection instanceof SortedSet) {\n", "      return Collections.unmodifiableSortedSet((SortedSet<V>) collection);\n", "    } else if (collection instanceof Set) {\n", "      return Collections.unmodifiableSet((Set<V>) collection);\n", "    } else if (collection instanceof List) {\n", "      return Collections.unmodifiableList((List<V>) collection);\n", "    } else {\n", "      return Collections.unmodifiableCollection(collection);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public void clear() {\n", "    // Clear each collection, to make previously returned collections empty.\n", "    for (Collection<V> collection : map.values()) {\n", "      collection.clear();\n", "    }\n", "    map.clear();\n", "    totalSize = 0;\n", "  }\n", "\n", "  // Views\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The returned collection is not serializable.\n", "   */\n", "  @Override\n", "  public Collection<V> get(@Nullable K key) {\n", "    Collection<V> collection = map.get(key);\n", "    if (collection == null) {\n", "      collection = createCollection(key);\n", "    }\n", "    return wrapCollection(key, collection);\n", "  }\n", "\n", "  /**\n", "   * Generates a decorated collection that remains consistent with the values in\n", "   * the multimap for the provided key. Changes to the multimap may alter the\n", "   * returned collection, and vice versa.\n", "   */\n", "  Collection<V> wrapCollection(@Nullable K key, Collection<V> collection) {\n", "    // We don't deal with NavigableSet here yet for GWT reasons -- instead,\n", "    // non-GWT TreeMultimap explicitly overrides this and uses NavigableSet.\n", "    if (collection instanceof SortedSet) {\n", "      return new WrappedSortedSet(key, (SortedSet<V>) collection, null);\n", "    } else if (collection instanceof Set) {\n", "      return new WrappedSet(key, (Set<V>) collection);\n", "    } else if (collection instanceof List) {\n", "      return wrapList(key, (List<V>) collection, null);\n", "    } else {\n", "      return new WrappedCollection(key, collection, null);\n", "    }\n", "  }\n", "\n", "  private List<V> wrapList(@Nullable K key, List<V> list, @Nullable WrappedCollection ancestor) {\n", "    return (list instanceof RandomAccess)\n", "        ? new RandomAccessWrappedList(key, list, ancestor)\n", "        : new WrappedList(key, list, ancestor);\n", "  }\n", "\n", "  /**\n", "   * Collection decorator that stays in sync with the multimap values for a key.\n", "   * There are two kinds of wrapped collections: full and subcollections. Both\n", "   * have a delegate pointing to the underlying collection class.\n", "   *\n", "   * <p>Full collections, identified by a null ancestor field, contain all\n", "   * multimap values for a given key. Its delegate is a value in {@link\n", "   * AbstractMapBasedMultimap#map} whenever the delegate is non-empty. The {@code\n", "   * refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods ensure\n", "   * that the {@code WrappedCollection} and map remain consistent.\n", "   *\n", "   * <p>A subcollection, such as a sublist, contains some of the values for a\n", "   * given key. Its ancestor field points to the full wrapped collection with\n", "   * all values for the key. The subcollection {@code refreshIfEmpty}, {@code\n", "   * removeIfEmpty}, and {@code addToMap} methods call the corresponding methods\n", "   * of the full wrapped collection.\n", "   */\n", "  @WeakOuter\n", "  private class WrappedCollection extends AbstractCollection<V> {\n", "    final K key;\n", "    Collection<V> delegate;\n", "    final WrappedCollection ancestor;\n", "    final Collection<V> ancestorDelegate;\n", "\n", "    WrappedCollection(\n", "        @Nullable K key, Collection<V> delegate, @Nullable WrappedCollection ancestor) {\n", "      this.key = key;\n", "      this.delegate = delegate;\n", "      this.ancestor = ancestor;\n", "      this.ancestorDelegate = (ancestor == null) ? null : ancestor.getDelegate();\n", "    }\n", "\n", "    /**\n", "     * If the delegate collection is empty, but the multimap has values for the\n", "     * key, replace the delegate with the new collection for the key.\n", "     *\n", "     * <p>For a subcollection, refresh its ancestor and validate that the\n", "     * ancestor delegate hasn't changed.\n", "     */\n", "    void refreshIfEmpty() {\n", "      if (ancestor != null) {\n", "        ancestor.refreshIfEmpty();\n", "        if (ancestor.getDelegate() != ancestorDelegate) {\n", "          throw new ConcurrentModificationException();\n", "        }\n", "      } else if (delegate.isEmpty()) {\n", "        Collection<V> newDelegate = map.get(key);\n", "        if (newDelegate != null) {\n", "          delegate = newDelegate;\n", "        }\n", "      }\n", "    }\n", "\n", "    /**\n", "     * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}.\n", "     * For subcollections, check whether the ancestor collection is empty.\n", "     */\n", "    void removeIfEmpty() {\n", "      if (ancestor != null) {\n", "        ancestor.removeIfEmpty();\n", "      } else if (delegate.isEmpty()) {\n", "        map.remove(key);\n", "      }\n", "    }\n", "\n", "    K getKey() {\n", "      return key;\n", "    }\n", "\n", "    /**\n", "     * Add the delegate to the map. Other {@code WrappedCollection} methods\n", "     * should call this method after adding elements to a previously empty\n", "     * collection.\n", "     *\n", "     * <p>Subcollection add the ancestor's delegate instead.\n", "     */\n", "    void addToMap() {\n", "      if (ancestor != null) {\n", "        ancestor.addToMap();\n", "      } else {\n", "        map.put(key, delegate);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      refreshIfEmpty();\n", "      return delegate.size();\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      if (object == this) {\n", "        return true;\n", "      }\n", "      refreshIfEmpty();\n", "      return delegate.equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      refreshIfEmpty();\n", "      return delegate.hashCode();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      refreshIfEmpty();\n", "      return delegate.toString();\n", "    }\n", "\n", "    Collection<V> getDelegate() {\n", "      return delegate;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<V> iterator() {\n", "      refreshIfEmpty();\n", "      return new WrappedIterator();\n", "    }\n", "\n", "    /** Collection iterator for {@code WrappedCollection}. */\n", "    class WrappedIterator implements Iterator<V> {\n", "      final Iterator<V> delegateIterator;\n", "      final Collection<V> originalDelegate = delegate;\n", "\n", "      WrappedIterator() {\n", "        delegateIterator = iteratorOrListIterator(delegate);\n", "      }\n", "\n", "      WrappedIterator(Iterator<V> delegateIterator) {\n", "        this.delegateIterator = delegateIterator;\n", "      }\n", "\n", "      /**\n", "       * If the delegate changed since the iterator was created, the iterator is\n", "       * no longer valid.\n", "       */\n", "      void validateIterator() {\n", "        refreshIfEmpty();\n", "        if (delegate != originalDelegate) {\n", "          throw new ConcurrentModificationException();\n", "        }\n", "      }\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        validateIterator();\n", "        return delegateIterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public V next() {\n", "        validateIterator();\n", "        return delegateIterator.next();\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        delegateIterator.remove();\n", "        totalSize--;\n", "        removeIfEmpty();\n", "      }\n", "\n", "      Iterator<V> getDelegateIterator() {\n", "        validateIterator();\n", "        return delegateIterator;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean add(V value) {\n", "      refreshIfEmpty();\n", "      boolean wasEmpty = delegate.isEmpty();\n", "      boolean changed = delegate.add(value);\n", "      if (changed) {\n", "        totalSize++;\n", "        if (wasEmpty) {\n", "          addToMap();\n", "        }\n", "      }\n", "      return changed;\n", "    }\n", "\n", "    WrappedCollection getAncestor() {\n", "      return ancestor;\n", "    }\n", "\n", "    // The following methods are provided for better performance.\n", "\n", "    @Override\n", "    public boolean addAll(Collection<? extends V> collection) {\n", "      if (collection.isEmpty()) {\n", "        return false;\n", "      }\n", "      int oldSize = size(); // calls refreshIfEmpty\n", "      boolean changed = delegate.addAll(collection);\n", "      if (changed) {\n", "        int newSize = delegate.size();\n", "        totalSize += (newSize - oldSize);\n", "        if (oldSize == 0) {\n", "          addToMap();\n", "        }\n", "      }\n", "      return changed;\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object o) {\n", "      refreshIfEmpty();\n", "      return delegate.contains(o);\n", "    }\n", "\n", "    @Override\n", "    public boolean containsAll(Collection<?> c) {\n", "      refreshIfEmpty();\n", "      return delegate.containsAll(c);\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      int oldSize = size(); // calls refreshIfEmpty\n", "      if (oldSize == 0) {\n", "        return;\n", "      }\n", "      delegate.clear();\n", "      totalSize -= oldSize;\n", "      removeIfEmpty(); // maybe shouldn't be removed if this is a sublist\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      refreshIfEmpty();\n", "      boolean changed = delegate.remove(o);\n", "      if (changed) {\n", "        totalSize--;\n", "        removeIfEmpty();\n", "      }\n", "      return changed;\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> c) {\n", "      if (c.isEmpty()) {\n", "        return false;\n", "      }\n", "      int oldSize = size(); // calls refreshIfEmpty\n", "      boolean changed = delegate.removeAll(c);\n", "      if (changed) {\n", "        int newSize = delegate.size();\n", "        totalSize += (newSize - oldSize);\n", "        removeIfEmpty();\n", "      }\n", "      return changed;\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> c) {\n", "      checkNotNull(c);\n", "      int oldSize = size(); // calls refreshIfEmpty\n", "      boolean changed = delegate.retainAll(c);\n", "      if (changed) {\n", "        int newSize = delegate.size();\n", "        totalSize += (newSize - oldSize);\n", "        removeIfEmpty();\n", "      }\n", "      return changed;\n", "    }\n", "  }\n", "\n", "  private Iterator<V> iteratorOrListIterator(Collection<V> collection) {\n", "    return (collection instanceof List)\n", "        ? ((List<V>) collection).listIterator()\n", "        : collection.iterator();\n", "  }\n", "\n", "  /** Set decorator that stays in sync with the multimap values for a key. */\n", "  @WeakOuter\n", "  private class WrappedSet extends WrappedCollection implements Set<V> {\n", "    WrappedSet(@Nullable K key, Set<V> delegate) {\n", "      super(key, delegate, null);\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> c) {\n", "      if (c.isEmpty()) {\n", "        return false;\n", "      }\n", "      int oldSize = size(); // calls refreshIfEmpty\n", "\n", "      // Guava issue 1013: AbstractSet and most JDK set implementations are\n", "      // susceptible to quadratic removeAll performance on lists;\n", "      // use a slightly smarter implementation here\n", "      boolean changed = Sets.removeAllImpl((Set<V>) delegate, c);\n", "      if (changed) {\n", "        int newSize = delegate.size();\n", "        totalSize += (newSize - oldSize);\n", "        removeIfEmpty();\n", "      }\n", "      return changed;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * SortedSet decorator that stays in sync with the multimap values for a key.\n", "   */\n", "  @WeakOuter\n", "  private class WrappedSortedSet extends WrappedCollection implements SortedSet<V> {\n", "    WrappedSortedSet(@Nullable K key, SortedSet<V> delegate, @Nullable WrappedCollection ancestor) {\n", "      super(key, delegate, ancestor);\n", "    }\n", "\n", "    SortedSet<V> getSortedSetDelegate() {\n", "      return (SortedSet<V>) getDelegate();\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super V> comparator() {\n", "      return getSortedSetDelegate().comparator();\n", "    }\n", "\n", "    @Override\n", "    public V first() {\n", "      refreshIfEmpty();\n", "      return getSortedSetDelegate().first();\n", "    }\n", "\n", "    @Override\n", "    public V last() {\n", "      refreshIfEmpty();\n", "      return getSortedSetDelegate().last();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> headSet(V toElement) {\n", "      refreshIfEmpty();\n", "      return new WrappedSortedSet(\n", "          getKey(),\n", "          getSortedSetDelegate().headSet(toElement),\n", "          (getAncestor() == null) ? this : getAncestor());\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> subSet(V fromElement, V toElement) {\n", "      refreshIfEmpty();\n", "      return new WrappedSortedSet(\n", "          getKey(),\n", "          getSortedSetDelegate().subSet(fromElement, toElement),\n", "          (getAncestor() == null) ? this : getAncestor());\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> tailSet(V fromElement) {\n", "      refreshIfEmpty();\n", "      return new WrappedSortedSet(\n", "          getKey(),\n", "          getSortedSetDelegate().tailSet(fromElement),\n", "          (getAncestor() == null) ? this : getAncestor());\n", "    }\n", "  }\n", "\n", "  /** List decorator that stays in sync with the multimap values for a key. */\n", "  @WeakOuter\n", "  private class WrappedList extends WrappedCollection implements List<V> {\n", "    WrappedList(@Nullable K key, List<V> delegate, @Nullable WrappedCollection ancestor) {\n", "      super(key, delegate, ancestor);\n", "    }\n", "\n", "    List<V> getListDelegate() {\n", "      return (List<V>) getDelegate();\n", "    }\n", "\n", "    @Override\n", "    public boolean addAll(int index, Collection<? extends V> c) {\n", "      if (c.isEmpty()) {\n", "        return false;\n", "      }\n", "      int oldSize = size(); // calls refreshIfEmpty\n", "      boolean changed = getListDelegate().addAll(index, c);\n", "      if (changed) {\n", "        int newSize = getDelegate().size();\n", "        totalSize += (newSize - oldSize);\n", "        if (oldSize == 0) {\n", "          addToMap();\n", "        }\n", "      }\n", "      return changed;\n", "    }\n", "\n", "    @Override\n", "    public V get(int index) {\n", "      refreshIfEmpty();\n", "      return getListDelegate().get(index);\n", "    }\n", "\n", "    @Override\n", "    public V set(int index, V element) {\n", "      refreshIfEmpty();\n", "      return getListDelegate().set(index, element);\n", "    }\n", "\n", "    @Override\n", "    public void add(int index, V element) {\n", "      refreshIfEmpty();\n", "      boolean wasEmpty = getDelegate().isEmpty();\n", "      getListDelegate().add(index, element);\n", "      totalSize++;\n", "      if (wasEmpty) {\n", "        addToMap();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V remove(int index) {\n", "      refreshIfEmpty();\n", "      V value = getListDelegate().remove(index);\n", "      totalSize--;\n", "      removeIfEmpty();\n", "      return value;\n", "    }\n", "\n", "    @Override\n", "    public int indexOf(Object o) {\n", "      refreshIfEmpty();\n", "      return getListDelegate().indexOf(o);\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexOf(Object o) {\n", "      refreshIfEmpty();\n", "      return getListDelegate().lastIndexOf(o);\n", "    }\n", "\n", "    @Override\n", "    public ListIterator<V> listIterator() {\n", "      refreshIfEmpty();\n", "      return new WrappedListIterator();\n", "    }\n", "\n", "    @Override\n", "    public ListIterator<V> listIterator(int index) {\n", "      refreshIfEmpty();\n", "      return new WrappedListIterator(index);\n", "    }\n", "\n", "    @Override\n", "    public List<V> subList(int fromIndex, int toIndex) {\n", "      refreshIfEmpty();\n", "      return wrapList(\n", "          getKey(),\n", "          getListDelegate().subList(fromIndex, toIndex),\n", "          (getAncestor() == null) ? this : getAncestor());\n", "    }\n", "\n", "    /** ListIterator decorator. */\n", "    private class WrappedListIterator extends WrappedIterator implements ListIterator<V> {\n", "      WrappedListIterator() {}\n", "\n", "      public WrappedListIterator(int index) {\n", "        super(getListDelegate().listIterator(index));\n", "      }\n", "\n", "      private ListIterator<V> getDelegateListIterator() {\n", "        return (ListIterator<V>) getDelegateIterator();\n", "      }\n", "\n", "      @Override\n", "      public boolean hasPrevious() {\n", "        return getDelegateListIterator().hasPrevious();\n", "      }\n", "\n", "      @Override\n", "      public V previous() {\n", "        return getDelegateListIterator().previous();\n", "      }\n", "\n", "      @Override\n", "      public int nextIndex() {\n", "        return getDelegateListIterator().nextIndex();\n", "      }\n", "\n", "      @Override\n", "      public int previousIndex() {\n", "        return getDelegateListIterator().previousIndex();\n", "      }\n", "\n", "      @Override\n", "      public void set(V value) {\n", "        getDelegateListIterator().set(value);\n", "      }\n", "\n", "      @Override\n", "      public void add(V value) {\n", "        boolean wasEmpty = isEmpty();\n", "        getDelegateListIterator().add(value);\n", "        totalSize++;\n", "        if (wasEmpty) {\n", "          addToMap();\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * List decorator that stays in sync with the multimap values for a key and\n", "   * supports rapid random access.\n", "   */\n", "  private class RandomAccessWrappedList extends WrappedList implements RandomAccess {\n", "    RandomAccessWrappedList(\n", "        @Nullable K key, List<V> delegate, @Nullable WrappedCollection ancestor) {\n", "      super(key, delegate, ancestor);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  Set<K> createKeySet() {\n", "    // TreeMultimap uses NavigableKeySet explicitly, but we don't handle that here for GWT\n", "    // compatibility reasons\n", "    return (map instanceof SortedMap)\n", "        ? new SortedKeySet((SortedMap<K, Collection<V>>) map)\n", "        : new KeySet(map);\n", "  }\n", "\n", "  @WeakOuter\n", "  private class KeySet extends Maps.KeySet<K, Collection<V>> {\n", "    KeySet(final Map<K, Collection<V>> subMap) {\n", "      super(subMap);\n", "    }\n", "\n", "    @Override\n", "    public Iterator<K> iterator() {\n", "      final Iterator<Map.Entry<K, Collection<V>>> entryIterator = map().entrySet().iterator();\n", "      return new Iterator<K>() {\n", "        Map.Entry<K, Collection<V>> entry;\n", "\n", "        @Override\n", "        public boolean hasNext() {\n", "          return entryIterator.hasNext();\n", "        }\n", "\n", "        @Override\n", "        public K next() {\n", "          entry = entryIterator.next();\n", "          return entry.getKey();\n", "        }\n", "\n", "        @Override\n", "        public void remove() {\n", "          checkRemove(entry != null);\n", "          Collection<V> collection = entry.getValue();\n", "          entryIterator.remove();\n", "          totalSize -= collection.size();\n", "          collection.clear();\n", "        }\n", "      };\n", "    }\n", "\n", "    // The following methods are included for better performance.\n", "\n", "    @Override\n", "    public boolean remove(Object key) {\n", "      int count = 0;\n", "      Collection<V> collection = map().remove(key);\n", "      if (collection != null) {\n", "        count = collection.size();\n", "        collection.clear();\n", "        totalSize -= count;\n", "      }\n", "      return count > 0;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      Iterators.clear(iterator());\n", "    }\n", "\n", "    @Override\n", "    public boolean containsAll(Collection<?> c) {\n", "      return map().keySet().containsAll(c);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      return this == object || this.map().keySet().equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return map().keySet().hashCode();\n", "    }\n", "  }\n", "\n", "  @WeakOuter\n", "  private class SortedKeySet extends KeySet implements SortedSet<K> {\n", "\n", "    SortedKeySet(SortedMap<K, Collection<V>> subMap) {\n", "      super(subMap);\n", "    }\n", "\n", "    SortedMap<K, Collection<V>> sortedMap() {\n", "      return (SortedMap<K, Collection<V>>) super.map();\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super K> comparator() {\n", "      return sortedMap().comparator();\n", "    }\n", "\n", "    @Override\n", "    public K first() {\n", "      return sortedMap().firstKey();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<K> headSet(K toElement) {\n", "      return new SortedKeySet(sortedMap().headMap(toElement));\n", "    }\n", "\n", "    @Override\n", "    public K last() {\n", "      return sortedMap().lastKey();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<K> subSet(K fromElement, K toElement) {\n", "      return new SortedKeySet(sortedMap().subMap(fromElement, toElement));\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<K> tailSet(K fromElement) {\n", "      return new SortedKeySet(sortedMap().tailMap(fromElement));\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Removes all values for the provided key. Unlike {@link #removeAll}, it\n", "   * returns the number of removed mappings.\n", "   */\n", "  private int removeValuesForKey(Object key) {\n", "    Collection<V> collection = Maps.safeRemove(map, key);\n", "\n", "    int count = 0;\n", "    if (collection != null) {\n", "      count = collection.size();\n", "      collection.clear();\n", "      totalSize -= count;\n", "    }\n", "    return count;\n", "  }\n", "\n", "  private abstract class Itr<T> implements Iterator<T> {\n", "    final Iterator<Map.Entry<K, Collection<V>>> keyIterator;\n", "    K key;\n", "    Collection<V> collection;\n", "    Iterator<V> valueIterator;\n", "\n", "    Itr() {\n", "      keyIterator = map.entrySet().iterator();\n", "      key = null;\n", "      collection = null;\n", "      valueIterator = Iterators.emptyModifiableIterator();\n", "    }\n", "\n", "    abstract T output(K key, V value);\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return keyIterator.hasNext() || valueIterator.hasNext();\n", "    }\n", "\n", "    @Override\n", "    public T next() {\n", "      if (!valueIterator.hasNext()) {\n", "        Map.Entry<K, Collection<V>> mapEntry = keyIterator.next();\n", "        key = mapEntry.getKey();\n", "        collection = mapEntry.getValue();\n", "        valueIterator = collection.iterator();\n", "      }\n", "      return output(key, valueIterator.next());\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "      valueIterator.remove();\n", "      if (collection.isEmpty()) {\n", "        keyIterator.remove();\n", "      }\n", "      totalSize--;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The iterator generated by the returned collection traverses the values\n", "   * for one key, followed by the values of a second key, and so on.\n", "   */\n", "  @Override\n", "  public Collection<V> values() {\n", "    return super.values();\n", "  }\n", "\n", "  @Override\n", "  Iterator<V> valueIterator() {\n", "    return new Itr<V>() {\n", "      @Override\n", "      V output(K key, V value) {\n", "        return value;\n", "      }\n", "    };\n", "  }\n", "\n", "  /*\n", "   * TODO(kevinb): should we copy this javadoc to each concrete class, so that\n", "   * classes like LinkedHashMultimap that need to say something different are\n", "   * still able to {@inheritDoc} all the way from Multimap?\n", "   */\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The iterator generated by the returned collection traverses the values\n", "   * for one key, followed by the values of a second key, and so on.\n", "   *\n", "   * <p>Each entry is an immutable snapshot of a key-value mapping in the\n", "   * multimap, taken at the time the entry is returned by a method call to the\n", "   * collection or its iterator.\n", "   */\n", "  @Override\n", "  public Collection<Map.Entry<K, V>> entries() {\n", "    return super.entries();\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator across all key-value map entries, used by {@code\n", "   * entries().iterator()} and {@code values().iterator()}. The default\n", "   * behavior, which traverses the values for one key, the values for a second\n", "   * key, and so on, suffices for most {@code AbstractMapBasedMultimap} implementations.\n", "   *\n", "   * @return an iterator across map entries\n", "   */\n", "  @Override\n", "  Iterator<Map.Entry<K, V>> entryIterator() {\n", "    return new Itr<Map.Entry<K, V>>() {\n", "      @Override\n", "      Entry<K, V> output(K key, V value) {\n", "        return Maps.immutableEntry(key, value);\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  Map<K, Collection<V>> createAsMap() {\n", "    // TreeMultimap uses NavigableAsMap explicitly, but we don't handle that here for GWT\n", "    // compatibility reasons\n", "    return (map instanceof SortedMap)\n", "        ? new SortedAsMap((SortedMap<K, Collection<V>>) map)\n", "        : new AsMap(map);\n", "  }\n", "\n", "  @WeakOuter\n", "  private class AsMap extends ViewCachingAbstractMap<K, Collection<V>> {\n", "    /**\n", "     * Usually the same as map, but smaller for the headMap(), tailMap(), or\n", "     * subMap() of a SortedAsMap.\n", "     */\n", "    final transient Map<K, Collection<V>> submap;\n", "\n", "    AsMap(Map<K, Collection<V>> submap) {\n", "      this.submap = submap;\n", "    }\n", "\n", "    @Override\n", "    protected Set<Entry<K, Collection<V>>> createEntrySet() {\n", "      return new AsMapEntries();\n", "    }\n", "\n", "    // The following methods are included for performance.\n", "\n", "    @Override\n", "    public boolean containsKey(Object key) {\n", "      return Maps.safeContainsKey(submap, key);\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> get(Object key) {\n", "      Collection<V> collection = Maps.safeGet(submap, key);\n", "      if (collection == null) {\n", "        return null;\n", "      }\n", "      @SuppressWarnings(\"unchecked\")\n", "      K k = (K) key;\n", "      return wrapCollection(k, collection);\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      return AbstractMapBasedMultimap.this.keySet();\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return submap.size();\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> remove(Object key) {\n", "      Collection<V> collection = submap.remove(key);\n", "      if (collection == null) {\n", "        return null;\n", "      }\n", "\n", "      Collection<V> output = createCollection();\n", "      output.addAll(collection);\n", "      totalSize -= collection.size();\n", "      collection.clear();\n", "      return output;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      return this == object || submap.equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return submap.hashCode();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return submap.toString();\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      if (submap == map) {\n", "        AbstractMapBasedMultimap.this.clear();\n", "      } else {\n", "        Iterators.clear(new AsMapIterator());\n", "      }\n", "    }\n", "\n", "    Entry<K, Collection<V>> wrapEntry(Entry<K, Collection<V>> entry) {\n", "      K key = entry.getKey();\n", "      return Maps.immutableEntry(key, wrapCollection(key, entry.getValue()));\n", "    }\n", "\n", "    @WeakOuter\n", "    class AsMapEntries extends Maps.EntrySet<K, Collection<V>> {\n", "      @Override\n", "      Map<K, Collection<V>> map() {\n", "        return AsMap.this;\n", "      }\n", "\n", "      @Override\n", "      public Iterator<Map.Entry<K, Collection<V>>> iterator() {\n", "        return new AsMapIterator();\n", "      }\n", "\n", "      // The following methods are included for performance.\n", "\n", "      @Override\n", "      public boolean contains(Object o) {\n", "        return Collections2.safeContains(submap.entrySet(), o);\n", "      }\n", "\n", "      @Override\n", "      public boolean remove(Object o) {\n", "        if (!contains(o)) {\n", "          return false;\n", "        }\n", "        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n", "        removeValuesForKey(entry.getKey());\n", "        return true;\n", "      }\n", "    }\n", "\n", "    /** Iterator across all keys and value collections. */\n", "    class AsMapIterator implements Iterator<Map.Entry<K, Collection<V>>> {\n", "      final Iterator<Map.Entry<K, Collection<V>>> delegateIterator = submap.entrySet().iterator();\n", "      Collection<V> collection;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return delegateIterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public Map.Entry<K, Collection<V>> next() {\n", "        Map.Entry<K, Collection<V>> entry = delegateIterator.next();\n", "        collection = entry.getValue();\n", "        return wrapEntry(entry);\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        delegateIterator.remove();\n", "        totalSize -= collection.size();\n", "        collection.clear();\n", "      }\n", "    }\n", "  }\n", "\n", "  @WeakOuter\n", "  private class SortedAsMap extends AsMap implements SortedMap<K, Collection<V>> {\n", "    SortedAsMap(SortedMap<K, Collection<V>> submap) {\n", "      super(submap);\n", "    }\n", "\n", "    SortedMap<K, Collection<V>> sortedMap() {\n", "      return (SortedMap<K, Collection<V>>) submap;\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super K> comparator() {\n", "      return sortedMap().comparator();\n", "    }\n", "\n", "    @Override\n", "    public K firstKey() {\n", "      return sortedMap().firstKey();\n", "    }\n", "\n", "    @Override\n", "    public K lastKey() {\n", "      return sortedMap().lastKey();\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, Collection<V>> headMap(K toKey) {\n", "      return new SortedAsMap(sortedMap().headMap(toKey));\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, Collection<V>> subMap(K fromKey, K toKey) {\n", "      return new SortedAsMap(sortedMap().subMap(fromKey, toKey));\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, Collection<V>> tailMap(K fromKey) {\n", "      return new SortedAsMap(sortedMap().tailMap(fromKey));\n", "    }\n", "\n", "    SortedSet<K> sortedKeySet;\n", "\n", "    // returns a SortedSet, even though returning a Set would be sufficient to\n", "    // satisfy the SortedMap.keySet() interface\n", "    @Override\n", "    public SortedSet<K> keySet() {\n", "      SortedSet<K> result = sortedKeySet;\n", "      return (result == null) ? sortedKeySet = createKeySet() : result;\n", "    }\n", "\n", "    @Override\n", "    SortedSet<K> createKeySet() {\n", "      return new SortedKeySet(sortedMap());\n", "    }\n", "  }\n", "\n", "  private static final long serialVersionUID = 2447537837011683357L;\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296]}}, {"11": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/AbstractMapBasedMultiset.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.primitives.Ints;\n", "\n", "import java.io.Serializable;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Basic implementation of {@code Multiset<E>} backed by an instance of {@code\n", " * Map<E, Count>}.\n", " *\n", " * <p>For serialization to work, the subclass must specify explicit {@code\n", " * readObject} and {@code writeObject} methods.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "abstract class AbstractMapBasedMultiset<E> extends AbstractMultiset<E> implements Serializable {\n", "\n", "  private transient Map<E, Count> backingMap;\n", "\n", "  /*\n", "   * Cache the size for efficiency. Using a long lets us avoid the need for\n", "   * overflow checking and ensures that size() will function correctly even if\n", "   * the multiset had once been larger than Integer.MAX_VALUE.\n", "   */\n", "  private transient long size;\n", "\n", "  /** Standard constructor. */\n", "  protected AbstractMapBasedMultiset(Map<E, Count> backingMap) {\n", "    this.backingMap = checkNotNull(backingMap);\n", "    this.size = super.size();\n", "  }\n", "\n", "  /** Used during deserialization only. The backing map must be empty. */\n", "  void setBackingMap(Map<E, Count> backingMap) {\n", "    this.backingMap = backingMap;\n", "  }\n", "\n", "  // Required Implementations\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>Invoking {@link Multiset.Entry#getCount} on an entry in the returned\n", "   * set always returns the current count of that element in the multiset, as\n", "   * opposed to the count at the time the entry was retrieved.\n", "   */\n", "  @Override\n", "  public Set<Multiset.Entry<E>> entrySet() {\n", "    return super.entrySet();\n", "  }\n", "\n", "  @Override\n", "  Iterator<Entry<E>> entryIterator() {\n", "    final Iterator<Map.Entry<E, Count>> backingEntries = backingMap.entrySet().iterator();\n", "    return new Iterator<Multiset.Entry<E>>() {\n", "      Map.Entry<E, Count> toRemove;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return backingEntries.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public Multiset.Entry<E> next() {\n", "        final Map.Entry<E, Count> mapEntry = backingEntries.next();\n", "        toRemove = mapEntry;\n", "        return new Multisets.AbstractEntry<E>() {\n", "          @Override\n", "          public E getElement() {\n", "            return mapEntry.getKey();\n", "          }\n", "\n", "          @Override\n", "          public int getCount() {\n", "            Count count = mapEntry.getValue();\n", "            if (count == null || count.get() == 0) {\n", "              Count frequency = backingMap.get(getElement());\n", "              if (frequency != null) {\n", "                return frequency.get();\n", "              }\n", "            }\n", "            return (count == null) ? 0 : count.get();\n", "          }\n", "        };\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        checkRemove(toRemove != null);\n", "        size -= toRemove.getValue().getAndSet(0);\n", "        backingEntries.remove();\n", "        toRemove = null;\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  public void clear() {\n", "    for (Count frequency : backingMap.values()) {\n", "      frequency.set(0);\n", "    }\n", "    backingMap.clear();\n", "    size = 0L;\n", "  }\n", "\n", "  @Override\n", "  int distinctElements() {\n", "    return backingMap.size();\n", "  }\n", "\n", "  // Optimizations - Query Operations\n", "\n", "  @Override\n", "  public int size() {\n", "    return Ints.saturatedCast(size);\n", "  }\n", "\n", "  @Override\n", "  public Iterator<E> iterator() {\n", "    return new MapBasedMultisetIterator();\n", "  }\n", "\n", "  /*\n", "   * Not subclassing AbstractMultiset$MultisetIterator because next() needs to\n", "   * retrieve the Map.Entry<E, Count> entry, which can then be used for\n", "   * a more efficient remove() call.\n", "   */\n", "  private class MapBasedMultisetIterator implements Iterator<E> {\n", "    final Iterator<Map.Entry<E, Count>> entryIterator;\n", "    Map.Entry<E, Count> currentEntry;\n", "    int occurrencesLeft;\n", "    boolean canRemove;\n", "\n", "    MapBasedMultisetIterator() {\n", "      this.entryIterator = backingMap.entrySet().iterator();\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return occurrencesLeft > 0 || entryIterator.hasNext();\n", "    }\n", "\n", "    @Override\n", "    public E next() {\n", "      if (occurrencesLeft == 0) {\n", "        currentEntry = entryIterator.next();\n", "        occurrencesLeft = currentEntry.getValue().get();\n", "      }\n", "      occurrencesLeft--;\n", "      canRemove = true;\n", "      return currentEntry.getKey();\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "      checkRemove(canRemove);\n", "      int frequency = currentEntry.getValue().get();\n", "      if (frequency <= 0) {\n", "        throw new ConcurrentModificationException();\n", "      }\n", "      if (currentEntry.getValue().addAndGet(-1) == 0) {\n", "        entryIterator.remove();\n", "      }\n", "      size--;\n", "      canRemove = false;\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public int count(@Nullable Object element) {\n", "    Count frequency = Maps.safeGet(backingMap, element);\n", "    return (frequency == null) ? 0 : frequency.get();\n", "  }\n", "\n", "  // Optional Operations - Modification Operations\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * @throws IllegalArgumentException if the call would result in more than\n", "   *     {@link Integer#MAX_VALUE} occurrences of {@code element} in this\n", "   *     multiset.\n", "   */\n", "  @Override\n", "  public int add(@Nullable E element, int occurrences) {\n", "    if (occurrences == 0) {\n", "      return count(element);\n", "    }\n", "    checkArgument(occurrences > 0, \"occurrences cannot be negative: %s\", occurrences);\n", "    Count frequency = backingMap.get(element);\n", "    int oldCount;\n", "    if (frequency == null) {\n", "      oldCount = 0;\n", "      backingMap.put(element, new Count(occurrences));\n", "    } else {\n", "      oldCount = frequency.get();\n", "      long newCount = (long) oldCount + (long) occurrences;\n", "      checkArgument(newCount <= Integer.MAX_VALUE, \"too many occurrences: %s\", newCount);\n", "      frequency.getAndAdd(occurrences);\n", "    }\n", "    size += occurrences;\n", "    return oldCount;\n", "  }\n", "\n", "  @Override\n", "  public int remove(@Nullable Object element, int occurrences) {\n", "    if (occurrences == 0) {\n", "      return count(element);\n", "    }\n", "    checkArgument(occurrences > 0, \"occurrences cannot be negative: %s\", occurrences);\n", "    Count frequency = backingMap.get(element);\n", "    if (frequency == null) {\n", "      return 0;\n", "    }\n", "\n", "    int oldCount = frequency.get();\n", "\n", "    int numberRemoved;\n", "    if (oldCount > occurrences) {\n", "      numberRemoved = occurrences;\n", "    } else {\n", "      numberRemoved = oldCount;\n", "      backingMap.remove(element);\n", "    }\n", "\n", "    frequency.addAndGet(-numberRemoved);\n", "    size -= numberRemoved;\n", "    return oldCount;\n", "  }\n", "\n", "  // Roughly a 33% performance improvement over AbstractMultiset.setCount().\n", "  @Override\n", "  public int setCount(@Nullable E element, int count) {\n", "    checkNonnegative(count, \"count\");\n", "\n", "    Count existingCounter;\n", "    int oldCount;\n", "    if (count == 0) {\n", "      existingCounter = backingMap.remove(element);\n", "      oldCount = getAndSet(existingCounter, count);\n", "    } else {\n", "      existingCounter = backingMap.get(element);\n", "      oldCount = getAndSet(existingCounter, count);\n", "\n", "      if (existingCounter == null) {\n", "        backingMap.put(element, new Count(count));\n", "      }\n", "    }\n", "\n", "    size += (count - oldCount);\n", "    return oldCount;\n", "  }\n", "\n", "  private static int getAndSet(Count i, int count) {\n", "    if (i == null) {\n", "      return 0;\n", "    }\n", "\n", "    return i.getAndSet(count);\n", "  }\n", "\n", "  // Don't allow default serialization.\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293]}}, {"12": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ArrayListMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "\n", "import java.util.ArrayList;\n", "import java.util.Collection;\n", "import java.util.HashMap;\n", "import java.util.List;\n", "\n", "/**\n", " * Implementation of {@code Multimap} that uses an {@code ArrayList} to store\n", " * the values for a given key. A {@link HashMap} associates each key with an\n", " * {@link ArrayList} of values.\n", " *\n", " * <p>When iterating through the collections supplied by this class, the\n", " * ordering of values for a given key agrees with the order in which the values\n", " * were added.\n", " *\n", " * <p>This multimap allows duplicate key-value pairs. After adding a new\n", " * key-value pair equal to an existing key-value pair, the {@code\n", " * ArrayListMultimap} will contain entries for both the new value and the old\n", " * value.\n", " *\n", " * <p>Keys and values may be null. All optional multimap methods are supported,\n", " * and all returned views are modifiable.\n", " *\n", " * <p>The lists returned by {@link #get}, {@link #removeAll}, and {@link\n", " * #replaceValues} all implement {@link java.util.RandomAccess}.\n", " *\n", " * <p>This class is not threadsafe when any concurrent operations update the\n", " * multimap. Concurrent read operations will work correctly. To allow concurrent\n", " * update operations, wrap your multimap with a call to {@link\n", " * Multimaps#synchronizedListMultimap}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n", " * {@code Multimap}</a>.\n", " *\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "public final class ArrayListMultimap<K, V> extends AbstractListMultimap<K, V> {\n", "  // Default from ArrayList\n", "  private static final int DEFAULT_VALUES_PER_KEY = 3;\n", "\n", "  @VisibleForTesting transient int expectedValuesPerKey;\n", "\n", "  /**\n", "   * Creates a new, empty {@code ArrayListMultimap} with the default initial\n", "   * capacities.\n", "   */\n", "  public static <K, V> ArrayListMultimap<K, V> create() {\n", "    return new ArrayListMultimap<K, V>();\n", "  }\n", "\n", "  /**\n", "   * Constructs an empty {@code ArrayListMultimap} with enough capacity to hold\n", "   * the specified numbers of keys and values without resizing.\n", "   *\n", "   * @param expectedKeys the expected number of distinct keys\n", "   * @param expectedValuesPerKey the expected average number of values per key\n", "   * @throws IllegalArgumentException if {@code expectedKeys} or {@code\n", "   *      expectedValuesPerKey} is negative\n", "   */\n", "  public static <K, V> ArrayListMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {\n", "    return new ArrayListMultimap<K, V>(expectedKeys, expectedValuesPerKey);\n", "  }\n", "\n", "  /**\n", "   * Constructs an {@code ArrayListMultimap} with the same mappings as the\n", "   * specified multimap.\n", "   *\n", "   * @param multimap the multimap whose contents are copied to this multimap\n", "   */\n", "  public static <K, V> ArrayListMultimap<K, V> create(Multimap<? extends K, ? extends V> multimap) {\n", "    return new ArrayListMultimap<K, V>(multimap);\n", "  }\n", "\n", "  private ArrayListMultimap() {\n", "    super(new HashMap<K, Collection<V>>());\n", "    expectedValuesPerKey = DEFAULT_VALUES_PER_KEY;\n", "  }\n", "\n", "  private ArrayListMultimap(int expectedKeys, int expectedValuesPerKey) {\n", "    super(Maps.<K, Collection<V>>newHashMapWithExpectedSize(expectedKeys));\n", "    checkNonnegative(expectedValuesPerKey, \"expectedValuesPerKey\");\n", "    this.expectedValuesPerKey = expectedValuesPerKey;\n", "  }\n", "\n", "  private ArrayListMultimap(Multimap<? extends K, ? extends V> multimap) {\n", "    this(\n", "        multimap.keySet().size(),\n", "        (multimap instanceof ArrayListMultimap)\n", "            ? ((ArrayListMultimap<?, ?>) multimap).expectedValuesPerKey\n", "            : DEFAULT_VALUES_PER_KEY);\n", "    putAll(multimap);\n", "  }\n", "\n", "  /**\n", "   * Creates a new, empty {@code ArrayList} to hold the collection of values for\n", "   * an arbitrary key.\n", "   */\n", "  @Override\n", "  List<V> createCollection() {\n", "    return new ArrayList<V>(expectedValuesPerKey);\n", "  }\n", "\n", "  /**\n", "   * Reduces the memory used by this {@code ArrayListMultimap}, if feasible.\n", "   */\n", "  public void trimToSize() {\n", "    for (Collection<V> collection : backingMap().values()) {\n", "      ArrayList<V> arrayList = (ArrayList<V>) collection;\n", "      arrayList.trimToSize();\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138]}}, {"13": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ArrayTable.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkElementIndex;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.Maps.IteratorBasedAbstractMap;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.io.Serializable;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Fixed-size {@link Table} implementation backed by a two-dimensional array.\n", " *\n", " * <p>The allowed row and column keys must be supplied when the table is\n", " * created. The table always contains a mapping for every row key / column pair.\n", " * The value corresponding to a given row and column is null unless another\n", " * value is provided.\n", " *\n", " * <p>The table's size is constant: the product of the number of supplied row\n", " * keys and the number of supplied column keys. The {@code remove} and {@code\n", " * clear} methods are not supported by the table or its views. The {@link\n", " * #erase} and {@link #eraseAll} methods may be used instead.\n", " *\n", " * <p>The ordering of the row and column keys provided when the table is\n", " * constructed determines the iteration ordering across rows and columns in the\n", " * table's views. None of the view iterators support {@link Iterator#remove}.\n", " * If the table is modified after an iterator is created, the iterator remains\n", " * valid.\n", " *\n", " * <p>This class requires less memory than the {@link HashBasedTable} and {@link\n", " * TreeBasedTable} implementations, except when the table is sparse.\n", " *\n", " * <p>Null row keys or column keys are not permitted.\n", " *\n", " * <p>This class provides methods involving the underlying array structure,\n", " * where the array indices correspond to the position of a row or column in the\n", " * lists of allowed keys and values. See the {@link #at}, {@link #set}, {@link\n", " * #toArray}, {@link #rowKeyList}, and {@link #columnKeyList} methods for more\n", " * details.\n", " *\n", " * <p>Note that this implementation is not synchronized. If multiple threads\n", " * access the same cell of an {@code ArrayTable} concurrently and one of the\n", " * threads modifies its value, there is no guarantee that the new value will be\n", " * fully visible to the other threads. To guarantee that modifications are\n", " * visible, synchronize access to the table. Unlike other {@code Table}\n", " * implementations, synchronization is unnecessary between a thread that writes\n", " * to one cell and a thread that reads from another.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#table\">\n", " * {@code Table}</a>.\n", " *\n", " * @author Jared Levy\n", " * @since 10.0\n", " */\n", "@Beta\n", "@GwtCompatible(emulated = true)\n", "public final class ArrayTable<R, C, V> extends AbstractTable<R, C, V> implements Serializable {\n", "\n", "  /**\n", "   * Creates an empty {@code ArrayTable}.\n", "   *\n", "   * @param rowKeys row keys that may be stored in the generated table\n", "   * @param columnKeys column keys that may be stored in the generated table\n", "   * @throws NullPointerException if any of the provided keys is null\n", "   * @throws IllegalArgumentException if {@code rowKeys} or {@code columnKeys}\n", "   *     contains duplicates or is empty\n", "   */\n", "  public static <R, C, V> ArrayTable<R, C, V> create(\n", "      Iterable<? extends R> rowKeys, Iterable<? extends C> columnKeys) {\n", "    return new ArrayTable<R, C, V>(rowKeys, columnKeys);\n", "  }\n", "\n", "  /*\n", "   * TODO(jlevy): Add factory methods taking an Enum class, instead of an\n", "   * iterable, to specify the allowed row keys and/or column keys. Note that\n", "   * custom serialization logic is needed to support different enum sizes during\n", "   * serialization and deserialization.\n", "   */\n", "\n", "  /**\n", "   * Creates an {@code ArrayTable} with the mappings in the provided table.\n", "   *\n", "   * <p>If {@code table} includes a mapping with row key {@code r} and a\n", "   * separate mapping with column key {@code c}, the returned table contains a\n", "   * mapping with row key {@code r} and column key {@code c}. If that row key /\n", "   * column key pair in not in {@code table}, the pair maps to {@code null} in\n", "   * the generated table.\n", "   *\n", "   * <p>The returned table allows subsequent {@code put} calls with the row keys\n", "   * in {@code table.rowKeySet()} and the column keys in {@code\n", "   * table.columnKeySet()}. Calling {@link #put} with other keys leads to an\n", "   * {@code IllegalArgumentException}.\n", "   *\n", "   * <p>The ordering of {@code table.rowKeySet()} and {@code\n", "   * table.columnKeySet()} determines the row and column iteration ordering of\n", "   * the returned table.\n", "   *\n", "   * @throws NullPointerException if {@code table} has a null key\n", "   * @throws IllegalArgumentException if the provided table is empty\n", "   */\n", "  public static <R, C, V> ArrayTable<R, C, V> create(Table<R, C, V> table) {\n", "    return (table instanceof ArrayTable<?, ?, ?>)\n", "        ? new ArrayTable<R, C, V>((ArrayTable<R, C, V>) table)\n", "        : new ArrayTable<R, C, V>(table);\n", "  }\n", "\n", "  private final ImmutableList<R> rowList;\n", "  private final ImmutableList<C> columnList;\n", "\n", "  // TODO(jlevy): Add getters returning rowKeyToIndex and columnKeyToIndex?\n", "  private final ImmutableMap<R, Integer> rowKeyToIndex;\n", "  private final ImmutableMap<C, Integer> columnKeyToIndex;\n", "  private final V[][] array;\n", "\n", "  private ArrayTable(Iterable<? extends R> rowKeys, Iterable<? extends C> columnKeys) {\n", "    this.rowList = ImmutableList.copyOf(rowKeys);\n", "    this.columnList = ImmutableList.copyOf(columnKeys);\n", "    checkArgument(!rowList.isEmpty());\n", "    checkArgument(!columnList.isEmpty());\n", "\n", "    /*\n", "     * TODO(jlevy): Support empty rowKeys or columnKeys? If we do, when\n", "     * columnKeys is empty but rowKeys isn't, the table is empty but\n", "     * containsRow() can return true and rowKeySet() isn't empty.\n", "     */\n", "    rowKeyToIndex = Maps.indexMap(rowList);\n", "    columnKeyToIndex = Maps.indexMap(columnList);\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    V[][] tmpArray = (V[][]) new Object[rowList.size()][columnList.size()];\n", "    array = tmpArray;\n", "    // Necessary because in GWT the arrays are initialized with \"undefined\" instead of null.\n", "    eraseAll();\n", "  }\n", "\n", "  private ArrayTable(Table<R, C, V> table) {\n", "    this(table.rowKeySet(), table.columnKeySet());\n", "    putAll(table);\n", "  }\n", "\n", "  private ArrayTable(ArrayTable<R, C, V> table) {\n", "    rowList = table.rowList;\n", "    columnList = table.columnList;\n", "    rowKeyToIndex = table.rowKeyToIndex;\n", "    columnKeyToIndex = table.columnKeyToIndex;\n", "    @SuppressWarnings(\"unchecked\")\n", "    V[][] copy = (V[][]) new Object[rowList.size()][columnList.size()];\n", "    array = copy;\n", "    // Necessary because in GWT the arrays are initialized with \"undefined\" instead of null.\n", "    eraseAll();\n", "    for (int i = 0; i < rowList.size(); i++) {\n", "      System.arraycopy(table.array[i], 0, copy[i], 0, table.array[i].length);\n", "    }\n", "  }\n", "\n", "  private abstract static class ArrayMap<K, V> extends IteratorBasedAbstractMap<K, V> {\n", "    private final ImmutableMap<K, Integer> keyIndex;\n", "\n", "    private ArrayMap(ImmutableMap<K, Integer> keyIndex) {\n", "      this.keyIndex = keyIndex;\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      return keyIndex.keySet();\n", "    }\n", "\n", "    K getKey(int index) {\n", "      return keyIndex.keySet().asList().get(index);\n", "    }\n", "\n", "    abstract String getKeyRole();\n", "\n", "    @Nullable\n", "    abstract V getValue(int index);\n", "\n", "    @Nullable\n", "    abstract V setValue(int index, V newValue);\n", "\n", "    @Override\n", "    public int size() {\n", "      return keyIndex.size();\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return keyIndex.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    Iterator<Entry<K, V>> entryIterator() {\n", "      return new AbstractIndexedListIterator<Entry<K, V>>(size()) {\n", "        @Override\n", "        protected Entry<K, V> get(final int index) {\n", "          return new AbstractMapEntry<K, V>() {\n", "            @Override\n", "            public K getKey() {\n", "              return ArrayMap.this.getKey(index);\n", "            }\n", "\n", "            @Override\n", "            public V getValue() {\n", "              return ArrayMap.this.getValue(index);\n", "            }\n", "\n", "            @Override\n", "            public V setValue(V value) {\n", "              return ArrayMap.this.setValue(index, value);\n", "            }\n", "          };\n", "        }\n", "      };\n", "    }\n", "\n", "    // TODO(lowasser): consider an optimized values() implementation\n", "\n", "    @Override\n", "    public boolean containsKey(@Nullable Object key) {\n", "      return keyIndex.containsKey(key);\n", "    }\n", "\n", "    @Override\n", "    public V get(@Nullable Object key) {\n", "      Integer index = keyIndex.get(key);\n", "      if (index == null) {\n", "        return null;\n", "      } else {\n", "        return getValue(index);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V put(K key, V value) {\n", "      Integer index = keyIndex.get(key);\n", "      if (index == null) {\n", "        throw new IllegalArgumentException(\n", "            getKeyRole() + \" \" + key + \" not in \" + keyIndex.keySet());\n", "      }\n", "      return setValue(index, value);\n", "    }\n", "\n", "    @Override\n", "    public V remove(Object key) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns, as an immutable list, the row keys provided when the table was\n", "   * constructed, including those that are mapped to null values only.\n", "   */\n", "  public ImmutableList<R> rowKeyList() {\n", "    return rowList;\n", "  }\n", "\n", "  /**\n", "   * Returns, as an immutable list, the column keys provided when the table was\n", "   * constructed, including those that are mapped to null values only.\n", "   */\n", "  public ImmutableList<C> columnKeyList() {\n", "    return columnList;\n", "  }\n", "\n", "  /**\n", "   * Returns the value corresponding to the specified row and column indices.\n", "   * The same value is returned by {@code\n", "   * get(rowKeyList().get(rowIndex), columnKeyList().get(columnIndex))}, but\n", "   * this method runs more quickly.\n", "   *\n", "   * @param rowIndex position of the row key in {@link #rowKeyList()}\n", "   * @param columnIndex position of the row key in {@link #columnKeyList()}\n", "   * @return the value with the specified row and column\n", "   * @throws IndexOutOfBoundsException if either index is negative, {@code\n", "   *     rowIndex} is greater then or equal to the number of allowed row keys,\n", "   *     or {@code columnIndex} is greater then or equal to the number of\n", "   *     allowed column keys\n", "   */\n", "  public V at(int rowIndex, int columnIndex) {\n", "    // In GWT array access never throws IndexOutOfBoundsException.\n", "    checkElementIndex(rowIndex, rowList.size());\n", "    checkElementIndex(columnIndex, columnList.size());\n", "    return array[rowIndex][columnIndex];\n", "  }\n", "\n", "  /**\n", "   * Associates {@code value} with the specified row and column indices. The\n", "   * logic {@code\n", "   * put(rowKeyList().get(rowIndex), columnKeyList().get(columnIndex), value)}\n", "   * has the same behavior, but this method runs more quickly.\n", "   *\n", "   * @param rowIndex position of the row key in {@link #rowKeyList()}\n", "   * @param columnIndex position of the row key in {@link #columnKeyList()}\n", "   * @param value value to store in the table\n", "   * @return the previous value with the specified row and column\n", "   * @throws IndexOutOfBoundsException if either index is negative, {@code\n", "   *     rowIndex} is greater then or equal to the number of allowed row keys,\n", "   *     or {@code columnIndex} is greater then or equal to the number of\n", "   *     allowed column keys\n", "   */\n", "  public V set(int rowIndex, int columnIndex, @Nullable V value) {\n", "    // In GWT array access never throws IndexOutOfBoundsException.\n", "    checkElementIndex(rowIndex, rowList.size());\n", "    checkElementIndex(columnIndex, columnList.size());\n", "    V oldValue = array[rowIndex][columnIndex];\n", "    array[rowIndex][columnIndex] = value;\n", "    return oldValue;\n", "  }\n", "\n", "  /**\n", "   * Not supported. Use {@link #eraseAll} instead.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Use {@link #eraseAll}\n", "   */\n", "  @Override\n", "  @Deprecated\n", "  public void clear() {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Associates the value {@code null} with every pair of allowed row and column\n", "   * keys.\n", "   */\n", "  public void eraseAll() {\n", "    for (V[] row : array) {\n", "      Arrays.fill(row, null);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if the provided keys are among the keys provided when\n", "   * the table was constructed.\n", "   */\n", "  @Override\n", "  public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {\n", "    return containsRow(rowKey) && containsColumn(columnKey);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if the provided column key is among the column keys\n", "   * provided when the table was constructed.\n", "   */\n", "  @Override\n", "  public boolean containsColumn(@Nullable Object columnKey) {\n", "    return columnKeyToIndex.containsKey(columnKey);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if the provided row key is among the row keys\n", "   * provided when the table was constructed.\n", "   */\n", "  @Override\n", "  public boolean containsRow(@Nullable Object rowKey) {\n", "    return rowKeyToIndex.containsKey(rowKey);\n", "  }\n", "\n", "  @Override\n", "  public boolean containsValue(@Nullable Object value) {\n", "    for (V[] row : array) {\n", "      for (V element : row) {\n", "        if (Objects.equal(value, element)) {\n", "          return true;\n", "        }\n", "      }\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public V get(@Nullable Object rowKey, @Nullable Object columnKey) {\n", "    Integer rowIndex = rowKeyToIndex.get(rowKey);\n", "    Integer columnIndex = columnKeyToIndex.get(columnKey);\n", "    return (rowIndex == null || columnIndex == null) ? null : at(rowIndex, columnIndex);\n", "  }\n", "\n", "  /**\n", "   * Always returns {@code false}.\n", "   */\n", "  @Override\n", "  public boolean isEmpty() {\n", "    return false;\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * @throws IllegalArgumentException if {@code rowKey} is not in {@link\n", "   *     #rowKeySet()} or {@code columnKey} is not in {@link #columnKeySet()}.\n", "   */\n", "  @Override\n", "  public V put(R rowKey, C columnKey, @Nullable V value) {\n", "    checkNotNull(rowKey);\n", "    checkNotNull(columnKey);\n", "    Integer rowIndex = rowKeyToIndex.get(rowKey);\n", "    checkArgument(rowIndex != null, \"Row %s not in %s\", rowKey, rowList);\n", "    Integer columnIndex = columnKeyToIndex.get(columnKey);\n", "    checkArgument(columnIndex != null, \"Column %s not in %s\", columnKey, columnList);\n", "    return set(rowIndex, columnIndex, value);\n", "  }\n", "\n", "  /*\n", "   * TODO(jlevy): Consider creating a merge() method, similar to putAll() but\n", "   * copying non-null values only.\n", "   */\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>If {@code table} is an {@code ArrayTable}, its null values will be\n", "   * stored in this table, possibly replacing values that were previously\n", "   * non-null.\n", "   *\n", "   * @throws NullPointerException if {@code table} has a null key\n", "   * @throws IllegalArgumentException if any of the provided table's row keys or\n", "   *     column keys is not in {@link #rowKeySet()} or {@link #columnKeySet()}\n", "   */\n", "  @Override\n", "  public void putAll(Table<? extends R, ? extends C, ? extends V> table) {\n", "    super.putAll(table);\n", "  }\n", "\n", "  /**\n", "   * Not supported. Use {@link #erase} instead.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Use {@link #erase}\n", "   */\n", "  @Override\n", "  @Deprecated\n", "  public V remove(Object rowKey, Object columnKey) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Associates the value {@code null} with the specified keys, assuming both\n", "   * keys are valid. If either key is null or isn't among the keys provided\n", "   * during construction, this method has no effect.\n", "   *\n", "   * <p>This method is equivalent to {@code put(rowKey, columnKey, null)} when\n", "   * both provided keys are valid.\n", "   *\n", "   * @param rowKey row key of mapping to be erased\n", "   * @param columnKey column key of mapping to be erased\n", "   * @return the value previously associated with the keys, or {@code null} if\n", "   *     no mapping existed for the keys\n", "   */\n", "  public V erase(@Nullable Object rowKey, @Nullable Object columnKey) {\n", "    Integer rowIndex = rowKeyToIndex.get(rowKey);\n", "    Integer columnIndex = columnKeyToIndex.get(columnKey);\n", "    if (rowIndex == null || columnIndex == null) {\n", "      return null;\n", "    }\n", "    return set(rowIndex, columnIndex, null);\n", "  }\n", "\n", "  // TODO(jlevy): Add eraseRow and eraseColumn methods?\n", "\n", "  @Override\n", "  public int size() {\n", "    return rowList.size() * columnList.size();\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable set of all row key / column key / value\n", "   * triplets. Changes to the table will update the returned set.\n", "   *\n", "   * <p>The returned set's iterator traverses the mappings with the first row\n", "   * key, the mappings with the second row key, and so on.\n", "   *\n", "   * <p>The value in the returned cells may change if the table subsequently\n", "   * changes.\n", "   *\n", "   * @return set of table cells consisting of row key / column key / value\n", "   *     triplets\n", "   */\n", "  @Override\n", "  public Set<Cell<R, C, V>> cellSet() {\n", "    return super.cellSet();\n", "  }\n", "\n", "  @Override\n", "  Iterator<Cell<R, C, V>> cellIterator() {\n", "    return new AbstractIndexedListIterator<Cell<R, C, V>>(size()) {\n", "      @Override\n", "      protected Cell<R, C, V> get(final int index) {\n", "        return new Tables.AbstractCell<R, C, V>() {\n", "          final int rowIndex = index / columnList.size();\n", "          final int columnIndex = index % columnList.size();\n", "\n", "          @Override\n", "          public R getRowKey() {\n", "            return rowList.get(rowIndex);\n", "          }\n", "\n", "          @Override\n", "          public C getColumnKey() {\n", "            return columnList.get(columnIndex);\n", "          }\n", "\n", "          @Override\n", "          public V getValue() {\n", "            return at(rowIndex, columnIndex);\n", "          }\n", "        };\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a view of all mappings that have the given column key. If the\n", "   * column key isn't in {@link #columnKeySet()}, an empty immutable map is\n", "   * returned.\n", "   *\n", "   * <p>Otherwise, for each row key in {@link #rowKeySet()}, the returned map\n", "   * associates the row key with the corresponding value in the table. Changes\n", "   * to the returned map will update the underlying table, and vice versa.\n", "   *\n", "   * @param columnKey key of column to search for in the table\n", "   * @return the corresponding map from row keys to values\n", "   */\n", "  @Override\n", "  public Map<R, V> column(C columnKey) {\n", "    checkNotNull(columnKey);\n", "    Integer columnIndex = columnKeyToIndex.get(columnKey);\n", "    return (columnIndex == null) ? ImmutableMap.<R, V>of() : new Column(columnIndex);\n", "  }\n", "\n", "  private class Column extends ArrayMap<R, V> {\n", "    final int columnIndex;\n", "\n", "    Column(int columnIndex) {\n", "      super(rowKeyToIndex);\n", "      this.columnIndex = columnIndex;\n", "    }\n", "\n", "    @Override\n", "    String getKeyRole() {\n", "      return \"Row\";\n", "    }\n", "\n", "    @Override\n", "    V getValue(int index) {\n", "      return at(index, columnIndex);\n", "    }\n", "\n", "    @Override\n", "    V setValue(int index, V newValue) {\n", "      return set(index, columnIndex, newValue);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable set of the valid column keys, including those that\n", "   * are associated with null values only.\n", "   *\n", "   * @return immutable set of column keys\n", "   */\n", "  @Override\n", "  public ImmutableSet<C> columnKeySet() {\n", "    return columnKeyToIndex.keySet();\n", "  }\n", "\n", "  private transient ColumnMap columnMap;\n", "\n", "  @Override\n", "  public Map<C, Map<R, V>> columnMap() {\n", "    ColumnMap map = columnMap;\n", "    return (map == null) ? columnMap = new ColumnMap() : map;\n", "  }\n", "\n", "  @WeakOuter\n", "  private class ColumnMap extends ArrayMap<C, Map<R, V>> {\n", "    private ColumnMap() {\n", "      super(columnKeyToIndex);\n", "    }\n", "\n", "    @Override\n", "    String getKeyRole() {\n", "      return \"Column\";\n", "    }\n", "\n", "    @Override\n", "    Map<R, V> getValue(int index) {\n", "      return new Column(index);\n", "    }\n", "\n", "    @Override\n", "    Map<R, V> setValue(int index, Map<R, V> newValue) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Map<R, V> put(C key, Map<R, V> value) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a view of all mappings that have the given row key. If the\n", "   * row key isn't in {@link #rowKeySet()}, an empty immutable map is\n", "   * returned.\n", "   *\n", "   * <p>Otherwise, for each column key in {@link #columnKeySet()}, the returned\n", "   * map associates the column key with the corresponding value in the\n", "   * table. Changes to the returned map will update the underlying table, and\n", "   * vice versa.\n", "   *\n", "   * @param rowKey key of row to search for in the table\n", "   * @return the corresponding map from column keys to values\n", "   */\n", "  @Override\n", "  public Map<C, V> row(R rowKey) {\n", "    checkNotNull(rowKey);\n", "    Integer rowIndex = rowKeyToIndex.get(rowKey);\n", "    return (rowIndex == null) ? ImmutableMap.<C, V>of() : new Row(rowIndex);\n", "  }\n", "\n", "  private class Row extends ArrayMap<C, V> {\n", "    final int rowIndex;\n", "\n", "    Row(int rowIndex) {\n", "      super(columnKeyToIndex);\n", "      this.rowIndex = rowIndex;\n", "    }\n", "\n", "    @Override\n", "    String getKeyRole() {\n", "      return \"Column\";\n", "    }\n", "\n", "    @Override\n", "    V getValue(int index) {\n", "      return at(rowIndex, index);\n", "    }\n", "\n", "    @Override\n", "    V setValue(int index, V newValue) {\n", "      return set(rowIndex, index, newValue);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable set of the valid row keys, including those that are\n", "   * associated with null values only.\n", "   *\n", "   * @return immutable set of row keys\n", "   */\n", "  @Override\n", "  public ImmutableSet<R> rowKeySet() {\n", "    return rowKeyToIndex.keySet();\n", "  }\n", "\n", "  private transient RowMap rowMap;\n", "\n", "  @Override\n", "  public Map<R, Map<C, V>> rowMap() {\n", "    RowMap map = rowMap;\n", "    return (map == null) ? rowMap = new RowMap() : map;\n", "  }\n", "\n", "  @WeakOuter\n", "  private class RowMap extends ArrayMap<R, Map<C, V>> {\n", "    private RowMap() {\n", "      super(rowKeyToIndex);\n", "    }\n", "\n", "    @Override\n", "    String getKeyRole() {\n", "      return \"Row\";\n", "    }\n", "\n", "    @Override\n", "    Map<C, V> getValue(int index) {\n", "      return new Row(index);\n", "    }\n", "\n", "    @Override\n", "    Map<C, V> setValue(int index, Map<C, V> newValue) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Map<C, V> put(R key, Map<C, V> value) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable collection of all values, which may contain\n", "   * duplicates. Changes to the table will update the returned collection.\n", "   *\n", "   * <p>The returned collection's iterator traverses the values of the first row\n", "   * key, the values of the second row key, and so on.\n", "   *\n", "   * @return collection of values\n", "   */\n", "  @Override\n", "  public Collection<V> values() {\n", "    return super.values();\n", "  }\n", "\n", "  private static final long serialVersionUID = 0;\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739]}}, {"14": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ContiguousSet.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2010 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.NoSuchElementException;\n", "\n", "/**\n", " * A sorted set of contiguous values in a given {@link DiscreteDomain}.\n", " *\n", " * <p><b>Warning:</b> Be extremely careful what you do with conceptually large instances (such as\n", " * {@code ContiguousSet.create(Range.greaterThan(0), DiscreteDomain.integers()}). Certain\n", " * operations on such a set can be performed efficiently, but others (such as {@link Set#hashCode}\n", " * or {@link Collections#frequency}) can cause major performance problems.\n", " *\n", " * @author Gregory Kick\n", " * @since 10.0\n", " */\n", "@Beta\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"rawtypes\") // allow ungenerified Comparable types\n", "public abstract class ContiguousSet<C extends Comparable> extends ImmutableSortedSet<C> {\n", "  /**\n", "   * Returns a {@code ContiguousSet} containing the same values in the given domain\n", "   * {@linkplain Range#contains contained} by the range.\n", "   *\n", "   * @throws IllegalArgumentException if neither range nor the domain has a lower bound, or if\n", "   *     neither has an upper bound\n", "   *\n", "   * @since 13.0\n", "   */\n", "  public static <C extends Comparable> ContiguousSet<C> create(\n", "      Range<C> range, DiscreteDomain<C> domain) {\n", "    checkNotNull(range);\n", "    checkNotNull(domain);\n", "    Range<C> effectiveRange = range;\n", "    try {\n", "      if (!range.hasLowerBound()) {\n", "        effectiveRange = effectiveRange.intersection(Range.atLeast(domain.minValue()));\n", "      }\n", "      if (!range.hasUpperBound()) {\n", "        effectiveRange = effectiveRange.intersection(Range.atMost(domain.maxValue()));\n", "      }\n", "    } catch (NoSuchElementException e) {\n", "      throw new IllegalArgumentException(e);\n", "    }\n", "\n", "    // Per class spec, we are allowed to throw CCE if necessary\n", "    boolean empty =\n", "        effectiveRange.isEmpty()\n", "            || Range.compareOrThrow(\n", "                    range.lowerBound.leastValueAbove(domain),\n", "                    range.upperBound.greatestValueBelow(domain))\n", "                > 0;\n", "\n", "    return empty\n", "        ? new EmptyContiguousSet<C>(domain)\n", "        : new RegularContiguousSet<C>(effectiveRange, domain);\n", "  }\n", "\n", "  final DiscreteDomain<C> domain;\n", "\n", "  ContiguousSet(DiscreteDomain<C> domain) {\n", "    super(Ordering.natural());\n", "    this.domain = domain;\n", "  }\n", "\n", "  @Override\n", "  public ContiguousSet<C> headSet(C toElement) {\n", "    return headSetImpl(checkNotNull(toElement), false);\n", "  }\n", "\n", "  @Override\n", "  public ContiguousSet<C> subSet(C fromElement, C toElement) {\n", "    checkNotNull(fromElement);\n", "    checkNotNull(toElement);\n", "    checkArgument(comparator().compare(fromElement, toElement) <= 0);\n", "    return subSetImpl(fromElement, true, toElement, false);\n", "  }\n", "\n", "  @Override\n", "  public ContiguousSet<C> tailSet(C fromElement) {\n", "    return tailSetImpl(checkNotNull(fromElement), true);\n", "  }\n", "\n", "  /*\n", "   * These methods perform most headSet, subSet, and tailSet logic, besides parameter validation.\n", "   */\n", "  // TODO(kevinb): we can probably make these real @Overrides now\n", "  /*@Override*/\n", "  abstract ContiguousSet<C> headSetImpl(C toElement, boolean inclusive);\n", "\n", "  /*@Override*/\n", "  abstract ContiguousSet<C> subSetImpl(\n", "      C fromElement, boolean fromInclusive, C toElement, boolean toInclusive);\n", "\n", "  /*@Override*/\n", "  abstract ContiguousSet<C> tailSetImpl(C fromElement, boolean inclusive);\n", "\n", "  /**\n", "   * Returns the set of values that are contained in both this set and the other.\n", "   *\n", "   * <p>This method should always be used instead of\n", "   * {@link Sets#intersection} for {@link ContiguousSet} instances.\n", "   */\n", "  public abstract ContiguousSet<C> intersection(ContiguousSet<C> other);\n", "\n", "  /**\n", "   * Returns a range, closed on both ends, whose endpoints are the minimum and maximum values\n", "   * contained in this set.  This is equivalent to {@code range(CLOSED, CLOSED)}.\n", "   *\n", "   * @throws NoSuchElementException if this set is empty\n", "   */\n", "  public abstract Range<C> range();\n", "\n", "  /**\n", "   * Returns the minimal range with the given boundary types for which all values in this set are\n", "   * {@linkplain Range#contains(Comparable) contained} within the range.\n", "   *\n", "   * <p>Note that this method will return ranges with unbounded endpoints if {@link BoundType#OPEN}\n", "   * is requested for a domain minimum or maximum.  For example, if {@code set} was created from the\n", "   * range {@code [1..Integer.MAX_VALUE]} then {@code set.range(CLOSED, OPEN)} must return\n", "   * {@code [1..\u221e)}.\n", "   *\n", "   * @throws NoSuchElementException if this set is empty\n", "   */\n", "  public abstract Range<C> range(BoundType lowerBoundType, BoundType upperBoundType);\n", "\n", "  /** Returns a short-hand representation of the contents such as {@code \"[1..100]\"}. */\n", "  @Override\n", "  public String toString() {\n", "    return range().toString();\n", "  }\n", "\n", "  /**\n", "   * Not supported. {@code ContiguousSet} instances are constructed with {@link #create}. This\n", "   * method exists only to hide {@link ImmutableSet#builder} from consumers of {@code\n", "   * ContiguousSet}.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Use {@link #create}.\n", "   */\n", "  @Deprecated\n", "  public static <E> ImmutableSortedSet.Builder<E> builder() {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165]}}, {"15": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/EmptyContiguousSet.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.NoSuchElementException;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * An empty contiguous set.\n", " *\n", " * @author Gregory Kick\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"unchecked\") // allow ungenerified Comparable types\n", "final class EmptyContiguousSet<C extends Comparable> extends ContiguousSet<C> {\n", "  EmptyContiguousSet(DiscreteDomain<C> domain) {\n", "    super(domain);\n", "  }\n", "\n", "  @Override\n", "  public C first() {\n", "    throw new NoSuchElementException();\n", "  }\n", "\n", "  @Override\n", "  public C last() {\n", "    throw new NoSuchElementException();\n", "  }\n", "\n", "  @Override\n", "  public int size() {\n", "    return 0;\n", "  }\n", "\n", "  @Override\n", "  public ContiguousSet<C> intersection(ContiguousSet<C> other) {\n", "    return this;\n", "  }\n", "\n", "  @Override\n", "  public Range<C> range() {\n", "    throw new NoSuchElementException();\n", "  }\n", "\n", "  @Override\n", "  public Range<C> range(BoundType lowerBoundType, BoundType upperBoundType) {\n", "    throw new NoSuchElementException();\n", "  }\n", "\n", "  @Override\n", "  ContiguousSet<C> headSetImpl(C toElement, boolean inclusive) {\n", "    return this;\n", "  }\n", "\n", "  @Override\n", "  ContiguousSet<C> subSetImpl(\n", "      C fromElement, boolean fromInclusive, C toElement, boolean toInclusive) {\n", "    return this;\n", "  }\n", "\n", "  @Override\n", "  ContiguousSet<C> tailSetImpl(C fromElement, boolean fromInclusive) {\n", "    return this;\n", "  }\n", "\n", "  @Override\n", "  public boolean contains(Object object) {\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public UnmodifiableIterator<C> iterator() {\n", "    return Iterators.emptyIterator();\n", "  }\n", "\n", "  @Override\n", "  boolean isPartialView() {\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public boolean isEmpty() {\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  public ImmutableList<C> asList() {\n", "    return ImmutableList.of();\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return \"[]\";\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object instanceof Set) {\n", "      Set<?> that = (Set<?>) object;\n", "      return that.isEmpty();\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return 0;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125]}}, {"16": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/EnumBiMap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.EnumMap;\n", "import java.util.Map;\n", "\n", "/**\n", " * A {@code BiMap} backed by two {@code EnumMap} instances. Null keys and values\n", " * are not permitted. An {@code EnumBiMap} and its inverse are both\n", " * serializable.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap\">\n", " * {@code BiMap}</a>.\n", " *\n", " * @author Mike Bostock\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class EnumBiMap<K extends Enum<K>, V extends Enum<V>> extends AbstractBiMap<K, V> {\n", "  private transient Class<K> keyType;\n", "  private transient Class<V> valueType;\n", "\n", "  /**\n", "   * Returns a new, empty {@code EnumBiMap} using the specified key and value\n", "   * types.\n", "   *\n", "   * @param keyType the key type\n", "   * @param valueType the value type\n", "   */\n", "  public static <K extends Enum<K>, V extends Enum<V>> EnumBiMap<K, V> create(\n", "      Class<K> keyType, Class<V> valueType) {\n", "    return new EnumBiMap<K, V>(keyType, valueType);\n", "  }\n", "\n", "  /**\n", "   * Returns a new bimap with the same mappings as the specified map. If the\n", "   * specified map is an {@code EnumBiMap}, the new bimap has the same types as\n", "   * the provided map. Otherwise, the specified map must contain at least one\n", "   * mapping, in order to determine the key and value types.\n", "   *\n", "   * @param map the map whose mappings are to be placed in this map\n", "   * @throws IllegalArgumentException if map is not an {@code EnumBiMap}\n", "   *     instance and contains no mappings\n", "   */\n", "  public static <K extends Enum<K>, V extends Enum<V>> EnumBiMap<K, V> create(Map<K, V> map) {\n", "    EnumBiMap<K, V> bimap = create(inferKeyType(map), inferValueType(map));\n", "    bimap.putAll(map);\n", "    return bimap;\n", "  }\n", "\n", "  private EnumBiMap(Class<K> keyType, Class<V> valueType) {\n", "    super(\n", "        WellBehavedMap.wrap(new EnumMap<K, V>(keyType)),\n", "        WellBehavedMap.wrap(new EnumMap<V, K>(valueType)));\n", "    this.keyType = keyType;\n", "    this.valueType = valueType;\n", "  }\n", "\n", "  static <K extends Enum<K>> Class<K> inferKeyType(Map<K, ?> map) {\n", "    if (map instanceof EnumBiMap) {\n", "      return ((EnumBiMap<K, ?>) map).keyType();\n", "    }\n", "    if (map instanceof EnumHashBiMap) {\n", "      return ((EnumHashBiMap<K, ?>) map).keyType();\n", "    }\n", "    checkArgument(!map.isEmpty());\n", "    return map\n", "        .keySet()\n", "        .iterator()\n", "        .next()\n", "        .getDeclaringClass();\n", "  }\n", "\n", "  private static <V extends Enum<V>> Class<V> inferValueType(Map<?, V> map) {\n", "    if (map instanceof EnumBiMap) {\n", "      return ((EnumBiMap<?, V>) map).valueType;\n", "    }\n", "    checkArgument(!map.isEmpty());\n", "    return map\n", "        .values()\n", "        .iterator()\n", "        .next()\n", "        .getDeclaringClass();\n", "  }\n", "\n", "  /** Returns the associated key type. */\n", "  public Class<K> keyType() {\n", "    return keyType;\n", "  }\n", "\n", "  /** Returns the associated value type. */\n", "  public Class<V> valueType() {\n", "    return valueType;\n", "  }\n", "\n", "  @Override\n", "  K checkKey(K key) {\n", "    return checkNotNull(key);\n", "  }\n", "\n", "  @Override\n", "  V checkValue(V value) {\n", "    return checkNotNull(value);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"17": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/EnumHashBiMap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.EnumMap;\n", "import java.util.Map;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A {@code BiMap} backed by an {@code EnumMap} instance for keys-to-values, and\n", " * a {@code HashMap} instance for values-to-keys. Null keys are not permitted,\n", " * but null values are. An {@code EnumHashBiMap} and its inverse are both\n", " * serializable.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap\">\n", " * {@code BiMap}</a>.\n", " *\n", " * @author Mike Bostock\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class EnumHashBiMap<K extends Enum<K>, V> extends AbstractBiMap<K, V> {\n", "  private transient Class<K> keyType;\n", "\n", "  /**\n", "   * Returns a new, empty {@code EnumHashBiMap} using the specified key type.\n", "   *\n", "   * @param keyType the key type\n", "   */\n", "  public static <K extends Enum<K>, V> EnumHashBiMap<K, V> create(Class<K> keyType) {\n", "    return new EnumHashBiMap<K, V>(keyType);\n", "  }\n", "\n", "  /**\n", "   * Constructs a new bimap with the same mappings as the specified map. If the\n", "   * specified map is an {@code EnumHashBiMap} or an {@link EnumBiMap}, the new\n", "   * bimap has the same key type as the input bimap. Otherwise, the specified\n", "   * map must contain at least one mapping, in order to determine the key type.\n", "   *\n", "   * @param map the map whose mappings are to be placed in this map\n", "   * @throws IllegalArgumentException if map is not an {@code EnumBiMap} or an\n", "   *     {@code EnumHashBiMap} instance and contains no mappings\n", "   */\n", "  public static <K extends Enum<K>, V> EnumHashBiMap<K, V> create(Map<K, ? extends V> map) {\n", "    EnumHashBiMap<K, V> bimap = create(EnumBiMap.inferKeyType(map));\n", "    bimap.putAll(map);\n", "    return bimap;\n", "  }\n", "\n", "  private EnumHashBiMap(Class<K> keyType) {\n", "    super(\n", "        WellBehavedMap.wrap(new EnumMap<K, V>(keyType)),\n", "        Maps.<V, K>newHashMapWithExpectedSize(keyType.getEnumConstants().length));\n", "    this.keyType = keyType;\n", "  }\n", "\n", "  // Overriding these 3 methods to show that values may be null (but not keys)\n", "\n", "  @Override\n", "  K checkKey(K key) {\n", "    return checkNotNull(key);\n", "  }\n", "\n", "  @Override\n", "  public V put(K key, @Nullable V value) {\n", "    return super.put(key, value);\n", "  }\n", "\n", "  @Override\n", "  public V forcePut(K key, @Nullable V value) {\n", "    return super.forcePut(key, value);\n", "  }\n", "\n", "  /** Returns the associated key type. */\n", "  public Class<K> keyType() {\n", "    return keyType;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]}}, {"18": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/EnumMultiset.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.EnumMap;\n", "import java.util.Iterator;\n", "\n", "/**\n", " * Multiset implementation backed by an {@link EnumMap}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset\">\n", " * {@code Multiset}</a>.\n", " *\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class EnumMultiset<E extends Enum<E>> extends AbstractMapBasedMultiset<E> {\n", "  /** Creates an empty {@code EnumMultiset}. */\n", "  public static <E extends Enum<E>> EnumMultiset<E> create(Class<E> type) {\n", "    return new EnumMultiset<E>(type);\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code EnumMultiset} containing the specified elements.\n", "   *\n", "   * <p>This implementation is highly efficient when {@code elements} is itself a {@link\n", "   * Multiset}.\n", "   *\n", "   * @param elements the elements that the multiset should contain\n", "   * @throws IllegalArgumentException if {@code elements} is empty\n", "   */\n", "  public static <E extends Enum<E>> EnumMultiset<E> create(Iterable<E> elements) {\n", "    Iterator<E> iterator = elements.iterator();\n", "    checkArgument(iterator.hasNext(), \"EnumMultiset constructor passed empty Iterable\");\n", "    EnumMultiset<E> multiset = new EnumMultiset<E>(iterator.next().getDeclaringClass());\n", "    Iterables.addAll(multiset, elements);\n", "    return multiset;\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code EnumMultiset} instance containing the given elements.  Unlike\n", "   * {@link EnumMultiset#create(Iterable)}, this method does not produce an exception on an empty\n", "   * iterable.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  public static <E extends Enum<E>> EnumMultiset<E> create(Iterable<E> elements, Class<E> type) {\n", "    EnumMultiset<E> result = create(type);\n", "    Iterables.addAll(result, elements);\n", "    return result;\n", "  }\n", "\n", "  private transient Class<E> type;\n", "\n", "  /** Creates an empty {@code EnumMultiset}. */\n", "  private EnumMultiset(Class<E> type) {\n", "    super(WellBehavedMap.wrap(new EnumMap<E, Count>(type)));\n", "    this.type = type;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79]}}, {"19": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Joiner;\n", "import com.google.common.base.Optional;\n", "import com.google.common.base.Predicate;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.SortedSet;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=\n", " * \"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"\n", " * >streams library</a> in a slightly different way.\n", " *\n", " * <p>The following types of methods are provided:\n", " *\n", " * <ul>\n", " * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents\n", " *     of the current one (for example {@link #transform})\n", " * <li>element extraction methods which facilitate the retrieval of certain elements (for example\n", " *     {@link #last})\n", " * <li>query methods which answer questions about the {@code FluentIterable}'s contents (for example\n", " *     {@link #anyMatch})\n", " * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or\n", " *     array (for example {@link #toList})\n", " * </ul>\n", " *\n", " * <p>Several lesser-used features are currently available only as static methods on the {@link\n", " * Iterables} class.\n", " *\n", " * <a name=\"streams\"></a>\n", " * <h3>Comparison to streams</h3>\n", " *\n", " * <p>Starting with Java 8, the core Java class libraries provide a new \"Streams\" library (in {@code\n", " * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key\n", " * differences include:</b>\n", " *\n", " * <ul>\n", " * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any \"terminal operation\" such as\n", " *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains\n", " *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually\n", " *     do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is\n", " *     multiple-use, and does implement {@link Iterable}.\n", " * <li>Streams offer many features not found here, including {@code min/max}, {@code\n", " *     distinct}, {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in\n", " *     support for parallelizing stream operations.\n", " * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are\n", " *     noted in the method descriptions below.\n", " * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is\n", " *     strongly recommended.\n", " * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code\n", " *     incompatible with Java 7 and earlier).\n", " * </ul>\n", " *\n", " * <h3>Example</h3>\n", " *\n", " * <p>Here is an example that accepts a list from a database call, filters it based on a predicate,\n", " * transforms it by invoking {@code toString()} on each element, and returns the first 10 elements\n", " * as a {@code List}: <pre>   {@code\n", " *\n", " *   List<String> results =\n", " *       FluentIterable.from(database.getClientList())\n", " *           .filter(activeInLastMonthPredicate)\n", " *           .transform(Functions.toStringFunction())\n", " *           .limit(10)\n", " *           .toList();}</pre>\n", " *\n", " * The approximate stream equivalent is: <pre>   {@code\n", " *\n", " *   List<String> results =\n", " *       database.getClientList()\n", " *           .stream()\n", " *           .filter(activeInLastMonthPredicate)\n", " *           .map(Functions.toStringFunction())\n", " *           .limit(10)\n", " *           .collect(Collectors.toList());}</pre>\n", " *\n", " * @author Marcin Mikosik\n", " * @since 12.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public abstract class FluentIterable<E> implements Iterable<E> {\n", "  // We store 'iterable' and use it instead of 'this' to allow Iterables to perform instanceof\n", "  // checks on the _original_ iterable when FluentIterable.from is used.\n", "  private final Iterable<E> iterable;\n", "\n", "  /** Constructor for use by subclasses. */\n", "  protected FluentIterable() {\n", "    this.iterable = this;\n", "  }\n", "\n", "  FluentIterable(Iterable<E> iterable) {\n", "    this.iterable = checkNotNull(iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable that wraps {@code iterable}, or {@code iterable} itself if it\n", "   * is already a {@code FluentIterable}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a\n", "   * {@link Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.\n", "   */\n", "  @CheckReturnValue\n", "  public static <E> FluentIterable<E> from(final Iterable<E> iterable) {\n", "    return (iterable instanceof FluentIterable)\n", "        ? (FluentIterable<E>) iterable\n", "        : new FluentIterable<E>(iterable) {\n", "          @Override\n", "          public Iterator<E> iterator() {\n", "            return iterable.iterator();\n", "          }\n", "        };\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable containing {@code elements} in the specified order.\n", "   *\n", "   * <p>The returned iterable is an unmodifiable view of the input array.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code\n", "   * Arrays.stream(elements)}.\n", "   *\n", "   * @since 20.0 (since 18.0 as an overload of {@code of})\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  public static <E> FluentIterable<E> from(E[] elements) {\n", "    return from(Arrays.asList(elements));\n", "  }\n", "\n", "  /**\n", "   * Construct a fluent iterable from another fluent iterable. This is obviously never necessary,\n", "   * but is intended to help call out cases where one migration from {@code Iterable} to\n", "   * {@code FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.\n", "   *\n", "   * @deprecated instances of {@code FluentIterable} don't need to be converted to\n", "   *     {@code FluentIterable}\n", "   */\n", "  @Deprecated\n", "  @CheckReturnValue\n", "  public static <E> FluentIterable<E> from(FluentIterable<E> iterable) {\n", "    return checkNotNull(iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable containing no elements.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.empty()}.\n", "   *\n", "   * @since 20.0\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  public static <E> FluentIterable<E> of() {\n", "    return FluentIterable.from(ImmutableList.<E>of());\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable containing {@code elements} in the specified order.\n", "   *\n", "   * <p>The returned iterable is modifiable, but modifications do not affect the input array.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(elements)} or {@code\n", "   * Arrays.stream(elements)}.\n", "   *\n", "   * @since 18.0\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  // TODO(kak): @deprecated Use {@link #from(E[])} instead.\n", "  public static <E> FluentIterable<E> of(E[] elements) {\n", "    return from(Lists.newArrayList(elements));\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable containing the specified elements in order.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.of(...)}.\n", "   *\n", "   * @since 20.0\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  public static <E> FluentIterable<E> of(@Nullable E element, E... elements) {\n", "    return from(Lists.asList(element, elements));\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of this fluent iterable, with the format\n", "   * {@code [e1, e2, ..., en]}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.joining(\", \", \"[\", \"]\"))}\n", "   * or (less efficiently) {@code collect(Collectors.toList()).toString()}.\n", "   */\n", "  @Override\n", "  @CheckReturnValue\n", "  public String toString() {\n", "    return Iterables.toString(iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns the number of elements in this fluent iterable.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.count()}.\n", "   */\n", "  @CheckReturnValue\n", "  public final int size() {\n", "    return Iterables.size(iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if this fluent iterable contains any object for which\n", "   * {@code equals(target)} is true.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}.\n", "   */\n", "  @CheckReturnValue\n", "  public final boolean contains(@Nullable Object target) {\n", "    return Iterables.contains(iterable, target);\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable whose {@code Iterator} cycles indefinitely over the elements of\n", "   * this fluent iterable.\n", "   *\n", "   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After\n", "   * {@code remove()} is called, subsequent cycles omit the removed element, which is no longer in\n", "   * this fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until\n", "   * this fluent iterable is empty.\n", "   *\n", "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n", "   * should use an explicit {@code break} or be certain that you will eventually remove all the\n", "   * elements.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> if the source iterable has only a single element {@code\n", "   * element}, use {@code Stream.generate(() -> element)}. Otherwise, if the source iterable has\n", "   * a {@code stream} method (for example, if it is a {@link Collection}), use\n", "   * {@code Stream.generate(iterable::stream).flatMap(s -> s)}.\n", "   */\n", "  @CheckReturnValue\n", "  public final FluentIterable<E> cycle() {\n", "    return from(Iterables.cycle(iterable));\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable whose iterators traverse first the elements of this fluent iterable,\n", "   * followed by those of {@code other}. The iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterable's {@code Iterator} supports {@code remove()} when the corresponding\n", "   * {@code Iterator} supports it.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, otherStream)}.\n", "   *\n", "   * @since 18.0\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  public final FluentIterable<E> append(Iterable<? extends E> other) {\n", "    return from(Iterables.concat(iterable, other));\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable whose iterators traverse first the elements of this fluent iterable,\n", "   * followed by {@code elements}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, Stream.of(elements))}.\n", "   *\n", "   * @since 18.0\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  public final FluentIterable<E> append(E... elements) {\n", "    return from(Iterables.concat(iterable, Arrays.asList(elements)));\n", "  }\n", "\n", "  /**\n", "   * Returns the elements from this fluent iterable that satisfy a predicate. The\n", "   * resulting fluent iterable's iterator does not support {@code remove()}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate)} (same).\n", "   */\n", "  @CheckReturnValue\n", "  public final FluentIterable<E> filter(Predicate<? super E> predicate) {\n", "    return from(Iterables.filter(iterable, predicate));\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if any element in this fluent iterable satisfies the predicate.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(predicate)} (same).\n", "   */\n", "  @CheckReturnValue\n", "  public final boolean anyMatch(Predicate<? super E> predicate) {\n", "    return Iterables.any(iterable, predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if every element in this fluent iterable satisfies the predicate.\n", "   * If this fluent iterable is empty, {@code true} is returned.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.allMatch(predicate)} (same).\n", "   */\n", "  @CheckReturnValue\n", "  public final boolean allMatch(Predicate<? super E> predicate) {\n", "    return Iterables.all(iterable, predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@link Optional} containing the first element in this fluent iterable that\n", "   * satisfies the given predicate, if such an element exists.\n", "   *\n", "   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n", "   * is matched in this fluent iterable, a {@link NullPointerException} will be thrown.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}.\n", "   */\n", "  @CheckReturnValue\n", "  public final Optional<E> firstMatch(Predicate<? super E> predicate) {\n", "    return Iterables.tryFind(iterable, predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns a fluent iterable that applies {@code function} to each element of this\n", "   * fluent iterable.\n", "   *\n", "   * <p>The returned fluent iterable's iterator supports {@code remove()} if this iterable's\n", "   * iterator does. After a successful {@code remove()} call, this fluent iterable no longer\n", "   * contains the corresponding element.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.map(function)}.\n", "   */\n", "  @CheckReturnValue\n", "  public final <T> FluentIterable<T> transform(Function<? super E, T> function) {\n", "    return from(Iterables.transform(iterable, function));\n", "  }\n", "\n", "  /**\n", "   * Applies {@code function} to each element of this fluent iterable and returns\n", "   * a fluent iterable with the concatenated combination of results.  {@code function}\n", "   * returns an Iterable of results.\n", "   *\n", "   * <p>The returned fluent iterable's iterator supports {@code remove()} if this\n", "   * function-returned iterables' iterator does. After a successful {@code remove()} call,\n", "   * the returned fluent iterable no longer contains the corresponding element.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.flatMap(function)} (using a function that\n", "   * produces streams, not iterables).\n", "   *\n", "   * @since 13.0 (required {@code Function<E, Iterable<T>>} until 14.0)\n", "   */\n", "  @CheckReturnValue\n", "  public <T> FluentIterable<T> transformAndConcat(\n", "      Function<? super E, ? extends Iterable<? extends T>> function) {\n", "    return from(Iterables.concat(transform(function)));\n", "  }\n", "\n", "  /**\n", "   * Returns an {@link Optional} containing the first element in this fluent iterable.\n", "   * If the iterable is empty, {@code Optional.absent()} is returned.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@code\n", "   * stream.findAny()}; if it must specifically be the <i>first</i> element, {@code\n", "   * stream.findFirst()}.\n", "   *\n", "   * @throws NullPointerException if the first element is null; if this is a possibility, use\n", "   *     {@code iterator().next()} or {@link Iterables#getFirst} instead.\n", "   */\n", "  @CheckReturnValue\n", "  public final Optional<E> first() {\n", "    Iterator<E> iterator = iterable.iterator();\n", "    return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.<E>absent();\n", "  }\n", "\n", "  /**\n", "   * Returns an {@link Optional} containing the last element in this fluent iterable.\n", "   * If the iterable is empty, {@code Optional.absent()} is returned.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}.\n", "   *\n", "   * @throws NullPointerException if the last element is null; if this is a possibility, use\n", "   *     {@link Iterables#getLast} instead.\n", "   */\n", "  @CheckReturnValue\n", "  public final Optional<E> last() {\n", "    // Iterables#getLast was inlined here so we don't have to throw/catch a NSEE\n", "\n", "    // TODO(kevinb): Support a concurrently modified collection?\n", "    if (iterable instanceof List) {\n", "      List<E> list = (List<E>) iterable;\n", "      if (list.isEmpty()) {\n", "        return Optional.absent();\n", "      }\n", "      return Optional.of(list.get(list.size() - 1));\n", "    }\n", "    Iterator<E> iterator = iterable.iterator();\n", "    if (!iterator.hasNext()) {\n", "      return Optional.absent();\n", "    }\n", "\n", "    /*\n", "     * TODO(kevinb): consider whether this \"optimization\" is worthwhile. Users\n", "     * with SortedSets tend to know they are SortedSets and probably would not\n", "     * call this method.\n", "     */\n", "    if (iterable instanceof SortedSet) {\n", "      SortedSet<E> sortedSet = (SortedSet<E>) iterable;\n", "      return Optional.of(sortedSet.last());\n", "    }\n", "\n", "    while (true) {\n", "      E current = iterator.next();\n", "      if (!iterator.hasNext()) {\n", "        return Optional.of(current);\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a view of this fluent iterable that skips its first {@code numberToSkip}\n", "   * elements. If this fluent iterable contains fewer than {@code numberToSkip} elements,\n", "   * the returned fluent iterable skips all of its elements.\n", "   *\n", "   * <p>Modifications to this fluent iterable before a call to {@code iterator()} are\n", "   * reflected in the returned fluent iterable. That is, the its iterator skips the first\n", "   * {@code numberToSkip} elements that exist when the iterator is created, not when {@code skip()}\n", "   * is called.\n", "   *\n", "   * <p>The returned fluent iterable's iterator supports {@code remove()} if the\n", "   * {@code Iterator} of this fluent iterable supports it. Note that it is <i>not</i>\n", "   * possible to delete the last skipped element by immediately calling {@code remove()} on the\n", "   * returned fluent iterable's iterator, as the {@code Iterator} contract states that a call\n", "   * to {@code * remove()} before a call to {@code next()} will throw an\n", "   * {@link IllegalStateException}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(numberToSkip)} (same).\n", "   */\n", "  @CheckReturnValue\n", "  public final FluentIterable<E> skip(int numberToSkip) {\n", "    return from(Iterables.skip(iterable, numberToSkip));\n", "  }\n", "\n", "  /**\n", "   * Creates a fluent iterable with the first {@code size} elements of this\n", "   * fluent iterable. If this fluent iterable does not contain that many elements,\n", "   * the returned fluent iterable will have the same behavior as this fluent iterable.\n", "   * The returned fluent iterable's iterator supports {@code remove()} if this\n", "   * fluent iterable's iterator does.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.limit(maxSize)} (same).\n", "   *\n", "   * @param maxSize the maximum number of elements in the returned fluent iterable\n", "   * @throws IllegalArgumentException if {@code size} is negative\n", "   */\n", "  @CheckReturnValue\n", "  public final FluentIterable<E> limit(int maxSize) {\n", "    return from(Iterables.limit(iterable, maxSize));\n", "  }\n", "\n", "  /**\n", "   * Determines whether this fluent iterable is empty.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}.\n", "   */\n", "  @CheckReturnValue\n", "  public final boolean isEmpty() {\n", "    return !iterable.iterator().hasNext();\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code ImmutableList} containing all of the elements from this fluent iterable in\n", "   * proper sequence.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}.\n", "   *\n", "   * @since 14.0 (since 12.0 as {@code toImmutableList()}).\n", "   */\n", "  @CheckReturnValue\n", "  public final ImmutableList<E> toList() {\n", "    return ImmutableList.copyOf(iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code ImmutableList} containing all of the elements from this {@code\n", "   * FluentIterable} in the order specified by {@code comparator}.  To produce an {@code\n", "   * ImmutableList} sorted by its natural ordering, use {@code toSortedList(Ordering.natural())}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b>\n", "   * {@code ImmutableList.copyOf(stream.sorted(comparator).iterator())}.\n", "   *\n", "   * @param comparator the function by which to sort list elements\n", "   * @throws NullPointerException if any element is null\n", "   * @since 14.0 (since 13.0 as {@code toSortedImmutableList()}).\n", "   */\n", "  @CheckReturnValue\n", "  public final ImmutableList<E> toSortedList(Comparator<? super E> comparator) {\n", "    return Ordering.from(comparator).immutableSortedCopy(iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code ImmutableSet} containing all of the elements from this fluent iterable with\n", "   * duplicates removed.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}.\n", "   *\n", "   * @since 14.0 (since 12.0 as {@code toImmutableSet()}).\n", "   */\n", "  @CheckReturnValue\n", "  public final ImmutableSet<E> toSet() {\n", "    return ImmutableSet.copyOf(iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code ImmutableSortedSet} containing all of the elements from this {@code\n", "   * FluentIterable} in the order specified by {@code comparator}, with duplicates (determined by\n", "   * {@code comparator.compare(x, y) == 0}) removed. To produce an {@code ImmutableSortedSet} sorted\n", "   * by its natural ordering, use {@code toSortedSet(Ordering.natural())}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b>\n", "   * {@code ImmutableSortedSet.copyOf(comparator, stream.iterator())}.\n", "   *\n", "   * @param comparator the function by which to sort set elements\n", "   * @throws NullPointerException if any element is null\n", "   * @since 14.0 (since 12.0 as {@code toImmutableSortedSet()}).\n", "   */\n", "  @CheckReturnValue\n", "  public final ImmutableSortedSet<E> toSortedSet(Comparator<? super E> comparator) {\n", "    return ImmutableSortedSet.copyOf(comparator, iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code ImmutableMultiset} containing all of the elements from this fluent iterable.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}.\n", "   *\n", "   * @since 19.0\n", "   */\n", "  @CheckReturnValue\n", "  public final ImmutableMultiset<E> toMultiset() {\n", "    return ImmutableMultiset.copyOf(iterable);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable map whose keys are the distinct elements of this {@code FluentIterable}\n", "   * and whose value for each key was computed by {@code valueFunction}. The map's iteration order\n", "   * is the order of the first appearance of each key in this iterable.\n", "   *\n", "   * <p>When there are multiple instances of a key in this iterable, it is unspecified whether\n", "   * {@code valueFunction} will be applied to more than one instance of that key and, if it is,\n", "   * which result will be mapped to that key in the returned map.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code\n", "   * ImmutableMap.copyOf(stream.collect(Collectors.toMap(k -> k, valueFunction)))} (but note that\n", "   * this may not preserve the order of entries).\n", "   *\n", "   * @throws NullPointerException if any element of this iterable is {@code null}, or if {@code\n", "   *     valueFunction} produces {@code null} for any key\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public final <V> ImmutableMap<E, V> toMap(Function<? super E, V> valueFunction) {\n", "    return Maps.toMap(iterable, valueFunction);\n", "  }\n", "\n", "  /**\n", "   * Creates an index {@code ImmutableListMultimap} that contains the results of applying a\n", "   * specified function to each item in this {@code FluentIterable} of values. Each element of this\n", "   * iterable will be stored as a value in the resulting multimap, yielding a multimap with the same\n", "   * size as this iterable. The key used to store that value in the multimap will be the result of\n", "   * calling the function on that value. The resulting multimap is created as an immutable snapshot.\n", "   * In the returned multimap, keys appear in the order they are first encountered, and the values\n", "   * corresponding to each key appear in the same order as they are encountered.\n", "   *\n", "   * @param keyFunction the function used to produce the key for each value\n", "   * @throws NullPointerException if any of the following cases is true:\n", "   *     <ul>\n", "   *       <li>{@code keyFunction} is null\n", "   *       <li>An element in this fluent iterable is null\n", "   *       <li>{@code keyFunction} returns {@code null} for any element of this iterable\n", "   *     </ul>\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.groupingBy(keyFunction))}\n", "   * behaves similarly, but returns a mutable {@code Map<K, List<E>>} instead, and may not preserve\n", "   * the order of entries).\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public final <K> ImmutableListMultimap<K, E> index(Function<? super E, K> keyFunction) {\n", "    return Multimaps.index(iterable, keyFunction);\n", "  }\n", "\n", "  /**\n", "   * Returns a map with the contents of this {@code FluentIterable} as its {@code values}, indexed\n", "   * by keys derived from those values. In other words, each input value produces an entry in the\n", "   * map whose key is the result of applying {@code keyFunction} to that value. These entries appear\n", "   * in the same order as they appeared in this fluent iterable. Example usage:\n", "   * <pre>   {@code\n", "   *\n", "   *   Color red = new Color(\"red\", 255, 0, 0);\n", "   *   ...\n", "   *   FluentIterable<Color> allColors = FluentIterable.from(ImmutableSet.of(red, green, blue));\n", "   *\n", "   *   Map<String, Color> colorForName = allColors.uniqueIndex(toStringFunction());\n", "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n", "   *\n", "   * <p>If your index may associate multiple values with each key, use {@link #index(Function)\n", "   * index}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code\n", "   * ImmutableMap.copyOf(stream.collect(Collectors.toMap(keyFunction, v -> v)))} (but note that this\n", "   * may not preserve the order of entries).\n", "   *\n", "   * @param keyFunction the function used to produce the key for each value\n", "   * @return a map mapping the result of evaluating the function {@code\n", "   *     keyFunction} on each value in this fluent iterable to that value\n", "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n", "   *     key for more than one value in this fluent iterable\n", "   * @throws NullPointerException if any elements of this fluent iterable is null, or\n", "   *     if {@code keyFunction} produces {@code null} for any value\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public final <K> ImmutableMap<K, E> uniqueIndex(Function<? super E, K> keyFunction) {\n", "    return Maps.uniqueIndex(iterable, keyFunction);\n", "  }\n", "\n", "  /**\n", "   * Copies all the elements from this fluent iterable to {@code collection}. This is equivalent to\n", "   * calling {@code Iterables.addAll(collection, this)}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.forEachOrdered(collection::add)} or\n", "   * {@code stream.forEach(collection::add)}.\n", "   *\n", "   * @param collection the collection to copy elements to\n", "   * @return {@code collection}, for convenience\n", "   * @since 14.0\n", "   */\n", "  public final <C extends Collection<? super E>> C copyInto(C collection) {\n", "    checkNotNull(collection);\n", "    if (iterable instanceof Collection) {\n", "      collection.addAll(Collections2.cast(iterable));\n", "    } else {\n", "      for (E item : iterable) {\n", "        collection.add(item);\n", "      }\n", "    }\n", "    return collection;\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link String} containing all of the elements of this fluent iterable joined with\n", "   * {@code joiner}.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code joiner.join(stream.iterator())}, or, if you are not\n", "   * using any optional {@code Joiner} features,\n", "   * {@code stream.collect(Collectors.joining(delimiter)}.\n", "   *\n", "   * @since 18.0\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  public final String join(Joiner joiner) {\n", "    return joiner.join(this);\n", "  }\n", "\n", "  /**\n", "   * Returns the element at the specified position in this fluent iterable.\n", "   *\n", "   * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()} (but note\n", "   * that this throws different exception types, and throws an exception if {@code null} would be\n", "   * returned).\n", "   *\n", "   * @param position position of the element to return\n", "   * @return the element at the specified position in this fluent iterable\n", "   * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to\n", "   *     the size of this fluent iterable\n", "   */\n", "  // TODO(kevinb): add @Nullable?\n", "  @CheckReturnValue\n", "  public final E get(int position) {\n", "    return Iterables.get(iterable, position);\n", "  }\n", "\n", "  /**\n", "   * Function that transforms {@code Iterable<E>} into a fluent iterable.\n", "   */\n", "  private static class FromIterableFunction<E> implements Function<Iterable<E>, FluentIterable<E>> {\n", "    @Override\n", "    public FluentIterable<E> apply(Iterable<E> fromObject) {\n", "      return FluentIterable.from(fromObject);\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721]}}, {"20": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/GenericMapMaker.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2010 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " *      http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS-IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "\n", "import java.util.concurrent.ConcurrentMap;\n", "import java.util.concurrent.TimeUnit;\n", "\n", "/**\n", " * A class exactly like {@link MapMaker}, except restricted in the types of maps it can build.\n", " * For the most part, you should probably just ignore the existence of this class.\n", " *\n", " * @param <K0> the base type for all key types of maps built by this map maker\n", " * @param <V0> the base type for all value types of maps built by this map maker\n", " * @author Kevin Bourrillion\n", " * @since 7.0\n", " * @deprecated This class existed only to support the generic paramterization necessary for the\n", " *     caching functionality in {@code MapMaker}. That functionality has been moved to {@link\n", " *     com.google.common.cache.CacheBuilder}, which is a properly generified class and thus needs no\n", " *     \"Generic\" equivalent; simple use {@code CacheBuilder} naturally. For general migration\n", " *     instructions, see the <a\n", " *     href=\"https://github.com/google/guava/wiki/MapMakerMigration\">MapMaker Migration\n", " *     Guide</a>.\n", " */\n", "@Beta\n", "@Deprecated\n", "@GwtCompatible(emulated = true)\n", "abstract class GenericMapMaker<K0, V0> {\n", "\n", "  // Set by MapMaker, but sits in this class to preserve the type relationship\n", "\n", "  // No subclasses but our own\n", "  GenericMapMaker() {}\n", "\n", "  /**\n", "   * See {@link MapMaker#initialCapacity}.\n", "   */\n", "  public abstract GenericMapMaker<K0, V0> initialCapacity(int initialCapacity);\n", "\n", "  /**\n", "   * See {@link MapMaker#maximumSize}.\n", "   */\n", "  abstract GenericMapMaker<K0, V0> maximumSize(int maximumSize);\n", "\n", "  /**\n", "   * See {@link MapMaker#concurrencyLevel}.\n", "   */\n", "  public abstract GenericMapMaker<K0, V0> concurrencyLevel(int concurrencyLevel);\n", "\n", "  /**\n", "   * See {@link MapMaker#expireAfterWrite}.\n", "   */\n", "  abstract GenericMapMaker<K0, V0> expireAfterWrite(long duration, TimeUnit unit);\n", "\n", "  /*\n", "   * Note that MapMaker's removalListener() is not here, because once you're interacting with a\n", "   * GenericMapMaker you've already called that, and shouldn't be calling it again.\n", "   */\n", "\n", "  /**\n", "   * See {@link MapMaker#makeMap}.\n", "   */\n", "  public abstract <K extends K0, V extends V0> ConcurrentMap<K, V> makeMap();\n", "\n", "  /**\n", "   * See {@link MapMaker#makeComputingMap}.\n", "   */\n", "  @Deprecated\n", "  abstract <K extends K0, V extends V0> ConcurrentMap<K, V> makeComputingMap(\n", "      Function<? super K, ? extends V> computingFunction);\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88]}}, {"21": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/HashMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "import com.google.common.base.Preconditions;\n", "\n", "import java.util.Collection;\n", "import java.util.HashMap;\n", "import java.util.Set;\n", "\n", "/**\n", " * Implementation of {@link Multimap} using hash tables.\n", " *\n", " * <p>The multimap does not store duplicate key-value pairs. Adding a new\n", " * key-value pair equal to an existing key-value pair has no effect.\n", " *\n", " * <p>Keys and values may be null. All optional multimap methods are supported,\n", " * and all returned views are modifiable.\n", " *\n", " * <p>This class is not threadsafe when any concurrent operations update the\n", " * multimap. Concurrent read operations will work correctly. To allow concurrent\n", " * update operations, wrap your multimap with a call to {@link\n", " * Multimaps#synchronizedSetMultimap}.\n", " *\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "public final class HashMultimap<K, V> extends AbstractSetMultimap<K, V> {\n", "  private static final int DEFAULT_VALUES_PER_KEY = 2;\n", "\n", "  @VisibleForTesting transient int expectedValuesPerKey = DEFAULT_VALUES_PER_KEY;\n", "\n", "  /**\n", "   * Creates a new, empty {@code HashMultimap} with the default initial\n", "   * capacities.\n", "   */\n", "  public static <K, V> HashMultimap<K, V> create() {\n", "    return new HashMultimap<K, V>();\n", "  }\n", "\n", "  /**\n", "   * Constructs an empty {@code HashMultimap} with enough capacity to hold the\n", "   * specified numbers of keys and values without rehashing.\n", "   *\n", "   * @param expectedKeys the expected number of distinct keys\n", "   * @param expectedValuesPerKey the expected average number of values per key\n", "   * @throws IllegalArgumentException if {@code expectedKeys} or {@code\n", "   *      expectedValuesPerKey} is negative\n", "   */\n", "  public static <K, V> HashMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {\n", "    return new HashMultimap<K, V>(expectedKeys, expectedValuesPerKey);\n", "  }\n", "\n", "  /**\n", "   * Constructs a {@code HashMultimap} with the same mappings as the specified\n", "   * multimap. If a key-value mapping appears multiple times in the input\n", "   * multimap, it only appears once in the constructed multimap.\n", "   *\n", "   * @param multimap the multimap whose contents are copied to this multimap\n", "   */\n", "  public static <K, V> HashMultimap<K, V> create(Multimap<? extends K, ? extends V> multimap) {\n", "    return new HashMultimap<K, V>(multimap);\n", "  }\n", "\n", "  private HashMultimap() {\n", "    super(new HashMap<K, Collection<V>>());\n", "  }\n", "\n", "  private HashMultimap(int expectedKeys, int expectedValuesPerKey) {\n", "    super(Maps.<K, Collection<V>>newHashMapWithExpectedSize(expectedKeys));\n", "    Preconditions.checkArgument(expectedValuesPerKey >= 0);\n", "    this.expectedValuesPerKey = expectedValuesPerKey;\n", "  }\n", "\n", "  private HashMultimap(Multimap<? extends K, ? extends V> multimap) {\n", "    super(Maps.<K, Collection<V>>newHashMapWithExpectedSize(multimap.keySet().size()));\n", "    putAll(multimap);\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>Creates an empty {@code HashSet} for a collection of values for one key.\n", "   *\n", "   * @return a new {@code HashSet} containing a collection of values for one key\n", "   */\n", "  @Override\n", "  Set<V> createCollection() {\n", "    return Sets.<V>newHashSetWithExpectedSize(expectedValuesPerKey);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109]}}, {"22": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/HashMultiset.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.HashMap;\n", "\n", "/**\n", " * Multiset implementation backed by a {@link HashMap}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "public final class HashMultiset<E> extends AbstractMapBasedMultiset<E> {\n", "\n", "  /**\n", "   * Creates a new, empty {@code HashMultiset} using the default initial\n", "   * capacity.\n", "   */\n", "  public static <E> HashMultiset<E> create() {\n", "    return new HashMultiset<E>();\n", "  }\n", "\n", "  /**\n", "   * Creates a new, empty {@code HashMultiset} with the specified expected\n", "   * number of distinct elements.\n", "   *\n", "   * @param distinctElements the expected number of distinct elements\n", "   * @throws IllegalArgumentException if {@code distinctElements} is negative\n", "   */\n", "  public static <E> HashMultiset<E> create(int distinctElements) {\n", "    return new HashMultiset<E>(distinctElements);\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code HashMultiset} containing the specified elements.\n", "   *\n", "   * <p>This implementation is highly efficient when {@code elements} is itself\n", "   * a {@link Multiset}.\n", "   *\n", "   * @param elements the elements that the multiset should contain\n", "   */\n", "  public static <E> HashMultiset<E> create(Iterable<? extends E> elements) {\n", "    HashMultiset<E> multiset = create(Multisets.inferDistinctElements(elements));\n", "    Iterables.addAll(multiset, elements);\n", "    return multiset;\n", "  }\n", "\n", "  private HashMultiset() {\n", "    super(new HashMap<E, Count>());\n", "  }\n", "\n", "  private HashMultiset(int distinctElements) {\n", "    super(Maps.<E, Count>newHashMapWithExpectedSize(distinctElements));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74]}}, {"23": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableAsList.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "/**\n", " * List returned by {@link ImmutableCollection#asList} that delegates {@code contains} checks\n", " * to the backing collection.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "@SuppressWarnings(\"serial\")\n", "abstract class ImmutableAsList<E> extends ImmutableList<E> {\n", "  abstract ImmutableCollection<E> delegateCollection();\n", "\n", "  @Override\n", "  public boolean contains(Object target) {\n", "    // The collection's contains() is at least as fast as ImmutableList's\n", "    // and is often faster.\n", "    return delegateCollection().contains(target);\n", "  }\n", "\n", "  @Override\n", "  public int size() {\n", "    return delegateCollection().size();\n", "  }\n", "\n", "  @Override\n", "  public boolean isEmpty() {\n", "    return delegateCollection().isEmpty();\n", "  }\n", "\n", "  @Override\n", "  boolean isPartialView() {\n", "    return delegateCollection().isPartialView();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55]}}, {"24": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableListMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.Collection;\n", "import java.util.Comparator;\n", "import java.util.Map.Entry;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A {@link ListMultimap} whose contents will never change, with many other important properties\n", " * detailed at {@link ImmutableCollection}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\">\n", " * immutable collections</a>.\n", " *\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>\n", "    implements ListMultimap<K, V> {\n", "\n", "  /** Returns the empty multimap. */\n", "  // Casting is safe because the multimap will never hold any elements.\n", "  @SuppressWarnings(\"unchecked\")\n", "  public static <K, V> ImmutableListMultimap<K, V> of() {\n", "    return (ImmutableListMultimap<K, V>) EmptyImmutableListMultimap.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing a single entry.\n", "   */\n", "  public static <K, V> ImmutableListMultimap<K, V> of(K k1, V v1) {\n", "    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n", "    builder.put(k1, v1);\n", "    return builder.build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   */\n", "  public static <K, V> ImmutableListMultimap<K, V> of(K k1, V v1, K k2, V v2) {\n", "    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n", "    builder.put(k1, v1);\n", "    builder.put(k2, v2);\n", "    return builder.build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   */\n", "  public static <K, V> ImmutableListMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {\n", "    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n", "    builder.put(k1, v1);\n", "    builder.put(k2, v2);\n", "    builder.put(k3, v3);\n", "    return builder.build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   */\n", "  public static <K, V> ImmutableListMultimap<K, V> of(\n", "      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {\n", "    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n", "    builder.put(k1, v1);\n", "    builder.put(k2, v2);\n", "    builder.put(k3, v3);\n", "    builder.put(k4, v4);\n", "    return builder.build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   */\n", "  public static <K, V> ImmutableListMultimap<K, V> of(\n", "      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {\n", "    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n", "    builder.put(k1, v1);\n", "    builder.put(k2, v2);\n", "    builder.put(k3, v3);\n", "    builder.put(k4, v4);\n", "    builder.put(k5, v5);\n", "    return builder.build();\n", "  }\n", "\n", "  // looking for of() with > 5 entries? Use the builder instead.\n", "\n", "  /**\n", "   * Returns a new builder. The generated builder is equivalent to the builder\n", "   * created by the {@link Builder} constructor.\n", "   */\n", "  public static <K, V> Builder<K, V> builder() {\n", "    return new Builder<K, V>();\n", "  }\n", "\n", "  /**\n", "   * A builder for creating immutable {@code ListMultimap} instances, especially\n", "   * {@code public static final} multimaps (\"constant multimaps\"). Example:\n", "   * <pre>   {@code\n", "   *\n", "   *   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =\n", "   *       new ImmutableListMultimap.Builder<String, Integer>()\n", "   *           .put(\"one\", 1)\n", "   *           .putAll(\"several\", 1, 2, 3)\n", "   *           .putAll(\"many\", 1, 2, 3, 4, 5)\n", "   *           .build();}</pre>\n", "   *\n", "   * <p>Builder instances can be reused; it is safe to call {@link #build} multiple\n", "   * times to build multiple multimaps in series. Each multimap contains the\n", "   * key-value mappings in the previously created multimaps.\n", "   *\n", "   * @since 2.0\n", "   */\n", "  public static final class Builder<K, V> extends ImmutableMultimap.Builder<K, V> {\n", "    /**\n", "     * Creates a new builder. The returned builder is equivalent to the builder\n", "     * generated by {@link ImmutableListMultimap#builder}.\n", "     */\n", "    public Builder() {}\n", "\n", "    @Override\n", "    public Builder<K, V> put(K key, V value) {\n", "      super.put(key, value);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     *\n", "     * @since 11.0\n", "     */\n", "    @Override\n", "    public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {\n", "      super.put(entry);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     *\n", "     * @since 19.0\n", "     */\n", "    @Beta\n", "    @Override\n", "    public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n", "      super.putAll(entries);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Builder<K, V> putAll(K key, Iterable<? extends V> values) {\n", "      super.putAll(key, values);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Builder<K, V> putAll(K key, V... values) {\n", "      super.putAll(key, values);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {\n", "      super.putAll(multimap);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     *\n", "     * @since 8.0\n", "     */\n", "    @Override\n", "    public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {\n", "      super.orderKeysBy(keyComparator);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     *\n", "     * @since 8.0\n", "     */\n", "    @Override\n", "    public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {\n", "      super.orderValuesBy(valueComparator);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Returns a newly-created immutable list multimap.\n", "     */\n", "    @Override\n", "    public ImmutableListMultimap<K, V> build() {\n", "      return (ImmutableListMultimap<K, V>) super.build();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the same mappings as {@code\n", "   * multimap}. The generated multimap's key and value orderings correspond to\n", "   * the iteration ordering of the {@code multimap.asMap()} view.\n", "   *\n", "   * <p>Despite the method name, this method attempts to avoid actually copying\n", "   * the data when it is safe to do so. The exact circumstances under which a\n", "   * copy will or will not be performed are undocumented and subject to change.\n", "   *\n", "   * @throws NullPointerException if any key or value in {@code multimap} is\n", "   *         null\n", "   */\n", "  public static <K, V> ImmutableListMultimap<K, V> copyOf(\n", "      Multimap<? extends K, ? extends V> multimap) {\n", "    if (multimap.isEmpty()) {\n", "      return of();\n", "    }\n", "\n", "    // TODO(lowasser): copy ImmutableSetMultimap by using asList() on the sets\n", "    if (multimap instanceof ImmutableListMultimap) {\n", "      @SuppressWarnings(\"unchecked\") // safe since multimap is not writable\n", "      ImmutableListMultimap<K, V> kvMultimap = (ImmutableListMultimap<K, V>) multimap;\n", "      if (!kvMultimap.isPartialView()) {\n", "        return kvMultimap;\n", "      }\n", "    }\n", "\n", "    ImmutableMap.Builder<K, ImmutableList<V>> builder =\n", "        new ImmutableMap.Builder<K, ImmutableList<V>>(multimap.asMap().size());\n", "    int size = 0;\n", "\n", "    for (Entry<? extends K, ? extends Collection<? extends V>> entry :\n", "        multimap.asMap().entrySet()) {\n", "      ImmutableList<V> list = ImmutableList.copyOf(entry.getValue());\n", "      if (!list.isEmpty()) {\n", "        builder.put(entry.getKey(), list);\n", "        size += list.size();\n", "      }\n", "    }\n", "\n", "    return new ImmutableListMultimap<K, V>(builder.build(), size);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the specified entries.  The\n", "   * returned multimap iterates over keys in the order they were first\n", "   * encountered in the input, and the values for each key are iterated in the\n", "   * order they were encountered.\n", "   *\n", "   * @throws NullPointerException if any key, value, or entry is null\n", "   * @since 19.0\n", "   */\n", "  @Beta\n", "  public static <K, V> ImmutableListMultimap<K, V> copyOf(\n", "      Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n", "    return new Builder<K, V>().putAll(entries).build();\n", "  }\n", "\n", "  ImmutableListMultimap(ImmutableMap<K, ImmutableList<V>> map, int size) {\n", "    super(map, size);\n", "  }\n", "\n", "  // views\n", "\n", "  /**\n", "   * Returns an immutable list of the values for the given key.  If no mappings\n", "   * in the multimap have the provided key, an empty immutable list is\n", "   * returned. The values are in the same order as the parameters used to build\n", "   * this multimap.\n", "   */\n", "  @Override\n", "  public ImmutableList<V> get(@Nullable K key) {\n", "    // This cast is safe as its type is known in constructor.\n", "    ImmutableList<V> list = (ImmutableList<V>) map.get(key);\n", "    return (list == null) ? ImmutableList.<V>of() : list;\n", "  }\n", "\n", "  private transient ImmutableListMultimap<V, K> inverse;\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>Because an inverse of a list multimap can contain multiple pairs with\n", "   * the same key and value, this method returns an {@code\n", "   * ImmutableListMultimap} rather than the {@code ImmutableMultimap} specified\n", "   * in the {@code ImmutableMultimap} class.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @Override\n", "  public ImmutableListMultimap<V, K> inverse() {\n", "    ImmutableListMultimap<V, K> result = inverse;\n", "    return (result == null) ? (inverse = invert()) : result;\n", "  }\n", "\n", "  private ImmutableListMultimap<V, K> invert() {\n", "    Builder<V, K> builder = builder();\n", "    for (Entry<K, V> entry : entries()) {\n", "      builder.put(entry.getValue(), entry.getKey());\n", "    }\n", "    ImmutableListMultimap<V, K> invertedMultimap = builder.build();\n", "    invertedMultimap.inverse = this;\n", "    return invertedMultimap;\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public ImmutableList<V> removeAll(Object key) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public ImmutableList<V> replaceValues(K key, Iterable<? extends V> values) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348]}}, {"25": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMapEntrySet.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.j2objc.annotations.Weak;\n", "\n", "import java.util.Map.Entry;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * {@code entrySet()} implementation for {@link ImmutableMap}.\n", " *\n", " * @author Jesse Wilson\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet<Entry<K, V>> {\n", "  static final class RegularEntrySet<K, V> extends ImmutableMapEntrySet<K, V> {\n", "    @Weak private final transient ImmutableMap<K, V> map;\n", "    private final transient Entry<K, V>[] entries;\n", "\n", "    RegularEntrySet(ImmutableMap<K, V> map, Entry<K, V>[] entries) {\n", "      this.map = map;\n", "      this.entries = entries;\n", "    }\n", "\n", "    @Override\n", "    ImmutableMap<K, V> map() {\n", "      return map;\n", "    }\n", "\n", "    @Override\n", "    public UnmodifiableIterator<Entry<K, V>> iterator() {\n", "      return asList().iterator();\n", "    }\n", "\n", "    @Override\n", "    ImmutableList<Entry<K, V>> createAsList() {\n", "      return new RegularImmutableAsList<Entry<K, V>>(this, entries);\n", "    }\n", "  }\n", "\n", "  ImmutableMapEntrySet() {}\n", "\n", "  abstract ImmutableMap<K, V> map();\n", "\n", "  @Override\n", "  public int size() {\n", "    return map().size();\n", "  }\n", "\n", "  @Override\n", "  public boolean contains(@Nullable Object object) {\n", "    if (object instanceof Entry) {\n", "      Entry<?, ?> entry = (Entry<?, ?>) object;\n", "      V value = map().get(entry.getKey());\n", "      return value != null && value.equals(entry.getValue());\n", "    }\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  boolean isPartialView() {\n", "    return map().isPartialView();\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return map().hashCode();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88]}}, {"26": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMapKeySet.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.j2objc.annotations.Weak;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * {@code keySet()} implementation for {@link ImmutableMap}.\n", " *\n", " * @author Jesse Wilson\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "final class ImmutableMapKeySet<K, V> extends ImmutableSet.Indexed<K> {\n", "  @Weak private final ImmutableMap<K, V> map;\n", "\n", "  ImmutableMapKeySet(ImmutableMap<K, V> map) {\n", "    this.map = map;\n", "  }\n", "\n", "  @Override\n", "  public int size() {\n", "    return map.size();\n", "  }\n", "\n", "  @Override\n", "  public UnmodifiableIterator<K> iterator() {\n", "    return map.keyIterator();\n", "  }\n", "\n", "  @Override\n", "  public boolean contains(@Nullable Object object) {\n", "    return map.containsKey(object);\n", "  }\n", "\n", "  @Override\n", "  K get(int index) {\n", "    return map.entrySet().asList().get(index).getKey();\n", "  }\n", "\n", "  @Override\n", "  boolean isPartialView() {\n", "    return true;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]}}, {"27": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMapValues.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.j2objc.annotations.Weak;\n", "\n", "import java.util.Map.Entry;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * {@code values()} implementation for {@link ImmutableMap}.\n", " *\n", " * @author Jesse Wilson\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "final class ImmutableMapValues<K, V> extends ImmutableCollection<V> {\n", "  @Weak private final ImmutableMap<K, V> map;\n", "\n", "  ImmutableMapValues(ImmutableMap<K, V> map) {\n", "    this.map = map;\n", "  }\n", "\n", "  @Override\n", "  public int size() {\n", "    return map.size();\n", "  }\n", "\n", "  @Override\n", "  public UnmodifiableIterator<V> iterator() {\n", "    return new UnmodifiableIterator<V>() {\n", "      final UnmodifiableIterator<Entry<K, V>> entryItr = map.entrySet().iterator();\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return entryItr.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public V next() {\n", "        return entryItr.next().getValue();\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  public boolean contains(@Nullable Object object) {\n", "    return object != null && Iterators.contains(iterator(), object);\n", "  }\n", "\n", "  @Override\n", "  boolean isPartialView() {\n", "    return true;\n", "  }\n", "\n", "  @Override\n", "  ImmutableList<V> createAsList() {\n", "    final ImmutableList<Entry<K, V>> entryList = map.entrySet().asList();\n", "    return new ImmutableAsList<V>() {\n", "      @Override\n", "      public V get(int index) {\n", "        return entryList.get(index).getValue();\n", "      }\n", "\n", "      @Override\n", "      ImmutableCollection<V> delegateCollection() {\n", "        return ImmutableMapValues.this;\n", "      }\n", "    };\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88]}}, {"28": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.j2objc.annotations.Weak;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.io.Serializable;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A {@link Multimap} whose contents will never change, with many other important properties\n", " * detailed at {@link ImmutableCollection}.\n", " *\n", " * <p><b>Warning:</b> avoid <i>direct</i> usage of {@link ImmutableMultimap} as a type (as with\n", " * {@link Multimap} itself). Prefer subtypes such as {@link ImmutableSetMultimap} or {@link\n", " * ImmutableListMultimap}, which have well-defined {@link #equals} semantics, thus avoiding a common\n", " * source of bugs and confusion.\n", " *\n", " * <p><b>Note:</b> every {@link ImmutableMultimap} offers an {@link #inverse} view, so there is no\n", " * need for a distinct {@code ImmutableBiMultimap} type.\n", " *\n", " * <a name=\"iteration\"></a>\n", " * <p><b>Key-grouped iteration.</b> All view collections follow the same iteration order. In all\n", " * current implementations, the iteration order always keeps multiple entries with the same key\n", " * together. Any creation method that would customarily respect insertion order (such as {@link\n", " * #copyOf(Multimap)}) instead preserves key-grouped order by inserting entries for an existing key\n", " * immediately after the last entry having that key.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\">\n", " * immutable collections</a>.\n", " *\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>\n", "    implements Serializable {\n", "\n", "  /** Returns an empty multimap. */\n", "  public static <K, V> ImmutableMultimap<K, V> of() {\n", "    return ImmutableListMultimap.of();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing a single entry.\n", "   */\n", "  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1) {\n", "    return ImmutableListMultimap.of(k1, v1);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   */\n", "  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {\n", "    return ImmutableListMultimap.of(k1, v1, k2, v2);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in the\n", "   * \"key-grouped\" insertion order described in the\n", "   * <a href=\"#iteration\">class documentation</a>.\n", "   */\n", "  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {\n", "    return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in the\n", "   * \"key-grouped\" insertion order described in the\n", "   * <a href=\"#iteration\">class documentation</a>.\n", "   */\n", "  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {\n", "    return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in the\n", "   * \"key-grouped\" insertion order described in the\n", "   * <a href=\"#iteration\">class documentation</a>.\n", "   */\n", "  public static <K, V> ImmutableMultimap<K, V> of(\n", "      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {\n", "    return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5);\n", "  }\n", "\n", "  // looking for of() with > 5 entries? Use the builder instead.\n", "\n", "  /**\n", "   * Returns a new builder. The generated builder is equivalent to the builder\n", "   * created by the {@link Builder} constructor.\n", "   */\n", "  public static <K, V> Builder<K, V> builder() {\n", "    return new Builder<K, V>();\n", "  }\n", "\n", "  /**\n", "   * A builder for creating immutable multimap instances, especially\n", "   * {@code public static final} multimaps (\"constant multimaps\"). Example:\n", "   * <pre>   {@code\n", "   *\n", "   *   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =\n", "   *       new ImmutableMultimap.Builder<String, Integer>()\n", "   *           .put(\"one\", 1)\n", "   *           .putAll(\"several\", 1, 2, 3)\n", "   *           .putAll(\"many\", 1, 2, 3, 4, 5)\n", "   *           .build();}</pre>\n", "   *\n", "   * <p>Builder instances can be reused; it is safe to call {@link #build} multiple\n", "   * times to build multiple multimaps in series. Each multimap contains the\n", "   * key-value mappings in the previously created multimaps.\n", "   *\n", "   * @since 2.0\n", "   */\n", "  public static class Builder<K, V> {\n", "    Multimap<K, V> builderMultimap;\n", "    Comparator<? super K> keyComparator;\n", "    Comparator<? super V> valueComparator;\n", "\n", "    /**\n", "     * Creates a new builder. The returned builder is equivalent to the builder\n", "     * generated by {@link ImmutableMultimap#builder}.\n", "     */\n", "    public Builder() {\n", "      this(MultimapBuilder.linkedHashKeys().arrayListValues().<K, V>build());\n", "    }\n", "    \n", "    Builder(Multimap<K, V> builderMultimap) {\n", "      this.builderMultimap = builderMultimap;\n", "    }\n", "\n", "    /**\n", "     * Adds a key-value mapping to the built multimap.\n", "     */\n", "    public Builder<K, V> put(K key, V value) {\n", "      checkEntryNotNull(key, value);\n", "      builderMultimap.put(key, value);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds an entry to the built multimap.\n", "     *\n", "     * @since 11.0\n", "     */\n", "    public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {\n", "      return put(entry.getKey(), entry.getValue());\n", "    }\n", "\n", "    /**\n", "     * Adds entries to the built multimap.\n", "     *\n", "     * @since 19.0\n", "     */\n", "    @Beta\n", "    public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n", "      for (Entry<? extends K, ? extends V> entry : entries) {\n", "        put(entry);\n", "      }\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Stores a collection of values with the same key in the built multimap.\n", "     *\n", "     * @throws NullPointerException if {@code key}, {@code values}, or any\n", "     *     element in {@code values} is null. The builder is left in an invalid\n", "     *     state.\n", "     */\n", "    public Builder<K, V> putAll(K key, Iterable<? extends V> values) {\n", "      if (key == null) {\n", "        throw new NullPointerException(\"null key in entry: null=\" + Iterables.toString(values));\n", "      }\n", "      Collection<V> valueList = builderMultimap.get(key);\n", "      for (V value : values) {\n", "        checkEntryNotNull(key, value);\n", "        valueList.add(value);\n", "      }\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Stores an array of values with the same key in the built multimap.\n", "     *\n", "     * @throws NullPointerException if the key or any value is null. The builder\n", "     *     is left in an invalid state.\n", "     */\n", "    public Builder<K, V> putAll(K key, V... values) {\n", "      return putAll(key, Arrays.asList(values));\n", "    }\n", "\n", "    /**\n", "     * Stores another multimap's entries in the built multimap. The generated\n", "     * multimap's key and value orderings correspond to the iteration ordering\n", "     * of the {@code multimap.asMap()} view, with new keys and values following\n", "     * any existing keys and values.\n", "     *\n", "     * @throws NullPointerException if any key or value in {@code multimap} is\n", "     *     null. The builder is left in an invalid state.\n", "     */\n", "    public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {\n", "      for (Entry<? extends K, ? extends Collection<? extends V>> entry :\n", "          multimap.asMap().entrySet()) {\n", "        putAll(entry.getKey(), entry.getValue());\n", "      }\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Specifies the ordering of the generated multimap's keys.\n", "     *\n", "     * @since 8.0\n", "     */\n", "    public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {\n", "      this.keyComparator = checkNotNull(keyComparator);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Specifies the ordering of the generated multimap's values for each key.\n", "     *\n", "     * @since 8.0\n", "     */\n", "    public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {\n", "      this.valueComparator = checkNotNull(valueComparator);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Returns a newly-created immutable multimap.\n", "     */\n", "    public ImmutableMultimap<K, V> build() {\n", "      if (valueComparator != null) {\n", "        for (Collection<V> values : builderMultimap.asMap().values()) {\n", "          List<V> list = (List<V>) values;\n", "          Collections.sort(list, valueComparator);\n", "        }\n", "      }\n", "      if (keyComparator != null) {\n", "        Multimap<K, V> sortedCopy =\n", "            MultimapBuilder.linkedHashKeys().arrayListValues().<K, V>build();\n", "        List<Map.Entry<K, Collection<V>>> entries =\n", "            Ordering.from(keyComparator)\n", "                .<K>onKeys()\n", "                .immutableSortedCopy(builderMultimap.asMap().entrySet());\n", "        for (Map.Entry<K, Collection<V>> entry : entries) {\n", "          sortedCopy.putAll(entry.getKey(), entry.getValue());\n", "        }\n", "        builderMultimap = sortedCopy;\n", "      }\n", "      return copyOf(builderMultimap);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the same mappings as {@code\n", "   * multimap}, in the \"key-grouped\" iteration order described in the class\n", "   * documentation.\n", "   *\n", "   * <p>Despite the method name, this method attempts to avoid actually copying\n", "   * the data when it is safe to do so. The exact circumstances under which a\n", "   * copy will or will not be performed are undocumented and subject to change.\n", "   *\n", "   * @throws NullPointerException if any key or value in {@code multimap} is\n", "   *         null\n", "   */\n", "  public static <K, V> ImmutableMultimap<K, V> copyOf(Multimap<? extends K, ? extends V> multimap) {\n", "    if (multimap instanceof ImmutableMultimap) {\n", "      @SuppressWarnings(\"unchecked\") // safe since multimap is not writable\n", "      ImmutableMultimap<K, V> kvMultimap = (ImmutableMultimap<K, V>) multimap;\n", "      if (!kvMultimap.isPartialView()) {\n", "        return kvMultimap;\n", "      }\n", "    }\n", "    return ImmutableListMultimap.copyOf(multimap);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the specified entries.  The\n", "   * returned multimap iterates over keys in the order they were first\n", "   * encountered in the input, and the values for each key are iterated in the\n", "   * order they were encountered.\n", "   *\n", "   * @throws NullPointerException if any key, value, or entry is null\n", "   * @since 19.0\n", "   */\n", "  @Beta\n", "  public static <K, V> ImmutableMultimap<K, V> copyOf(\n", "      Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n", "    return ImmutableListMultimap.copyOf(entries);\n", "  }\n", "\n", "  final transient ImmutableMap<K, ? extends ImmutableCollection<V>> map;\n", "  final transient int size;\n", "\n", "  // These constants allow the deserialization code to set final fields. This\n", "  // holder class makes sure they are not initialized unless an instance is\n", "  // deserialized.\n", "\n", "  ImmutableMultimap(ImmutableMap<K, ? extends ImmutableCollection<V>> map, int size) {\n", "    this.map = map;\n", "    this.size = size;\n", "  }\n", "\n", "  // mutators (not supported)\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public ImmutableCollection<V> removeAll(Object key) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public ImmutableCollection<V> replaceValues(K key, Iterable<? extends V> values) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public void clear() {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable collection of the values for the given key.  If no\n", "   * mappings in the multimap have the provided key, an empty immutable\n", "   * collection is returned. The values are in the same order as the parameters\n", "   * used to build this multimap.\n", "   */\n", "  @Override\n", "  public abstract ImmutableCollection<V> get(K key);\n", "\n", "  /**\n", "   * Returns an immutable multimap which is the inverse of this one. For every\n", "   * key-value mapping in the original, the result will have a mapping with\n", "   * key and value reversed.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  public abstract ImmutableMultimap<V, K> inverse();\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public boolean put(K key, V value) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public boolean putAll(K key, Iterable<? extends V> values) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public boolean putAll(Multimap<? extends K, ? extends V> multimap) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public boolean remove(Object key, Object value) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if this immutable multimap's implementation contains references to\n", "   * user-created objects that aren't accessible via this multimap's methods. This is generally\n", "   * used to determine whether {@code copyOf} implementations should make an explicit copy to avoid\n", "   * memory leaks.\n", "   */\n", "  boolean isPartialView() {\n", "    return map.isPartialView();\n", "  }\n", "\n", "  // accessors\n", "\n", "  @Override\n", "  public boolean containsKey(@Nullable Object key) {\n", "    return map.containsKey(key);\n", "  }\n", "\n", "  @Override\n", "  public boolean containsValue(@Nullable Object value) {\n", "    return value != null && super.containsValue(value);\n", "  }\n", "\n", "  @Override\n", "  public int size() {\n", "    return size;\n", "  }\n", "\n", "  // views\n", "\n", "  /**\n", "   * Returns an immutable set of the distinct keys in this multimap, in the same\n", "   * order as they appear in this multimap.\n", "   */\n", "  @Override\n", "  public ImmutableSet<K> keySet() {\n", "    return map.keySet();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable map that associates each key with its corresponding\n", "   * values in the multimap. Keys and values appear in the same order as in this\n", "   * multimap.\n", "   */\n", "  @Override\n", "  @SuppressWarnings(\"unchecked\") // a widening cast\n", "  public ImmutableMap<K, Collection<V>> asMap() {\n", "    return (ImmutableMap) map;\n", "  }\n", "\n", "  @Override\n", "  Map<K, Collection<V>> createAsMap() {\n", "    throw new AssertionError(\"should never be called\");\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable collection of all key-value pairs in the multimap.\n", "   */\n", "  @Override\n", "  public ImmutableCollection<Entry<K, V>> entries() {\n", "    return (ImmutableCollection<Entry<K, V>>) super.entries();\n", "  }\n", "\n", "  @Override\n", "  ImmutableCollection<Entry<K, V>> createEntries() {\n", "    return new EntryCollection<K, V>(this);\n", "  }\n", "\n", "  private static class EntryCollection<K, V> extends ImmutableCollection<Entry<K, V>> {\n", "    @Weak final ImmutableMultimap<K, V> multimap;\n", "\n", "    EntryCollection(ImmutableMultimap<K, V> multimap) {\n", "      this.multimap = multimap;\n", "    }\n", "\n", "    @Override\n", "    public UnmodifiableIterator<Entry<K, V>> iterator() {\n", "      return multimap.entryIterator();\n", "    }\n", "\n", "    @Override\n", "    boolean isPartialView() {\n", "      return multimap.isPartialView();\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return multimap.size();\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object object) {\n", "      if (object instanceof Entry) {\n", "        Entry<?, ?> entry = (Entry<?, ?>) object;\n", "        return multimap.containsEntry(entry.getKey(), entry.getValue());\n", "      }\n", "      return false;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private abstract class Itr<T> extends UnmodifiableIterator<T> {\n", "    final Iterator<Entry<K, Collection<V>>> mapIterator = asMap().entrySet().iterator();\n", "    K key = null;\n", "    Iterator<V> valueIterator = Iterators.emptyIterator();\n", "\n", "    abstract T output(K key, V value);\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return mapIterator.hasNext() || valueIterator.hasNext();\n", "    }\n", "\n", "    @Override\n", "    public T next() {\n", "      if (!valueIterator.hasNext()) {\n", "        Entry<K, Collection<V>> mapEntry = mapIterator.next();\n", "        key = mapEntry.getKey();\n", "        valueIterator = mapEntry.getValue().iterator();\n", "      }\n", "      return output(key, valueIterator.next());\n", "    }\n", "  }\n", "\n", "  @Override\n", "  UnmodifiableIterator<Entry<K, V>> entryIterator() {\n", "    return new Itr<Entry<K, V>>() {\n", "      @Override\n", "      Entry<K, V> output(K key, V value) {\n", "        return Maps.immutableEntry(key, value);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing all the keys in this multimap, in\n", "   * the same order and with the same frequencies as they appear in this\n", "   * multimap; to get only a single occurrence of each key, use {@link #keySet}.\n", "   */\n", "  @Override\n", "  public ImmutableMultiset<K> keys() {\n", "    return (ImmutableMultiset<K>) super.keys();\n", "  }\n", "\n", "  @Override\n", "  ImmutableMultiset<K> createKeys() {\n", "    return new Keys();\n", "  }\n", "\n", "  @SuppressWarnings(\"serial\") // Uses writeReplace, not default serialization\n", "  @WeakOuter\n", "  class Keys extends ImmutableMultiset<K> {\n", "    @Override\n", "    public boolean contains(@Nullable Object object) {\n", "      return containsKey(object);\n", "    }\n", "\n", "    @Override\n", "    public int count(@Nullable Object element) {\n", "      Collection<V> values = map.get(element);\n", "      return (values == null) ? 0 : values.size();\n", "    }\n", "\n", "    @Override\n", "    public Set<K> elementSet() {\n", "      return keySet();\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return ImmutableMultimap.this.size();\n", "    }\n", "\n", "    @Override\n", "    Multiset.Entry<K> getEntry(int index) {\n", "      Map.Entry<K, ? extends Collection<V>> entry = map.entrySet().asList().get(index);\n", "      return Multisets.immutableEntry(entry.getKey(), entry.getValue().size());\n", "    }\n", "\n", "    @Override\n", "    boolean isPartialView() {\n", "      return true;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable collection of the values in this multimap. Its\n", "   * iterator traverses the values for the first key, the values for the second\n", "   * key, and so on.\n", "   */\n", "  @Override\n", "  public ImmutableCollection<V> values() {\n", "    return (ImmutableCollection<V>) super.values();\n", "  }\n", "\n", "  @Override\n", "  ImmutableCollection<V> createValues() {\n", "    return new Values<K, V>(this);\n", "  }\n", "\n", "  @Override\n", "  UnmodifiableIterator<V> valueIterator() {\n", "    return new Itr<V>() {\n", "      @Override\n", "      V output(K key, V value) {\n", "        return value;\n", "      }\n", "    };\n", "  }\n", "\n", "  private static final class Values<K, V> extends ImmutableCollection<V> {\n", "    @Weak private final transient ImmutableMultimap<K, V> multimap;\n", "\n", "    Values(ImmutableMultimap<K, V> multimap) {\n", "      this.multimap = multimap;\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(@Nullable Object object) {\n", "      return multimap.containsValue(object);\n", "    }\n", "\n", "    @Override\n", "    public UnmodifiableIterator<V> iterator() {\n", "      return multimap.valueIterator();\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return multimap.size();\n", "    }\n", "\n", "    @Override\n", "    boolean isPartialView() {\n", "      return true;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static final long serialVersionUID = 0;\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681]}}, {"29": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMultiset.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Multiset.Entry;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.io.Serializable;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A {@link Multiset} whose contents will never change, with many other important properties\n", " * detailed at {@link ImmutableCollection}.\n", " *\n", " * <p><b>Grouped iteration.</b> In all current implementations, duplicate elements always appear\n", " * consecutively when iterating. Elements iterate in order by the <i>first</i> appearance of\n", " * that element when the multiset was created.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\">\n", " * immutable collections</a>.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "@SuppressWarnings(\"serial\") // we're overriding default serialization\n", "// TODO(lowasser): write an efficient asList() implementation\n", "public abstract class ImmutableMultiset<E> extends ImmutableCollection<E> implements Multiset<E> {\n", "  /**\n", "   * Returns the empty immutable multiset.\n", "   */\n", "  @SuppressWarnings(\"unchecked\") // all supported methods are covariant\n", "  public static <E> ImmutableMultiset<E> of() {\n", "    return (ImmutableMultiset<E>) RegularImmutableMultiset.EMPTY;\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing a single element.\n", "   *\n", "   * @throws NullPointerException if {@code element} is null\n", "   * @since 6.0 (source-compatible since 2.0)\n", "   */\n", "  @SuppressWarnings(\"unchecked\") // generic array created but never written\n", "  public static <E> ImmutableMultiset<E> of(E element) {\n", "    return copyFromElements(element);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing the given elements, in order.\n", "   *\n", "   * @throws NullPointerException if any element is null\n", "   * @since 6.0 (source-compatible since 2.0)\n", "   */\n", "  @SuppressWarnings(\"unchecked\") //\n", "  public static <E> ImmutableMultiset<E> of(E e1, E e2) {\n", "    return copyFromElements(e1, e2);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing the given elements, in the \"grouped iteration order\"\n", "   * described in the class documentation.\n", "   *\n", "   * @throws NullPointerException if any element is null\n", "   * @since 6.0 (source-compatible since 2.0)\n", "   */\n", "  @SuppressWarnings(\"unchecked\") //\n", "  public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3) {\n", "    return copyFromElements(e1, e2, e3);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing the given elements, in the \"grouped iteration order\"\n", "   * described in the class documentation.\n", "   *\n", "   * @throws NullPointerException if any element is null\n", "   * @since 6.0 (source-compatible since 2.0)\n", "   */\n", "  @SuppressWarnings(\"unchecked\") //\n", "  public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3, E e4) {\n", "    return copyFromElements(e1, e2, e3, e4);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing the given elements, in the \"grouped iteration order\"\n", "   * described in the class documentation.\n", "   *\n", "   * @throws NullPointerException if any element is null\n", "   * @since 6.0 (source-compatible since 2.0)\n", "   */\n", "  @SuppressWarnings(\"unchecked\") //\n", "  public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3, E e4, E e5) {\n", "    return copyFromElements(e1, e2, e3, e4, e5);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing the given elements, in the \"grouped iteration order\"\n", "   * described in the class documentation.\n", "   *\n", "   * @throws NullPointerException if any element is null\n", "   * @since 6.0 (source-compatible since 2.0)\n", "   */\n", "  @SuppressWarnings(\"unchecked\") //\n", "  public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... others) {\n", "    return new Builder<E>()\n", "        .add(e1)\n", "        .add(e2)\n", "        .add(e3)\n", "        .add(e4)\n", "        .add(e5)\n", "        .add(e6)\n", "        .add(others)\n", "        .build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing the given elements, in the \"grouped iteration order\"\n", "   * described in the class documentation.\n", "   *\n", "   * @throws NullPointerException if any of {@code elements} is null\n", "   * @since 6.0\n", "   */\n", "  public static <E> ImmutableMultiset<E> copyOf(E[] elements) {\n", "    return copyFromElements(elements);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing the given elements, in the \"grouped iteration order\"\n", "   * described in the class documentation.\n", "   *\n", "   * @throws NullPointerException if any of {@code elements} is null\n", "   */\n", "  public static <E> ImmutableMultiset<E> copyOf(Iterable<? extends E> elements) {\n", "    if (elements instanceof ImmutableMultiset) {\n", "      @SuppressWarnings(\"unchecked\") // all supported methods are covariant\n", "      ImmutableMultiset<E> result = (ImmutableMultiset<E>) elements;\n", "      if (!result.isPartialView()) {\n", "        return result;\n", "      }\n", "    }\n", "\n", "    Multiset<? extends E> multiset =\n", "        (elements instanceof Multiset)\n", "            ? Multisets.cast(elements)\n", "            : LinkedHashMultiset.create(elements);\n", "\n", "    return copyFromEntries(multiset.entrySet());\n", "  }\n", "\n", "  private static <E> ImmutableMultiset<E> copyFromElements(E... elements) {\n", "    Multiset<E> multiset = LinkedHashMultiset.create();\n", "    Collections.addAll(multiset, elements);\n", "    return copyFromEntries(multiset.entrySet());\n", "  }\n", "\n", "  static <E> ImmutableMultiset<E> copyFromEntries(\n", "      Collection<? extends Entry<? extends E>> entries) {\n", "    if (entries.isEmpty()) {\n", "      return of();\n", "    } else {\n", "      return new RegularImmutableMultiset<E>(entries);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multiset containing the given elements, in the \"grouped iteration order\"\n", "   * described in the class documentation.\n", "   *\n", "   * @throws NullPointerException if any of {@code elements} is null\n", "   */\n", "  public static <E> ImmutableMultiset<E> copyOf(Iterator<? extends E> elements) {\n", "    Multiset<E> multiset = LinkedHashMultiset.create();\n", "    Iterators.addAll(multiset, elements);\n", "    return copyFromEntries(multiset.entrySet());\n", "  }\n", "\n", "  ImmutableMultiset() {}\n", "\n", "  @Override\n", "  public UnmodifiableIterator<E> iterator() {\n", "    final Iterator<Entry<E>> entryIterator = entrySet().iterator();\n", "    return new UnmodifiableIterator<E>() {\n", "      int remaining;\n", "      E element;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return (remaining > 0) || entryIterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public E next() {\n", "        if (remaining <= 0) {\n", "          Entry<E> entry = entryIterator.next();\n", "          element = entry.getElement();\n", "          remaining = entry.getCount();\n", "        }\n", "        remaining--;\n", "        return element;\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  public boolean contains(@Nullable Object object) {\n", "    return count(object) > 0;\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the collection unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final int add(E element, int occurrences) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the collection unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final int remove(Object element, int occurrences) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the collection unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final int setCount(E element, int count) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the collection unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public final boolean setCount(E element, int oldCount, int newCount) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    return Multisets.equalsImpl(this, object);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return Sets.hashCodeImpl(entrySet());\n", "  }\n", "\n", "  @Override\n", "  public String toString() {\n", "    return entrySet().toString();\n", "  }\n", "\n", "  private transient ImmutableSet<Entry<E>> entrySet;\n", "\n", "  @Override\n", "  public ImmutableSet<Entry<E>> entrySet() {\n", "    ImmutableSet<Entry<E>> es = entrySet;\n", "    return (es == null) ? (entrySet = createEntrySet()) : es;\n", "  }\n", "\n", "  private final ImmutableSet<Entry<E>> createEntrySet() {\n", "    return isEmpty() ? ImmutableSet.<Entry<E>>of() : new EntrySet();\n", "  }\n", "\n", "  abstract Entry<E> getEntry(int index);\n", "\n", "  @WeakOuter\n", "  private final class EntrySet extends ImmutableSet.Indexed<Entry<E>> {\n", "    @Override\n", "    boolean isPartialView() {\n", "      return ImmutableMultiset.this.isPartialView();\n", "    }\n", "\n", "    @Override\n", "    Entry<E> get(int index) {\n", "      return getEntry(index);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return elementSet().size();\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object o) {\n", "      if (o instanceof Entry) {\n", "        Entry<?> entry = (Entry<?>) o;\n", "        if (entry.getCount() <= 0) {\n", "          return false;\n", "        }\n", "        int count = count(entry.getElement());\n", "        return count == entry.getCount();\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return ImmutableMultiset.this.hashCode();\n", "    }\n", "\n", "    // We can't label this with @Override, because it doesn't override anything\n", "    // in the GWT emulated version.\n", "    // TODO(cpovirk): try making all copies of this method @GwtIncompatible instead\n", "    Object writeReplace() {\n", "      return new EntrySetSerializedForm<E>(ImmutableMultiset.this);\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static class EntrySetSerializedForm<E> implements Serializable {\n", "    final ImmutableMultiset<E> multiset;\n", "\n", "    EntrySetSerializedForm(ImmutableMultiset<E> multiset) {\n", "      this.multiset = multiset;\n", "    }\n", "\n", "    Object readResolve() {\n", "      return multiset.entrySet();\n", "    }\n", "  }\n", "\n", "  private static class SerializedForm implements Serializable {\n", "    final Object[] elements;\n", "    final int[] counts;\n", "\n", "    SerializedForm(Multiset<?> multiset) {\n", "      int distinct = multiset.entrySet().size();\n", "      elements = new Object[distinct];\n", "      counts = new int[distinct];\n", "      int i = 0;\n", "      for (Entry<?> entry : multiset.entrySet()) {\n", "        elements[i] = entry.getElement();\n", "        counts[i] = entry.getCount();\n", "        i++;\n", "      }\n", "    }\n", "\n", "    Object readResolve() {\n", "      LinkedHashMultiset<Object> multiset = LinkedHashMultiset.create(elements.length);\n", "      for (int i = 0; i < elements.length; i++) {\n", "        multiset.add(elements[i], counts[i]);\n", "      }\n", "      return ImmutableMultiset.copyOf(multiset);\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  // We can't label this with @Override, because it doesn't override anything\n", "  // in the GWT emulated version.\n", "  Object writeReplace() {\n", "    return new SerializedForm(this);\n", "  }\n", "\n", "  /**\n", "   * Returns a new builder. The generated builder is equivalent to the builder\n", "   * created by the {@link Builder} constructor.\n", "   */\n", "  public static <E> Builder<E> builder() {\n", "    return new Builder<E>();\n", "  }\n", "\n", "  /**\n", "   * A builder for creating immutable multiset instances, especially {@code\n", "   * public static final} multisets (\"constant multisets\"). Example:\n", "   * <pre> {@code\n", "   *\n", "   *   public static final ImmutableMultiset<Bean> BEANS =\n", "   *       new ImmutableMultiset.Builder<Bean>()\n", "   *           .addCopies(Bean.COCOA, 4)\n", "   *           .addCopies(Bean.GARDEN, 6)\n", "   *           .addCopies(Bean.RED, 8)\n", "   *           .addCopies(Bean.BLACK_EYED, 10)\n", "   *           .build();}</pre>\n", "   *\n", "   * <p>Builder instances can be reused; it is safe to call {@link #build} multiple\n", "   * times to build multiple multisets in series.\n", "   *\n", "   * @since 2.0\n", "   */\n", "  public static class Builder<E> extends ImmutableCollection.Builder<E> {\n", "    final Multiset<E> contents;\n", "\n", "    /**\n", "     * Creates a new builder. The returned builder is equivalent to the builder\n", "     * generated by {@link ImmutableMultiset#builder}.\n", "     */\n", "    public Builder() {\n", "      this(LinkedHashMultiset.<E>create());\n", "    }\n", "\n", "    Builder(Multiset<E> contents) {\n", "      this.contents = contents;\n", "    }\n", "\n", "    /**\n", "     * Adds {@code element} to the {@code ImmutableMultiset}.\n", "     *\n", "     * @param element the element to add\n", "     * @return this {@code Builder} object\n", "     * @throws NullPointerException if {@code element} is null\n", "     */\n", "    @Override\n", "    public Builder<E> add(E element) {\n", "      contents.add(checkNotNull(element));\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds a number of occurrences of an element to this {@code\n", "     * ImmutableMultiset}.\n", "     *\n", "     * @param element the element to add\n", "     * @param occurrences the number of occurrences of the element to add. May\n", "     *     be zero, in which case no change will be made.\n", "     * @return this {@code Builder} object\n", "     * @throws NullPointerException if {@code element} is null\n", "     * @throws IllegalArgumentException if {@code occurrences} is negative, or\n", "     *     if this operation would result in more than {@link Integer#MAX_VALUE}\n", "     *     occurrences of the element\n", "     */\n", "    public Builder<E> addCopies(E element, int occurrences) {\n", "      contents.add(checkNotNull(element), occurrences);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds or removes the necessary occurrences of an element such that the\n", "     * element attains the desired count.\n", "     *\n", "     * @param element the element to add or remove occurrences of\n", "     * @param count the desired count of the element in this multiset\n", "     * @return this {@code Builder} object\n", "     * @throws NullPointerException if {@code element} is null\n", "     * @throws IllegalArgumentException if {@code count} is negative\n", "     */\n", "    public Builder<E> setCount(E element, int count) {\n", "      contents.setCount(checkNotNull(element), count);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds each element of {@code elements} to the {@code ImmutableMultiset}.\n", "     *\n", "     * @param elements the elements to add\n", "     * @return this {@code Builder} object\n", "     * @throws NullPointerException if {@code elements} is null or contains a\n", "     *     null element\n", "     */\n", "    @Override\n", "    public Builder<E> add(E... elements) {\n", "      super.add(elements);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds each element of {@code elements} to the {@code ImmutableMultiset}.\n", "     *\n", "     * @param elements the {@code Iterable} to add to the {@code\n", "     *     ImmutableMultiset}\n", "     * @return this {@code Builder} object\n", "     * @throws NullPointerException if {@code elements} is null or contains a\n", "     *     null element\n", "     */\n", "    @Override\n", "    public Builder<E> addAll(Iterable<? extends E> elements) {\n", "      if (elements instanceof Multiset) {\n", "        Multiset<? extends E> multiset = Multisets.cast(elements);\n", "        for (Entry<? extends E> entry : multiset.entrySet()) {\n", "          addCopies(entry.getElement(), entry.getCount());\n", "        }\n", "      } else {\n", "        super.addAll(elements);\n", "      }\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds each element of {@code elements} to the {@code ImmutableMultiset}.\n", "     *\n", "     * @param elements the elements to add to the {@code ImmutableMultiset}\n", "     * @return this {@code Builder} object\n", "     * @throws NullPointerException if {@code elements} is null or contains a\n", "     *     null element\n", "     */\n", "    @Override\n", "    public Builder<E> addAll(Iterator<? extends E> elements) {\n", "      super.addAll(elements);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Returns a newly-created {@code ImmutableMultiset} based on the contents\n", "     * of the {@code Builder}.\n", "     */\n", "    @Override\n", "    public ImmutableMultiset<E> build() {\n", "      return copyOf(contents);\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544]}}, {"30": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSetMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.MoreObjects;\n", "import com.google.j2objc.annotations.Weak;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A {@link SetMultimap} whose contents will never change, with many other important properties\n", " * detailed at {@link ImmutableCollection}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\">\n", " * immutable collections</a>.\n", " *\n", " * @author Mike Ward\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>\n", "    implements SetMultimap<K, V> {\n", "\n", "  /** Returns the empty multimap. */\n", "  // Casting is safe because the multimap will never hold any elements.\n", "  @SuppressWarnings(\"unchecked\")\n", "  public static <K, V> ImmutableSetMultimap<K, V> of() {\n", "    return (ImmutableSetMultimap<K, V>) EmptyImmutableSetMultimap.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing a single entry.\n", "   */\n", "  public static <K, V> ImmutableSetMultimap<K, V> of(K k1, V v1) {\n", "    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n", "    builder.put(k1, v1);\n", "    return builder.build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   * Repeated occurrences of an entry (according to {@link Object#equals}) after\n", "   * the first are ignored.\n", "   */\n", "  public static <K, V> ImmutableSetMultimap<K, V> of(K k1, V v1, K k2, V v2) {\n", "    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n", "    builder.put(k1, v1);\n", "    builder.put(k2, v2);\n", "    return builder.build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   * Repeated occurrences of an entry (according to {@link Object#equals}) after\n", "   * the first are ignored.\n", "   */\n", "  public static <K, V> ImmutableSetMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {\n", "    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n", "    builder.put(k1, v1);\n", "    builder.put(k2, v2);\n", "    builder.put(k3, v3);\n", "    return builder.build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   * Repeated occurrences of an entry (according to {@link Object#equals}) after\n", "   * the first are ignored.\n", "   */\n", "  public static <K, V> ImmutableSetMultimap<K, V> of(\n", "      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {\n", "    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n", "    builder.put(k1, v1);\n", "    builder.put(k2, v2);\n", "    builder.put(k3, v3);\n", "    builder.put(k4, v4);\n", "    return builder.build();\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the given entries, in order.\n", "   * Repeated occurrences of an entry (according to {@link Object#equals}) after\n", "   * the first are ignored.\n", "   */\n", "  public static <K, V> ImmutableSetMultimap<K, V> of(\n", "      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {\n", "    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n", "    builder.put(k1, v1);\n", "    builder.put(k2, v2);\n", "    builder.put(k3, v3);\n", "    builder.put(k4, v4);\n", "    builder.put(k5, v5);\n", "    return builder.build();\n", "  }\n", "\n", "  // looking for of() with > 5 entries? Use the builder instead.\n", "\n", "  /**\n", "   * Returns a new {@link Builder}.\n", "   */\n", "  public static <K, V> Builder<K, V> builder() {\n", "    return new Builder<K, V>();\n", "  }\n", "\n", "  /**\n", "   * A builder for creating immutable {@code SetMultimap} instances, especially\n", "   * {@code public static final} multimaps (\"constant multimaps\"). Example:\n", "   * <pre>   {@code\n", "   *\n", "   *   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =\n", "   *       new ImmutableSetMultimap.Builder<String, Integer>()\n", "   *           .put(\"one\", 1)\n", "   *           .putAll(\"several\", 1, 2, 3)\n", "   *           .putAll(\"many\", 1, 2, 3, 4, 5)\n", "   *           .build();}</pre>\n", "   *\n", "   * <p>Builder instances can be reused; it is safe to call {@link #build} multiple\n", "   * times to build multiple multimaps in series. Each multimap contains the\n", "   * key-value mappings in the previously created multimaps.\n", "   *\n", "   * @since 2.0\n", "   */\n", "  public static final class Builder<K, V> extends ImmutableMultimap.Builder<K, V> {\n", "    /**\n", "     * Creates a new builder. The returned builder is equivalent to the builder\n", "     * generated by {@link ImmutableSetMultimap#builder}.\n", "     */\n", "    public Builder() {\n", "      super(MultimapBuilder.linkedHashKeys().linkedHashSetValues().<K, V>build());\n", "    }\n", "\n", "    /**\n", "     * Adds a key-value mapping to the built multimap if it is not already\n", "     * present.\n", "     */\n", "    @Override\n", "    public Builder<K, V> put(K key, V value) {\n", "      builderMultimap.put(checkNotNull(key), checkNotNull(value));\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Adds an entry to the built multimap if it is not already present.\n", "     *\n", "     * @since 11.0\n", "     */\n", "    @Override\n", "    public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {\n", "      builderMultimap.put(checkNotNull(entry.getKey()), checkNotNull(entry.getValue()));\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     *\n", "     * @since 19.0\n", "     */\n", "    @Beta\n", "    @Override\n", "    public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n", "      super.putAll(entries);\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Builder<K, V> putAll(K key, Iterable<? extends V> values) {\n", "      Collection<V> collection = builderMultimap.get(checkNotNull(key));\n", "      for (V value : values) {\n", "        collection.add(checkNotNull(value));\n", "      }\n", "      return this;\n", "    }\n", "\n", "    @Override\n", "    public Builder<K, V> putAll(K key, V... values) {\n", "      return putAll(key, Arrays.asList(values));\n", "    }\n", "\n", "    @Override\n", "    public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {\n", "      for (Entry<? extends K, ? extends Collection<? extends V>> entry :\n", "          multimap.asMap().entrySet()) {\n", "        putAll(entry.getKey(), entry.getValue());\n", "      }\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     *\n", "     * @since 8.0\n", "     */\n", "    @Override\n", "    public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {\n", "      this.keyComparator = checkNotNull(keyComparator);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Specifies the ordering of the generated multimap's values for each key.\n", "     *\n", "     * <p>If this method is called, the sets returned by the {@code get()}\n", "     * method of the generated multimap and its {@link Multimap#asMap()} view\n", "     * are {@link ImmutableSortedSet} instances. However, serialization does not\n", "     * preserve that property, though it does maintain the key and value\n", "     * ordering.\n", "     *\n", "     * @since 8.0\n", "     */\n", "    // TODO: Make serialization behavior consistent.\n", "    @Override\n", "    public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {\n", "      super.orderValuesBy(valueComparator);\n", "      return this;\n", "    }\n", "\n", "    /**\n", "     * Returns a newly-created immutable set multimap.\n", "     */\n", "    @Override\n", "    public ImmutableSetMultimap<K, V> build() {\n", "      if (keyComparator != null) {\n", "        Multimap<K, V> sortedCopy =\n", "            MultimapBuilder.linkedHashKeys().linkedHashSetValues().<K, V>build();\n", "        List<Map.Entry<K, Collection<V>>> entries =\n", "            Ordering.from(keyComparator)\n", "                .<K>onKeys()\n", "                .immutableSortedCopy(builderMultimap.asMap().entrySet());\n", "        for (Map.Entry<K, Collection<V>> entry : entries) {\n", "          sortedCopy.putAll(entry.getKey(), entry.getValue());\n", "        }\n", "        builderMultimap = sortedCopy;\n", "      }\n", "      return copyOf(builderMultimap, valueComparator);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable set multimap containing the same mappings as\n", "   * {@code multimap}. The generated multimap's key and value orderings\n", "   * correspond to the iteration ordering of the {@code multimap.asMap()} view.\n", "   * Repeated occurrences of an entry in the multimap after the first are\n", "   * ignored.\n", "   *\n", "   * <p>Despite the method name, this method attempts to avoid actually copying\n", "   * the data when it is safe to do so. The exact circumstances under which a\n", "   * copy will or will not be performed are undocumented and subject to change.\n", "   *\n", "   * @throws NullPointerException if any key or value in {@code multimap} is\n", "   *     null\n", "   */\n", "  public static <K, V> ImmutableSetMultimap<K, V> copyOf(\n", "      Multimap<? extends K, ? extends V> multimap) {\n", "    return copyOf(multimap, null);\n", "  }\n", "\n", "  private static <K, V> ImmutableSetMultimap<K, V> copyOf(\n", "      Multimap<? extends K, ? extends V> multimap, Comparator<? super V> valueComparator) {\n", "    checkNotNull(multimap); // eager for GWT\n", "    if (multimap.isEmpty() && valueComparator == null) {\n", "      return of();\n", "    }\n", "\n", "    if (multimap instanceof ImmutableSetMultimap) {\n", "      @SuppressWarnings(\"unchecked\") // safe since multimap is not writable\n", "      ImmutableSetMultimap<K, V> kvMultimap = (ImmutableSetMultimap<K, V>) multimap;\n", "      if (!kvMultimap.isPartialView()) {\n", "        return kvMultimap;\n", "      }\n", "    }\n", "\n", "    ImmutableMap.Builder<K, ImmutableSet<V>> builder =\n", "        new ImmutableMap.Builder<K, ImmutableSet<V>>(multimap.asMap().size());\n", "    int size = 0;\n", "\n", "    for (Entry<? extends K, ? extends Collection<? extends V>> entry :\n", "        multimap.asMap().entrySet()) {\n", "      K key = entry.getKey();\n", "      Collection<? extends V> values = entry.getValue();\n", "      ImmutableSet<V> set = valueSet(valueComparator, values);\n", "      if (!set.isEmpty()) {\n", "        builder.put(key, set);\n", "        size += set.size();\n", "      }\n", "    }\n", "\n", "    return new ImmutableSetMultimap<K, V>(builder.build(), size, valueComparator);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable multimap containing the specified entries.  The\n", "   * returned multimap iterates over keys in the order they were first\n", "   * encountered in the input, and the values for each key are iterated in the\n", "   * order they were encountered.  If two values for the same key are\n", "   * {@linkplain Object#equals equal}, the first value encountered is used.\n", "   *\n", "   * @throws NullPointerException if any key, value, or entry is null\n", "   * @since 19.0\n", "   */\n", "  @Beta\n", "  public static <K, V> ImmutableSetMultimap<K, V> copyOf(\n", "      Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n", "    return new Builder<K, V>().putAll(entries).build();\n", "  }\n", "\n", "  /**\n", "   * Returned by get() when a missing key is provided. Also holds the\n", "   * comparator, if any, used for values.\n", "   */\n", "  private final transient ImmutableSet<V> emptySet;\n", "\n", "  ImmutableSetMultimap(\n", "      ImmutableMap<K, ImmutableSet<V>> map,\n", "      int size,\n", "      @Nullable Comparator<? super V> valueComparator) {\n", "    super(map, size);\n", "    this.emptySet = emptySet(valueComparator);\n", "  }\n", "\n", "  // views\n", "\n", "  /**\n", "   * Returns an immutable set of the values for the given key.  If no mappings\n", "   * in the multimap have the provided key, an empty immutable set is returned.\n", "   * The values are in the same order as the parameters used to build this\n", "   * multimap.\n", "   */\n", "  @Override\n", "  public ImmutableSet<V> get(@Nullable K key) {\n", "    // This cast is safe as its type is known in constructor.\n", "    ImmutableSet<V> set = (ImmutableSet<V>) map.get(key);\n", "    return MoreObjects.firstNonNull(set, emptySet);\n", "  }\n", "\n", "  private transient ImmutableSetMultimap<V, K> inverse;\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>Because an inverse of a set multimap cannot contain multiple pairs with\n", "   * the same key and value, this method returns an {@code ImmutableSetMultimap}\n", "   * rather than the {@code ImmutableMultimap} specified in the {@code\n", "   * ImmutableMultimap} class.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  public ImmutableSetMultimap<V, K> inverse() {\n", "    ImmutableSetMultimap<V, K> result = inverse;\n", "    return (result == null) ? (inverse = invert()) : result;\n", "  }\n", "\n", "  private ImmutableSetMultimap<V, K> invert() {\n", "    Builder<V, K> builder = builder();\n", "    for (Entry<K, V> entry : entries()) {\n", "      builder.put(entry.getValue(), entry.getKey());\n", "    }\n", "    ImmutableSetMultimap<V, K> invertedMultimap = builder.build();\n", "    invertedMultimap.inverse = this;\n", "    return invertedMultimap;\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public ImmutableSet<V> removeAll(Object key) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  /**\n", "   * Guaranteed to throw an exception and leave the multimap unmodified.\n", "   *\n", "   * @throws UnsupportedOperationException always\n", "   * @deprecated Unsupported operation.\n", "   */\n", "  @Deprecated\n", "  @Override\n", "  public ImmutableSet<V> replaceValues(K key, Iterable<? extends V> values) {\n", "    throw new UnsupportedOperationException();\n", "  }\n", "\n", "  private transient ImmutableSet<Entry<K, V>> entries;\n", "\n", "  /**\n", "   * Returns an immutable collection of all key-value pairs in the multimap.\n", "   * Its iterator traverses the values for the first key, the values for the\n", "   * second key, and so on.\n", "   */\n", "  @Override\n", "  public ImmutableSet<Entry<K, V>> entries() {\n", "    ImmutableSet<Entry<K, V>> result = entries;\n", "    return result == null\n", "        ? (entries = new EntrySet<K, V>(this))\n", "        : result;\n", "  }\n", "\n", "  private static final class EntrySet<K, V> extends ImmutableSet<Entry<K, V>> {\n", "    @Weak private final transient ImmutableSetMultimap<K, V> multimap;\n", "\n", "    EntrySet(ImmutableSetMultimap<K, V> multimap) {\n", "      this.multimap = multimap;\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(@Nullable Object object) {\n", "      if (object instanceof Entry) {\n", "        Entry<?, ?> entry = (Entry<?, ?>) object;\n", "        return multimap.containsEntry(entry.getKey(), entry.getValue());\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return multimap.size();\n", "    }\n", "\n", "    @Override\n", "    public UnmodifiableIterator<Entry<K, V>> iterator() {\n", "      return multimap.entryIterator();\n", "    }\n", "\n", "    @Override\n", "    boolean isPartialView() {\n", "      return false;\n", "    }\n", "  }\n", "\n", "  private static <V> ImmutableSet<V> valueSet(\n", "      @Nullable Comparator<? super V> valueComparator, Collection<? extends V> values) {\n", "    return (valueComparator == null)\n", "        ? ImmutableSet.copyOf(values)\n", "        : ImmutableSortedSet.copyOf(valueComparator, values);\n", "  }\n", "\n", "  private static <V> ImmutableSet<V> emptySet(@Nullable Comparator<? super V> valueComparator) {\n", "    return (valueComparator == null)\n", "        ? ImmutableSet.<V>of()\n", "        : ImmutableSortedSet.<V>emptySet(valueComparator);\n", "  }\n", "\n", "  private static <V> ImmutableSet.Builder<V> valuesBuilder(\n", "      @Nullable Comparator<? super V> valueComparator) {\n", "    return (valueComparator == null)\n", "        ? new ImmutableSet.Builder<V>()\n", "        : new ImmutableSortedSet.Builder<V>(valueComparator);\n", "  }\n", "\n", "  @Nullable\n", "  Comparator<? super V> valueComparator() {\n", "    return emptySet instanceof ImmutableSortedSet\n", "        ? ((ImmutableSortedSet<V>) emptySet).comparator()\n", "        : null;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485]}}, {"31": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedAsList.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the\n", " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n", " * express or implied. See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.Comparator;\n", "\n", "/**\n", " * List returned by {@code ImmutableSortedSet.asList()} when the set isn't empty.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"serial\")\n", "final class ImmutableSortedAsList<E> extends RegularImmutableAsList<E>\n", "    implements SortedIterable<E> {\n", "  ImmutableSortedAsList(ImmutableSortedSet<E> backingSet, ImmutableList<E> backingList) {\n", "    super(backingSet, backingList);\n", "  }\n", "\n", "  @Override\n", "  ImmutableSortedSet<E> delegateCollection() {\n", "    return (ImmutableSortedSet<E>) super.delegateCollection();\n", "  }\n", "\n", "  @Override\n", "  public Comparator<? super E> comparator() {\n", "    return delegateCollection().comparator();\n", "  }\n", "\n", "  // Override indexOf() and lastIndexOf() to be O(log N) instead of O(N).\n", "\n", "  @Override\n", "  public boolean contains(Object target) {\n", "    // Necessary for ISS's with comparators inconsistent with equals.\n", "    return indexOf(target) >= 0;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53]}}, {"32": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterables.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Optional;\n", "import com.google.common.base.Predicate;\n", "\n", "import java.util.Collection;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.NoSuchElementException;\n", "import java.util.Queue;\n", "import java.util.RandomAccess;\n", "import java.util.Set;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * This class contains static utility methods that operate on or return objects\n", " * of type {@code Iterable}. Except as noted, each method has a corresponding\n", " * {@link Iterator}-based method in the {@link Iterators} class.\n", " *\n", " * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables\n", " * produced in this class are <i>lazy</i>, which means that their iterators\n", " * only advance the backing iteration when absolutely necessary.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\">\n", " * {@code Iterables}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Iterables {\n", "  private Iterables() {}\n", "\n", "  /** Returns an unmodifiable view of {@code iterable}. */\n", "  public static <T> Iterable<T> unmodifiableIterable(final Iterable<T> iterable) {\n", "    checkNotNull(iterable);\n", "    if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection) {\n", "      return iterable;\n", "    }\n", "    return new UnmodifiableIterable<T>(iterable);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   * @since 10.0\n", "   */\n", "  @Deprecated\n", "  public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable) {\n", "    return checkNotNull(iterable);\n", "  }\n", "\n", "  private static final class UnmodifiableIterable<T> extends FluentIterable<T> {\n", "    private final Iterable<T> iterable;\n", "\n", "    private UnmodifiableIterable(Iterable<T> iterable) {\n", "      this.iterable = iterable;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<T> iterator() {\n", "      return Iterators.unmodifiableIterator(iterable.iterator());\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return iterable.toString();\n", "    }\n", "    // no equals and hashCode; it would break the contract!\n", "  }\n", "\n", "  /**\n", "   * Returns the number of elements in {@code iterable}.\n", "   */\n", "  public static int size(Iterable<?> iterable) {\n", "    return (iterable instanceof Collection)\n", "        ? ((Collection<?>) iterable).size()\n", "        : Iterators.size(iterable.iterator());\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code iterable} contains any object for which {@code equals(element)}\n", "   * is true.\n", "   */\n", "  public static boolean contains(Iterable<?> iterable, @Nullable Object element) {\n", "    if (iterable instanceof Collection) {\n", "      Collection<?> collection = (Collection<?>) iterable;\n", "      return Collections2.safeContains(collection, element);\n", "    }\n", "    return Iterators.contains(iterable.iterator(), element);\n", "  }\n", "\n", "  /**\n", "   * Removes, from an iterable, every element that belongs to the provided\n", "   * collection.\n", "   *\n", "   * <p>This method calls {@link Collection#removeAll} if {@code iterable} is a\n", "   * collection, and {@link Iterators#removeAll} otherwise.\n", "   *\n", "   * @param removeFrom the iterable to (potentially) remove elements from\n", "   * @param elementsToRemove the elements to remove\n", "   * @return {@code true} if any element was removed from {@code iterable}\n", "   */\n", "  public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove) {\n", "    return (removeFrom instanceof Collection)\n", "        ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove))\n", "        : Iterators.removeAll(removeFrom.iterator(), elementsToRemove);\n", "  }\n", "\n", "  /**\n", "   * Removes, from an iterable, every element that does not belong to the\n", "   * provided collection.\n", "   *\n", "   * <p>This method calls {@link Collection#retainAll} if {@code iterable} is a\n", "   * collection, and {@link Iterators#retainAll} otherwise.\n", "   *\n", "   * @param removeFrom the iterable to (potentially) remove elements from\n", "   * @param elementsToRetain the elements to retain\n", "   * @return {@code true} if any element was removed from {@code iterable}\n", "   */\n", "  public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain) {\n", "    return (removeFrom instanceof Collection)\n", "        ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain))\n", "        : Iterators.retainAll(removeFrom.iterator(), elementsToRetain);\n", "  }\n", "\n", "  /**\n", "   * Removes, from an iterable, every element that satisfies the provided\n", "   * predicate.\n", "   *\n", "   * <p>Removals may or may not happen immediately as each element is tested\n", "   * against the predicate.  The behavior of this method is not specified if\n", "   * {@code predicate} is dependent on {@code removeFrom}.\n", "   *\n", "   * @param removeFrom the iterable to (potentially) remove elements from\n", "   * @param predicate a predicate that determines whether an element should\n", "   *     be removed\n", "   * @return {@code true} if any elements were removed from the iterable\n", "   *\n", "   * @throws UnsupportedOperationException if the iterable does not support\n", "   *     {@code remove()}.\n", "   * @since 2.0\n", "   */\n", "  public static <T> boolean removeIf(Iterable<T> removeFrom, Predicate<? super T> predicate) {\n", "    if (removeFrom instanceof RandomAccess && removeFrom instanceof List) {\n", "      return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\n", "    }\n", "    return Iterators.removeIf(removeFrom.iterator(), predicate);\n", "  }\n", "\n", "  private static <T> boolean removeIfFromRandomAccessList(\n", "      List<T> list, Predicate<? super T> predicate) {\n", "    // Note: Not all random access lists support set() so we need to deal with\n", "    // those that don't and attempt the slower remove() based solution.\n", "    int from = 0;\n", "    int to = 0;\n", "\n", "    for (; from < list.size(); from++) {\n", "      T element = list.get(from);\n", "      if (!predicate.apply(element)) {\n", "        if (from > to) {\n", "          try {\n", "            list.set(to, element);\n", "          } catch (UnsupportedOperationException e) {\n", "            slowRemoveIfForRemainingElements(list, predicate, to, from);\n", "            return true;\n", "          }\n", "        }\n", "        to++;\n", "      }\n", "    }\n", "\n", "    // Clear the tail of any remaining items\n", "    list.subList(to, list.size()).clear();\n", "    return from != to;\n", "  }\n", "\n", "  private static <T> void slowRemoveIfForRemainingElements(\n", "      List<T> list, Predicate<? super T> predicate, int to, int from) {\n", "    // Here we know that:\n", "    // * (to < from) and that both are valid indices.\n", "    // * Everything with (index < to) should be kept.\n", "    // * Everything with (to <= index < from) should be removed.\n", "    // * The element with (index == from) should be kept.\n", "    // * Everything with (index > from) has not been checked yet.\n", "\n", "    // Check from the end of the list backwards (minimize expected cost of\n", "    // moving elements when remove() is called). Stop before 'from' because\n", "    // we already know that should be kept.\n", "    for (int n = list.size() - 1; n > from; n--) {\n", "      if (predicate.apply(list.get(n))) {\n", "        list.remove(n);\n", "      }\n", "    }\n", "    // And now remove everything in the range [to, from) (going backwards).\n", "    for (int n = from - 1; n >= to; n--) {\n", "      list.remove(n);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Removes and returns the first matching element, or returns {@code null} if there is none.\n", "   */\n", "  @Nullable\n", "  static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate) {\n", "    checkNotNull(predicate);\n", "    Iterator<T> iterator = removeFrom.iterator();\n", "    while (iterator.hasNext()) {\n", "      T next = iterator.next();\n", "      if (predicate.apply(next)) {\n", "        iterator.remove();\n", "        return next;\n", "      }\n", "    }\n", "    return null;\n", "  }\n", "\n", "  /**\n", "   * Determines whether two iterables contain equal elements in the same order.\n", "   * More specifically, this method returns {@code true} if {@code iterable1}\n", "   * and {@code iterable2} contain the same number of elements and every element\n", "   * of {@code iterable1} is equal to the corresponding element of\n", "   * {@code iterable2}.\n", "   */\n", "  @CheckReturnValue\n", "  public static boolean elementsEqual(Iterable<?> iterable1, Iterable<?> iterable2) {\n", "    if (iterable1 instanceof Collection && iterable2 instanceof Collection) {\n", "      Collection<?> collection1 = (Collection<?>) iterable1;\n", "      Collection<?> collection2 = (Collection<?>) iterable2;\n", "      if (collection1.size() != collection2.size()) {\n", "        return false;\n", "      }\n", "    }\n", "    return Iterators.elementsEqual(iterable1.iterator(), iterable2.iterator());\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of {@code iterable}, with the format {@code\n", "   * [e1, e2, ..., en]} (that is, identical to {@link java.util.Arrays\n", "   * Arrays}{@code .toString(Iterables.toArray(iterable))}). Note that for\n", "   * <i>most</i> implementations of {@link Collection}, {@code\n", "   * collection.toString()} also gives the same result, but that behavior is not\n", "   * generally guaranteed.\n", "   */\n", "  public static String toString(Iterable<?> iterable) {\n", "    return Iterators.toString(iterable.iterator());\n", "  }\n", "\n", "  /**\n", "   * Returns the single element contained in {@code iterable}.\n", "   *\n", "   * @throws NoSuchElementException if the iterable is empty\n", "   * @throws IllegalArgumentException if the iterable contains multiple\n", "   *     elements\n", "   */\n", "  public static <T> T getOnlyElement(Iterable<T> iterable) {\n", "    return Iterators.getOnlyElement(iterable.iterator());\n", "  }\n", "\n", "  /**\n", "   * Returns the single element contained in {@code iterable}, or {@code\n", "   * defaultValue} if the iterable is empty.\n", "   *\n", "   * @throws IllegalArgumentException if the iterator contains multiple\n", "   *     elements\n", "   */\n", "  @Nullable\n", "  public static <T> T getOnlyElement(Iterable<? extends T> iterable, @Nullable T defaultValue) {\n", "    return Iterators.getOnlyElement(iterable.iterator(), defaultValue);\n", "  }\n", "\n", "  static <T> T[] toArray(Iterable<? extends T> iterable, T[] array) {\n", "    Collection<? extends T> collection = castOrCopyToCollection(iterable);\n", "    return collection.toArray(array);\n", "  }\n", "\n", "  /**\n", "   * Copies an iterable's elements into an array.\n", "   *\n", "   * @param iterable the iterable to copy\n", "   * @return a newly-allocated array into which all the elements of the iterable\n", "   *     have been copied\n", "   */\n", "  static Object[] toArray(Iterable<?> iterable) {\n", "    return castOrCopyToCollection(iterable).toArray();\n", "  }\n", "\n", "  /**\n", "   * Converts an iterable into a collection. If the iterable is already a\n", "   * collection, it is returned. Otherwise, an {@link java.util.ArrayList} is\n", "   * created with the contents of the iterable in the same iteration order.\n", "   */\n", "  private static <E> Collection<E> castOrCopyToCollection(Iterable<E> iterable) {\n", "    return (iterable instanceof Collection)\n", "        ? (Collection<E>) iterable\n", "        : Lists.newArrayList(iterable.iterator());\n", "  }\n", "\n", "  /**\n", "   * Adds all elements in {@code iterable} to {@code collection}.\n", "   *\n", "   * @return {@code true} if {@code collection} was modified as a result of this\n", "   *     operation.\n", "   */\n", "  public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd) {\n", "    if (elementsToAdd instanceof Collection) {\n", "      Collection<? extends T> c = Collections2.cast(elementsToAdd);\n", "      return addTo.addAll(c);\n", "    }\n", "    return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());\n", "  }\n", "\n", "  /**\n", "   * Returns the number of elements in the specified iterable that equal the\n", "   * specified object. This implementation avoids a full iteration when the\n", "   * iterable is a {@link Multiset} or {@link Set}.\n", "   *\n", "   * @see Collections#frequency\n", "   */\n", "  public static int frequency(Iterable<?> iterable, @Nullable Object element) {\n", "    if ((iterable instanceof Multiset)) {\n", "      return ((Multiset<?>) iterable).count(element);\n", "    } else if ((iterable instanceof Set)) {\n", "      return ((Set<?>) iterable).contains(element) ? 1 : 0;\n", "    }\n", "    return Iterators.frequency(iterable.iterator(), element);\n", "  }\n", "\n", "  /**\n", "   * Returns an iterable whose iterators cycle indefinitely over the elements of\n", "   * {@code iterable}.\n", "   *\n", "   * <p>That iterator supports {@code remove()} if {@code iterable.iterator()}\n", "   * does. After {@code remove()} is called, subsequent cycles omit the removed\n", "   * element, which is no longer in {@code iterable}. The iterator's\n", "   * {@code hasNext()} method returns {@code true} until {@code iterable} is\n", "   * empty.\n", "   *\n", "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an\n", "   * infinite loop. You should use an explicit {@code break} or be certain that\n", "   * you will eventually remove all the elements.\n", "   *\n", "   * <p>To cycle over the iterable {@code n} times, use the following:\n", "   * {@code Iterables.concat(Collections.nCopies(n, iterable))}\n", "   */\n", "  public static <T> Iterable<T> cycle(final Iterable<T> iterable) {\n", "    checkNotNull(iterable);\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        return Iterators.cycle(iterable);\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return iterable.toString() + \" (cycled)\";\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an iterable whose iterators cycle indefinitely over the provided\n", "   * elements.\n", "   *\n", "   * <p>After {@code remove} is invoked on a generated iterator, the removed\n", "   * element will no longer appear in either that iterator or any other iterator\n", "   * created from the same source iterable. That is, this method behaves exactly\n", "   * as {@code Iterables.cycle(Lists.newArrayList(elements))}. The iterator's\n", "   * {@code hasNext} method returns {@code true} until all of the original\n", "   * elements have been removed.\n", "   *\n", "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an\n", "   * infinite loop. You should use an explicit {@code break} or be certain that\n", "   * you will eventually remove all the elements.\n", "   *\n", "   * <p>To cycle over the elements {@code n} times, use the following:\n", "   * {@code Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}\n", "   */\n", "  public static <T> Iterable<T> cycle(T... elements) {\n", "    return cycle(Lists.newArrayList(elements));\n", "  }\n", "\n", "  /**\n", "   * Combines two iterables into a single iterable. The returned iterable has an\n", "   * iterator that traverses the elements in {@code a}, followed by the elements\n", "   * in {@code b}. The source iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterable's iterator supports {@code remove()} when the\n", "   * corresponding input iterator supports it.\n", "   */\n", "  public static <T> Iterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b) {\n", "    return concat(ImmutableList.of(a, b));\n", "  }\n", "\n", "  /**\n", "   * Combines three iterables into a single iterable. The returned iterable has\n", "   * an iterator that traverses the elements in {@code a}, followed by the\n", "   * elements in {@code b}, followed by the elements in {@code c}. The source\n", "   * iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterable's iterator supports {@code remove()} when the\n", "   * corresponding input iterator supports it.\n", "   */\n", "  public static <T> Iterable<T> concat(\n", "      Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c) {\n", "    return concat(ImmutableList.of(a, b, c));\n", "  }\n", "\n", "  /**\n", "   * Combines four iterables into a single iterable. The returned iterable has\n", "   * an iterator that traverses the elements in {@code a}, followed by the\n", "   * elements in {@code b}, followed by the elements in {@code c}, followed by\n", "   * the elements in {@code d}. The source iterators are not polled until\n", "   * necessary.\n", "   *\n", "   * <p>The returned iterable's iterator supports {@code remove()} when the\n", "   * corresponding input iterator supports it.\n", "   */\n", "  public static <T> Iterable<T> concat(\n", "      Iterable<? extends T> a,\n", "      Iterable<? extends T> b,\n", "      Iterable<? extends T> c,\n", "      Iterable<? extends T> d) {\n", "    return concat(ImmutableList.of(a, b, c, d));\n", "  }\n", "\n", "  /**\n", "   * Combines multiple iterables into a single iterable. The returned iterable\n", "   * has an iterator that traverses the elements of each iterable in\n", "   * {@code inputs}. The input iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterable's iterator supports {@code remove()} when the\n", "   * corresponding input iterator supports it.\n", "   *\n", "   * @throws NullPointerException if any of the provided iterables is null\n", "   */\n", "  public static <T> Iterable<T> concat(Iterable<? extends T>... inputs) {\n", "    return concat(ImmutableList.copyOf(inputs));\n", "  }\n", "\n", "  /**\n", "   * Combines multiple iterables into a single iterable. The returned iterable\n", "   * has an iterator that traverses the elements of each iterable in\n", "   * {@code inputs}. The input iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterable's iterator supports {@code remove()} when the\n", "   * corresponding input iterator supports it. The methods of the returned\n", "   * iterable may throw {@code NullPointerException} if any of the input\n", "   * iterators is null.\n", "   */\n", "  public static <T> Iterable<T> concat(final Iterable<? extends Iterable<? extends T>> inputs) {\n", "    checkNotNull(inputs);\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        return Iterators.concat(iterators(inputs));\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator over the iterators of the given iterables.\n", "   */\n", "  private static <T> Iterator<Iterator<? extends T>> iterators(\n", "      Iterable<? extends Iterable<? extends T>> iterables) {\n", "    return new TransformedIterator<Iterable<? extends T>, Iterator<? extends T>>(\n", "        iterables.iterator()) {\n", "      @Override\n", "      Iterator<? extends T> transform(Iterable<? extends T> from) {\n", "        return from.iterator();\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Divides an iterable into unmodifiable sublists of the given size (the final\n", "   * iterable may be smaller). For example, partitioning an iterable containing\n", "   * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code\n", "   * [[a, b, c], [d, e]]} -- an outer iterable containing two inner lists of\n", "   * three and two elements, all in the original order.\n", "   *\n", "   * <p>Iterators returned by the returned iterable do not support the {@link\n", "   * Iterator#remove()} method. The returned lists implement {@link\n", "   * RandomAccess}, whether or not the input list does.\n", "   *\n", "   * <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link\n", "   * Lists#partition(List, int)} instead.\n", "   *\n", "   * @param iterable the iterable to return a partitioned view of\n", "   * @param size the desired size of each partition (the last may be smaller)\n", "   * @return an iterable of unmodifiable lists containing the elements of {@code\n", "   *     iterable} divided into partitions\n", "   * @throws IllegalArgumentException if {@code size} is nonpositive\n", "   */\n", "  public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size) {\n", "    checkNotNull(iterable);\n", "    checkArgument(size > 0);\n", "    return new FluentIterable<List<T>>() {\n", "      @Override\n", "      public Iterator<List<T>> iterator() {\n", "        return Iterators.partition(iterable.iterator(), size);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Divides an iterable into unmodifiable sublists of the given size, padding\n", "   * the final iterable with null values if necessary. For example, partitioning\n", "   * an iterable containing {@code [a, b, c, d, e]} with a partition size of 3\n", "   * yields {@code [[a, b, c], [d, e, null]]} -- an outer iterable containing\n", "   * two inner lists of three elements each, all in the original order.\n", "   *\n", "   * <p>Iterators returned by the returned iterable do not support the {@link\n", "   * Iterator#remove()} method.\n", "   *\n", "   * @param iterable the iterable to return a partitioned view of\n", "   * @param size the desired size of each partition\n", "   * @return an iterable of unmodifiable lists containing the elements of {@code\n", "   *     iterable} divided into partitions (the final iterable may have\n", "   *     trailing null elements)\n", "   * @throws IllegalArgumentException if {@code size} is nonpositive\n", "   */\n", "  public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size) {\n", "    checkNotNull(iterable);\n", "    checkArgument(size > 0);\n", "    return new FluentIterable<List<T>>() {\n", "      @Override\n", "      public Iterator<List<T>> iterator() {\n", "        return Iterators.paddedPartition(iterable.iterator(), size);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns the elements of {@code unfiltered} that satisfy the input predicate\n", "   * {@code retainIfTrue}. The resulting iterable's iterator does not support {@code remove()}.\n", "   */\n", "  @CheckReturnValue\n", "  public static <T> Iterable<T> filter(\n", "      final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue) {\n", "    checkNotNull(unfiltered);\n", "    checkNotNull(retainIfTrue);\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        return Iterators.filter(unfiltered.iterator(), retainIfTrue);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if any element in {@code iterable} satisfies the predicate.\n", "   */\n", "  public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate) {\n", "    return Iterators.any(iterable.iterator(), predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if every element in {@code iterable} satisfies the\n", "   * predicate. If {@code iterable} is empty, {@code true} is returned.\n", "   */\n", "  public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate) {\n", "    return Iterators.all(iterable.iterator(), predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns the first element in {@code iterable} that satisfies the given\n", "   * predicate; use this method only when such an element is known to exist. If\n", "   * it is possible that <i>no</i> element will match, use {@link #tryFind} or\n", "   * {@link #find(Iterable, Predicate, Object)} instead.\n", "   *\n", "   * @throws NoSuchElementException if no element in {@code iterable} matches\n", "   *     the given predicate\n", "   */\n", "  public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate) {\n", "    return Iterators.find(iterable.iterator(), predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns the first element in {@code iterable} that satisfies the given\n", "   * predicate, or {@code defaultValue} if none found. Note that this can\n", "   * usually be handled more naturally using {@code\n", "   * tryFind(iterable, predicate).or(defaultValue)}.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  @Nullable\n", "  public static <T> T find(\n", "      Iterable<? extends T> iterable, Predicate<? super T> predicate, @Nullable T defaultValue) {\n", "    return Iterators.find(iterable.iterator(), predicate, defaultValue);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@link Optional} containing the first element in {@code\n", "   * iterable} that satisfies the given predicate, if such an element exists.\n", "   *\n", "   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code\n", "   * null}. If {@code null} is matched in {@code iterable}, a\n", "   * NullPointerException will be thrown.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  public static <T> Optional<T> tryFind(Iterable<T> iterable, Predicate<? super T> predicate) {\n", "    return Iterators.tryFind(iterable.iterator(), predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns the index in {@code iterable} of the first element that satisfies\n", "   * the provided {@code predicate}, or {@code -1} if the Iterable has no such\n", "   * elements.\n", "   *\n", "   * <p>More formally, returns the lowest index {@code i} such that\n", "   * {@code predicate.apply(Iterables.get(iterable, i))} returns {@code true},\n", "   * or {@code -1} if there is no such index.\n", "   *\n", "   * @since 2.0\n", "   */\n", "  public static <T> int indexOf(Iterable<T> iterable, Predicate<? super T> predicate) {\n", "    return Iterators.indexOf(iterable.iterator(), predicate);\n", "  }\n", "\n", "  /**\n", "   * Returns an iterable that applies {@code function} to each element of {@code\n", "   * fromIterable}.\n", "   *\n", "   * <p>The returned iterable's iterator supports {@code remove()} if the\n", "   * provided iterator does. After a successful {@code remove()} call,\n", "   * {@code fromIterable} no longer contains the corresponding element.\n", "   *\n", "   * <p>If the input {@code Iterable} is known to be a {@code List} or other\n", "   * {@code Collection}, consider {@link Lists#transform} and {@link\n", "   * Collections2#transform}.\n", "   */\n", "  @CheckReturnValue\n", "  public static <F, T> Iterable<T> transform(\n", "      final Iterable<F> fromIterable, final Function<? super F, ? extends T> function) {\n", "    checkNotNull(fromIterable);\n", "    checkNotNull(function);\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        return Iterators.transform(fromIterable.iterator(), function);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns the element at the specified position in an iterable.\n", "   *\n", "   * @param position position of the element to return\n", "   * @return the element at the specified position in {@code iterable}\n", "   * @throws IndexOutOfBoundsException if {@code position} is negative or\n", "   *     greater than or equal to the size of {@code iterable}\n", "   */\n", "  public static <T> T get(Iterable<T> iterable, int position) {\n", "    checkNotNull(iterable);\n", "    return (iterable instanceof List)\n", "        ? ((List<T>) iterable).get(position)\n", "        : Iterators.get(iterable.iterator(), position);\n", "  }\n", "\n", "  /**\n", "   * Returns the element at the specified position in an iterable or a default\n", "   * value otherwise.\n", "   *\n", "   * @param position position of the element to return\n", "   * @param defaultValue the default value to return if {@code position} is\n", "   *     greater than or equal to the size of the iterable\n", "   * @return the element at the specified position in {@code iterable} or\n", "   *     {@code defaultValue} if {@code iterable} contains fewer than\n", "   *     {@code position + 1} elements.\n", "   * @throws IndexOutOfBoundsException if {@code position} is negative\n", "   * @since 4.0\n", "   */\n", "  @Nullable\n", "  public static <T> T get(Iterable<? extends T> iterable, int position, @Nullable T defaultValue) {\n", "    checkNotNull(iterable);\n", "    Iterators.checkNonnegative(position);\n", "    if (iterable instanceof List) {\n", "      List<? extends T> list = Lists.cast(iterable);\n", "      return (position < list.size()) ? list.get(position) : defaultValue;\n", "    } else {\n", "      Iterator<? extends T> iterator = iterable.iterator();\n", "      Iterators.advance(iterator, position);\n", "      return Iterators.getNext(iterator, defaultValue);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns the first element in {@code iterable} or {@code defaultValue} if\n", "   * the iterable is empty.  The {@link Iterators} analog to this method is\n", "   * {@link Iterators#getNext}.\n", "   *\n", "   * <p>If no default value is desired (and the caller instead wants a\n", "   * {@link NoSuchElementException} to be thrown), it is recommended that\n", "   * {@code iterable.iterator().next()} is used instead.\n", "   *\n", "   * @param defaultValue the default value to return if the iterable is empty\n", "   * @return the first element of {@code iterable} or the default value\n", "   * @since 7.0\n", "   */\n", "  @Nullable\n", "  public static <T> T getFirst(Iterable<? extends T> iterable, @Nullable T defaultValue) {\n", "    return Iterators.getNext(iterable.iterator(), defaultValue);\n", "  }\n", "\n", "  /**\n", "   * Returns the last element of {@code iterable}.\n", "   *\n", "   * @return the last element of {@code iterable}\n", "   * @throws NoSuchElementException if the iterable is empty\n", "   */\n", "  public static <T> T getLast(Iterable<T> iterable) {\n", "    // TODO(kevinb): Support a concurrently modified collection?\n", "    if (iterable instanceof List) {\n", "      List<T> list = (List<T>) iterable;\n", "      if (list.isEmpty()) {\n", "        throw new NoSuchElementException();\n", "      }\n", "      return getLastInNonemptyList(list);\n", "    }\n", "\n", "    return Iterators.getLast(iterable.iterator());\n", "  }\n", "\n", "  /**\n", "   * Returns the last element of {@code iterable} or {@code defaultValue} if\n", "   * the iterable is empty.\n", "   *\n", "   * @param defaultValue the value to return if {@code iterable} is empty\n", "   * @return the last element of {@code iterable} or the default value\n", "   * @since 3.0\n", "   */\n", "  @Nullable\n", "  public static <T> T getLast(Iterable<? extends T> iterable, @Nullable T defaultValue) {\n", "    if (iterable instanceof Collection) {\n", "      Collection<? extends T> c = Collections2.cast(iterable);\n", "      if (c.isEmpty()) {\n", "        return defaultValue;\n", "      } else if (iterable instanceof List) {\n", "        return getLastInNonemptyList(Lists.cast(iterable));\n", "      }\n", "    }\n", "\n", "    return Iterators.getLast(iterable.iterator(), defaultValue);\n", "  }\n", "\n", "  private static <T> T getLastInNonemptyList(List<T> list) {\n", "    return list.get(list.size() - 1);\n", "  }\n", "\n", "  /**\n", "   * Returns a view of {@code iterable} that skips its first\n", "   * {@code numberToSkip} elements. If {@code iterable} contains fewer than\n", "   * {@code numberToSkip} elements, the returned iterable skips all of its\n", "   * elements.\n", "   *\n", "   * <p>Modifications to the underlying {@link Iterable} before a call to\n", "   * {@code iterator()} are reflected in the returned iterator. That is, the\n", "   * iterator skips the first {@code numberToSkip} elements that exist when the\n", "   * {@code Iterator} is created, not when {@code skip()} is called.\n", "   *\n", "   * <p>The returned iterable's iterator supports {@code remove()} if the\n", "   * iterator of the underlying iterable supports it. Note that it is\n", "   * <i>not</i> possible to delete the last skipped element by immediately\n", "   * calling {@code remove()} on that iterator, as the {@code Iterator}\n", "   * contract states that a call to {@code remove()} before a call to\n", "   * {@code next()} will throw an {@link IllegalStateException}.\n", "   *\n", "   * @since 3.0\n", "   */\n", "  public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip) {\n", "    checkNotNull(iterable);\n", "    checkArgument(numberToSkip >= 0, \"number to skip cannot be negative\");\n", "\n", "    if (iterable instanceof List) {\n", "      final List<T> list = (List<T>) iterable;\n", "      return new FluentIterable<T>() {\n", "        @Override\n", "        public Iterator<T> iterator() {\n", "          // TODO(kevinb): Support a concurrently modified collection?\n", "          int toSkip = Math.min(list.size(), numberToSkip);\n", "          return list.subList(toSkip, list.size()).iterator();\n", "        }\n", "      };\n", "    }\n", "\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        final Iterator<T> iterator = iterable.iterator();\n", "\n", "        Iterators.advance(iterator, numberToSkip);\n", "\n", "        /*\n", "         * We can't just return the iterator because an immediate call to its\n", "         * remove() method would remove one of the skipped elements instead of\n", "         * throwing an IllegalStateException.\n", "         */\n", "        return new Iterator<T>() {\n", "          boolean atStart = true;\n", "\n", "          @Override\n", "          public boolean hasNext() {\n", "            return iterator.hasNext();\n", "          }\n", "\n", "          @Override\n", "          public T next() {\n", "            T result = iterator.next();\n", "            atStart = false; // not called if next() fails\n", "            return result;\n", "          }\n", "\n", "          @Override\n", "          public void remove() {\n", "            checkRemove(!atStart);\n", "            iterator.remove();\n", "          }\n", "        };\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Creates an iterable with the first {@code limitSize} elements of the given\n", "   * iterable. If the original iterable does not contain that many elements, the\n", "   * returned iterable will have the same behavior as the original iterable. The\n", "   * returned iterable's iterator supports {@code remove()} if the original\n", "   * iterator does.\n", "   *\n", "   * @param iterable the iterable to limit\n", "   * @param limitSize the maximum number of elements in the returned iterable\n", "   * @throws IllegalArgumentException if {@code limitSize} is negative\n", "   * @since 3.0\n", "   */\n", "  public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize) {\n", "    checkNotNull(iterable);\n", "    checkArgument(limitSize >= 0, \"limit is negative\");\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        return Iterators.limit(iterable.iterator(), limitSize);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a view of the supplied iterable that wraps each generated\n", "   * {@link Iterator} through {@link Iterators#consumingIterator(Iterator)}.\n", "   *\n", "   * <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will\n", "   * get entries from {@link Queue#remove()} since {@link Queue}'s iteration\n", "   * order is undefined.  Calling {@link Iterator#hasNext()} on a generated\n", "   * iterator from the returned iterable may cause an item to be immediately\n", "   * dequeued for return on a subsequent call to {@link Iterator#next()}.\n", "   *\n", "   * @param iterable the iterable to wrap\n", "   * @return a view of the supplied iterable that wraps each generated iterator\n", "   *     through {@link Iterators#consumingIterator(Iterator)}; for queues,\n", "   *     an iterable that generates iterators that return and consume the\n", "   *     queue's elements in queue order\n", "   *\n", "   * @see Iterators#consumingIterator(Iterator)\n", "   * @since 2.0\n", "   */\n", "  public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable) {\n", "    if (iterable instanceof Queue) {\n", "      return new FluentIterable<T>() {\n", "        @Override\n", "        public Iterator<T> iterator() {\n", "          return new ConsumingQueueIterator<T>((Queue<T>) iterable);\n", "        }\n", "\n", "        @Override\n", "        public String toString() {\n", "          return \"Iterables.consumingIterable(...)\";\n", "        }\n", "      };\n", "    }\n", "\n", "    checkNotNull(iterable);\n", "\n", "    return new FluentIterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        return Iterators.consumingIterator(iterable.iterator());\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return \"Iterables.consumingIterable(...)\";\n", "      }\n", "    };\n", "  }\n", "\n", "  // Methods only in Iterables, not in Iterators\n", "\n", "  /**\n", "   * Determines if the given iterable contains no elements.\n", "   *\n", "   * <p>There is no precise {@link Iterator} equivalent to this method, since\n", "   * one can only ask an iterator whether it has any elements <i>remaining</i>\n", "   * (which one does using {@link Iterator#hasNext}).\n", "   *\n", "   * @return {@code true} if the iterable contains no elements\n", "   */\n", "  public static boolean isEmpty(Iterable<?> iterable) {\n", "    if (iterable instanceof Collection) {\n", "      return ((Collection<?>) iterable).isEmpty();\n", "    }\n", "    return !iterable.iterator().hasNext();\n", "  }\n", "\n", "  /**\n", "   * Returns an iterable over the merged contents of all given\n", "   * {@code iterables}. Equivalent entries will not be de-duplicated.\n", "   *\n", "   * <p>Callers must ensure that the source {@code iterables} are in\n", "   * non-descending order as this method does not sort its input.\n", "   *\n", "   * <p>For any equivalent elements across all {@code iterables}, it is\n", "   * undefined which element is returned first.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @Beta\n", "  public static <T> Iterable<T> mergeSorted(\n", "      final Iterable<? extends Iterable<? extends T>> iterables,\n", "      final Comparator<? super T> comparator) {\n", "    checkNotNull(iterables, \"iterables\");\n", "    checkNotNull(comparator, \"comparator\");\n", "    Iterable<T> iterable =\n", "        new FluentIterable<T>() {\n", "          @Override\n", "          public Iterator<T> iterator() {\n", "            return Iterators.mergeSorted(\n", "                Iterables.transform(iterables, Iterables.<T>toIterator()),\n", "                comparator);\n", "          }\n", "        };\n", "    return new UnmodifiableIterable<T>(iterable);\n", "  }\n", "\n", "  // TODO(user): Is this the best place for this? Move to fluent functions?\n", "  // Useful as a public method?\n", "  private static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator() {\n", "    return new Function<Iterable<? extends T>, Iterator<? extends T>>() {\n", "      @Override\n", "      public Iterator<? extends T> apply(Iterable<? extends T> iterable) {\n", "        return iterable.iterator();\n", "      }\n", "    };\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984]}}, {"33": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterators.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.base.Predicates.equalTo;\n", "import static com.google.common.base.Predicates.in;\n", "import static com.google.common.base.Predicates.not;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Objects;\n", "import com.google.common.base.Optional;\n", "import com.google.common.base.Preconditions;\n", "import com.google.common.base.Predicate;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.Enumeration;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.NoSuchElementException;\n", "import java.util.PriorityQueue;\n", "import java.util.Queue;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * This class contains static utility methods that operate on or return objects\n", " * of type {@link Iterator}. Except as noted, each method has a corresponding\n", " * {@link Iterable}-based method in the {@link Iterables} class.\n", " *\n", " * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators\n", " * produced in this class are <i>lazy</i>, which means that they only advance\n", " * the backing iteration when absolutely necessary.\n", " *\n", " * <p>See the Guava User Guide section on <a href=\n", " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\">\n", " * {@code Iterators}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Iterators {\n", "  private Iterators() {}\n", "\n", "  static final UnmodifiableListIterator<Object> EMPTY_LIST_ITERATOR =\n", "      new UnmodifiableListIterator<Object>() {\n", "        @Override\n", "        public boolean hasNext() {\n", "          return false;\n", "        }\n", "\n", "        @Override\n", "        public Object next() {\n", "          throw new NoSuchElementException();\n", "        }\n", "\n", "        @Override\n", "        public boolean hasPrevious() {\n", "          return false;\n", "        }\n", "\n", "        @Override\n", "        public Object previous() {\n", "          throw new NoSuchElementException();\n", "        }\n", "\n", "        @Override\n", "        public int nextIndex() {\n", "          return 0;\n", "        }\n", "\n", "        @Override\n", "        public int previousIndex() {\n", "          return -1;\n", "        }\n", "      };\n", "\n", "  /**\n", "   * Returns the empty iterator.\n", "   *\n", "   * <p>The {@link Iterable} equivalent of this method is {@link\n", "   * ImmutableSet#of()}.\n", "   *\n", "   * @deprecated Use {@code ImmutableSet.<T>of().iterator()} instead; or for\n", "   *     Java 7 or later, {@link Collections#emptyIterator}. This method is\n", "   *     scheduled for removal in May 2016.\n", "   */\n", "  @Deprecated\n", "  public static <T> UnmodifiableIterator<T> emptyIterator() {\n", "    return emptyListIterator();\n", "  }\n", "\n", "  /**\n", "   * Returns the empty iterator.\n", "   *\n", "   * <p>The {@link Iterable} equivalent of this method is {@link\n", "   * ImmutableSet#of()}.\n", "   */\n", "  // Casting to any type is safe since there are no actual elements.\n", "  @SuppressWarnings(\"unchecked\")\n", "  static <T> UnmodifiableListIterator<T> emptyListIterator() {\n", "    return (UnmodifiableListIterator<T>) EMPTY_LIST_ITERATOR;\n", "  }\n", "\n", "  private static final Iterator<Object> EMPTY_MODIFIABLE_ITERATOR =\n", "      new Iterator<Object>() {\n", "        @Override\n", "        public boolean hasNext() {\n", "          return false;\n", "        }\n", "\n", "        @Override\n", "        public Object next() {\n", "          throw new NoSuchElementException();\n", "        }\n", "\n", "        @Override\n", "        public void remove() {\n", "          checkRemove(false);\n", "        }\n", "      };\n", "\n", "  /**\n", "   * Returns the empty {@code Iterator} that throws\n", "   * {@link IllegalStateException} instead of\n", "   * {@link UnsupportedOperationException} on a call to\n", "   * {@link Iterator#remove()}.\n", "   */\n", "  // Casting to any type is safe since there are no actual elements.\n", "  @SuppressWarnings(\"unchecked\")\n", "  static <T> Iterator<T> emptyModifiableIterator() {\n", "    return (Iterator<T>) EMPTY_MODIFIABLE_ITERATOR;\n", "  }\n", "\n", "  /** Returns an unmodifiable view of {@code iterator}. */\n", "  public static <T> UnmodifiableIterator<T> unmodifiableIterator(final Iterator<T> iterator) {\n", "    checkNotNull(iterator);\n", "    if (iterator instanceof UnmodifiableIterator) {\n", "      return (UnmodifiableIterator<T>) iterator;\n", "    }\n", "    return new UnmodifiableIterator<T>() {\n", "      @Override\n", "      public boolean hasNext() {\n", "        return iterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public T next() {\n", "        return iterator.next();\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   * @since 10.0\n", "   */\n", "  @Deprecated\n", "  public static <T> UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator<T> iterator) {\n", "    return checkNotNull(iterator);\n", "  }\n", "\n", "  /**\n", "   * Returns the number of elements remaining in {@code iterator}. The iterator\n", "   * will be left exhausted: its {@code hasNext()} method will return\n", "   * {@code false}.\n", "   */\n", "  public static int size(Iterator<?> iterator) {\n", "    int count = 0;\n", "    while (iterator.hasNext()) {\n", "      iterator.next();\n", "      count++;\n", "    }\n", "    return count;\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code iterator} contains {@code element}.\n", "   */\n", "  public static boolean contains(Iterator<?> iterator, @Nullable Object element) {\n", "    return any(iterator, equalTo(element));\n", "  }\n", "\n", "  /**\n", "   * Traverses an iterator and removes every element that belongs to the\n", "   * provided collection. The iterator will be left exhausted: its\n", "   * {@code hasNext()} method will return {@code false}.\n", "   *\n", "   * @param removeFrom the iterator to (potentially) remove elements from\n", "   * @param elementsToRemove the elements to remove\n", "   * @return {@code true} if any element was removed from {@code iterator}\n", "   */\n", "  public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove) {\n", "    return removeIf(removeFrom, in(elementsToRemove));\n", "  }\n", "\n", "  /**\n", "   * Removes every element that satisfies the provided predicate from the\n", "   * iterator. The iterator will be left exhausted: its {@code hasNext()}\n", "   * method will return {@code false}.\n", "   *\n", "   * @param removeFrom the iterator to (potentially) remove elements from\n", "   * @param predicate a predicate that determines whether an element should\n", "   *     be removed\n", "   * @return {@code true} if any elements were removed from the iterator\n", "   * @since 2.0\n", "   */\n", "  public static <T> boolean removeIf(Iterator<T> removeFrom, Predicate<? super T> predicate) {\n", "    checkNotNull(predicate);\n", "    boolean modified = false;\n", "    while (removeFrom.hasNext()) {\n", "      if (predicate.apply(removeFrom.next())) {\n", "        removeFrom.remove();\n", "        modified = true;\n", "      }\n", "    }\n", "    return modified;\n", "  }\n", "\n", "  /**\n", "   * Traverses an iterator and removes every element that does not belong to the\n", "   * provided collection. The iterator will be left exhausted: its\n", "   * {@code hasNext()} method will return {@code false}.\n", "   *\n", "   * @param removeFrom the iterator to (potentially) remove elements from\n", "   * @param elementsToRetain the elements to retain\n", "   * @return {@code true} if any element was removed from {@code iterator}\n", "   */\n", "  public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain) {\n", "    return removeIf(removeFrom, not(in(elementsToRetain)));\n", "  }\n", "\n", "  /**\n", "   * Determines whether two iterators contain equal elements in the same order.\n", "   * More specifically, this method returns {@code true} if {@code iterator1}\n", "   * and {@code iterator2} contain the same number of elements and every element\n", "   * of {@code iterator1} is equal to the corresponding element of\n", "   * {@code iterator2}.\n", "   *\n", "   * <p>Note that this will modify the supplied iterators, since they will have\n", "   * been advanced some number of elements forward.\n", "   */\n", "  public static boolean elementsEqual(Iterator<?> iterator1, Iterator<?> iterator2) {\n", "    while (iterator1.hasNext()) {\n", "      if (!iterator2.hasNext()) {\n", "        return false;\n", "      }\n", "      Object o1 = iterator1.next();\n", "      Object o2 = iterator2.next();\n", "      if (!Objects.equal(o1, o2)) {\n", "        return false;\n", "      }\n", "    }\n", "    return !iterator2.hasNext();\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of {@code iterator}, with the format\n", "   * {@code [e1, e2, ..., en]}. The iterator will be left exhausted: its\n", "   * {@code hasNext()} method will return {@code false}.\n", "   */\n", "  public static String toString(Iterator<?> iterator) {\n", "    return Collections2.STANDARD_JOINER\n", "        .appendTo(new StringBuilder().append('['), iterator)\n", "        .append(']')\n", "        .toString();\n", "  }\n", "\n", "  /**\n", "   * Returns the single element contained in {@code iterator}.\n", "   *\n", "   * @throws NoSuchElementException if the iterator is empty\n", "   * @throws IllegalArgumentException if the iterator contains multiple\n", "   *     elements.  The state of the iterator is unspecified.\n", "   */\n", "  public static <T> T getOnlyElement(Iterator<T> iterator) {\n", "    T first = iterator.next();\n", "    if (!iterator.hasNext()) {\n", "      return first;\n", "    }\n", "\n", "    StringBuilder sb = new StringBuilder();\n", "    sb.append(\"expected one element but was: <\" + first);\n", "    for (int i = 0; i < 4 && iterator.hasNext(); i++) {\n", "      sb.append(\", \" + iterator.next());\n", "    }\n", "    if (iterator.hasNext()) {\n", "      sb.append(\", ...\");\n", "    }\n", "    sb.append('>');\n", "\n", "    throw new IllegalArgumentException(sb.toString());\n", "  }\n", "\n", "  /**\n", "   * Returns the single element contained in {@code iterator}, or {@code\n", "   * defaultValue} if the iterator is empty.\n", "   *\n", "   * @throws IllegalArgumentException if the iterator contains multiple\n", "   *     elements.  The state of the iterator is unspecified.\n", "   */\n", "  @Nullable\n", "  public static <T> T getOnlyElement(Iterator<? extends T> iterator, @Nullable T defaultValue) {\n", "    return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;\n", "  }\n", "\n", "  /**\n", "   * Adds all elements in {@code iterator} to {@code collection}. The iterator\n", "   * will be left exhausted: its {@code hasNext()} method will return\n", "   * {@code false}.\n", "   *\n", "   * @return {@code true} if {@code collection} was modified as a result of this\n", "   *         operation\n", "   */\n", "  public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator) {\n", "    checkNotNull(addTo);\n", "    checkNotNull(iterator);\n", "    boolean wasModified = false;\n", "    while (iterator.hasNext()) {\n", "      wasModified |= addTo.add(iterator.next());\n", "    }\n", "    return wasModified;\n", "  }\n", "\n", "  /**\n", "   * Returns the number of elements in the specified iterator that equal the\n", "   * specified object. The iterator will be left exhausted: its\n", "   * {@code hasNext()} method will return {@code false}.\n", "   *\n", "   * @see Collections#frequency\n", "   */\n", "  public static int frequency(Iterator<?> iterator, @Nullable Object element) {\n", "    return size(filter(iterator, equalTo(element)));\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator that cycles indefinitely over the elements of {@code\n", "   * iterable}.\n", "   *\n", "   * <p>The returned iterator supports {@code remove()} if the provided iterator\n", "   * does. After {@code remove()} is called, subsequent cycles omit the removed\n", "   * element, which is no longer in {@code iterable}. The iterator's\n", "   * {@code hasNext()} method returns {@code true} until {@code iterable} is\n", "   * empty.\n", "   *\n", "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an\n", "   * infinite loop. You should use an explicit {@code break} or be certain that\n", "   * you will eventually remove all the elements.\n", "   */\n", "  public static <T> Iterator<T> cycle(final Iterable<T> iterable) {\n", "    checkNotNull(iterable);\n", "    return new Iterator<T>() {\n", "      Iterator<T> iterator = emptyModifiableIterator();\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        /*\n", "         * Don't store a new Iterator until we know the user can't remove() the last returned\n", "         * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating\n", "         * the new one. The result is a ConcurrentModificationException or other bad behavior.\n", "         *\n", "         * (If we decide that we really, really hate allocating two Iterators per cycle instead of\n", "         * one, we can optimistically store the new Iterator and then be willing to throw it out if\n", "         * the user calls remove().)\n", "         */\n", "        return iterator.hasNext() || iterable.iterator().hasNext();\n", "      }\n", "\n", "      @Override\n", "      public T next() {\n", "        if (!iterator.hasNext()) {\n", "          iterator = iterable.iterator();\n", "          if (!iterator.hasNext()) {\n", "            throw new NoSuchElementException();\n", "          }\n", "        }\n", "        return iterator.next();\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        iterator.remove();\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator that cycles indefinitely over the provided elements.\n", "   *\n", "   * <p>The returned iterator supports {@code remove()}. After {@code remove()}\n", "   * is called, subsequent cycles omit the removed\n", "   * element, but {@code elements} does not change. The iterator's\n", "   * {@code hasNext()} method returns {@code true} until all of the original\n", "   * elements have been removed.\n", "   *\n", "   * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an\n", "   * infinite loop. You should use an explicit {@code break} or be certain that\n", "   * you will eventually remove all the elements.\n", "   */\n", "  public static <T> Iterator<T> cycle(T... elements) {\n", "    return cycle(Lists.newArrayList(elements));\n", "  }\n", "\n", "  /**\n", "   * Combines two iterators into a single iterator. The returned iterator\n", "   * iterates across the elements in {@code a}, followed by the elements in\n", "   * {@code b}. The source iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterator supports {@code remove()} when the corresponding\n", "   * input iterator supports it.\n", "   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n", "   */\n", "  public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b) {\n", "    checkNotNull(a);\n", "    checkNotNull(b);\n", "    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b));\n", "  }\n", "\n", "  /**\n", "   * Combines three iterators into a single iterator. The returned iterator\n", "   * iterates across the elements in {@code a}, followed by the elements in\n", "   * {@code b}, followed by the elements in {@code c}. The source iterators\n", "   * are not polled until necessary.\n", "   *\n", "   * <p>The returned iterator supports {@code remove()} when the corresponding\n", "   * input iterator supports it.\n", "   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n", "   */\n", "  public static <T> Iterator<T> concat(\n", "      Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c) {\n", "    checkNotNull(a);\n", "    checkNotNull(b);\n", "    checkNotNull(c);\n", "    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b, c));\n", "  }\n", "\n", "  /**\n", "   * Combines four iterators into a single iterator. The returned iterator\n", "   * iterates across the elements in {@code a}, followed by the elements in\n", "   * {@code b}, followed by the elements in {@code c}, followed by the elements\n", "   * in {@code d}. The source iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterator supports {@code remove()} when the corresponding\n", "   * input iterator supports it.\n", "   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n", "   */\n", "  public static <T> Iterator<T> concat(\n", "      Iterator<? extends T> a,\n", "      Iterator<? extends T> b,\n", "      Iterator<? extends T> c,\n", "      Iterator<? extends T> d) {\n", "    checkNotNull(a);\n", "    checkNotNull(b);\n", "    checkNotNull(c);\n", "    checkNotNull(d);\n", "    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b, c, d));\n", "  }\n", "\n", "  /**\n", "   * Combines multiple iterators into a single iterator. The returned iterator\n", "   * iterates across the elements of each iterator in {@code inputs}. The input\n", "   * iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterator supports {@code remove()} when the corresponding\n", "   * input iterator supports it.\n", "   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n", "   *\n", "   * @throws NullPointerException if any of the provided iterators is null\n", "   */\n", "  public static <T> Iterator<T> concat(Iterator<? extends T>... inputs) {\n", "    for (Iterator<? extends T> input : checkNotNull(inputs)) {\n", "      checkNotNull(input);\n", "    }\n", "    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(inputs));\n", "  }\n", "\n", "  /**\n", "   * Combines multiple iterators into a single iterator. The returned iterator\n", "   * iterates across the elements of each iterator in {@code inputs}. The input\n", "   * iterators are not polled until necessary.\n", "   *\n", "   * <p>The returned iterator supports {@code remove()} when the corresponding\n", "   * input iterator supports it. The methods of the returned iterator may throw\n", "   * {@code NullPointerException} if any of the input iterators is null.\n", "   *\n", "   * <p><b>Note:</b> the current implementation is not suitable for nested\n", "   * concatenated iterators, i.e. the following should be avoided when in a loop:\n", "   * {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the\n", "   * resulting iterator has a cubic complexity to the depth of the nesting.\n", "   */\n", "  public static <T> Iterator<T> concat(final Iterator<? extends Iterator<? extends T>> inputs) {\n", "    checkNotNull(inputs);\n", "    return new Iterator<T>() {\n", "      Iterator<? extends T> current = emptyIterator();\n", "      Iterator<? extends T> removeFrom;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        // http://code.google.com/p/google-collections/issues/detail?id=151\n", "        // current.hasNext() might be relatively expensive, worth minimizing.\n", "        boolean currentHasNext;\n", "        // checkNotNull eager for GWT\n", "        // note: it must be here & not where 'current' is assigned,\n", "        // because otherwise we'll have called inputs.next() before throwing\n", "        // the first NPE, and the next time around we'll call inputs.next()\n", "        // again, incorrectly moving beyond the error.\n", "        while (!(currentHasNext = checkNotNull(current).hasNext()) && inputs.hasNext()) {\n", "          current = inputs.next();\n", "        }\n", "        return currentHasNext;\n", "      }\n", "\n", "      @Override\n", "      public T next() {\n", "        if (!hasNext()) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        removeFrom = current;\n", "        return current.next();\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        checkRemove(removeFrom != null);\n", "        removeFrom.remove();\n", "        removeFrom = null;\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Divides an iterator into unmodifiable sublists of the given size (the final\n", "   * list may be smaller). For example, partitioning an iterator containing\n", "   * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code\n", "   * [[a, b, c], [d, e]]} -- an outer iterator containing two inner lists of\n", "   * three and two elements, all in the original order.\n", "   *\n", "   * <p>The returned lists implement {@link java.util.RandomAccess}.\n", "   *\n", "   * @param iterator the iterator to return a partitioned view of\n", "   * @param size the desired size of each partition (the last may be smaller)\n", "   * @return an iterator of immutable lists containing the elements of {@code\n", "   *     iterator} divided into partitions\n", "   * @throws IllegalArgumentException if {@code size} is nonpositive\n", "   */\n", "  public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size) {\n", "    return partitionImpl(iterator, size, false);\n", "  }\n", "\n", "  /**\n", "   * Divides an iterator into unmodifiable sublists of the given size, padding\n", "   * the final iterator with null values if necessary. For example, partitioning\n", "   * an iterator containing {@code [a, b, c, d, e]} with a partition size of 3\n", "   * yields {@code [[a, b, c], [d, e, null]]} -- an outer iterator containing\n", "   * two inner lists of three elements each, all in the original order.\n", "   *\n", "   * <p>The returned lists implement {@link java.util.RandomAccess}.\n", "   *\n", "   * @param iterator the iterator to return a partitioned view of\n", "   * @param size the desired size of each partition\n", "   * @return an iterator of immutable lists containing the elements of {@code\n", "   *     iterator} divided into partitions (the final iterable may have\n", "   *     trailing null elements)\n", "   * @throws IllegalArgumentException if {@code size} is nonpositive\n", "   */\n", "  public static <T> UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size) {\n", "    return partitionImpl(iterator, size, true);\n", "  }\n", "\n", "  private static <T> UnmodifiableIterator<List<T>> partitionImpl(\n", "      final Iterator<T> iterator, final int size, final boolean pad) {\n", "    checkNotNull(iterator);\n", "    checkArgument(size > 0);\n", "    return new UnmodifiableIterator<List<T>>() {\n", "      @Override\n", "      public boolean hasNext() {\n", "        return iterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public List<T> next() {\n", "        if (!hasNext()) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        Object[] array = new Object[size];\n", "        int count = 0;\n", "        for (; count < size && iterator.hasNext(); count++) {\n", "          array[count] = iterator.next();\n", "        }\n", "        for (int i = count; i < size; i++) {\n", "          array[i] = null; // for GWT\n", "        }\n", "\n", "        @SuppressWarnings(\"unchecked\") // we only put Ts in it\n", "        List<T> list = Collections.unmodifiableList((List<T>) Arrays.asList(array));\n", "        return (pad || count == size) ? list : list.subList(0, count);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns the elements of {@code unfiltered} that satisfy the input predicate\n", "   * {@code retainIfTrue}.\n", "   */\n", "  @CheckReturnValue\n", "  public static <T> UnmodifiableIterator<T> filter(\n", "      final Iterator<T> unfiltered, final Predicate<? super T> retainIfTrue) {\n", "    checkNotNull(unfiltered);\n", "    checkNotNull(retainIfTrue);\n", "    return new AbstractIterator<T>() {\n", "      @Override\n", "      protected T computeNext() {\n", "        while (unfiltered.hasNext()) {\n", "          T element = unfiltered.next();\n", "          if (retainIfTrue.apply(element)) {\n", "            return element;\n", "          }\n", "        }\n", "        return endOfData();\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if one or more elements returned by {@code iterator}\n", "   * satisfy the given predicate.\n", "   */\n", "  public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate) {\n", "    return indexOf(iterator, predicate) != -1;\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if every element returned by {@code iterator}\n", "   * satisfies the given predicate. If {@code iterator} is empty, {@code true}\n", "   * is returned.\n", "   */\n", "  public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate) {\n", "    checkNotNull(predicate);\n", "    while (iterator.hasNext()) {\n", "      T element = iterator.next();\n", "      if (!predicate.apply(element)) {\n", "        return false;\n", "      }\n", "    }\n", "    return true;\n", "  }\n", "\n", "  /**\n", "   * Returns the first element in {@code iterator} that satisfies the given\n", "   * predicate; use this method only when such an element is known to exist. If\n", "   * no such element is found, the iterator will be left exhausted: its {@code\n", "   * hasNext()} method will return {@code false}. If it is possible that\n", "   * <i>no</i> element will match, use {@link #tryFind} or {@link\n", "   * #find(Iterator, Predicate, Object)} instead.\n", "   *\n", "   * @throws NoSuchElementException if no element in {@code iterator} matches\n", "   *     the given predicate\n", "   */\n", "  public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate) {\n", "    return filter(iterator, predicate).next();\n", "  }\n", "\n", "  /**\n", "   * Returns the first element in {@code iterator} that satisfies the given\n", "   * predicate. If no such element is found, {@code defaultValue} will be\n", "   * returned from this method and the iterator will be left exhausted: its\n", "   * {@code hasNext()} method will return {@code false}. Note that this can\n", "   * usually be handled more naturally using {@code\n", "   * tryFind(iterator, predicate).or(defaultValue)}.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  @Nullable\n", "  public static <T> T find(\n", "      Iterator<? extends T> iterator, Predicate<? super T> predicate, @Nullable T defaultValue) {\n", "    return getNext(filter(iterator, predicate), defaultValue);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@link Optional} containing the first element in {@code\n", "   * iterator} that satisfies the given predicate, if such an element exists. If\n", "   * no such element is found, an empty {@link Optional} will be returned from\n", "   * this method and the iterator will be left exhausted: its {@code\n", "   * hasNext()} method will return {@code false}.\n", "   *\n", "   * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code\n", "   * null}. If {@code null} is matched in {@code iterator}, a\n", "   * NullPointerException will be thrown.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate) {\n", "    UnmodifiableIterator<T> filteredIterator = filter(iterator, predicate);\n", "    return filteredIterator.hasNext()\n", "        ? Optional.of(filteredIterator.next())\n", "        : Optional.<T>absent();\n", "  }\n", "\n", "  /**\n", "   * Returns the index in {@code iterator} of the first element that satisfies\n", "   * the provided {@code predicate}, or {@code -1} if the Iterator has no such\n", "   * elements.\n", "   *\n", "   * <p>More formally, returns the lowest index {@code i} such that\n", "   * {@code predicate.apply(Iterators.get(iterator, i))} returns {@code true},\n", "   * or {@code -1} if there is no such index.\n", "   *\n", "   * <p>If -1 is returned, the iterator will be left exhausted: its\n", "   * {@code hasNext()} method will return {@code false}.  Otherwise,\n", "   * the iterator will be set to the element which satisfies the\n", "   * {@code predicate}.\n", "   *\n", "   * @since 2.0\n", "   */\n", "  public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate) {\n", "    checkNotNull(predicate, \"predicate\");\n", "    for (int i = 0; iterator.hasNext(); i++) {\n", "      T current = iterator.next();\n", "      if (predicate.apply(current)) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator that applies {@code function} to each element of {@code\n", "   * fromIterator}.\n", "   *\n", "   * <p>The returned iterator supports {@code remove()} if the provided iterator\n", "   * does. After a successful {@code remove()} call, {@code fromIterator} no\n", "   * longer contains the corresponding element.\n", "   */\n", "  public static <F, T> Iterator<T> transform(\n", "      final Iterator<F> fromIterator, final Function<? super F, ? extends T> function) {\n", "    checkNotNull(function);\n", "    return new TransformedIterator<F, T>(fromIterator) {\n", "      @Override\n", "      T transform(F from) {\n", "        return function.apply(from);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Advances {@code iterator} {@code position + 1} times, returning the\n", "   * element at the {@code position}th position.\n", "   *\n", "   * @param position position of the element to return\n", "   * @return the element at the specified position in {@code iterator}\n", "   * @throws IndexOutOfBoundsException if {@code position} is negative or\n", "   *     greater than or equal to the number of elements remaining in\n", "   *     {@code iterator}\n", "   */\n", "  public static <T> T get(Iterator<T> iterator, int position) {\n", "    checkNonnegative(position);\n", "    int skipped = advance(iterator, position);\n", "    if (!iterator.hasNext()) {\n", "      throw new IndexOutOfBoundsException(\n", "          \"position (\"\n", "              + position\n", "              + \") must be less than the number of elements that remained (\"\n", "              + skipped\n", "              + \")\");\n", "    }\n", "    return iterator.next();\n", "  }\n", "\n", "  static void checkNonnegative(int position) {\n", "    if (position < 0) {\n", "      throw new IndexOutOfBoundsException(\"position (\" + position + \") must not be negative\");\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Advances {@code iterator} {@code position + 1} times, returning the\n", "   * element at the {@code position}th position or {@code defaultValue}\n", "   * otherwise.\n", "   *\n", "   * @param position position of the element to return\n", "   * @param defaultValue the default value to return if the iterator is empty\n", "   *     or if {@code position} is greater than the number of elements\n", "   *     remaining in {@code iterator}\n", "   * @return the element at the specified position in {@code iterator} or\n", "   *     {@code defaultValue} if {@code iterator} produces fewer than\n", "   *     {@code position + 1} elements.\n", "   * @throws IndexOutOfBoundsException if {@code position} is negative\n", "   * @since 4.0\n", "   */\n", "  @Nullable\n", "  public static <T> T get(Iterator<? extends T> iterator, int position, @Nullable T defaultValue) {\n", "    checkNonnegative(position);\n", "    advance(iterator, position);\n", "    return getNext(iterator, defaultValue);\n", "  }\n", "\n", "  /**\n", "   * Returns the next element in {@code iterator} or {@code defaultValue} if\n", "   * the iterator is empty.  The {@link Iterables} analog to this method is\n", "   * {@link Iterables#getFirst}.\n", "   *\n", "   * @param defaultValue the default value to return if the iterator is empty\n", "   * @return the next element of {@code iterator} or the default value\n", "   * @since 7.0\n", "   */\n", "  @Nullable\n", "  public static <T> T getNext(Iterator<? extends T> iterator, @Nullable T defaultValue) {\n", "    return iterator.hasNext() ? iterator.next() : defaultValue;\n", "  }\n", "\n", "  /**\n", "   * Advances {@code iterator} to the end, returning the last element.\n", "   *\n", "   * @return the last element of {@code iterator}\n", "   * @throws NoSuchElementException if the iterator is empty\n", "   */\n", "  public static <T> T getLast(Iterator<T> iterator) {\n", "    while (true) {\n", "      T current = iterator.next();\n", "      if (!iterator.hasNext()) {\n", "        return current;\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Advances {@code iterator} to the end, returning the last element or\n", "   * {@code defaultValue} if the iterator is empty.\n", "   *\n", "   * @param defaultValue the default value to return if the iterator is empty\n", "   * @return the last element of {@code iterator}\n", "   * @since 3.0\n", "   */\n", "  @Nullable\n", "  public static <T> T getLast(Iterator<? extends T> iterator, @Nullable T defaultValue) {\n", "    return iterator.hasNext() ? getLast(iterator) : defaultValue;\n", "  }\n", "\n", "  /**\n", "   * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times\n", "   * or until {@code hasNext()} returns {@code false}, whichever comes first.\n", "   *\n", "   * @return the number of elements the iterator was advanced\n", "   * @since 13.0 (since 3.0 as {@code Iterators.skip})\n", "   */\n", "  public static int advance(Iterator<?> iterator, int numberToAdvance) {\n", "    checkNotNull(iterator);\n", "    checkArgument(numberToAdvance >= 0, \"numberToAdvance must be nonnegative\");\n", "\n", "    int i;\n", "    for (i = 0; i < numberToAdvance && iterator.hasNext(); i++) {\n", "      iterator.next();\n", "    }\n", "    return i;\n", "  }\n", "\n", "  /**\n", "   * Creates an iterator returning the first {@code limitSize} elements of the\n", "   * given iterator. If the original iterator does not contain that many\n", "   * elements, the returned iterator will have the same behavior as the original\n", "   * iterator. The returned iterator supports {@code remove()} if the original\n", "   * iterator does.\n", "   *\n", "   * @param iterator the iterator to limit\n", "   * @param limitSize the maximum number of elements in the returned iterator\n", "   * @throws IllegalArgumentException if {@code limitSize} is negative\n", "   * @since 3.0\n", "   */\n", "  public static <T> Iterator<T> limit(final Iterator<T> iterator, final int limitSize) {\n", "    checkNotNull(iterator);\n", "    checkArgument(limitSize >= 0, \"limit is negative\");\n", "    return new Iterator<T>() {\n", "      private int count;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return count < limitSize && iterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public T next() {\n", "        if (!hasNext()) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        count++;\n", "        return iterator.next();\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        iterator.remove();\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a view of the supplied {@code iterator} that removes each element\n", "   * from the supplied {@code iterator} as it is returned.\n", "   *\n", "   * <p>The provided iterator must support {@link Iterator#remove()} or\n", "   * else the returned iterator will fail on the first call to {@code\n", "   * next}.\n", "   *\n", "   * @param iterator the iterator to remove and return elements from\n", "   * @return an iterator that removes and returns elements from the\n", "   *     supplied iterator\n", "   * @since 2.0\n", "   */\n", "  public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator) {\n", "    checkNotNull(iterator);\n", "    return new UnmodifiableIterator<T>() {\n", "      @Override\n", "      public boolean hasNext() {\n", "        return iterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public T next() {\n", "        T next = iterator.next();\n", "        iterator.remove();\n", "        return next;\n", "      }\n", "\n", "      @Override\n", "      public String toString() {\n", "        return \"Iterators.consumingIterator(...)\";\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Deletes and returns the next value from the iterator, or returns\n", "   * {@code null} if there is no such value.\n", "   */\n", "  @Nullable\n", "  static <T> T pollNext(Iterator<T> iterator) {\n", "    if (iterator.hasNext()) {\n", "      T result = iterator.next();\n", "      iterator.remove();\n", "      return result;\n", "    } else {\n", "      return null;\n", "    }\n", "  }\n", "\n", "  // Methods only in Iterators, not in Iterables\n", "\n", "  /**\n", "   * Clears the iterator using its remove method.\n", "   */\n", "  static void clear(Iterator<?> iterator) {\n", "    checkNotNull(iterator);\n", "    while (iterator.hasNext()) {\n", "      iterator.next();\n", "      iterator.remove();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator containing the elements of {@code array} in order. The\n", "   * returned iterator is a view of the array; subsequent changes to the array\n", "   * will be reflected in the iterator.\n", "   *\n", "   * <p><b>Note:</b> It is often preferable to represent your data using a\n", "   * collection type, for example using {@link Arrays#asList(Object[])}, making\n", "   * this method unnecessary.\n", "   *\n", "   * <p>The {@code Iterable} equivalent of this method is either {@link\n", "   * Arrays#asList(Object[])}, {@link ImmutableList#copyOf(Object[])}},\n", "   * or {@link ImmutableList#of}.\n", "   */\n", "  public static <T> UnmodifiableIterator<T> forArray(final T... array) {\n", "    return forArray(array, 0, array.length, 0);\n", "  }\n", "\n", "  /**\n", "   * Returns a list iterator containing the elements in the specified range of\n", "   * {@code array} in order, starting at the specified index.\n", "   *\n", "   * <p>The {@code Iterable} equivalent of this method is {@code\n", "   * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.\n", "   */\n", "  static <T> UnmodifiableListIterator<T> forArray(\n", "      final T[] array, final int offset, int length, int index) {\n", "    checkArgument(length >= 0);\n", "    int end = offset + length;\n", "\n", "    // Technically we should give a slightly more descriptive error on overflow\n", "    Preconditions.checkPositionIndexes(offset, end, array.length);\n", "    Preconditions.checkPositionIndex(index, length);\n", "    if (length == 0) {\n", "      return emptyListIterator();\n", "    }\n", "\n", "    /*\n", "     * We can't use call the two-arg constructor with arguments (offset, end)\n", "     * because the returned Iterator is a ListIterator that may be moved back\n", "     * past the beginning of the iteration.\n", "     */\n", "    return new AbstractIndexedListIterator<T>(length, index) {\n", "      @Override\n", "      protected T get(int index) {\n", "        return array[offset + index];\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator containing only {@code value}.\n", "   *\n", "   * <p>The {@link Iterable} equivalent of this method is {@link\n", "   * Collections#singleton}.\n", "   */\n", "  public static <T> UnmodifiableIterator<T> singletonIterator(@Nullable final T value) {\n", "    return new UnmodifiableIterator<T>() {\n", "      boolean done;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return !done;\n", "      }\n", "\n", "      @Override\n", "      public T next() {\n", "        if (done) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        done = true;\n", "        return value;\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Adapts an {@code Enumeration} to the {@code Iterator} interface.\n", "   *\n", "   * <p>This method has no equivalent in {@link Iterables} because viewing an\n", "   * {@code Enumeration} as an {@code Iterable} is impossible. However, the\n", "   * contents can be <i>copied</i> into a collection using {@link\n", "   * Collections#list}.\n", "   */\n", "  public static <T> UnmodifiableIterator<T> forEnumeration(final Enumeration<T> enumeration) {\n", "    checkNotNull(enumeration);\n", "    return new UnmodifiableIterator<T>() {\n", "      @Override\n", "      public boolean hasNext() {\n", "        return enumeration.hasMoreElements();\n", "      }\n", "\n", "      @Override\n", "      public T next() {\n", "        return enumeration.nextElement();\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Adapts an {@code Iterator} to the {@code Enumeration} interface.\n", "   *\n", "   * <p>The {@code Iterable} equivalent of this method is either {@link\n", "   * Collections#enumeration} (if you have a {@link Collection}), or\n", "   * {@code Iterators.asEnumeration(collection.iterator())}.\n", "   */\n", "  public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator) {\n", "    checkNotNull(iterator);\n", "    return new Enumeration<T>() {\n", "      @Override\n", "      public boolean hasMoreElements() {\n", "        return iterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public T nextElement() {\n", "        return iterator.next();\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Implementation of PeekingIterator that avoids peeking unless necessary.\n", "   */\n", "  private static class PeekingImpl<E> implements PeekingIterator<E> {\n", "\n", "    private final Iterator<? extends E> iterator;\n", "    private boolean hasPeeked;\n", "    private E peekedElement;\n", "\n", "    public PeekingImpl(Iterator<? extends E> iterator) {\n", "      this.iterator = checkNotNull(iterator);\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return hasPeeked || iterator.hasNext();\n", "    }\n", "\n", "    @Override\n", "    public E next() {\n", "      if (!hasPeeked) {\n", "        return iterator.next();\n", "      }\n", "      E result = peekedElement;\n", "      hasPeeked = false;\n", "      peekedElement = null;\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "      checkState(!hasPeeked, \"Can't remove after you've peeked at next\");\n", "      iterator.remove();\n", "    }\n", "\n", "    @Override\n", "    public E peek() {\n", "      if (!hasPeeked) {\n", "        peekedElement = iterator.next();\n", "        hasPeeked = true;\n", "      }\n", "      return peekedElement;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code PeekingIterator} backed by the given iterator.\n", "   *\n", "   * <p>Calls to the {@code peek} method with no intervening calls to {@code\n", "   * next} do not affect the iteration, and hence return the same object each\n", "   * time. A subsequent call to {@code next} is guaranteed to return the same\n", "   * object again. For example: <pre>   {@code\n", "   *\n", "   *   PeekingIterator<String> peekingIterator =\n", "   *       Iterators.peekingIterator(Iterators.forArray(\"a\", \"b\"));\n", "   *   String a1 = peekingIterator.peek(); // returns \"a\"\n", "   *   String a2 = peekingIterator.peek(); // also returns \"a\"\n", "   *   String a3 = peekingIterator.next(); // also returns \"a\"}</pre>\n", "   *\n", "   * <p>Any structural changes to the underlying iteration (aside from those\n", "   * performed by the iterator's own {@link PeekingIterator#remove()} method)\n", "   * will leave the iterator in an undefined state.\n", "   *\n", "   * <p>The returned iterator does not support removal after peeking, as\n", "   * explained by {@link PeekingIterator#remove()}.\n", "   *\n", "   * <p>Note: If the given iterator is already a {@code PeekingIterator},\n", "   * it <i>might</i> be returned to the caller, although this is neither\n", "   * guaranteed to occur nor required to be consistent.  For example, this\n", "   * method <i>might</i> choose to pass through recognized implementations of\n", "   * {@code PeekingIterator} when the behavior of the implementation is\n", "   * known to meet the contract guaranteed by this method.\n", "   *\n", "   * <p>There is no {@link Iterable} equivalent to this method, so use this\n", "   * method to wrap each individual iterator as it is generated.\n", "   *\n", "   * @param iterator the backing iterator. The {@link PeekingIterator} assumes\n", "   *     ownership of this iterator, so users should cease making direct calls\n", "   *     to it after calling this method.\n", "   * @return a peeking iterator backed by that iterator. Apart from the\n", "   *     additional {@link PeekingIterator#peek()} method, this iterator behaves\n", "   *     exactly the same as {@code iterator}.\n", "   */\n", "  public static <T> PeekingIterator<T> peekingIterator(Iterator<? extends T> iterator) {\n", "    if (iterator instanceof PeekingImpl) {\n", "      // Safe to cast <? extends T> to <T> because PeekingImpl only uses T\n", "      // covariantly (and cannot be subclassed to add non-covariant uses).\n", "      @SuppressWarnings(\"unchecked\")\n", "      PeekingImpl<T> peeking = (PeekingImpl<T>) iterator;\n", "      return peeking;\n", "    }\n", "    return new PeekingImpl<T>(iterator);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   * @since 10.0\n", "   */\n", "  @Deprecated\n", "  public static <T> PeekingIterator<T> peekingIterator(PeekingIterator<T> iterator) {\n", "    return checkNotNull(iterator);\n", "  }\n", "\n", "  /**\n", "   * Returns an iterator over the merged contents of all given\n", "   * {@code iterators}, traversing every element of the input iterators.\n", "   * Equivalent entries will not be de-duplicated.\n", "   *\n", "   * <p>Callers must ensure that the source {@code iterators} are in\n", "   * non-descending order as this method does not sort its input.\n", "   *\n", "   * <p>For any equivalent elements across all {@code iterators}, it is\n", "   * undefined which element is returned first.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @Beta\n", "  public static <T> UnmodifiableIterator<T> mergeSorted(\n", "      Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator) {\n", "    checkNotNull(iterators, \"iterators\");\n", "    checkNotNull(comparator, \"comparator\");\n", "\n", "    return new MergingIterator<T>(iterators, comparator);\n", "  }\n", "\n", "  /**\n", "   * An iterator that performs a lazy N-way merge, calculating the next value\n", "   * each time the iterator is polled. This amortizes the sorting cost over the\n", "   * iteration and requires less memory than sorting all elements at once.\n", "   *\n", "   * <p>Retrieving a single element takes approximately O(log(M)) time, where M\n", "   * is the number of iterators. (Retrieving all elements takes approximately\n", "   * O(N*log(M)) time, where N is the total number of elements.)\n", "   */\n", "  private static class MergingIterator<T> extends UnmodifiableIterator<T> {\n", "    final Queue<PeekingIterator<T>> queue;\n", "\n", "    public MergingIterator(\n", "        Iterable<? extends Iterator<? extends T>> iterators,\n", "        final Comparator<? super T> itemComparator) {\n", "      // A comparator that's used by the heap, allowing the heap\n", "      // to be sorted based on the top of each iterator.\n", "      Comparator<PeekingIterator<T>> heapComparator =\n", "          new Comparator<PeekingIterator<T>>() {\n", "            @Override\n", "            public int compare(PeekingIterator<T> o1, PeekingIterator<T> o2) {\n", "              return itemComparator.compare(o1.peek(), o2.peek());\n", "            }\n", "          };\n", "\n", "      queue = new PriorityQueue<PeekingIterator<T>>(2, heapComparator);\n", "\n", "      for (Iterator<? extends T> iterator : iterators) {\n", "        if (iterator.hasNext()) {\n", "          queue.add(Iterators.peekingIterator(iterator));\n", "        }\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return !queue.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public T next() {\n", "      PeekingIterator<T> nextIter = queue.remove();\n", "      T next = nextIter.next();\n", "      if (nextIter.hasNext()) {\n", "        queue.add(nextIter);\n", "      }\n", "      return next;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557\n", "   */\n", "  static <T> ListIterator<T> cast(Iterator<T> iterator) {\n", "    return (ListIterator<T>) iterator;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306]}}, {"34": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "import com.google.common.base.Objects;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "import java.util.LinkedHashMap;\n", "import java.util.LinkedHashSet;\n", "import java.util.Map;\n", "import java.util.NoSuchElementException;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Implementation of {@code Multimap} that does not allow duplicate key-value\n", " * entries and that returns collections whose iterators follow the ordering in\n", " * which the data was added to the multimap.\n", " *\n", " * <p>The collections returned by {@code keySet}, {@code keys}, and {@code\n", " * asMap} iterate through the keys in the order they were first added to the\n", " * multimap. Similarly, {@code get}, {@code removeAll}, and {@code\n", " * replaceValues} return collections that iterate through the values in the\n", " * order they were added. The collections generated by {@code entries} and\n", " * {@code values} iterate across the key-value mappings in the order they were\n", " * added to the multimap.\n", " *\n", " * <p>The iteration ordering of the collections generated by {@code keySet},\n", " * {@code keys}, and {@code asMap} has a few subtleties. As long as the set of\n", " * keys remains unchanged, adding or removing mappings does not affect the key\n", " * iteration order. However, if you remove all values associated with a key and\n", " * then add the key back to the multimap, that key will come last in the key\n", " * iteration order.\n", " *\n", " * <p>The multimap does not store duplicate key-value pairs. Adding a new\n", " * key-value pair equal to an existing key-value pair has no effect.\n", " *\n", " * <p>Keys and values may be null. All optional multimap methods are supported,\n", " * and all returned views are modifiable.\n", " *\n", " * <p>This class is not threadsafe when any concurrent operations update the\n", " * multimap. Concurrent read operations will work correctly. To allow concurrent\n", " * update operations, wrap your multimap with a call to {@link\n", " * Multimaps#synchronizedSetMultimap}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n", " * {@code Multimap}</a>.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "public final class LinkedHashMultimap<K, V> extends AbstractSetMultimap<K, V> {\n", "\n", "  /**\n", "   * Creates a new, empty {@code LinkedHashMultimap} with the default initial\n", "   * capacities.\n", "   */\n", "  public static <K, V> LinkedHashMultimap<K, V> create() {\n", "    return new LinkedHashMultimap<K, V>(DEFAULT_KEY_CAPACITY, DEFAULT_VALUE_SET_CAPACITY);\n", "  }\n", "\n", "  /**\n", "   * Constructs an empty {@code LinkedHashMultimap} with enough capacity to hold\n", "   * the specified numbers of keys and values without rehashing.\n", "   *\n", "   * @param expectedKeys the expected number of distinct keys\n", "   * @param expectedValuesPerKey the expected average number of values per key\n", "   * @throws IllegalArgumentException if {@code expectedKeys} or {@code\n", "   *      expectedValuesPerKey} is negative\n", "   */\n", "  public static <K, V> LinkedHashMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {\n", "    return new LinkedHashMultimap<K, V>(\n", "        Maps.capacity(expectedKeys), Maps.capacity(expectedValuesPerKey));\n", "  }\n", "\n", "  /**\n", "   * Constructs a {@code LinkedHashMultimap} with the same mappings as the\n", "   * specified multimap. If a key-value mapping appears multiple times in the\n", "   * input multimap, it only appears once in the constructed multimap. The new\n", "   * multimap has the same {@link Multimap#entries()} iteration order as the\n", "   * input multimap, except for excluding duplicate mappings.\n", "   *\n", "   * @param multimap the multimap whose contents are copied to this multimap\n", "   */\n", "  public static <K, V> LinkedHashMultimap<K, V> create(\n", "      Multimap<? extends K, ? extends V> multimap) {\n", "    LinkedHashMultimap<K, V> result = create(multimap.keySet().size(), DEFAULT_VALUE_SET_CAPACITY);\n", "    result.putAll(multimap);\n", "    return result;\n", "  }\n", "\n", "  private interface ValueSetLink<K, V> {\n", "    ValueSetLink<K, V> getPredecessorInValueSet();\n", "\n", "    ValueSetLink<K, V> getSuccessorInValueSet();\n", "\n", "    void setPredecessorInValueSet(ValueSetLink<K, V> entry);\n", "\n", "    void setSuccessorInValueSet(ValueSetLink<K, V> entry);\n", "  }\n", "\n", "  private static <K, V> void succeedsInValueSet(ValueSetLink<K, V> pred, ValueSetLink<K, V> succ) {\n", "    pred.setSuccessorInValueSet(succ);\n", "    succ.setPredecessorInValueSet(pred);\n", "  }\n", "\n", "  private static <K, V> void succeedsInMultimap(ValueEntry<K, V> pred, ValueEntry<K, V> succ) {\n", "    pred.setSuccessorInMultimap(succ);\n", "    succ.setPredecessorInMultimap(pred);\n", "  }\n", "\n", "  private static <K, V> void deleteFromValueSet(ValueSetLink<K, V> entry) {\n", "    succeedsInValueSet(entry.getPredecessorInValueSet(), entry.getSuccessorInValueSet());\n", "  }\n", "\n", "  private static <K, V> void deleteFromMultimap(ValueEntry<K, V> entry) {\n", "    succeedsInMultimap(entry.getPredecessorInMultimap(), entry.getSuccessorInMultimap());\n", "  }\n", "\n", "  /**\n", "   * LinkedHashMultimap entries are in no less than three coexisting linked lists:\n", "   * a bucket in the hash table for a Set<V> associated with a key, the linked list\n", "   * of insertion-ordered entries in that Set<V>, and the linked list of entries\n", "   * in the LinkedHashMultimap as a whole.\n", "   */\n", "  @VisibleForTesting\n", "  static final class ValueEntry<K, V> extends ImmutableEntry<K, V> implements ValueSetLink<K, V> {\n", "    final int smearedValueHash;\n", "\n", "    @Nullable ValueEntry<K, V> nextInValueBucket;\n", "\n", "    ValueSetLink<K, V> predecessorInValueSet;\n", "    ValueSetLink<K, V> successorInValueSet;\n", "\n", "    ValueEntry<K, V> predecessorInMultimap;\n", "    ValueEntry<K, V> successorInMultimap;\n", "\n", "    ValueEntry(\n", "        @Nullable K key,\n", "        @Nullable V value,\n", "        int smearedValueHash,\n", "        @Nullable ValueEntry<K, V> nextInValueBucket) {\n", "      super(key, value);\n", "      this.smearedValueHash = smearedValueHash;\n", "      this.nextInValueBucket = nextInValueBucket;\n", "    }\n", "\n", "    boolean matchesValue(@Nullable Object v, int smearedVHash) {\n", "      return smearedValueHash == smearedVHash && Objects.equal(getValue(), v);\n", "    }\n", "\n", "    @Override\n", "    public ValueSetLink<K, V> getPredecessorInValueSet() {\n", "      return predecessorInValueSet;\n", "    }\n", "\n", "    @Override\n", "    public ValueSetLink<K, V> getSuccessorInValueSet() {\n", "      return successorInValueSet;\n", "    }\n", "\n", "    @Override\n", "    public void setPredecessorInValueSet(ValueSetLink<K, V> entry) {\n", "      predecessorInValueSet = entry;\n", "    }\n", "\n", "    @Override\n", "    public void setSuccessorInValueSet(ValueSetLink<K, V> entry) {\n", "      successorInValueSet = entry;\n", "    }\n", "\n", "    public ValueEntry<K, V> getPredecessorInMultimap() {\n", "      return predecessorInMultimap;\n", "    }\n", "\n", "    public ValueEntry<K, V> getSuccessorInMultimap() {\n", "      return successorInMultimap;\n", "    }\n", "\n", "    public void setSuccessorInMultimap(ValueEntry<K, V> multimapSuccessor) {\n", "      this.successorInMultimap = multimapSuccessor;\n", "    }\n", "\n", "    public void setPredecessorInMultimap(ValueEntry<K, V> multimapPredecessor) {\n", "      this.predecessorInMultimap = multimapPredecessor;\n", "    }\n", "  }\n", "\n", "  private static final int DEFAULT_KEY_CAPACITY = 16;\n", "  private static final int DEFAULT_VALUE_SET_CAPACITY = 2;\n", "  @VisibleForTesting static final double VALUE_SET_LOAD_FACTOR = 1.0;\n", "\n", "  @VisibleForTesting transient int valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;\n", "  private transient ValueEntry<K, V> multimapHeaderEntry;\n", "\n", "  private LinkedHashMultimap(int keyCapacity, int valueSetCapacity) {\n", "    super(new LinkedHashMap<K, Collection<V>>(keyCapacity));\n", "    checkNonnegative(valueSetCapacity, \"expectedValuesPerKey\");\n", "\n", "    this.valueSetCapacity = valueSetCapacity;\n", "    this.multimapHeaderEntry = new ValueEntry<K, V>(null, null, 0, null);\n", "    succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>Creates an empty {@code LinkedHashSet} for a collection of values for\n", "   * one key.\n", "   *\n", "   * @return a new {@code LinkedHashSet} containing a collection of values for\n", "   *     one key\n", "   */\n", "  @Override\n", "  Set<V> createCollection() {\n", "    return new LinkedHashSet<V>(valueSetCapacity);\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>Creates a decorated insertion-ordered set that also keeps track of the\n", "   * order in which key-value pairs are added to the multimap.\n", "   *\n", "   * @param key key to associate with values in the collection\n", "   * @return a new decorated set containing a collection of values for one key\n", "   */\n", "  @Override\n", "  Collection<V> createCollection(K key) {\n", "    return new ValueSet(key, valueSetCapacity);\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>If {@code values} is not empty and the multimap already contains a\n", "   * mapping for {@code key}, the {@code keySet()} ordering is unchanged.\n", "   * However, the provided values always come last in the {@link #entries()} and\n", "   * {@link #values()} iteration orderings.\n", "   */\n", "  @Override\n", "  public Set<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {\n", "    return super.replaceValues(key, values);\n", "  }\n", "\n", "  /**\n", "   * Returns a set of all key-value pairs. Changes to the returned set will\n", "   * update the underlying multimap, and vice versa. The entries set does not\n", "   * support the {@code add} or {@code addAll} operations.\n", "   *\n", "   * <p>The iterator generated by the returned set traverses the entries in the\n", "   * order they were added to the multimap.\n", "   *\n", "   * <p>Each entry is an immutable snapshot of a key-value mapping in the\n", "   * multimap, taken at the time the entry is returned by a method call to the\n", "   * collection or its iterator.\n", "   */\n", "  @Override\n", "  public Set<Map.Entry<K, V>> entries() {\n", "    return super.entries();\n", "  }\n", "\n", "  /**\n", "   * Returns a collection of all values in the multimap. Changes to the returned\n", "   * collection will update the underlying multimap, and vice versa.\n", "   *\n", "   * <p>The iterator generated by the returned collection traverses the values\n", "   * in the order they were added to the multimap.\n", "   */\n", "  @Override\n", "  public Collection<V> values() {\n", "    return super.values();\n", "  }\n", "\n", "  @VisibleForTesting\n", "  @WeakOuter\n", "  final class ValueSet extends Sets.ImprovedAbstractSet<V> implements ValueSetLink<K, V> {\n", "    /*\n", "     * We currently use a fixed load factor of 1.0, a bit higher than normal to reduce memory\n", "     * consumption.\n", "     */\n", "\n", "    private final K key;\n", "    @VisibleForTesting ValueEntry<K, V>[] hashTable;\n", "    private int size = 0;\n", "    private int modCount = 0;\n", "\n", "    // We use the set object itself as the end of the linked list, avoiding an unnecessary\n", "    // entry object per key.\n", "    private ValueSetLink<K, V> firstEntry;\n", "    private ValueSetLink<K, V> lastEntry;\n", "\n", "    ValueSet(K key, int expectedValues) {\n", "      this.key = key;\n", "      this.firstEntry = this;\n", "      this.lastEntry = this;\n", "      // Round expected values up to a power of 2 to get the table size.\n", "      int tableSize = Hashing.closedTableSize(expectedValues, VALUE_SET_LOAD_FACTOR);\n", "\n", "      @SuppressWarnings(\"unchecked\")\n", "      ValueEntry<K, V>[] hashTable = new ValueEntry[tableSize];\n", "      this.hashTable = hashTable;\n", "    }\n", "\n", "    private int mask() {\n", "      return hashTable.length - 1;\n", "    }\n", "\n", "    @Override\n", "    public ValueSetLink<K, V> getPredecessorInValueSet() {\n", "      return lastEntry;\n", "    }\n", "\n", "    @Override\n", "    public ValueSetLink<K, V> getSuccessorInValueSet() {\n", "      return firstEntry;\n", "    }\n", "\n", "    @Override\n", "    public void setPredecessorInValueSet(ValueSetLink<K, V> entry) {\n", "      lastEntry = entry;\n", "    }\n", "\n", "    @Override\n", "    public void setSuccessorInValueSet(ValueSetLink<K, V> entry) {\n", "      firstEntry = entry;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<V> iterator() {\n", "      return new Iterator<V>() {\n", "        ValueSetLink<K, V> nextEntry = firstEntry;\n", "        ValueEntry<K, V> toRemove;\n", "        int expectedModCount = modCount;\n", "\n", "        private void checkForComodification() {\n", "          if (modCount != expectedModCount) {\n", "            throw new ConcurrentModificationException();\n", "          }\n", "        }\n", "\n", "        @Override\n", "        public boolean hasNext() {\n", "          checkForComodification();\n", "          return nextEntry != ValueSet.this;\n", "        }\n", "\n", "        @Override\n", "        public V next() {\n", "          if (!hasNext()) {\n", "            throw new NoSuchElementException();\n", "          }\n", "          ValueEntry<K, V> entry = (ValueEntry<K, V>) nextEntry;\n", "          V result = entry.getValue();\n", "          toRemove = entry;\n", "          nextEntry = entry.getSuccessorInValueSet();\n", "          return result;\n", "        }\n", "\n", "        @Override\n", "        public void remove() {\n", "          checkForComodification();\n", "          checkRemove(toRemove != null);\n", "          ValueSet.this.remove(toRemove.getValue());\n", "          expectedModCount = modCount;\n", "          toRemove = null;\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return size;\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(@Nullable Object o) {\n", "      int smearedHash = Hashing.smearedHash(o);\n", "      for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()];\n", "          entry != null;\n", "          entry = entry.nextInValueBucket) {\n", "        if (entry.matchesValue(o, smearedHash)) {\n", "          return true;\n", "        }\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean add(@Nullable V value) {\n", "      int smearedHash = Hashing.smearedHash(value);\n", "      int bucket = smearedHash & mask();\n", "      ValueEntry<K, V> rowHead = hashTable[bucket];\n", "      for (ValueEntry<K, V> entry = rowHead; entry != null; entry = entry.nextInValueBucket) {\n", "        if (entry.matchesValue(value, smearedHash)) {\n", "          return false;\n", "        }\n", "      }\n", "\n", "      ValueEntry<K, V> newEntry = new ValueEntry<K, V>(key, value, smearedHash, rowHead);\n", "      succeedsInValueSet(lastEntry, newEntry);\n", "      succeedsInValueSet(newEntry, this);\n", "      succeedsInMultimap(multimapHeaderEntry.getPredecessorInMultimap(), newEntry);\n", "      succeedsInMultimap(newEntry, multimapHeaderEntry);\n", "      hashTable[bucket] = newEntry;\n", "      size++;\n", "      modCount++;\n", "      rehashIfNecessary();\n", "      return true;\n", "    }\n", "\n", "    private void rehashIfNecessary() {\n", "      if (Hashing.needsResizing(size, hashTable.length, VALUE_SET_LOAD_FACTOR)) {\n", "        @SuppressWarnings(\"unchecked\")\n", "        ValueEntry<K, V>[] hashTable = new ValueEntry[this.hashTable.length * 2];\n", "        this.hashTable = hashTable;\n", "        int mask = hashTable.length - 1;\n", "        for (ValueSetLink<K, V> entry = firstEntry;\n", "            entry != this;\n", "            entry = entry.getSuccessorInValueSet()) {\n", "          ValueEntry<K, V> valueEntry = (ValueEntry<K, V>) entry;\n", "          int bucket = valueEntry.smearedValueHash & mask;\n", "          valueEntry.nextInValueBucket = hashTable[bucket];\n", "          hashTable[bucket] = valueEntry;\n", "        }\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(@Nullable Object o) {\n", "      int smearedHash = Hashing.smearedHash(o);\n", "      int bucket = smearedHash & mask();\n", "      ValueEntry<K, V> prev = null;\n", "      for (ValueEntry<K, V> entry = hashTable[bucket];\n", "          entry != null;\n", "          prev = entry, entry = entry.nextInValueBucket) {\n", "        if (entry.matchesValue(o, smearedHash)) {\n", "          if (prev == null) {\n", "            // first entry in the bucket\n", "            hashTable[bucket] = entry.nextInValueBucket;\n", "          } else {\n", "            prev.nextInValueBucket = entry.nextInValueBucket;\n", "          }\n", "          deleteFromValueSet(entry);\n", "          deleteFromMultimap(entry);\n", "          size--;\n", "          modCount++;\n", "          return true;\n", "        }\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      Arrays.fill(hashTable, null);\n", "      size = 0;\n", "      for (ValueSetLink<K, V> entry = firstEntry;\n", "          entry != this;\n", "          entry = entry.getSuccessorInValueSet()) {\n", "        ValueEntry<K, V> valueEntry = (ValueEntry<K, V>) entry;\n", "        deleteFromMultimap(valueEntry);\n", "      }\n", "      succeedsInValueSet(this, this);\n", "      modCount++;\n", "    }\n", "  }\n", "\n", "  @Override\n", "  Iterator<Map.Entry<K, V>> entryIterator() {\n", "    return new Iterator<Map.Entry<K, V>>() {\n", "      ValueEntry<K, V> nextEntry = multimapHeaderEntry.successorInMultimap;\n", "      ValueEntry<K, V> toRemove;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        return nextEntry != multimapHeaderEntry;\n", "      }\n", "\n", "      @Override\n", "      public Map.Entry<K, V> next() {\n", "        if (!hasNext()) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        ValueEntry<K, V> result = nextEntry;\n", "        toRemove = result;\n", "        nextEntry = nextEntry.successorInMultimap;\n", "        return result;\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        checkRemove(toRemove != null);\n", "        LinkedHashMultimap.this.remove(toRemove.getKey(), toRemove.getValue());\n", "        toRemove = null;\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  Iterator<V> valueIterator() {\n", "    return Maps.valueIterator(entryIterator());\n", "  }\n", "\n", "  @Override\n", "  public void clear() {\n", "    super.clear();\n", "    succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538]}}, {"35": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultiset.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.LinkedHashMap;\n", "\n", "/**\n", " * A {@code Multiset} implementation with predictable iteration order. Its\n", " * iterator orders elements according to when the first occurrence of the\n", " * element was added. When the multiset contains multiple instances of an\n", " * element, those instances are consecutive in the iteration order. If all\n", " * occurrences of an element are removed, after which that element is added to\n", " * the multiset, the element will appear at the end of the iteration.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset\">\n", " * {@code Multiset}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "@SuppressWarnings(\"serial\") // we're overriding default serialization\n", "public final class LinkedHashMultiset<E> extends AbstractMapBasedMultiset<E> {\n", "\n", "  /**\n", "   * Creates a new, empty {@code LinkedHashMultiset} using the default initial\n", "   * capacity.\n", "   */\n", "  public static <E> LinkedHashMultiset<E> create() {\n", "    return new LinkedHashMultiset<E>();\n", "  }\n", "\n", "  /**\n", "   * Creates a new, empty {@code LinkedHashMultiset} with the specified expected\n", "   * number of distinct elements.\n", "   *\n", "   * @param distinctElements the expected number of distinct elements\n", "   * @throws IllegalArgumentException if {@code distinctElements} is negative\n", "   */\n", "  public static <E> LinkedHashMultiset<E> create(int distinctElements) {\n", "    return new LinkedHashMultiset<E>(distinctElements);\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code LinkedHashMultiset} containing the specified elements.\n", "   *\n", "   * <p>This implementation is highly efficient when {@code elements} is itself\n", "   * a {@link Multiset}.\n", "   *\n", "   * @param elements the elements that the multiset should contain\n", "   */\n", "  public static <E> LinkedHashMultiset<E> create(Iterable<? extends E> elements) {\n", "    LinkedHashMultiset<E> multiset = create(Multisets.inferDistinctElements(elements));\n", "    Iterables.addAll(multiset, elements);\n", "    return multiset;\n", "  }\n", "\n", "  private LinkedHashMultiset() {\n", "    super(new LinkedHashMap<E, Count>());\n", "  }\n", "\n", "  private LinkedHashMultiset(int distinctElements) {\n", "    super(Maps.<E, Count>newLinkedHashMapWithExpectedSize(distinctElements));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84]}}, {"36": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkPositionIndex;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "import static java.util.Collections.unmodifiableList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractSequentialList;\n", "import java.util.Collection;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.HashMap;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.NoSuchElementException;\n", "import java.util.Set;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * An implementation of {@code ListMultimap} that supports deterministic\n", " * iteration order for both keys and values. The iteration order is preserved\n", " * across non-distinct key values. For example, for the following multimap\n", " * definition: <pre>   {@code\n", " *\n", " *   Multimap<K, V> multimap = LinkedListMultimap.create();\n", " *   multimap.put(key1, foo);\n", " *   multimap.put(key2, bar);\n", " *   multimap.put(key1, baz);}</pre>\n", " *\n", " * ... the iteration order for {@link #keys()} is {@code [key1, key2, key1]},\n", " * and similarly for {@link #entries()}. Unlike {@link LinkedHashMultimap}, the\n", " * iteration order is kept consistent between keys, entries and values. For\n", " * example, calling: <pre>   {@code\n", " *\n", " *   map.remove(key1, foo);}</pre>\n", " *\n", " * <p>changes the entries iteration order to {@code [key2=bar, key1=baz]} and the\n", " * key iteration order to {@code [key2, key1]}. The {@link #entries()} iterator\n", " * returns mutable map entries, and {@link #replaceValues} attempts to preserve\n", " * iteration order as much as possible.\n", " *\n", " * <p>The collections returned by {@link #keySet()} and {@link #asMap} iterate\n", " * through the keys in the order they were first added to the multimap.\n", " * Similarly, {@link #get}, {@link #removeAll}, and {@link #replaceValues}\n", " * return collections that iterate through the values in the order they were\n", " * added. The collections generated by {@link #entries()}, {@link #keys()}, and\n", " * {@link #values} iterate across the key-value mappings in the order they were\n", " * added to the multimap.\n", " *\n", " * <p>The {@link #values()} and {@link #entries()} methods both return a\n", " * {@code List}, instead of the {@code Collection} specified by the {@link\n", " * ListMultimap} interface.\n", " *\n", " * <p>The methods {@link #get}, {@link #keySet()}, {@link #keys()},\n", " * {@link #values}, {@link #entries()}, and {@link #asMap} return collections\n", " * that are views of the multimap. If the multimap is modified while an\n", " * iteration over any of those collections is in progress, except through the\n", " * iterator's methods, the results of the iteration are undefined.\n", " *\n", " * <p>Keys and values may be null. All optional multimap methods are supported,\n", " * and all returned views are modifiable.\n", " *\n", " * <p>This class is not threadsafe when any concurrent operations update the\n", " * multimap. Concurrent read operations will work correctly. To allow concurrent\n", " * update operations, wrap your multimap with a call to {@link\n", " * Multimaps#synchronizedListMultimap}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n", " * {@code Multimap}</a>.\n", " *\n", " * @author Mike Bostock\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "public class LinkedListMultimap<K, V> extends AbstractMultimap<K, V>\n", "    implements ListMultimap<K, V>, Serializable {\n", "  /*\n", "   * Order is maintained using a linked list containing all key-value pairs. In\n", "   * addition, a series of disjoint linked lists of \"siblings\", each containing\n", "   * the values for a specific key, is used to implement {@link\n", "   * ValueForKeyIterator} in constant time.\n", "   */\n", "\n", "  private static final class Node<K, V> extends AbstractMapEntry<K, V> {\n", "    final K key;\n", "    V value;\n", "    Node<K, V> next; // the next node (with any key)\n", "    Node<K, V> previous; // the previous node (with any key)\n", "    Node<K, V> nextSibling; // the next node with the same key\n", "    Node<K, V> previousSibling; // the previous node with the same key\n", "\n", "    Node(@Nullable K key, @Nullable V value) {\n", "      this.key = key;\n", "      this.value = value;\n", "    }\n", "\n", "    @Override\n", "    public K getKey() {\n", "      return key;\n", "    }\n", "\n", "    @Override\n", "    public V getValue() {\n", "      return value;\n", "    }\n", "\n", "    @Override\n", "    public V setValue(@Nullable V newValue) {\n", "      V result = value;\n", "      this.value = newValue;\n", "      return result;\n", "    }\n", "  }\n", "\n", "  private static class KeyList<K, V> {\n", "    Node<K, V> head;\n", "    Node<K, V> tail;\n", "    int count;\n", "\n", "    KeyList(Node<K, V> firstNode) {\n", "      this.head = firstNode;\n", "      this.tail = firstNode;\n", "      firstNode.previousSibling = null;\n", "      firstNode.nextSibling = null;\n", "      this.count = 1;\n", "    }\n", "  }\n", "\n", "  private transient Node<K, V> head; // the head for all keys\n", "  private transient Node<K, V> tail; // the tail for all keys\n", "  private transient Map<K, KeyList<K, V>> keyToKeyList;\n", "  private transient int size;\n", "\n", "  /*\n", "   * Tracks modifications to keyToKeyList so that addition or removal of keys invalidates\n", "   * preexisting iterators. This does *not* track simple additions and removals of values\n", "   * that are not the first to be added or last to be removed for their key.\n", "   */\n", "  private transient int modCount;\n", "\n", "  /**\n", "   * Creates a new, empty {@code LinkedListMultimap} with the default initial\n", "   * capacity.\n", "   */\n", "  public static <K, V> LinkedListMultimap<K, V> create() {\n", "    return new LinkedListMultimap<K, V>();\n", "  }\n", "\n", "  /**\n", "   * Constructs an empty {@code LinkedListMultimap} with enough capacity to hold\n", "   * the specified number of keys without rehashing.\n", "   *\n", "   * @param expectedKeys the expected number of distinct keys\n", "   * @throws IllegalArgumentException if {@code expectedKeys} is negative\n", "   */\n", "  public static <K, V> LinkedListMultimap<K, V> create(int expectedKeys) {\n", "    return new LinkedListMultimap<K, V>(expectedKeys);\n", "  }\n", "\n", "  /**\n", "   * Constructs a {@code LinkedListMultimap} with the same mappings as the\n", "   * specified {@code Multimap}. The new multimap has the same\n", "   * {@link Multimap#entries()} iteration order as the input multimap.\n", "   *\n", "   * @param multimap the multimap whose contents are copied to this multimap\n", "   */\n", "  public static <K, V> LinkedListMultimap<K, V> create(\n", "      Multimap<? extends K, ? extends V> multimap) {\n", "    return new LinkedListMultimap<K, V>(multimap);\n", "  }\n", "\n", "  LinkedListMultimap() {\n", "    keyToKeyList = Maps.newHashMap();\n", "  }\n", "\n", "  private LinkedListMultimap(int expectedKeys) {\n", "    keyToKeyList = new HashMap<K, KeyList<K, V>>(expectedKeys);\n", "  }\n", "\n", "  private LinkedListMultimap(Multimap<? extends K, ? extends V> multimap) {\n", "    this(multimap.keySet().size());\n", "    putAll(multimap);\n", "  }\n", "\n", "  /**\n", "   * Adds a new node for the specified key-value pair before the specified\n", "   * {@code nextSibling} element, or at the end of the list if {@code\n", "   * nextSibling} is null. Note: if {@code nextSibling} is specified, it MUST be\n", "   * for an node for the same {@code key}!\n", "   */\n", "  private Node<K, V> addNode(@Nullable K key, @Nullable V value, @Nullable Node<K, V> nextSibling) {\n", "    Node<K, V> node = new Node<K, V>(key, value);\n", "    if (head == null) { // empty list\n", "      head = tail = node;\n", "      keyToKeyList.put(key, new KeyList<K, V>(node));\n", "      modCount++;\n", "    } else if (nextSibling == null) { // non-empty list, add to tail\n", "      tail.next = node;\n", "      node.previous = tail;\n", "      tail = node;\n", "      KeyList<K, V> keyList = keyToKeyList.get(key);\n", "      if (keyList == null) {\n", "        keyToKeyList.put(key, keyList = new KeyList<K, V>(node));\n", "        modCount++;\n", "      } else {\n", "        keyList.count++;\n", "        Node<K, V> keyTail = keyList.tail;\n", "        keyTail.nextSibling = node;\n", "        node.previousSibling = keyTail;\n", "        keyList.tail = node;\n", "      }\n", "    } else { // non-empty list, insert before nextSibling\n", "      KeyList<K, V> keyList = keyToKeyList.get(key);\n", "      keyList.count++;\n", "      node.previous = nextSibling.previous;\n", "      node.previousSibling = nextSibling.previousSibling;\n", "      node.next = nextSibling;\n", "      node.nextSibling = nextSibling;\n", "      if (nextSibling.previousSibling == null) { // nextSibling was key head\n", "        keyToKeyList.get(key).head = node;\n", "      } else {\n", "        nextSibling.previousSibling.nextSibling = node;\n", "      }\n", "      if (nextSibling.previous == null) { // nextSibling was head\n", "        head = node;\n", "      } else {\n", "        nextSibling.previous.next = node;\n", "      }\n", "      nextSibling.previous = node;\n", "      nextSibling.previousSibling = node;\n", "    }\n", "    size++;\n", "    return node;\n", "  }\n", "\n", "  /**\n", "   * Removes the specified node from the linked list. This method is only\n", "   * intended to be used from the {@code Iterator} classes. See also {@link\n", "   * LinkedListMultimap#removeAllNodes(Object)}.\n", "   */\n", "  private void removeNode(Node<K, V> node) {\n", "    if (node.previous != null) {\n", "      node.previous.next = node.next;\n", "    } else { // node was head\n", "      head = node.next;\n", "    }\n", "    if (node.next != null) {\n", "      node.next.previous = node.previous;\n", "    } else { // node was tail\n", "      tail = node.previous;\n", "    }\n", "    if (node.previousSibling == null && node.nextSibling == null) {\n", "      KeyList<K, V> keyList = keyToKeyList.remove(node.key);\n", "      keyList.count = 0;\n", "      modCount++;\n", "    } else {\n", "      KeyList<K, V> keyList = keyToKeyList.get(node.key);\n", "      keyList.count--;\n", "\n", "      if (node.previousSibling == null) {\n", "        keyList.head = node.nextSibling;\n", "      } else {\n", "        node.previousSibling.nextSibling = node.nextSibling;\n", "      }\n", "\n", "      if (node.nextSibling == null) {\n", "        keyList.tail = node.previousSibling;\n", "      } else {\n", "        node.nextSibling.previousSibling = node.previousSibling;\n", "      }\n", "    }\n", "    size--;\n", "  }\n", "\n", "  /** Removes all nodes for the specified key. */\n", "  private void removeAllNodes(@Nullable Object key) {\n", "    Iterators.clear(new ValueForKeyIterator(key));\n", "  }\n", "\n", "  /** Helper method for verifying that an iterator element is present. */\n", "  private static void checkElement(@Nullable Object node) {\n", "    if (node == null) {\n", "      throw new NoSuchElementException();\n", "    }\n", "  }\n", "\n", "  /** An {@code Iterator} over all nodes. */\n", "  private class NodeIterator implements ListIterator<Entry<K, V>> {\n", "    int nextIndex;\n", "    Node<K, V> next;\n", "    Node<K, V> current;\n", "    Node<K, V> previous;\n", "    int expectedModCount = modCount;\n", "\n", "    NodeIterator(int index) {\n", "      int size = size();\n", "      checkPositionIndex(index, size);\n", "      if (index >= (size / 2)) {\n", "        previous = tail;\n", "        nextIndex = size;\n", "        while (index++ < size) {\n", "          previous();\n", "        }\n", "      } else {\n", "        next = head;\n", "        while (index-- > 0) {\n", "          next();\n", "        }\n", "      }\n", "      current = null;\n", "    }\n", "\n", "    private void checkForConcurrentModification() {\n", "      if (modCount != expectedModCount) {\n", "        throw new ConcurrentModificationException();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      checkForConcurrentModification();\n", "      return next != null;\n", "    }\n", "\n", "    @Override\n", "    public Node<K, V> next() {\n", "      checkForConcurrentModification();\n", "      checkElement(next);\n", "      previous = current = next;\n", "      next = next.next;\n", "      nextIndex++;\n", "      return current;\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "      checkForConcurrentModification();\n", "      checkRemove(current != null);\n", "      if (current != next) { // after call to next()\n", "        previous = current.previous;\n", "        nextIndex--;\n", "      } else { // after call to previous()\n", "        next = current.next;\n", "      }\n", "      removeNode(current);\n", "      current = null;\n", "      expectedModCount = modCount;\n", "    }\n", "\n", "    @Override\n", "    public boolean hasPrevious() {\n", "      checkForConcurrentModification();\n", "      return previous != null;\n", "    }\n", "\n", "    @Override\n", "    public Node<K, V> previous() {\n", "      checkForConcurrentModification();\n", "      checkElement(previous);\n", "      next = current = previous;\n", "      previous = previous.previous;\n", "      nextIndex--;\n", "      return current;\n", "    }\n", "\n", "    @Override\n", "    public int nextIndex() {\n", "      return nextIndex;\n", "    }\n", "\n", "    @Override\n", "    public int previousIndex() {\n", "      return nextIndex - 1;\n", "    }\n", "\n", "    @Override\n", "    public void set(Entry<K, V> e) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public void add(Entry<K, V> e) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    void setValue(V value) {\n", "      checkState(current != null);\n", "      current.value = value;\n", "    }\n", "  }\n", "\n", "  /** An {@code Iterator} over distinct keys in key head order. */\n", "  private class DistinctKeyIterator implements Iterator<K> {\n", "    final Set<K> seenKeys = Sets.<K>newHashSetWithExpectedSize(keySet().size());\n", "    Node<K, V> next = head;\n", "    Node<K, V> current;\n", "    int expectedModCount = modCount;\n", "\n", "    private void checkForConcurrentModification() {\n", "      if (modCount != expectedModCount) {\n", "        throw new ConcurrentModificationException();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      checkForConcurrentModification();\n", "      return next != null;\n", "    }\n", "\n", "    @Override\n", "    public K next() {\n", "      checkForConcurrentModification();\n", "      checkElement(next);\n", "      current = next;\n", "      seenKeys.add(current.key);\n", "      do { // skip ahead to next unseen key\n", "        next = next.next;\n", "      } while ((next != null) && !seenKeys.add(next.key));\n", "      return current.key;\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "      checkForConcurrentModification();\n", "      checkRemove(current != null);\n", "      removeAllNodes(current.key);\n", "      current = null;\n", "      expectedModCount = modCount;\n", "    }\n", "  }\n", "\n", "  /** A {@code ListIterator} over values for a specified key. */\n", "  private class ValueForKeyIterator implements ListIterator<V> {\n", "    final Object key;\n", "    int nextIndex;\n", "    Node<K, V> next;\n", "    Node<K, V> current;\n", "    Node<K, V> previous;\n", "\n", "    /** Constructs a new iterator over all values for the specified key. */\n", "    ValueForKeyIterator(@Nullable Object key) {\n", "      this.key = key;\n", "      KeyList<K, V> keyList = keyToKeyList.get(key);\n", "      next = (keyList == null) ? null : keyList.head;\n", "    }\n", "\n", "    /**\n", "     * Constructs a new iterator over all values for the specified key starting\n", "     * at the specified index. This constructor is optimized so that it starts\n", "     * at either the head or the tail, depending on which is closer to the\n", "     * specified index. This allows adds to the tail to be done in constant\n", "     * time.\n", "     *\n", "     * @throws IndexOutOfBoundsException if index is invalid\n", "     */\n", "    public ValueForKeyIterator(@Nullable Object key, int index) {\n", "      KeyList<K, V> keyList = keyToKeyList.get(key);\n", "      int size = (keyList == null) ? 0 : keyList.count;\n", "      checkPositionIndex(index, size);\n", "      if (index >= (size / 2)) {\n", "        previous = (keyList == null) ? null : keyList.tail;\n", "        nextIndex = size;\n", "        while (index++ < size) {\n", "          previous();\n", "        }\n", "      } else {\n", "        next = (keyList == null) ? null : keyList.head;\n", "        while (index-- > 0) {\n", "          next();\n", "        }\n", "      }\n", "      this.key = key;\n", "      current = null;\n", "    }\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "      return next != null;\n", "    }\n", "\n", "    @Override\n", "    public V next() {\n", "      checkElement(next);\n", "      previous = current = next;\n", "      next = next.nextSibling;\n", "      nextIndex++;\n", "      return current.value;\n", "    }\n", "\n", "    @Override\n", "    public boolean hasPrevious() {\n", "      return previous != null;\n", "    }\n", "\n", "    @Override\n", "    public V previous() {\n", "      checkElement(previous);\n", "      next = current = previous;\n", "      previous = previous.previousSibling;\n", "      nextIndex--;\n", "      return current.value;\n", "    }\n", "\n", "    @Override\n", "    public int nextIndex() {\n", "      return nextIndex;\n", "    }\n", "\n", "    @Override\n", "    public int previousIndex() {\n", "      return nextIndex - 1;\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "      checkRemove(current != null);\n", "      if (current != next) { // after call to next()\n", "        previous = current.previousSibling;\n", "        nextIndex--;\n", "      } else { // after call to previous()\n", "        next = current.nextSibling;\n", "      }\n", "      removeNode(current);\n", "      current = null;\n", "    }\n", "\n", "    @Override\n", "    public void set(V value) {\n", "      checkState(current != null);\n", "      current.value = value;\n", "    }\n", "\n", "    @Override\n", "    @SuppressWarnings(\"unchecked\")\n", "    public void add(V value) {\n", "      previous = addNode((K) key, value, next);\n", "      nextIndex++;\n", "      current = null;\n", "    }\n", "  }\n", "\n", "  // Query Operations\n", "\n", "  @Override\n", "  public int size() {\n", "    return size;\n", "  }\n", "\n", "  @Override\n", "  public boolean isEmpty() {\n", "    return head == null;\n", "  }\n", "\n", "  @Override\n", "  public boolean containsKey(@Nullable Object key) {\n", "    return keyToKeyList.containsKey(key);\n", "  }\n", "\n", "  @Override\n", "  public boolean containsValue(@Nullable Object value) {\n", "    return values().contains(value);\n", "  }\n", "\n", "  // Modification Operations\n", "\n", "  /**\n", "   * Stores a key-value pair in the multimap.\n", "   *\n", "   * @param key key to store in the multimap\n", "   * @param value value to store in the multimap\n", "   * @return {@code true} always\n", "   */\n", "  @Override\n", "  public boolean put(@Nullable K key, @Nullable V value) {\n", "    addNode(key, value, null);\n", "    return true;\n", "  }\n", "\n", "  // Bulk Operations\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>If any entries for the specified {@code key} already exist in the\n", "   * multimap, their values are changed in-place without affecting the iteration\n", "   * order.\n", "   *\n", "   * <p>The returned list is immutable and implements\n", "   * {@link java.util.RandomAccess}.\n", "   */\n", "  @Override\n", "  public List<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {\n", "    List<V> oldValues = getCopy(key);\n", "    ListIterator<V> keyValues = new ValueForKeyIterator(key);\n", "    Iterator<? extends V> newValues = values.iterator();\n", "\n", "    // Replace existing values, if any.\n", "    while (keyValues.hasNext() && newValues.hasNext()) {\n", "      keyValues.next();\n", "      keyValues.set(newValues.next());\n", "    }\n", "\n", "    // Remove remaining old values, if any.\n", "    while (keyValues.hasNext()) {\n", "      keyValues.next();\n", "      keyValues.remove();\n", "    }\n", "\n", "    // Add remaining new values, if any.\n", "    while (newValues.hasNext()) {\n", "      keyValues.add(newValues.next());\n", "    }\n", "\n", "    return oldValues;\n", "  }\n", "\n", "  private List<V> getCopy(@Nullable Object key) {\n", "    return unmodifiableList(Lists.newArrayList(new ValueForKeyIterator(key)));\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The returned list is immutable and implements\n", "   * {@link java.util.RandomAccess}.\n", "   */\n", "  @Override\n", "  public List<V> removeAll(@Nullable Object key) {\n", "    List<V> oldValues = getCopy(key);\n", "    removeAllNodes(key);\n", "    return oldValues;\n", "  }\n", "\n", "  @Override\n", "  public void clear() {\n", "    head = null;\n", "    tail = null;\n", "    keyToKeyList.clear();\n", "    size = 0;\n", "    modCount++;\n", "  }\n", "\n", "  // Views\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>If the multimap is modified while an iteration over the list is in\n", "   * progress (except through the iterator's own {@code add}, {@code set} or\n", "   * {@code remove} operations) the results of the iteration are undefined.\n", "   *\n", "   * <p>The returned list is not serializable and does not have random access.\n", "   */\n", "  @Override\n", "  public List<V> get(final @Nullable K key) {\n", "    return new AbstractSequentialList<V>() {\n", "      @Override\n", "      public int size() {\n", "        KeyList<K, V> keyList = keyToKeyList.get(key);\n", "        return (keyList == null) ? 0 : keyList.count;\n", "      }\n", "\n", "      @Override\n", "      public ListIterator<V> listIterator(int index) {\n", "        return new ValueForKeyIterator(key, index);\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  Set<K> createKeySet() {\n", "    @WeakOuter\n", "    class KeySetImpl extends Sets.ImprovedAbstractSet<K> {\n", "      @Override\n", "      public int size() {\n", "        return keyToKeyList.size();\n", "      }\n", "\n", "      @Override\n", "      public Iterator<K> iterator() {\n", "        return new DistinctKeyIterator();\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object key) { // for performance\n", "        return containsKey(key);\n", "      }\n", "\n", "      @Override\n", "      public boolean remove(Object o) { // for performance\n", "        return !LinkedListMultimap.this.removeAll(o).isEmpty();\n", "      }\n", "    }\n", "    return new KeySetImpl();\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The iterator generated by the returned collection traverses the values\n", "   * in the order they were added to the multimap. Because the values may have\n", "   * duplicates and follow the insertion ordering, this method returns a {@link\n", "   * List}, instead of the {@link Collection} specified in the {@link\n", "   * ListMultimap} interface.\n", "   */\n", "  @Override\n", "  public List<V> values() {\n", "    return (List<V>) super.values();\n", "  }\n", "\n", "  @Override\n", "  List<V> createValues() {\n", "    @WeakOuter\n", "    class ValuesImpl extends AbstractSequentialList<V> {\n", "      @Override\n", "      public int size() {\n", "        return size;\n", "      }\n", "\n", "      @Override\n", "      public ListIterator<V> listIterator(int index) {\n", "        final NodeIterator nodeItr = new NodeIterator(index);\n", "        return new TransformedListIterator<Entry<K, V>, V>(nodeItr) {\n", "          @Override\n", "          V transform(Entry<K, V> entry) {\n", "            return entry.getValue();\n", "          }\n", "\n", "          @Override\n", "          public void set(V value) {\n", "            nodeItr.setValue(value);\n", "          }\n", "        };\n", "      }\n", "    }\n", "    return new ValuesImpl();\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>The iterator generated by the returned collection traverses the entries\n", "   * in the order they were added to the multimap. Because the entries may have\n", "   * duplicates and follow the insertion ordering, this method returns a {@link\n", "   * List}, instead of the {@link Collection} specified in the {@link\n", "   * ListMultimap} interface.\n", "   *\n", "   * <p>An entry's {@link Entry#getKey} method always returns the same key,\n", "   * regardless of what happens subsequently. As long as the corresponding\n", "   * key-value mapping is not removed from the multimap, {@link Entry#getValue}\n", "   * returns the value from the multimap, which may change over time, and {@link\n", "   * Entry#setValue} modifies that value. Removing the mapping from the\n", "   * multimap does not alter the value returned by {@code getValue()}, though a\n", "   * subsequent {@code setValue()} call won't update the multimap but will lead\n", "   * to a revised value being returned by {@code getValue()}.\n", "   */\n", "  @Override\n", "  public List<Entry<K, V>> entries() {\n", "    return (List<Entry<K, V>>) super.entries();\n", "  }\n", "\n", "  @Override\n", "  List<Entry<K, V>> createEntries() {\n", "    @WeakOuter\n", "    class EntriesImpl extends AbstractSequentialList<Entry<K, V>> {\n", "      @Override\n", "      public int size() {\n", "        return size;\n", "      }\n", "\n", "      @Override\n", "      public ListIterator<Entry<K, V>> listIterator(int index) {\n", "        return new NodeIterator(index);\n", "      }\n", "    }\n", "    return new EntriesImpl();\n", "  }\n", "\n", "  @Override\n", "  Iterator<Entry<K, V>> entryIterator() {\n", "    throw new AssertionError(\"should never be called\");\n", "  }\n", "\n", "  @Override\n", "  Map<K, Collection<V>> createAsMap() {\n", "    return new Multimaps.AsMap<K, V>(this);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814]}}, {"37": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Lists.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkElementIndex;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkPositionIndex;\n", "import static com.google.common.base.Preconditions.checkPositionIndexes;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Objects;\n", "import com.google.common.math.IntMath;\n", "import com.google.common.primitives.Ints;\n", "\n", "import java.io.Serializable;\n", "import java.math.RoundingMode;\n", "import java.util.AbstractList;\n", "import java.util.AbstractSequentialList;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.LinkedList;\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.NoSuchElementException;\n", "import java.util.RandomAccess;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to {@link List} instances. Also see this\n", " * class's counterparts {@link Sets}, {@link Maps} and {@link Queues}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#lists\">\n", " * {@code Lists}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Mike Bostock\n", " * @author Louis Wasserman\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Lists {\n", "  private Lists() {}\n", "\n", "  // ArrayList\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty {@code ArrayList} instance (for Java 6 and\n", "   * earlier).\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableList#of()} instead.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n", "   * should be treated as deprecated. Instead, use the {@code ArrayList}\n", "   * {@linkplain ArrayList#ArrayList() constructor} directly, taking advantage\n", "   * of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <E> ArrayList<E> newArrayList() {\n", "    return new ArrayList<E>();\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n", "   * elements.\n", "   *\n", "   * <p><b>Note:</b> essentially the only reason to use this method is when you\n", "   * will need to add or remove elements later. Otherwise, for non-null elements\n", "   * use {@link ImmutableList#of()} (for varargs) or {@link\n", "   * ImmutableList#copyOf(Object[])} (for an array) instead. If any elements\n", "   * might be null, or you need support for {@link List#set(int, Object)}, use\n", "   * {@link Arrays#asList}.\n", "   *\n", "   * <p>Note that even when you do need the ability to add or remove, this method\n", "   * provides only a tiny bit of syntactic sugar for {@code newArrayList(}{@link\n", "   * Arrays#asList asList}{@code (...))}, or for creating an empty list then\n", "   * calling {@link Collections#addAll}. This method is not actually very useful\n", "   * and will likely be deprecated in the future.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <E> ArrayList<E> newArrayList(E... elements) {\n", "    checkNotNull(elements); // for GWT\n", "    // Avoid integer overflow when a large array is passed in\n", "    int capacity = computeArrayListCapacity(elements.length);\n", "    ArrayList<E> list = new ArrayList<E>(capacity);\n", "    Collections.addAll(list, elements);\n", "    return list;\n", "  }\n", "\n", "  @VisibleForTesting\n", "  static int computeArrayListCapacity(int arraySize) {\n", "    checkNonnegative(arraySize, \"arraySize\");\n", "\n", "    // TODO(kevinb): Figure out the right behavior, and document it\n", "    return Ints.saturatedCast(5L + arraySize + (arraySize / 10));\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n", "   * elements; a very thin shortcut for creating an empty list then calling\n", "   * {@link Iterables#addAll}.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required and the elements are\n", "   * non-null, use {@link ImmutableList#copyOf(Iterable)} instead. (Or, change\n", "   * {@code elements} to be a {@link FluentIterable} and call\n", "   * {@code elements.toList()}.)\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link\n", "   * Collection}, you don't need this method. Use the {@code ArrayList}\n", "   * {@linkplain ArrayList#ArrayList(Collection) constructor} directly, taking\n", "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <E> ArrayList<E> newArrayList(Iterable<? extends E> elements) {\n", "    checkNotNull(elements); // for GWT\n", "    // Let ArrayList's sizing logic work, if possible\n", "    return (elements instanceof Collection)\n", "        ? new ArrayList<E>(Collections2.cast(elements))\n", "        : newArrayList(elements.iterator());\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given\n", "   * elements; a very thin shortcut for creating an empty list and then calling\n", "   * {@link Iterators#addAll}.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required and the elements are\n", "   * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <E> ArrayList<E> newArrayList(Iterator<? extends E> elements) {\n", "    ArrayList<E> list = newArrayList();\n", "    Iterators.addAll(list, elements);\n", "    return list;\n", "  }\n", "\n", "  /**\n", "   * Creates an {@code ArrayList} instance backed by an array with the specified\n", "   * initial size; simply delegates to {@link ArrayList#ArrayList(int)}.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n", "   * should be treated as deprecated. Instead, use {@code new }{@link\n", "   * ArrayList#ArrayList(int) ArrayList}{@code <>(int)} directly, taking\n", "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n", "   * (Unlike here, there is no risk of overload ambiguity, since the {@code\n", "   * ArrayList} constructors very wisely did not accept varargs.)\n", "   *\n", "   * @param initialArraySize the exact size of the initial backing array for\n", "   *     the returned array list ({@code ArrayList} documentation calls this\n", "   *     value the \"capacity\")\n", "   * @return a new, empty {@code ArrayList} which is guaranteed not to resize\n", "   *     itself unless its size reaches {@code initialArraySize + 1}\n", "   * @throws IllegalArgumentException if {@code initialArraySize} is negative\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <E> ArrayList<E> newArrayListWithCapacity(int initialArraySize) {\n", "    checkNonnegative(initialArraySize, \"initialArraySize\"); // for GWT.\n", "    return new ArrayList<E>(initialArraySize);\n", "  }\n", "\n", "  /**\n", "   * Creates an {@code ArrayList} instance to hold {@code estimatedSize}\n", "   * elements, <i>plus</i> an unspecified amount of padding; you almost\n", "   * certainly mean to call {@link #newArrayListWithCapacity} (see that method\n", "   * for further advice on usage).\n", "   *\n", "   * <p><b>Note:</b> This method will soon be deprecated. Even in the rare case\n", "   * that you do want some amount of padding, it's best if you choose your\n", "   * desired amount explicitly.\n", "   *\n", "   * @param estimatedSize an estimate of the eventual {@link List#size()} of\n", "   *     the new list\n", "   * @return a new, empty {@code ArrayList}, sized appropriately to hold the\n", "   *     estimated number of elements\n", "   * @throws IllegalArgumentException if {@code estimatedSize} is negative\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <E> ArrayList<E> newArrayListWithExpectedSize(int estimatedSize) {\n", "    return new ArrayList<E>(computeArrayListCapacity(estimatedSize));\n", "  }\n", "\n", "  // LinkedList\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty {@code LinkedList} instance (for Java 6 and\n", "   * earlier).\n", "   *\n", "   * <p><b>Note:</b> if you won't be adding any elements to the list, use {@link\n", "   * ImmutableList#of()} instead.\n", "   *\n", "   * <p><b>Performance note:</b> {@link ArrayList} and {@link\n", "   * java.util.ArrayDeque} consistently outperform {@code LinkedList} except in\n", "   * certain rare and specific situations. Unless you have spent a lot of time\n", "   * benchmarking your specific needs, use one of those instead.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and\n", "   * should be treated as deprecated. Instead, use the {@code LinkedList}\n", "   * {@linkplain LinkedList#LinkedList() constructor} directly, taking advantage\n", "   * of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <E> LinkedList<E> newLinkedList() {\n", "    return new LinkedList<E>();\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code LinkedList} instance containing the given\n", "   * elements; a very thin shortcut for creating an empty list then calling\n", "   * {@link Iterables#addAll}.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required and the elements are\n", "   * non-null, use {@link ImmutableList#copyOf(Iterable)} instead. (Or, change\n", "   * {@code elements} to be a {@link FluentIterable} and call\n", "   * {@code elements.toList()}.)\n", "   *\n", "   * <p><b>Performance note:</b> {@link ArrayList} and {@link\n", "   * java.util.ArrayDeque} consistently outperform {@code LinkedList} except in\n", "   * certain rare and specific situations. Unless you have spent a lot of time\n", "   * benchmarking your specific needs, use one of those instead.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link\n", "   * Collection}, you don't need this method. Use the {@code LinkedList}\n", "   * {@linkplain LinkedList#LinkedList(Collection) constructor} directly, taking\n", "   * advantage of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <E> LinkedList<E> newLinkedList(Iterable<? extends E> elements) {\n", "    LinkedList<E> list = newLinkedList();\n", "    Iterables.addAll(list, elements);\n", "    return list;\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable list containing the specified first element and\n", "   * backed by the specified array of additional elements. Changes to the {@code\n", "   * rest} array will be reflected in the returned list. Unlike {@link\n", "   * Arrays#asList}, the returned list is unmodifiable.\n", "   *\n", "   * <p>This is useful when a varargs method needs to use a signature such as\n", "   * {@code (Foo firstFoo, Foo... moreFoos)}, in order to avoid overload\n", "   * ambiguity or to enforce a minimum argument count.\n", "   *\n", "   * <p>The returned list is serializable and implements {@link RandomAccess}.\n", "   *\n", "   * @param first the first element\n", "   * @param rest an array of additional elements, possibly empty\n", "   * @return an unmodifiable list containing the specified elements\n", "   */\n", "  public static <E> List<E> asList(@Nullable E first, E[] rest) {\n", "    return new OnePlusArrayList<E>(first, rest);\n", "  }\n", "\n", "  /** @see Lists#asList(Object, Object[]) */\n", "  private static class OnePlusArrayList<E> extends AbstractList<E>\n", "      implements Serializable, RandomAccess {\n", "    final E first;\n", "    final E[] rest;\n", "\n", "    OnePlusArrayList(@Nullable E first, E[] rest) {\n", "      this.first = first;\n", "      this.rest = checkNotNull(rest);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return rest.length + 1;\n", "    }\n", "\n", "    @Override\n", "    public E get(int index) {\n", "      // check explicitly so the IOOBE will have the right message\n", "      checkElementIndex(index, size());\n", "      return (index == 0) ? first : rest[index - 1];\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable list containing the specified first and second\n", "   * element, and backed by the specified array of additional elements. Changes\n", "   * to the {@code rest} array will be reflected in the returned list. Unlike\n", "   * {@link Arrays#asList}, the returned list is unmodifiable.\n", "   *\n", "   * <p>This is useful when a varargs method needs to use a signature such as\n", "   * {@code (Foo firstFoo, Foo secondFoo, Foo... moreFoos)}, in order to avoid\n", "   * overload ambiguity or to enforce a minimum argument count.\n", "   *\n", "   * <p>The returned list is serializable and implements {@link RandomAccess}.\n", "   *\n", "   * @param first the first element\n", "   * @param second the second element\n", "   * @param rest an array of additional elements, possibly empty\n", "   * @return an unmodifiable list containing the specified elements\n", "   */\n", "  public static <E> List<E> asList(@Nullable E first, @Nullable E second, E[] rest) {\n", "    return new TwoPlusArrayList<E>(first, second, rest);\n", "  }\n", "\n", "  /** @see Lists#asList(Object, Object, Object[]) */\n", "  private static class TwoPlusArrayList<E> extends AbstractList<E>\n", "      implements Serializable, RandomAccess {\n", "    final E first;\n", "    final E second;\n", "    final E[] rest;\n", "\n", "    TwoPlusArrayList(@Nullable E first, @Nullable E second, E[] rest) {\n", "      this.first = first;\n", "      this.second = second;\n", "      this.rest = checkNotNull(rest);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return rest.length + 2;\n", "    }\n", "\n", "    @Override\n", "    public E get(int index) {\n", "      switch (index) {\n", "        case 0:\n", "          return first;\n", "        case 1:\n", "          return second;\n", "        default:\n", "          // check explicitly so the IOOBE will have the right message\n", "          checkElementIndex(index, size());\n", "          return rest[index - 2];\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Returns every possible list that can be formed by choosing one element\n", "   * from each of the given lists in order; the \"n-ary\n", "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n", "   * product</a>\" of the lists. For example: <pre>   {@code\n", "   *\n", "   *   Lists.cartesianProduct(ImmutableList.of(\n", "   *       ImmutableList.of(1, 2),\n", "   *       ImmutableList.of(\"A\", \"B\", \"C\")))}</pre>\n", "   *\n", "   * <p>returns a list containing six lists in the following order:\n", "   *\n", "   * <ul>\n", "   * <li>{@code ImmutableList.of(1, \"A\")}\n", "   * <li>{@code ImmutableList.of(1, \"B\")}\n", "   * <li>{@code ImmutableList.of(1, \"C\")}\n", "   * <li>{@code ImmutableList.of(2, \"A\")}\n", "   * <li>{@code ImmutableList.of(2, \"B\")}\n", "   * <li>{@code ImmutableList.of(2, \"C\")}\n", "   * </ul>\n", "   *\n", "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n", "   * order for Cartesian products that you would get from nesting for loops:\n", "   * <pre>   {@code\n", "   *\n", "   *   for (B b0 : lists.get(0)) {\n", "   *     for (B b1 : lists.get(1)) {\n", "   *       ...\n", "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n", "   *       // operate on tuple\n", "   *     }\n", "   *   }}</pre>\n", "   *\n", "   * <p>Note that if any input list is empty, the Cartesian product will also be\n", "   * empty. If no lists at all are provided (an empty list), the resulting\n", "   * Cartesian product has one element, an empty list (counter-intuitive, but\n", "   * mathematically consistent).\n", "   *\n", "   * <p><i>Performance notes:</i> while the cartesian product of lists of size\n", "   * {@code m, n, p} is a list of size {@code m x n x p}, its actual memory\n", "   * consumption is much smaller. When the cartesian product is constructed, the\n", "   * input lists are merely copied. Only as the resulting list is iterated are\n", "   * the individual lists created, and these are not retained after iteration.\n", "   *\n", "   * @param lists the lists to choose elements from, in the order that\n", "   *     the elements chosen from those lists should appear in the resulting\n", "   *     lists\n", "   * @param <B> any common base class shared by all axes (often just {@link\n", "   *     Object})\n", "   * @return the Cartesian product, as an immutable list containing immutable\n", "   *     lists\n", "   * @throws IllegalArgumentException if the size of the cartesian product would\n", "   *     be greater than {@link Integer#MAX_VALUE}\n", "   * @throws NullPointerException if {@code lists}, any one of the {@code lists},\n", "   *     or any element of a provided list is null\n", "   * @since 19.0\n", "   */\n", "  public static <B> List<List<B>> cartesianProduct(List<? extends List<? extends B>> lists) {\n", "    return CartesianList.create(lists);\n", "  }\n", "\n", "  /**\n", "   * Returns every possible list that can be formed by choosing one element\n", "   * from each of the given lists in order; the \"n-ary\n", "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n", "   * product</a>\" of the lists. For example: <pre>   {@code\n", "   *\n", "   *   Lists.cartesianProduct(ImmutableList.of(\n", "   *       ImmutableList.of(1, 2),\n", "   *       ImmutableList.of(\"A\", \"B\", \"C\")))}</pre>\n", "   *\n", "   * <p>returns a list containing six lists in the following order:\n", "   *\n", "   * <ul>\n", "   * <li>{@code ImmutableList.of(1, \"A\")}\n", "   * <li>{@code ImmutableList.of(1, \"B\")}\n", "   * <li>{@code ImmutableList.of(1, \"C\")}\n", "   * <li>{@code ImmutableList.of(2, \"A\")}\n", "   * <li>{@code ImmutableList.of(2, \"B\")}\n", "   * <li>{@code ImmutableList.of(2, \"C\")}\n", "   * </ul>\n", "   *\n", "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n", "   * order for Cartesian products that you would get from nesting for loops:\n", "   * <pre>   {@code\n", "   *\n", "   *   for (B b0 : lists.get(0)) {\n", "   *     for (B b1 : lists.get(1)) {\n", "   *       ...\n", "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n", "   *       // operate on tuple\n", "   *     }\n", "   *   }}</pre>\n", "   *\n", "   * <p>Note that if any input list is empty, the Cartesian product will also be\n", "   * empty. If no lists at all are provided (an empty list), the resulting\n", "   * Cartesian product has one element, an empty list (counter-intuitive, but\n", "   * mathematically consistent).\n", "   *\n", "   * <p><i>Performance notes:</i> while the cartesian product of lists of size\n", "   * {@code m, n, p} is a list of size {@code m x n x p}, its actual memory\n", "   * consumption is much smaller. When the cartesian product is constructed, the\n", "   * input lists are merely copied. Only as the resulting list is iterated are\n", "   * the individual lists created, and these are not retained after iteration.\n", "   *\n", "   * @param lists the lists to choose elements from, in the order that\n", "   *     the elements chosen from those lists should appear in the resulting\n", "   *     lists\n", "   * @param <B> any common base class shared by all axes (often just {@link\n", "   *     Object})\n", "   * @return the Cartesian product, as an immutable list containing immutable\n", "   *     lists\n", "   * @throws IllegalArgumentException if the size of the cartesian product would\n", "   *     be greater than {@link Integer#MAX_VALUE}\n", "   * @throws NullPointerException if {@code lists}, any one of the\n", "   *     {@code lists}, or any element of a provided list is null\n", "   * @since 19.0\n", "   */\n", "  public static <B> List<List<B>> cartesianProduct(List<? extends B>... lists) {\n", "    return cartesianProduct(Arrays.asList(lists));\n", "  }\n", "\n", "  /**\n", "   * Returns a list that applies {@code function} to each element of {@code\n", "   * fromList}. The returned list is a transformed view of {@code fromList};\n", "   * changes to {@code fromList} will be reflected in the returned list and vice\n", "   * versa.\n", "   *\n", "   * <p>Since functions are not reversible, the transform is one-way and new\n", "   * items cannot be stored in the returned list. The {@code add},\n", "   * {@code addAll} and {@code set} methods are unsupported in the returned\n", "   * list.\n", "   *\n", "   * <p>The function is applied lazily, invoked when needed. This is necessary\n", "   * for the returned list to be a view, but it means that the function will be\n", "   * applied many times for bulk operations like {@link List#contains} and\n", "   * {@link List#hashCode}. For this to perform well, {@code function} should be\n", "   * fast. To avoid lazy evaluation when the returned list doesn't need to be a\n", "   * view, copy the returned list into a new list of your choosing.\n", "   *\n", "   * <p>If {@code fromList} implements {@link RandomAccess}, so will the\n", "   * returned list. The returned list is threadsafe if the supplied list and\n", "   * function are.\n", "   *\n", "   * <p>If only a {@code Collection} or {@code Iterable} input is available, use\n", "   * {@link Collections2#transform} or {@link Iterables#transform}.\n", "   *\n", "   * <p><b>Note:</b> serializing the returned list is implemented by serializing\n", "   * {@code fromList}, its contents, and {@code function} -- <i>not</i> by\n", "   * serializing the transformed values. This can lead to surprising behavior,\n", "   * so serializing the returned list is <b>not recommended</b>. Instead,\n", "   * copy the list using {@link ImmutableList#copyOf(Collection)} (for example),\n", "   * then serialize the copy. Other methods similar to this do not implement\n", "   * serialization at all for this reason.\n", "   */\n", "  @CheckReturnValue\n", "  public static <F, T> List<T> transform(\n", "      List<F> fromList, Function<? super F, ? extends T> function) {\n", "    return (fromList instanceof RandomAccess)\n", "        ? new TransformingRandomAccessList<F, T>(fromList, function)\n", "        : new TransformingSequentialList<F, T>(fromList, function);\n", "  }\n", "\n", "  /**\n", "   * Implementation of a sequential transforming list.\n", "   *\n", "   * @see Lists#transform\n", "   */\n", "  private static class TransformingSequentialList<F, T> extends AbstractSequentialList<T>\n", "      implements Serializable {\n", "    final List<F> fromList;\n", "    final Function<? super F, ? extends T> function;\n", "\n", "    TransformingSequentialList(List<F> fromList, Function<? super F, ? extends T> function) {\n", "      this.fromList = checkNotNull(fromList);\n", "      this.function = checkNotNull(function);\n", "    }\n", "    /**\n", "     * The default implementation inherited is based on iteration and removal of\n", "     * each element which can be overkill. That's why we forward this call\n", "     * directly to the backing list.\n", "     */\n", "    @Override\n", "    public void clear() {\n", "      fromList.clear();\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return fromList.size();\n", "    }\n", "\n", "    @Override\n", "    public ListIterator<T> listIterator(final int index) {\n", "      return new TransformedListIterator<F, T>(fromList.listIterator(index)) {\n", "        @Override\n", "        T transform(F from) {\n", "          return function.apply(from);\n", "        }\n", "      };\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Implementation of a transforming random access list. We try to make as many\n", "   * of these methods pass-through to the source list as possible so that the\n", "   * performance characteristics of the source list and transformed list are\n", "   * similar.\n", "   *\n", "   * @see Lists#transform\n", "   */\n", "  private static class TransformingRandomAccessList<F, T> extends AbstractList<T>\n", "      implements RandomAccess, Serializable {\n", "    final List<F> fromList;\n", "    final Function<? super F, ? extends T> function;\n", "\n", "    TransformingRandomAccessList(List<F> fromList, Function<? super F, ? extends T> function) {\n", "      this.fromList = checkNotNull(fromList);\n", "      this.function = checkNotNull(function);\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      fromList.clear();\n", "    }\n", "\n", "    @Override\n", "    public T get(int index) {\n", "      return function.apply(fromList.get(index));\n", "    }\n", "\n", "    @Override\n", "    public Iterator<T> iterator() {\n", "      return listIterator();\n", "    }\n", "\n", "    @Override\n", "    public ListIterator<T> listIterator(int index) {\n", "      return new TransformedListIterator<F, T>(fromList.listIterator(index)) {\n", "        @Override\n", "        T transform(F from) {\n", "          return function.apply(from);\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return fromList.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public T remove(int index) {\n", "      return function.apply(fromList.remove(index));\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return fromList.size();\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Returns consecutive {@linkplain List#subList(int, int) sublists} of a list,\n", "   * each of the same size (the final list may be smaller). For example,\n", "   * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n", "   * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n", "   * two inner lists of three and two elements, all in the original order.\n", "   *\n", "   * <p>The outer list is unmodifiable, but reflects the latest state of the\n", "   * source list. The inner lists are sublist views of the original list,\n", "   * produced on demand using {@link List#subList(int, int)}, and are subject\n", "   * to all the usual caveats about modification as explained in that API.\n", "   *\n", "   * @param list the list to return consecutive sublists of\n", "   * @param size the desired size of each sublist (the last may be\n", "   *     smaller)\n", "   * @return a list of consecutive sublists\n", "   * @throws IllegalArgumentException if {@code partitionSize} is nonpositive\n", "   */\n", "  public static <T> List<List<T>> partition(List<T> list, int size) {\n", "    checkNotNull(list);\n", "    checkArgument(size > 0);\n", "    return (list instanceof RandomAccess)\n", "        ? new RandomAccessPartition<T>(list, size)\n", "        : new Partition<T>(list, size);\n", "  }\n", "\n", "  private static class Partition<T> extends AbstractList<List<T>> {\n", "    final List<T> list;\n", "    final int size;\n", "\n", "    Partition(List<T> list, int size) {\n", "      this.list = list;\n", "      this.size = size;\n", "    }\n", "\n", "    @Override\n", "    public List<T> get(int index) {\n", "      checkElementIndex(index, size());\n", "      int start = index * size;\n", "      int end = Math.min(start + size, list.size());\n", "      return list.subList(start, end);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return IntMath.divide(list.size(), size, RoundingMode.CEILING);\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return list.isEmpty();\n", "    }\n", "  }\n", "\n", "  private static class RandomAccessPartition<T> extends Partition<T> implements RandomAccess {\n", "    RandomAccessPartition(List<T> list, int size) {\n", "      super(list, size);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a view of the specified string as an immutable list of {@code\n", "   * Character} values.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  @Beta\n", "  public static ImmutableList<Character> charactersOf(String string) {\n", "    return new StringAsImmutableList(checkNotNull(string));\n", "  }\n", "\n", "  @SuppressWarnings(\"serial\") // serialized using ImmutableList serialization\n", "  private static final class StringAsImmutableList extends ImmutableList<Character> {\n", "\n", "    private final String string;\n", "\n", "    StringAsImmutableList(String string) {\n", "      this.string = string;\n", "    }\n", "\n", "    @Override\n", "    public int indexOf(@Nullable Object object) {\n", "      return (object instanceof Character) ? string.indexOf((Character) object) : -1;\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexOf(@Nullable Object object) {\n", "      return (object instanceof Character) ? string.lastIndexOf((Character) object) : -1;\n", "    }\n", "\n", "    @Override\n", "    public ImmutableList<Character> subList(int fromIndex, int toIndex) {\n", "      checkPositionIndexes(fromIndex, toIndex, size()); // for GWT\n", "      return charactersOf(string.substring(fromIndex, toIndex));\n", "    }\n", "\n", "    @Override\n", "    boolean isPartialView() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public Character get(int index) {\n", "      checkElementIndex(index, size()); // for GWT\n", "      return string.charAt(index);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return string.length();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a view of the specified {@code CharSequence} as a {@code\n", "   * List<Character>}, viewing {@code sequence} as a sequence of Unicode code\n", "   * units. The view does not support any modification operations, but reflects\n", "   * any changes to the underlying character sequence.\n", "   *\n", "   * @param sequence the character sequence to view as a {@code List} of\n", "   *        characters\n", "   * @return an {@code List<Character>} view of the character sequence\n", "   * @since 7.0\n", "   */\n", "  @Beta\n", "  public static List<Character> charactersOf(CharSequence sequence) {\n", "    return new CharSequenceAsList(checkNotNull(sequence));\n", "  }\n", "\n", "  private static final class CharSequenceAsList extends AbstractList<Character> {\n", "    private final CharSequence sequence;\n", "\n", "    CharSequenceAsList(CharSequence sequence) {\n", "      this.sequence = sequence;\n", "    }\n", "\n", "    @Override\n", "    public Character get(int index) {\n", "      checkElementIndex(index, size()); // for GWT\n", "      return sequence.charAt(index);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return sequence.length();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a reversed view of the specified list. For example, {@code\n", "   * Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3,\n", "   * 2, 1}. The returned list is backed by this list, so changes in the returned\n", "   * list are reflected in this list, and vice-versa. The returned list supports\n", "   * all of the optional list operations supported by this list.\n", "   *\n", "   * <p>The returned list is random-access if the specified list is random\n", "   * access.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <T> List<T> reverse(List<T> list) {\n", "    if (list instanceof ImmutableList) {\n", "      return ((ImmutableList<T>) list).reverse();\n", "    } else if (list instanceof ReverseList) {\n", "      return ((ReverseList<T>) list).getForwardList();\n", "    } else if (list instanceof RandomAccess) {\n", "      return new RandomAccessReverseList<T>(list);\n", "    } else {\n", "      return new ReverseList<T>(list);\n", "    }\n", "  }\n", "\n", "  private static class ReverseList<T> extends AbstractList<T> {\n", "    private final List<T> forwardList;\n", "\n", "    ReverseList(List<T> forwardList) {\n", "      this.forwardList = checkNotNull(forwardList);\n", "    }\n", "\n", "    List<T> getForwardList() {\n", "      return forwardList;\n", "    }\n", "\n", "    private int reverseIndex(int index) {\n", "      int size = size();\n", "      checkElementIndex(index, size);\n", "      return (size - 1) - index;\n", "    }\n", "\n", "    private int reversePosition(int index) {\n", "      int size = size();\n", "      checkPositionIndex(index, size);\n", "      return size - index;\n", "    }\n", "\n", "    @Override\n", "    public void add(int index, @Nullable T element) {\n", "      forwardList.add(reversePosition(index), element);\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      forwardList.clear();\n", "    }\n", "\n", "    @Override\n", "    public T remove(int index) {\n", "      return forwardList.remove(reverseIndex(index));\n", "    }\n", "\n", "    @Override\n", "    protected void removeRange(int fromIndex, int toIndex) {\n", "      subList(fromIndex, toIndex).clear();\n", "    }\n", "\n", "    @Override\n", "    public T set(int index, @Nullable T element) {\n", "      return forwardList.set(reverseIndex(index), element);\n", "    }\n", "\n", "    @Override\n", "    public T get(int index) {\n", "      return forwardList.get(reverseIndex(index));\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return forwardList.size();\n", "    }\n", "\n", "    @Override\n", "    public List<T> subList(int fromIndex, int toIndex) {\n", "      checkPositionIndexes(fromIndex, toIndex, size());\n", "      return reverse(forwardList.subList(reversePosition(toIndex), reversePosition(fromIndex)));\n", "    }\n", "\n", "    @Override\n", "    public Iterator<T> iterator() {\n", "      return listIterator();\n", "    }\n", "\n", "    @Override\n", "    public ListIterator<T> listIterator(int index) {\n", "      int start = reversePosition(index);\n", "      final ListIterator<T> forwardIterator = forwardList.listIterator(start);\n", "      return new ListIterator<T>() {\n", "\n", "        boolean canRemoveOrSet;\n", "\n", "        @Override\n", "        public void add(T e) {\n", "          forwardIterator.add(e);\n", "          forwardIterator.previous();\n", "          canRemoveOrSet = false;\n", "        }\n", "\n", "        @Override\n", "        public boolean hasNext() {\n", "          return forwardIterator.hasPrevious();\n", "        }\n", "\n", "        @Override\n", "        public boolean hasPrevious() {\n", "          return forwardIterator.hasNext();\n", "        }\n", "\n", "        @Override\n", "        public T next() {\n", "          if (!hasNext()) {\n", "            throw new NoSuchElementException();\n", "          }\n", "          canRemoveOrSet = true;\n", "          return forwardIterator.previous();\n", "        }\n", "\n", "        @Override\n", "        public int nextIndex() {\n", "          return reversePosition(forwardIterator.nextIndex());\n", "        }\n", "\n", "        @Override\n", "        public T previous() {\n", "          if (!hasPrevious()) {\n", "            throw new NoSuchElementException();\n", "          }\n", "          canRemoveOrSet = true;\n", "          return forwardIterator.next();\n", "        }\n", "\n", "        @Override\n", "        public int previousIndex() {\n", "          return nextIndex() - 1;\n", "        }\n", "\n", "        @Override\n", "        public void remove() {\n", "          checkRemove(canRemoveOrSet);\n", "          forwardIterator.remove();\n", "          canRemoveOrSet = false;\n", "        }\n", "\n", "        @Override\n", "        public void set(T e) {\n", "          checkState(canRemoveOrSet);\n", "          forwardIterator.set(e);\n", "        }\n", "      };\n", "    }\n", "  }\n", "\n", "  private static class RandomAccessReverseList<T> extends ReverseList<T> implements RandomAccess {\n", "    RandomAccessReverseList(List<T> forwardList) {\n", "      super(forwardList);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link List#hashCode()}.\n", "   */\n", "  static int hashCodeImpl(List<?> list) {\n", "    // TODO(lowasser): worth optimizing for RandomAccess?\n", "    int hashCode = 1;\n", "    for (Object o : list) {\n", "      hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());\n", "\n", "      hashCode = ~~hashCode;\n", "      // needed to deal with GWT integer overflow\n", "    }\n", "    return hashCode;\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link List#equals(Object)}.\n", "   */\n", "  static boolean equalsImpl(List<?> thisList, @Nullable Object other) {\n", "    if (other == checkNotNull(thisList)) {\n", "      return true;\n", "    }\n", "    if (!(other instanceof List)) {\n", "      return false;\n", "    }\n", "    List<?> otherList = (List<?>) other;\n", "    int size = thisList.size();\n", "    if (size != otherList.size()) {\n", "      return false;\n", "    }\n", "    if (thisList instanceof RandomAccess && otherList instanceof RandomAccess) {\n", "      // avoid allocation and use the faster loop\n", "      for (int i = 0; i < size; i++) {\n", "        if (!Objects.equal(thisList.get(i), otherList.get(i))) {\n", "          return false;\n", "        }\n", "      }\n", "      return true;\n", "    } else {\n", "      return Iterators.elementsEqual(thisList.iterator(), otherList.iterator());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link List#addAll(int, Collection)}.\n", "   */\n", "  static <E> boolean addAllImpl(List<E> list, int index, Iterable<? extends E> elements) {\n", "    boolean changed = false;\n", "    ListIterator<E> listIterator = list.listIterator(index);\n", "    for (E e : elements) {\n", "      listIterator.add(e);\n", "      changed = true;\n", "    }\n", "    return changed;\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link List#indexOf(Object)}.\n", "   */\n", "  static int indexOfImpl(List<?> list, @Nullable Object element) {\n", "    if (list instanceof RandomAccess) {\n", "      return indexOfRandomAccess(list, element);\n", "    } else {\n", "      ListIterator<?> listIterator = list.listIterator();\n", "      while (listIterator.hasNext()) {\n", "        if (Objects.equal(element, listIterator.next())) {\n", "          return listIterator.previousIndex();\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "  }\n", "\n", "  private static int indexOfRandomAccess(List<?> list, @Nullable Object element) {\n", "    int size = list.size();\n", "    if (element == null) {\n", "      for (int i = 0; i < size; i++) {\n", "        if (list.get(i) == null) {\n", "          return i;\n", "        }\n", "      }\n", "    } else {\n", "      for (int i = 0; i < size; i++) {\n", "        if (element.equals(list.get(i))) {\n", "          return i;\n", "        }\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link List#lastIndexOf(Object)}.\n", "   */\n", "  static int lastIndexOfImpl(List<?> list, @Nullable Object element) {\n", "    if (list instanceof RandomAccess) {\n", "      return lastIndexOfRandomAccess(list, element);\n", "    } else {\n", "      ListIterator<?> listIterator = list.listIterator(list.size());\n", "      while (listIterator.hasPrevious()) {\n", "        if (Objects.equal(element, listIterator.previous())) {\n", "          return listIterator.nextIndex();\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "  }\n", "\n", "  private static int lastIndexOfRandomAccess(List<?> list, @Nullable Object element) {\n", "    if (element == null) {\n", "      for (int i = list.size() - 1; i >= 0; i--) {\n", "        if (list.get(i) == null) {\n", "          return i;\n", "        }\n", "      }\n", "    } else {\n", "      for (int i = list.size() - 1; i >= 0; i--) {\n", "        if (element.equals(list.get(i))) {\n", "          return i;\n", "        }\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns an implementation of {@link List#listIterator(int)}.\n", "   */\n", "  static <E> ListIterator<E> listIteratorImpl(List<E> list, int index) {\n", "    return new AbstractListWrapper<E>(list).listIterator(index);\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link List#subList(int, int)}.\n", "   */\n", "  static <E> List<E> subListImpl(final List<E> list, int fromIndex, int toIndex) {\n", "    List<E> wrapper;\n", "    if (list instanceof RandomAccess) {\n", "      wrapper = new RandomAccessListWrapper<E>(list) {\n", "        @Override\n", "        public ListIterator<E> listIterator(int index) {\n", "          return backingList.listIterator(index);\n", "        }\n", "\n", "        private static final long serialVersionUID = 0;\n", "      };\n", "    } else {\n", "      wrapper = new AbstractListWrapper<E>(list) {\n", "        @Override\n", "        public ListIterator<E> listIterator(int index) {\n", "          return backingList.listIterator(index);\n", "        }\n", "\n", "        private static final long serialVersionUID = 0;\n", "      };\n", "    }\n", "    return wrapper.subList(fromIndex, toIndex);\n", "  }\n", "\n", "  private static class AbstractListWrapper<E> extends AbstractList<E> {\n", "    final List<E> backingList;\n", "\n", "    AbstractListWrapper(List<E> backingList) {\n", "      this.backingList = checkNotNull(backingList);\n", "    }\n", "\n", "    @Override\n", "    public void add(int index, E element) {\n", "      backingList.add(index, element);\n", "    }\n", "\n", "    @Override\n", "    public boolean addAll(int index, Collection<? extends E> c) {\n", "      return backingList.addAll(index, c);\n", "    }\n", "\n", "    @Override\n", "    public E get(int index) {\n", "      return backingList.get(index);\n", "    }\n", "\n", "    @Override\n", "    public E remove(int index) {\n", "      return backingList.remove(index);\n", "    }\n", "\n", "    @Override\n", "    public E set(int index, E element) {\n", "      return backingList.set(index, element);\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object o) {\n", "      return backingList.contains(o);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return backingList.size();\n", "    }\n", "  }\n", "\n", "  private static class RandomAccessListWrapper<E> extends AbstractListWrapper<E>\n", "      implements RandomAccess {\n", "    RandomAccessListWrapper(List<E> backingList) {\n", "      super(backingList);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557\n", "   */\n", "  static <T> List<T> cast(Iterable<T> iterable) {\n", "    return (List<T>) iterable;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160]}}, {"38": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Maps.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Predicates.compose;\n", "import static com.google.common.base.Predicates.equalTo;\n", "import static com.google.common.base.Predicates.in;\n", "import static com.google.common.base.Predicates.not;\n", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "import com.google.common.base.Equivalence;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Joiner.MapJoiner;\n", "import com.google.common.base.Objects;\n", "import com.google.common.base.Preconditions;\n", "import com.google.common.base.Predicate;\n", "import com.google.common.base.Predicates;\n", "import com.google.common.collect.MapDifference.ValueDifference;\n", "import com.google.common.primitives.Ints;\n", "import com.google.j2objc.annotations.Weak;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractCollection;\n", "import java.util.AbstractMap;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.EnumMap;\n", "import java.util.HashMap;\n", "import java.util.IdentityHashMap;\n", "import java.util.Iterator;\n", "import java.util.LinkedHashMap;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "import java.util.SortedMap;\n", "import java.util.SortedSet;\n", "import java.util.TreeMap;\n", "import java.util.concurrent.ConcurrentMap;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to {@link Map} instances (including instances of\n", " * {@link SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts\n", " * {@link Lists}, {@link Sets} and {@link Queues}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps\">\n", " * {@code Maps}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Mike Bostock\n", " * @author Isaac Shum\n", " * @author Louis Wasserman\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Maps {\n", "  private Maps() {}\n", "\n", "  private enum EntryFunction implements Function<Entry<?, ?>, Object> {\n", "    KEY {\n", "      @Override\n", "      @Nullable\n", "      public Object apply(Entry<?, ?> entry) {\n", "        return entry.getKey();\n", "      }\n", "    },\n", "    VALUE {\n", "      @Override\n", "      @Nullable\n", "      public Object apply(Entry<?, ?> entry) {\n", "        return entry.getValue();\n", "      }\n", "    };\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  static <K> Function<Entry<K, ?>, K> keyFunction() {\n", "    return (Function) EntryFunction.KEY;\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  static <V> Function<Entry<?, V>, V> valueFunction() {\n", "    return (Function) EntryFunction.VALUE;\n", "  }\n", "\n", "  static <K, V> Iterator<K> keyIterator(Iterator<Entry<K, V>> entryIterator) {\n", "    return Iterators.transform(entryIterator, Maps.<K>keyFunction());\n", "  }\n", "\n", "  static <K, V> Iterator<V> valueIterator(Iterator<Entry<K, V>> entryIterator) {\n", "    return Iterators.transform(entryIterator, Maps.<V>valueFunction());\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable map instance containing the given entries.\n", "   * Internally, the returned map will be backed by an {@link EnumMap}.\n", "   *\n", "   * <p>The iteration order of the returned map follows the enum's iteration\n", "   * order, not the order in which the elements appear in the given map.\n", "   *\n", "   * @param map the map to make an immutable copy of\n", "   * @return an immutable map containing those entries\n", "   * @since 14.0\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  @Beta\n", "  public static <K extends Enum<K>, V> ImmutableMap<K, V> immutableEnumMap(\n", "      Map<K, ? extends V> map) {\n", "    if (map instanceof ImmutableEnumMap) {\n", "      @SuppressWarnings(\"unchecked\") // safe covariant cast\n", "      ImmutableEnumMap<K, V> result = (ImmutableEnumMap<K, V>) map;\n", "      return result;\n", "    } else if (map.isEmpty()) {\n", "      return ImmutableMap.of();\n", "    } else {\n", "      for (Map.Entry<K, ? extends V> entry : map.entrySet()) {\n", "        checkNotNull(entry.getKey());\n", "        checkNotNull(entry.getValue());\n", "      }\n", "      return ImmutableEnumMap.asImmutable(new EnumMap<K, V>(map));\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty {@code HashMap} instance.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableMap#of()} instead.\n", "   *\n", "   * <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link\n", "   * #newEnumMap} instead.\n", "   *\n", "   * @return a new, empty {@code HashMap}\n", "   */\n", "  public static <K, V> HashMap<K, V> newHashMap() {\n", "    return new HashMap<K, V>();\n", "  }\n", "\n", "  /**\n", "   * Creates a {@code HashMap} instance, with a high enough \"initial capacity\"\n", "   * that it <i>should</i> hold {@code expectedSize} elements without growth.\n", "   * This behavior cannot be broadly guaranteed, but it is observed to be true\n", "   * for OpenJDK 1.7. It also can't be guaranteed that the method isn't\n", "   * inadvertently <i>oversizing</i> the returned map.\n", "   *\n", "   * @param expectedSize the number of entries you expect to add to the\n", "   *        returned map\n", "   * @return a new, empty {@code HashMap} with enough capacity to hold {@code\n", "   *         expectedSize} entries without resizing\n", "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n", "   */\n", "  public static <K, V> HashMap<K, V> newHashMapWithExpectedSize(int expectedSize) {\n", "    return new HashMap<K, V>(capacity(expectedSize));\n", "  }\n", "\n", "  /**\n", "   * Returns a capacity that is sufficient to keep the map from being resized as\n", "   * long as it grows no larger than expectedSize and the load factor is >= its\n", "   * default (0.75).\n", "   */\n", "  static int capacity(int expectedSize) {\n", "    if (expectedSize < 3) {\n", "      checkNonnegative(expectedSize, \"expectedSize\");\n", "      return expectedSize + 1;\n", "    }\n", "    if (expectedSize < Ints.MAX_POWER_OF_TWO) {\n", "      // This is the calculation used in JDK8 to resize when a putAll\n", "      // happens; it seems to be the most conservative calculation we\n", "      // can make.  0.75 is the default load factor.\n", "      return (int) ((float) expectedSize / 0.75F + 1.0F);\n", "    }\n", "    return Integer.MAX_VALUE; // any large value\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as\n", "   * the specified map.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableMap#copyOf(Map)} instead.\n", "   *\n", "   * <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link\n", "   * #newEnumMap} instead.\n", "   *\n", "   * @param map the mappings to be placed in the new map\n", "   * @return a new {@code HashMap} initialized with the mappings from {@code\n", "   *         map}\n", "   */\n", "  public static <K, V> HashMap<K, V> newHashMap(Map<? extends K, ? extends V> map) {\n", "    return new HashMap<K, V>(map);\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}\n", "   * instance.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableMap#of()} instead.\n", "   *\n", "   * @return a new, empty {@code LinkedHashMap}\n", "   */\n", "  public static <K, V> LinkedHashMap<K, V> newLinkedHashMap() {\n", "    return new LinkedHashMap<K, V>();\n", "  }\n", "\n", "  /**\n", "   * Creates a {@code LinkedHashMap} instance, with a high enough\n", "   * \"initial capacity\" that it <i>should</i> hold {@code expectedSize}\n", "   * elements without growth. This behavior cannot be broadly guaranteed, but\n", "   * it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n", "   * that the method isn't inadvertently <i>oversizing</i> the returned map.\n", "   *\n", "   * @param expectedSize the number of entries you expect to add to the\n", "   *        returned map\n", "   * @return a new, empty {@code LinkedHashMap} with enough capacity to hold\n", "   *         {@code expectedSize} entries without resizing\n", "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n", "   * @since 19.0\n", "   */\n", "  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {\n", "    return new LinkedHashMap<K, V>(capacity(expectedSize));\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance\n", "   * with the same mappings as the specified map.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableMap#copyOf(Map)} instead.\n", "   *\n", "   * @param map the mappings to be placed in the new map\n", "   * @return a new, {@code LinkedHashMap} initialized with the mappings from\n", "   *         {@code map}\n", "   */\n", "  public static <K, V> LinkedHashMap<K, V> newLinkedHashMap(Map<? extends K, ? extends V> map) {\n", "    return new LinkedHashMap<K, V>(map);\n", "  }\n", "\n", "  /**\n", "   * Returns a general-purpose instance of {@code ConcurrentMap}, which supports\n", "   * all optional operations of the ConcurrentMap interface. It does not permit\n", "   * null keys or values. It is serializable.\n", "   *\n", "   * <p>This is currently accomplished by calling {@link MapMaker#makeMap()}.\n", "   *\n", "   * <p>It is preferable to use {@code MapMaker} directly (rather than through\n", "   * this method), as it presents numerous useful configuration options,\n", "   * such as the concurrency level, load factor, key/value reference types,\n", "   * and value computation.\n", "   *\n", "   * @return a new, empty {@code ConcurrentMap}\n", "   * @since 3.0\n", "   */\n", "  public static <K, V> ConcurrentMap<K, V> newConcurrentMap() {\n", "    return new MapMaker().<K, V>makeMap();\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural\n", "   * ordering of its elements.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableSortedMap#of()} instead.\n", "   *\n", "   * @return a new, empty {@code TreeMap}\n", "   */\n", "  public static <K extends Comparable, V> TreeMap<K, V> newTreeMap() {\n", "    return new TreeMap<K, V>();\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as\n", "   * the specified map and using the same ordering as the specified map.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableSortedMap#copyOfSorted(SortedMap)} instead.\n", "   *\n", "   * @param map the sorted map whose mappings are to be placed in the new map\n", "   *        and whose comparator is to be used to sort the new map\n", "   * @return a new {@code TreeMap} initialized with the mappings from {@code\n", "   *         map} and using the comparator of {@code map}\n", "   */\n", "  public static <K, V> TreeMap<K, V> newTreeMap(SortedMap<K, ? extends V> map) {\n", "    return new TreeMap<K, V>(map);\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given\n", "   * comparator.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@code\n", "   * ImmutableSortedMap.orderedBy(comparator).build()} instead.\n", "   *\n", "   * @param comparator the comparator to sort the keys with\n", "   * @return a new, empty {@code TreeMap}\n", "   */\n", "  public static <C, K extends C, V> TreeMap<K, V> newTreeMap(@Nullable Comparator<C> comparator) {\n", "    // Ideally, the extra type parameter \"C\" shouldn't be necessary. It is a\n", "    // work-around of a compiler type inference quirk that prevents the\n", "    // following code from being compiled:\n", "    // Comparator<Class<?>> comparator = null;\n", "    // Map<Class<? extends Throwable>, String> map = newTreeMap(comparator);\n", "    return new TreeMap<K, V>(comparator);\n", "  }\n", "\n", "  /**\n", "   * Creates an {@code EnumMap} instance.\n", "   *\n", "   * @param type the key type for this map\n", "   * @return a new, empty {@code EnumMap}\n", "   */\n", "  public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Class<K> type) {\n", "    return new EnumMap<K, V>(checkNotNull(type));\n", "  }\n", "\n", "  /**\n", "   * Creates an {@code EnumMap} with the same mappings as the specified map.\n", "   *\n", "   * @param map the map from which to initialize this {@code EnumMap}\n", "   * @return a new {@code EnumMap} initialized with the mappings from {@code\n", "   *         map}\n", "   * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}\n", "   *         instance and contains no mappings\n", "   */\n", "  public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Map<K, ? extends V> map) {\n", "    return new EnumMap<K, V>(map);\n", "  }\n", "\n", "  /**\n", "   * Creates an {@code IdentityHashMap} instance.\n", "   *\n", "   * @return a new, empty {@code IdentityHashMap}\n", "   */\n", "  public static <K, V> IdentityHashMap<K, V> newIdentityHashMap() {\n", "    return new IdentityHashMap<K, V>();\n", "  }\n", "\n", "  /**\n", "   * Computes the difference between two maps. This difference is an immutable\n", "   * snapshot of the state of the maps at the time this method is called. It\n", "   * will never change, even if the maps change at a later time.\n", "   *\n", "   * <p>Since this method uses {@code HashMap} instances internally, the keys of\n", "   * the supplied maps must be well-behaved with respect to\n", "   * {@link Object#equals} and {@link Object#hashCode}.\n", "   *\n", "   * <p><b>Note:</b>If you only need to know whether two maps have the same\n", "   * mappings, call {@code left.equals(right)} instead of this method.\n", "   *\n", "   * @param left the map to treat as the \"left\" map for purposes of comparison\n", "   * @param right the map to treat as the \"right\" map for purposes of comparison\n", "   * @return the difference between the two maps\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public static <K, V> MapDifference<K, V> difference(\n", "      Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right) {\n", "    if (left instanceof SortedMap) {\n", "      SortedMap<K, ? extends V> sortedLeft = (SortedMap<K, ? extends V>) left;\n", "      SortedMapDifference<K, V> result = difference(sortedLeft, right);\n", "      return result;\n", "    }\n", "    return difference(left, right, Equivalence.equals());\n", "  }\n", "\n", "  /**\n", "   * Computes the difference between two maps. This difference is an immutable\n", "   * snapshot of the state of the maps at the time this method is called. It\n", "   * will never change, even if the maps change at a later time.\n", "   *\n", "   * <p>Values are compared using a provided equivalence, in the case of\n", "   * equality, the value on the 'left' is returned in the difference.\n", "   *\n", "   * <p>Since this method uses {@code HashMap} instances internally, the keys of\n", "   * the supplied maps must be well-behaved with respect to\n", "   * {@link Object#equals} and {@link Object#hashCode}.\n", "   *\n", "   * @param left the map to treat as the \"left\" map for purposes of comparison\n", "   * @param right the map to treat as the \"right\" map for purposes of comparison\n", "   * @param valueEquivalence the equivalence relationship to use to compare\n", "   *    values\n", "   * @return the difference between the two maps\n", "   * @since 10.0\n", "   */\n", "  @Beta\n", "  public static <K, V> MapDifference<K, V> difference(\n", "      Map<? extends K, ? extends V> left,\n", "      Map<? extends K, ? extends V> right,\n", "      Equivalence<? super V> valueEquivalence) {\n", "    Preconditions.checkNotNull(valueEquivalence);\n", "\n", "    Map<K, V> onlyOnLeft = newLinkedHashMap();\n", "    Map<K, V> onlyOnRight = new LinkedHashMap<K, V>(right); // will whittle it down\n", "    Map<K, V> onBoth = newLinkedHashMap();\n", "    Map<K, MapDifference.ValueDifference<V>> differences = newLinkedHashMap();\n", "    doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);\n", "    return new MapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);\n", "  }\n", "\n", "  private static <K, V> void doDifference(\n", "      Map<? extends K, ? extends V> left,\n", "      Map<? extends K, ? extends V> right,\n", "      Equivalence<? super V> valueEquivalence,\n", "      Map<K, V> onlyOnLeft,\n", "      Map<K, V> onlyOnRight,\n", "      Map<K, V> onBoth,\n", "      Map<K, MapDifference.ValueDifference<V>> differences) {\n", "    for (Entry<? extends K, ? extends V> entry : left.entrySet()) {\n", "      K leftKey = entry.getKey();\n", "      V leftValue = entry.getValue();\n", "      if (right.containsKey(leftKey)) {\n", "        V rightValue = onlyOnRight.remove(leftKey);\n", "        if (valueEquivalence.equivalent(leftValue, rightValue)) {\n", "          onBoth.put(leftKey, leftValue);\n", "        } else {\n", "          differences.put(leftKey, ValueDifferenceImpl.create(leftValue, rightValue));\n", "        }\n", "      } else {\n", "        onlyOnLeft.put(leftKey, leftValue);\n", "      }\n", "    }\n", "  }\n", "\n", "  private static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n", "    if (map instanceof SortedMap) {\n", "      return Collections.unmodifiableSortedMap((SortedMap<K, ? extends V>) map);\n", "    } else {\n", "      return Collections.unmodifiableMap(map);\n", "    }\n", "  }\n", "\n", "  static class MapDifferenceImpl<K, V> implements MapDifference<K, V> {\n", "    final Map<K, V> onlyOnLeft;\n", "    final Map<K, V> onlyOnRight;\n", "    final Map<K, V> onBoth;\n", "    final Map<K, ValueDifference<V>> differences;\n", "\n", "    MapDifferenceImpl(\n", "        Map<K, V> onlyOnLeft,\n", "        Map<K, V> onlyOnRight,\n", "        Map<K, V> onBoth,\n", "        Map<K, ValueDifference<V>> differences) {\n", "      this.onlyOnLeft = unmodifiableMap(onlyOnLeft);\n", "      this.onlyOnRight = unmodifiableMap(onlyOnRight);\n", "      this.onBoth = unmodifiableMap(onBoth);\n", "      this.differences = unmodifiableMap(differences);\n", "    }\n", "\n", "    @Override\n", "    public boolean areEqual() {\n", "      return onlyOnLeft.isEmpty() && onlyOnRight.isEmpty() && differences.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public Map<K, V> entriesOnlyOnLeft() {\n", "      return onlyOnLeft;\n", "    }\n", "\n", "    @Override\n", "    public Map<K, V> entriesOnlyOnRight() {\n", "      return onlyOnRight;\n", "    }\n", "\n", "    @Override\n", "    public Map<K, V> entriesInCommon() {\n", "      return onBoth;\n", "    }\n", "\n", "    @Override\n", "    public Map<K, ValueDifference<V>> entriesDiffering() {\n", "      return differences;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object object) {\n", "      if (object == this) {\n", "        return true;\n", "      }\n", "      if (object instanceof MapDifference) {\n", "        MapDifference<?, ?> other = (MapDifference<?, ?>) object;\n", "        return entriesOnlyOnLeft().equals(other.entriesOnlyOnLeft())\n", "            && entriesOnlyOnRight().equals(other.entriesOnlyOnRight())\n", "            && entriesInCommon().equals(other.entriesInCommon())\n", "            && entriesDiffering().equals(other.entriesDiffering());\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return Objects.hashCode(\n", "          entriesOnlyOnLeft(), entriesOnlyOnRight(), entriesInCommon(), entriesDiffering());\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      if (areEqual()) {\n", "        return \"equal\";\n", "      }\n", "\n", "      StringBuilder result = new StringBuilder(\"not equal\");\n", "      if (!onlyOnLeft.isEmpty()) {\n", "        result.append(\": only on left=\").append(onlyOnLeft);\n", "      }\n", "      if (!onlyOnRight.isEmpty()) {\n", "        result.append(\": only on right=\").append(onlyOnRight);\n", "      }\n", "      if (!differences.isEmpty()) {\n", "        result.append(\": value differences=\").append(differences);\n", "      }\n", "      return result.toString();\n", "    }\n", "  }\n", "\n", "  static class ValueDifferenceImpl<V> implements MapDifference.ValueDifference<V> {\n", "    private final V left;\n", "    private final V right;\n", "\n", "    static <V> ValueDifference<V> create(@Nullable V left, @Nullable V right) {\n", "      return new ValueDifferenceImpl<V>(left, right);\n", "    }\n", "\n", "    private ValueDifferenceImpl(@Nullable V left, @Nullable V right) {\n", "      this.left = left;\n", "      this.right = right;\n", "    }\n", "\n", "    @Override\n", "    public V leftValue() {\n", "      return left;\n", "    }\n", "\n", "    @Override\n", "    public V rightValue() {\n", "      return right;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      if (object instanceof MapDifference.ValueDifference) {\n", "        MapDifference.ValueDifference<?> that = (MapDifference.ValueDifference<?>) object;\n", "        return Objects.equal(this.left, that.leftValue())\n", "            && Objects.equal(this.right, that.rightValue());\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return Objects.hashCode(left, right);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"(\" + left + \", \" + right + \")\";\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Computes the difference between two sorted maps, using the comparator of\n", "   * the left map, or {@code Ordering.natural()} if the left map uses the\n", "   * natural ordering of its elements. This difference is an immutable snapshot\n", "   * of the state of the maps at the time this method is called. It will never\n", "   * change, even if the maps change at a later time.\n", "   *\n", "   * <p>Since this method uses {@code TreeMap} instances internally, the keys of\n", "   * the right map must all compare as distinct according to the comparator\n", "   * of the left map.\n", "   *\n", "   * <p><b>Note:</b>If you only need to know whether two sorted maps have the\n", "   * same mappings, call {@code left.equals(right)} instead of this method.\n", "   *\n", "   * @param left the map to treat as the \"left\" map for purposes of comparison\n", "   * @param right the map to treat as the \"right\" map for purposes of comparison\n", "   * @return the difference between the two maps\n", "   * @since 11.0\n", "   */\n", "  public static <K, V> SortedMapDifference<K, V> difference(\n", "      SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right) {\n", "    checkNotNull(left);\n", "    checkNotNull(right);\n", "    Comparator<? super K> comparator = orNaturalOrder(left.comparator());\n", "    SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);\n", "    SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);\n", "    onlyOnRight.putAll(right); // will whittle it down\n", "    SortedMap<K, V> onBoth = Maps.newTreeMap(comparator);\n", "    SortedMap<K, MapDifference.ValueDifference<V>> differences = Maps.newTreeMap(comparator);\n", "    doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);\n", "    return new SortedMapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);\n", "  }\n", "\n", "  static class SortedMapDifferenceImpl<K, V> extends MapDifferenceImpl<K, V>\n", "      implements SortedMapDifference<K, V> {\n", "    SortedMapDifferenceImpl(\n", "        SortedMap<K, V> onlyOnLeft,\n", "        SortedMap<K, V> onlyOnRight,\n", "        SortedMap<K, V> onBoth,\n", "        SortedMap<K, ValueDifference<V>> differences) {\n", "      super(onlyOnLeft, onlyOnRight, onBoth, differences);\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, ValueDifference<V>> entriesDiffering() {\n", "      return (SortedMap<K, ValueDifference<V>>) super.entriesDiffering();\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> entriesInCommon() {\n", "      return (SortedMap<K, V>) super.entriesInCommon();\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> entriesOnlyOnLeft() {\n", "      return (SortedMap<K, V>) super.entriesOnlyOnLeft();\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> entriesOnlyOnRight() {\n", "      return (SortedMap<K, V>) super.entriesOnlyOnRight();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns the specified comparator if not null; otherwise returns {@code\n", "   * Ordering.natural()}. This method is an abomination of generics; the only\n", "   * purpose of this method is to contain the ugly type-casting in one place.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  static <E> Comparator<? super E> orNaturalOrder(@Nullable Comparator<? super E> comparator) {\n", "    if (comparator != null) { // can't use ? : because of javac bug 5080917\n", "      return comparator;\n", "    }\n", "    return (Comparator<E>) Ordering.natural();\n", "  }\n", "\n", "  /**\n", "   * Returns a live {@link Map} view whose keys are the contents of {@code set}\n", "   * and whose values are computed on demand using {@code function}. To get an\n", "   * immutable <i>copy</i> instead, use {@link #toMap(Iterable, Function)}.\n", "   *\n", "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n", "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n", "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n", "   * iterate in the same order as the backing set.\n", "   *\n", "   * <p>Modifications to the backing set are read through to the returned map.\n", "   * The returned map supports removal operations if the backing set does.\n", "   * Removal operations write through to the backing set.  The returned map\n", "   * does not support put operations.\n", "   *\n", "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n", "   * required to make sure the set does not contain {@code null}, because the\n", "   * view cannot stop {@code null} from being added to the set.\n", "   *\n", "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n", "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also\n", "   * of type {@code K}. Using a key type for which this may not hold, such as\n", "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n", "   * methods on the resulting map view.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  public static <K, V> Map<K, V> asMap(Set<K> set, Function<? super K, V> function) {\n", "    if (set instanceof SortedSet) {\n", "      return asMap((SortedSet<K>) set, function);\n", "    } else {\n", "      return new AsMapView<K, V>(set, function);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a view of the sorted set as a map, mapping keys from the set\n", "   * according to the specified function.\n", "   *\n", "   * <p>Specifically, for each {@code k} in the backing set, the returned map\n", "   * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code\n", "   * keySet}, {@code values}, and {@code entrySet} views of the returned map\n", "   * iterate in the same order as the backing set.\n", "   *\n", "   * <p>Modifications to the backing set are read through to the returned map.\n", "   * The returned map supports removal operations if the backing set does.\n", "   * Removal operations write through to the backing set.  The returned map does\n", "   * not support put operations.\n", "   *\n", "   * <p><b>Warning:</b> If the function rejects {@code null}, caution is\n", "   * required to make sure the set does not contain {@code null}, because the\n", "   * view cannot stop {@code null} from being added to the set.\n", "   *\n", "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n", "   * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of\n", "   * type {@code K}. Using a key type for which this may not hold, such as\n", "   * {@code ArrayList}, may risk a {@code ClassCastException} when calling\n", "   * methods on the resulting map view.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  public static <K, V> SortedMap<K, V> asMap(SortedSet<K> set, Function<? super K, V> function) {\n", "    return Platform.mapsAsMapSortedSet(set, function);\n", "  }\n", "\n", "  static <K, V> SortedMap<K, V> asMapSortedIgnoreNavigable(\n", "      SortedSet<K> set, Function<? super K, V> function) {\n", "    return new SortedAsMapView<K, V>(set, function);\n", "  }\n", "\n", "  private static class AsMapView<K, V> extends ViewCachingAbstractMap<K, V> {\n", "\n", "    private final Set<K> set;\n", "    final Function<? super K, V> function;\n", "\n", "    Set<K> backingSet() {\n", "      return set;\n", "    }\n", "\n", "    AsMapView(Set<K> set, Function<? super K, V> function) {\n", "      this.set = checkNotNull(set);\n", "      this.function = checkNotNull(function);\n", "    }\n", "\n", "    @Override\n", "    public Set<K> createKeySet() {\n", "      return removeOnlySet(backingSet());\n", "    }\n", "\n", "    @Override\n", "    Collection<V> createValues() {\n", "      return Collections2.transform(set, function);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return backingSet().size();\n", "    }\n", "\n", "    @Override\n", "    public boolean containsKey(@Nullable Object key) {\n", "      return backingSet().contains(key);\n", "    }\n", "\n", "    @Override\n", "    public V get(@Nullable Object key) {\n", "      if (Collections2.safeContains(backingSet(), key)) {\n", "        @SuppressWarnings(\"unchecked\") // unsafe, but Javadoc warns about it\n", "        K k = (K) key;\n", "        return function.apply(k);\n", "      } else {\n", "        return null;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V remove(@Nullable Object key) {\n", "      if (backingSet().remove(key)) {\n", "        @SuppressWarnings(\"unchecked\") // unsafe, but Javadoc warns about it\n", "        K k = (K) key;\n", "        return function.apply(k);\n", "      } else {\n", "        return null;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      backingSet().clear();\n", "    }\n", "\n", "    @Override\n", "    protected Set<Entry<K, V>> createEntrySet() {\n", "      @WeakOuter\n", "      class EntrySetImpl extends EntrySet<K, V> {\n", "        @Override\n", "        Map<K, V> map() {\n", "          return AsMapView.this;\n", "        }\n", "\n", "        @Override\n", "        public Iterator<Entry<K, V>> iterator() {\n", "          return asMapEntryIterator(backingSet(), function);\n", "        }\n", "      }\n", "      return new EntrySetImpl();\n", "    }\n", "  }\n", "\n", "  static <K, V> Iterator<Entry<K, V>> asMapEntryIterator(\n", "      Set<K> set, final Function<? super K, V> function) {\n", "    return new TransformedIterator<K, Entry<K, V>>(set.iterator()) {\n", "      @Override\n", "      Entry<K, V> transform(final K key) {\n", "        return immutableEntry(key, function.apply(key));\n", "      }\n", "    };\n", "  }\n", "\n", "  private static class SortedAsMapView<K, V> extends AsMapView<K, V> implements SortedMap<K, V> {\n", "\n", "    SortedAsMapView(SortedSet<K> set, Function<? super K, V> function) {\n", "      super(set, function);\n", "    }\n", "\n", "    @Override\n", "    SortedSet<K> backingSet() {\n", "      return (SortedSet<K>) super.backingSet();\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super K> comparator() {\n", "      return backingSet().comparator();\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      return removeOnlySortedSet(backingSet());\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n", "      return asMap(backingSet().subSet(fromKey, toKey), function);\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> headMap(K toKey) {\n", "      return asMap(backingSet().headSet(toKey), function);\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> tailMap(K fromKey) {\n", "      return asMap(backingSet().tailSet(fromKey), function);\n", "    }\n", "\n", "    @Override\n", "    public K firstKey() {\n", "      return backingSet().first();\n", "    }\n", "\n", "    @Override\n", "    public K lastKey() {\n", "      return backingSet().last();\n", "    }\n", "  }\n", "\n", "  private static <E> Set<E> removeOnlySet(final Set<E> set) {\n", "    return new ForwardingSet<E>() {\n", "      @Override\n", "      protected Set<E> delegate() {\n", "        return set;\n", "      }\n", "\n", "      @Override\n", "      public boolean add(E element) {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "\n", "      @Override\n", "      public boolean addAll(Collection<? extends E> es) {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "    };\n", "  }\n", "\n", "  private static <E> SortedSet<E> removeOnlySortedSet(final SortedSet<E> set) {\n", "    return new ForwardingSortedSet<E>() {\n", "      @Override\n", "      protected SortedSet<E> delegate() {\n", "        return set;\n", "      }\n", "\n", "      @Override\n", "      public boolean add(E element) {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "\n", "      @Override\n", "      public boolean addAll(Collection<? extends E> es) {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "\n", "      @Override\n", "      public SortedSet<E> headSet(E toElement) {\n", "        return removeOnlySortedSet(super.headSet(toElement));\n", "      }\n", "\n", "      @Override\n", "      public SortedSet<E> subSet(E fromElement, E toElement) {\n", "        return removeOnlySortedSet(super.subSet(fromElement, toElement));\n", "      }\n", "\n", "      @Override\n", "      public SortedSet<E> tailSet(E fromElement) {\n", "        return removeOnlySortedSet(super.tailSet(fromElement));\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable map whose keys are the distinct elements of {@code\n", "   * keys} and whose value for each key was computed by {@code valueFunction}.\n", "   * The map's iteration order is the order of the first appearance of each key\n", "   * in {@code keys}.\n", "   *\n", "   * <p>When there are multiple instances of a key in {@code keys}, it is\n", "   * unspecified whether {@code valueFunction} will be applied to more than one\n", "   * instance of that key and, if it is, which result will be mapped to that\n", "   * key in the returned map.\n", "   *\n", "   * <p>If {@code keys} is a {@link Set}, a live view can be obtained instead of\n", "   * a copy using {@link Maps#asMap(Set, Function)}.\n", "   *\n", "   * @throws NullPointerException if any element of {@code keys} is\n", "   *     {@code null}, or if {@code valueFunction} produces {@code null}\n", "   *     for any key\n", "   * @since 14.0\n", "   */\n", "  public static <K, V> ImmutableMap<K, V> toMap(\n", "      Iterable<K> keys, Function<? super K, V> valueFunction) {\n", "    return toMap(keys.iterator(), valueFunction);\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable map whose keys are the distinct elements of {@code\n", "   * keys} and whose value for each key was computed by {@code valueFunction}.\n", "   * The map's iteration order is the order of the first appearance of each key\n", "   * in {@code keys}.\n", "   *\n", "   * <p>When there are multiple instances of a key in {@code keys}, it is\n", "   * unspecified whether {@code valueFunction} will be applied to more than one\n", "   * instance of that key and, if it is, which result will be mapped to that\n", "   * key in the returned map.\n", "   *\n", "   * @throws NullPointerException if any element of {@code keys} is\n", "   *     {@code null}, or if {@code valueFunction} produces {@code null}\n", "   *     for any key\n", "   * @since 14.0\n", "   */\n", "  public static <K, V> ImmutableMap<K, V> toMap(\n", "      Iterator<K> keys, Function<? super K, V> valueFunction) {\n", "    checkNotNull(valueFunction);\n", "    // Using LHM instead of a builder so as not to fail on duplicate keys\n", "    Map<K, V> builder = newLinkedHashMap();\n", "    while (keys.hasNext()) {\n", "      K key = keys.next();\n", "      builder.put(key, valueFunction.apply(key));\n", "    }\n", "    return ImmutableMap.copyOf(builder);\n", "  }\n", "\n", "  /**\n", "   * Returns a map with the given {@code values}, indexed by keys derived from\n", "   * those values. In other words, each input value produces an entry in the map\n", "   * whose key is the result of applying {@code keyFunction} to that value.\n", "   * These entries appear in the same order as the input values. Example usage:\n", "   * <pre>   {@code\n", "   *\n", "   *   Color red = new Color(\"red\", 255, 0, 0);\n", "   *   ...\n", "   *   ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);\n", "   *\n", "   *   Map<String, Color> colorForName =\n", "   *       uniqueIndex(allColors, toStringFunction());\n", "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n", "   *\n", "   * <p>If your index may associate multiple values with each key, use {@link\n", "   * Multimaps#index(Iterable, Function) Multimaps.index}.\n", "   *\n", "   * @param values the values to use when constructing the {@code Map}\n", "   * @param keyFunction the function used to produce the key for each value\n", "   * @return a map mapping the result of evaluating the function {@code\n", "   *         keyFunction} on each value in the input collection to that value\n", "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n", "   *         key for more than one value in the input collection\n", "   * @throws NullPointerException if any elements of {@code values} is null, or\n", "   *         if {@code keyFunction} produces {@code null} for any value\n", "   */\n", "  public static <K, V> ImmutableMap<K, V> uniqueIndex(\n", "      Iterable<V> values, Function<? super V, K> keyFunction) {\n", "    // TODO(lowasser): consider presizing the builder if values is a Collection\n", "    return uniqueIndex(values.iterator(), keyFunction);\n", "  }\n", "\n", "  /**\n", "   * Returns a map with the given {@code values}, indexed by keys derived from\n", "   * those values. In other words, each input value produces an entry in the map\n", "   * whose key is the result of applying {@code keyFunction} to that value.\n", "   * These entries appear in the same order as the input values. Example usage:\n", "   * <pre>   {@code\n", "   *\n", "   *   Color red = new Color(\"red\", 255, 0, 0);\n", "   *   ...\n", "   *   Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();\n", "   *\n", "   *   Map<String, Color> colorForName =\n", "   *       uniqueIndex(allColors, toStringFunction());\n", "   *   assertThat(colorForName).containsEntry(\"red\", red);}</pre>\n", "   *\n", "   * <p>If your index may associate multiple values with each key, use {@link\n", "   * Multimaps#index(Iterator, Function) Multimaps.index}.\n", "   *\n", "   * @param values the values to use when constructing the {@code Map}\n", "   * @param keyFunction the function used to produce the key for each value\n", "   * @return a map mapping the result of evaluating the function {@code\n", "   *         keyFunction} on each value in the input collection to that value\n", "   * @throws IllegalArgumentException if {@code keyFunction} produces the same\n", "   *         key for more than one value in the input collection\n", "   * @throws NullPointerException if any elements of {@code values} is null, or\n", "   *         if {@code keyFunction} produces {@code null} for any value\n", "   * @since 10.0\n", "   */\n", "  public static <K, V> ImmutableMap<K, V> uniqueIndex(\n", "      Iterator<V> values, Function<? super V, K> keyFunction) {\n", "    checkNotNull(keyFunction);\n", "    ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();\n", "    while (values.hasNext()) {\n", "      V value = values.next();\n", "      builder.put(keyFunction.apply(value), value);\n", "    }\n", "    try {\n", "      return builder.build();\n", "    } catch (IllegalArgumentException duplicateKeys) {\n", "      throw new IllegalArgumentException(\n", "          duplicateKeys.getMessage()\n", "              + \". To index multiple values under a key, use Multimaps.index.\");\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable map entry with the specified key and value. The {@link\n", "   * Entry#setValue} operation throws an {@link UnsupportedOperationException}.\n", "   *\n", "   * <p>The returned entry is serializable.\n", "   *\n", "   * @param key the key to be associated with the returned entry\n", "   * @param value the value to be associated with the returned entry\n", "   */\n", "  @GwtCompatible(serializable = true)\n", "  public static <K, V> Entry<K, V> immutableEntry(@Nullable K key, @Nullable V value) {\n", "    return new ImmutableEntry<K, V>(key, value);\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified set of entries. The {@link\n", "   * Entry#setValue} operation throws an {@link UnsupportedOperationException},\n", "   * as do any operations that would modify the returned set.\n", "   *\n", "   * @param entrySet the entries for which to return an unmodifiable view\n", "   * @return an unmodifiable view of the entries\n", "   */\n", "  static <K, V> Set<Entry<K, V>> unmodifiableEntrySet(Set<Entry<K, V>> entrySet) {\n", "    return new UnmodifiableEntrySet<K, V>(Collections.unmodifiableSet(entrySet));\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified map entry. The {@link\n", "   * Entry#setValue} operation throws an {@link UnsupportedOperationException}.\n", "   * This also has the side-effect of redefining {@code equals} to comply with\n", "   * the Entry contract, to avoid a possible nefarious implementation of equals.\n", "   *\n", "   * @param entry the entry for which to return an unmodifiable view\n", "   * @return an unmodifiable view of the entry\n", "   */\n", "  static <K, V> Entry<K, V> unmodifiableEntry(final Entry<? extends K, ? extends V> entry) {\n", "    checkNotNull(entry);\n", "    return new AbstractMapEntry<K, V>() {\n", "      @Override\n", "      public K getKey() {\n", "        return entry.getKey();\n", "      }\n", "\n", "      @Override\n", "      public V getValue() {\n", "        return entry.getValue();\n", "      }\n", "    };\n", "  }\n", "\n", "  static <K, V> UnmodifiableIterator<Entry<K, V>> unmodifiableEntryIterator(\n", "      final Iterator<Entry<K, V>> entryIterator) {\n", "    return new UnmodifiableIterator<Entry<K, V>>() {\n", "      @Override\n", "      public boolean hasNext() {\n", "        return entryIterator.hasNext();\n", "      }\n", "\n", "      @Override\n", "      public Entry<K, V> next() {\n", "        return unmodifiableEntry(entryIterator.next());\n", "      }\n", "    };\n", "  }\n", "\n", "  /** @see Multimaps#unmodifiableEntries */\n", "  static class UnmodifiableEntries<K, V> extends ForwardingCollection<Entry<K, V>> {\n", "    private final Collection<Entry<K, V>> entries;\n", "\n", "    UnmodifiableEntries(Collection<Entry<K, V>> entries) {\n", "      this.entries = entries;\n", "    }\n", "\n", "    @Override\n", "    protected Collection<Entry<K, V>> delegate() {\n", "      return entries;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<Entry<K, V>> iterator() {\n", "      return unmodifiableEntryIterator(entries.iterator());\n", "    }\n", "\n", "    // See java.util.Collections.UnmodifiableEntrySet for details on attacks.\n", "\n", "    @Override\n", "    public Object[] toArray() {\n", "      return standardToArray();\n", "    }\n", "\n", "    @Override\n", "    public <T> T[] toArray(T[] array) {\n", "      return standardToArray(array);\n", "    }\n", "  }\n", "\n", "  /** @see Maps#unmodifiableEntrySet(Set) */\n", "  static class UnmodifiableEntrySet<K, V> extends UnmodifiableEntries<K, V>\n", "      implements Set<Entry<K, V>> {\n", "    UnmodifiableEntrySet(Set<Entry<K, V>> entries) {\n", "      super(entries);\n", "    }\n", "\n", "    // See java.util.Collections.UnmodifiableEntrySet for details on attacks.\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      return Sets.equalsImpl(this, object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return Sets.hashCodeImpl(this);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()},\n", "   * and whose inverse view converts values using\n", "   * {@link BiMap#inverse bimap.inverse()}{@code .get()}.\n", "   *\n", "   * <p>To use a plain {@link Map} as a {@link Function}, see\n", "   * {@link com.google.common.base.Functions#forMap(Map)} or\n", "   * {@link com.google.common.base.Functions#forMap(Map, Object)}.\n", "   *\n", "   * @since 16.0\n", "   */\n", "  @Beta\n", "  public static <A, B> Converter<A, B> asConverter(final BiMap<A, B> bimap) {\n", "    return new BiMapConverter<A, B>(bimap);\n", "  }\n", "\n", "  private static final class BiMapConverter<A, B> extends Converter<A, B> implements Serializable {\n", "    private final BiMap<A, B> bimap;\n", "\n", "    BiMapConverter(BiMap<A, B> bimap) {\n", "      this.bimap = checkNotNull(bimap);\n", "    }\n", "\n", "    @Override\n", "    protected B doForward(A a) {\n", "      return convert(bimap, a);\n", "    }\n", "\n", "    @Override\n", "    protected A doBackward(B b) {\n", "      return convert(bimap.inverse(), b);\n", "    }\n", "\n", "    private static <X, Y> Y convert(BiMap<X, Y> bimap, X input) {\n", "      Y output = bimap.get(input);\n", "      checkArgument(output != null, \"No non-null mapping present for input: %s\", input);\n", "      return output;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      if (object instanceof BiMapConverter) {\n", "        BiMapConverter<?, ?> that = (BiMapConverter<?, ?>) object;\n", "        return this.bimap.equals(that.bimap);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return bimap.hashCode();\n", "    }\n", "\n", "    // There's really no good way to implement toString() without printing the entire BiMap, right?\n", "    @Override\n", "    public String toString() {\n", "      return \"Maps.asConverter(\" + bimap + \")\";\n", "    }\n", "\n", "    private static final long serialVersionUID = 0L;\n", "  }\n", "\n", "  /**\n", "   * Returns a synchronized (thread-safe) bimap backed by the specified bimap.\n", "   * In order to guarantee serial access, it is critical that <b>all</b> access\n", "   * to the backing bimap is accomplished through the returned bimap.\n", "   *\n", "   * <p>It is imperative that the user manually synchronize on the returned map\n", "   * when accessing any of its collection views: <pre>   {@code\n", "   *\n", "   *   BiMap<Long, String> map = Maps.synchronizedBiMap(\n", "   *       HashBiMap.<Long, String>create());\n", "   *   ...\n", "   *   Set<Long> set = map.keySet();  // Needn't be in synchronized block\n", "   *   ...\n", "   *   synchronized (map) {  // Synchronizing on map, not set!\n", "   *     Iterator<Long> it = set.iterator(); // Must be in synchronized block\n", "   *     while (it.hasNext()) {\n", "   *       foo(it.next());\n", "   *     }\n", "   *   }}</pre>\n", "   *\n", "   * <p>Failure to follow this advice may result in non-deterministic behavior.\n", "   *\n", "   * <p>The returned bimap will be serializable if the specified bimap is\n", "   * serializable.\n", "   *\n", "   * @param bimap the bimap to be wrapped in a synchronized view\n", "   * @return a sychronized view of the specified bimap\n", "   */\n", "  public static <K, V> BiMap<K, V> synchronizedBiMap(BiMap<K, V> bimap) {\n", "    return Synchronized.biMap(bimap, null);\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified bimap. This method allows\n", "   * modules to provide users with \"read-only\" access to internal bimaps. Query\n", "   * operations on the returned bimap \"read through\" to the specified bimap, and\n", "   * attempts to modify the returned map, whether direct or via its collection\n", "   * views, result in an {@code UnsupportedOperationException}.\n", "   *\n", "   * <p>The returned bimap will be serializable if the specified bimap is\n", "   * serializable.\n", "   *\n", "   * @param bimap the bimap for which an unmodifiable view is to be returned\n", "   * @return an unmodifiable view of the specified bimap\n", "   */\n", "  public static <K, V> BiMap<K, V> unmodifiableBiMap(BiMap<? extends K, ? extends V> bimap) {\n", "    return new UnmodifiableBiMap<K, V>(bimap, null);\n", "  }\n", "\n", "  /** @see Maps#unmodifiableBiMap(BiMap) */\n", "  private static class UnmodifiableBiMap<K, V> extends ForwardingMap<K, V>\n", "      implements BiMap<K, V>, Serializable {\n", "    final Map<K, V> unmodifiableMap;\n", "    final BiMap<? extends K, ? extends V> delegate;\n", "    BiMap<V, K> inverse;\n", "    transient Set<V> values;\n", "\n", "    UnmodifiableBiMap(BiMap<? extends K, ? extends V> delegate, @Nullable BiMap<V, K> inverse) {\n", "      unmodifiableMap = Collections.unmodifiableMap(delegate);\n", "      this.delegate = delegate;\n", "      this.inverse = inverse;\n", "    }\n", "\n", "    @Override\n", "    protected Map<K, V> delegate() {\n", "      return unmodifiableMap;\n", "    }\n", "\n", "    @Override\n", "    public V forcePut(K key, V value) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public BiMap<V, K> inverse() {\n", "      BiMap<V, K> result = inverse;\n", "      return (result == null)\n", "          ? inverse = new UnmodifiableBiMap<V, K>(delegate.inverse(), this)\n", "          : result;\n", "    }\n", "\n", "    @Override\n", "    public Set<V> values() {\n", "      Set<V> result = values;\n", "      return (result == null)\n", "          ? values = Collections.unmodifiableSet(delegate.values())\n", "          : result;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Returns a view of a map where each value is transformed by a function. All\n", "   * other properties of the map, such as iteration order, are left intact. For\n", "   * example, the code: <pre>   {@code\n", "   *\n", "   *   Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9);\n", "   *   Function<Integer, Double> sqrt =\n", "   *       new Function<Integer, Double>() {\n", "   *         public Double apply(Integer in) {\n", "   *           return Math.sqrt((int) in);\n", "   *         }\n", "   *       };\n", "   *   Map<String, Double> transformed = Maps.transformValues(map, sqrt);\n", "   *   System.out.println(transformed);}</pre>\n", "   *\n", "   * ... prints {@code {a=2.0, b=3.0}}.\n", "   *\n", "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n", "   * this view supports removal operations, and these are reflected in the\n", "   * underlying map.\n", "   *\n", "   * <p>It's acceptable for the underlying map to contain null keys, and even\n", "   * null values provided that the function is capable of accepting null input.\n", "   * The transformed map might contain null values, if the function sometimes\n", "   * gives a null result.\n", "   *\n", "   * <p>The returned map is not thread-safe or serializable, even if the\n", "   * underlying map is.\n", "   *\n", "   * <p>The function is applied lazily, invoked when needed. This is necessary\n", "   * for the returned map to be a view, but it means that the function will be\n", "   * applied many times for bulk operations like {@link Map#containsValue} and\n", "   * {@code Map.toString()}. For this to perform well, {@code function} should\n", "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n", "   * a view, copy the returned map into a new map of your choosing.\n", "   */\n", "  public static <K, V1, V2> Map<K, V2> transformValues(\n", "      Map<K, V1> fromMap, Function<? super V1, V2> function) {\n", "    return transformEntries(fromMap, asEntryTransformer(function));\n", "  }\n", "\n", "  /**\n", "   * Returns a view of a sorted map where each value is transformed by a\n", "   * function. All other properties of the map, such as iteration order, are\n", "   * left intact. For example, the code: <pre>   {@code\n", "   *\n", "   *   SortedMap<String, Integer> map = ImmutableSortedMap.of(\"a\", 4, \"b\", 9);\n", "   *   Function<Integer, Double> sqrt =\n", "   *       new Function<Integer, Double>() {\n", "   *         public Double apply(Integer in) {\n", "   *           return Math.sqrt((int) in);\n", "   *         }\n", "   *       };\n", "   *   SortedMap<String, Double> transformed =\n", "   *        Maps.transformValues(map, sqrt);\n", "   *   System.out.println(transformed);}</pre>\n", "   *\n", "   * ... prints {@code {a=2.0, b=3.0}}.\n", "   *\n", "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n", "   * this view supports removal operations, and these are reflected in the\n", "   * underlying map.\n", "   *\n", "   * <p>It's acceptable for the underlying map to contain null keys, and even\n", "   * null values provided that the function is capable of accepting null input.\n", "   * The transformed map might contain null values, if the function sometimes\n", "   * gives a null result.\n", "   *\n", "   * <p>The returned map is not thread-safe or serializable, even if the\n", "   * underlying map is.\n", "   *\n", "   * <p>The function is applied lazily, invoked when needed. This is necessary\n", "   * for the returned map to be a view, but it means that the function will be\n", "   * applied many times for bulk operations like {@link Map#containsValue} and\n", "   * {@code Map.toString()}. For this to perform well, {@code function} should\n", "   * be fast. To avoid lazy evaluation when the returned map doesn't need to be\n", "   * a view, copy the returned map into a new map of your choosing.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  public static <K, V1, V2> SortedMap<K, V2> transformValues(\n", "      SortedMap<K, V1> fromMap, Function<? super V1, V2> function) {\n", "    return transformEntries(fromMap, asEntryTransformer(function));\n", "  }\n", "\n", "  /**\n", "   * Returns a view of a map whose values are derived from the original map's\n", "   * entries. In contrast to {@link #transformValues}, this method's\n", "   * entry-transformation logic may depend on the key as well as the value.\n", "   *\n", "   * <p>All other properties of the transformed map, such as iteration order,\n", "   * are left intact. For example, the code: <pre>   {@code\n", "   *\n", "   *   Map<String, Boolean> options =\n", "   *       ImmutableMap.of(\"verbose\", true, \"sort\", false);\n", "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n", "   *       new EntryTransformer<String, Boolean, String>() {\n", "   *         public String transformEntry(String key, Boolean value) {\n", "   *           return value ? key : \"no\" + key;\n", "   *         }\n", "   *       };\n", "   *   Map<String, String> transformed =\n", "   *       Maps.transformEntries(options, flagPrefixer);\n", "   *   System.out.println(transformed);}</pre>\n", "   *\n", "   * ... prints {@code {verbose=verbose, sort=nosort}}.\n", "   *\n", "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n", "   * this view supports removal operations, and these are reflected in the\n", "   * underlying map.\n", "   *\n", "   * <p>It's acceptable for the underlying map to contain null keys and null\n", "   * values provided that the transformer is capable of accepting null inputs.\n", "   * The transformed map might contain null values if the transformer sometimes\n", "   * gives a null result.\n", "   *\n", "   * <p>The returned map is not thread-safe or serializable, even if the\n", "   * underlying map is.\n", "   *\n", "   * <p>The transformer is applied lazily, invoked when needed. This is\n", "   * necessary for the returned map to be a view, but it means that the\n", "   * transformer will be applied many times for bulk operations like {@link\n", "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n", "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n", "   * returned map doesn't need to be a view, copy the returned map into a new\n", "   * map of your choosing.\n", "   *\n", "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n", "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n", "   * that {@code k2} is also of type {@code K}. Using an {@code\n", "   * EntryTransformer} key type for which this may not hold, such as {@code\n", "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n", "   * the transformed map.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  public static <K, V1, V2> Map<K, V2> transformEntries(\n", "      Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "    if (fromMap instanceof SortedMap) {\n", "      return transformEntries((SortedMap<K, V1>) fromMap, transformer);\n", "    }\n", "    return new TransformedEntriesMap<K, V1, V2>(fromMap, transformer);\n", "  }\n", "\n", "  /**\n", "   * Returns a view of a sorted map whose values are derived from the original\n", "   * sorted map's entries. In contrast to {@link #transformValues}, this\n", "   * method's entry-transformation logic may depend on the key as well as the\n", "   * value.\n", "   *\n", "   * <p>All other properties of the transformed map, such as iteration order,\n", "   * are left intact. For example, the code: <pre>   {@code\n", "   *\n", "   *   Map<String, Boolean> options =\n", "   *       ImmutableSortedMap.of(\"verbose\", true, \"sort\", false);\n", "   *   EntryTransformer<String, Boolean, String> flagPrefixer =\n", "   *       new EntryTransformer<String, Boolean, String>() {\n", "   *         public String transformEntry(String key, Boolean value) {\n", "   *           return value ? key : \"yes\" + key;\n", "   *         }\n", "   *       };\n", "   *   SortedMap<String, String> transformed =\n", "   *       Maps.transformEntries(options, flagPrefixer);\n", "   *   System.out.println(transformed);}</pre>\n", "   *\n", "   * ... prints {@code {sort=yessort, verbose=verbose}}.\n", "   *\n", "   * <p>Changes in the underlying map are reflected in this view. Conversely,\n", "   * this view supports removal operations, and these are reflected in the\n", "   * underlying map.\n", "   *\n", "   * <p>It's acceptable for the underlying map to contain null keys and null\n", "   * values provided that the transformer is capable of accepting null inputs.\n", "   * The transformed map might contain null values if the transformer sometimes\n", "   * gives a null result.\n", "   *\n", "   * <p>The returned map is not thread-safe or serializable, even if the\n", "   * underlying map is.\n", "   *\n", "   * <p>The transformer is applied lazily, invoked when needed. This is\n", "   * necessary for the returned map to be a view, but it means that the\n", "   * transformer will be applied many times for bulk operations like {@link\n", "   * Map#containsValue} and {@link Object#toString}. For this to perform well,\n", "   * {@code transformer} should be fast. To avoid lazy evaluation when the\n", "   * returned map doesn't need to be a view, copy the returned map into a new\n", "   * map of your choosing.\n", "   *\n", "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n", "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n", "   * that {@code k2} is also of type {@code K}. Using an {@code\n", "   * EntryTransformer} key type for which this may not hold, such as {@code\n", "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n", "   * the transformed map.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  public static <K, V1, V2> SortedMap<K, V2> transformEntries(\n", "      SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "    return Platform.mapsTransformEntriesSortedMap(fromMap, transformer);\n", "  }\n", "\n", "  static <K, V1, V2> SortedMap<K, V2> transformEntriesIgnoreNavigable(\n", "      SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "    return new TransformedEntriesSortedMap<K, V1, V2>(fromMap, transformer);\n", "  }\n", "\n", "  /**\n", "   * A transformation of the value of a key-value pair, using both key and value\n", "   * as inputs. To apply the transformation to a map, use\n", "   * {@link Maps#transformEntries(Map, EntryTransformer)}.\n", "   *\n", "   * @param <K> the key type of the input and output entries\n", "   * @param <V1> the value type of the input entry\n", "   * @param <V2> the value type of the output entry\n", "   * @since 7.0\n", "   */\n", "  public interface EntryTransformer<K, V1, V2> {\n", "    /**\n", "     * Determines an output value based on a key-value pair. This method is\n", "     * <i>generally expected</i>, but not absolutely required, to have the\n", "     * following properties:\n", "     *\n", "     * <ul>\n", "     * <li>Its execution does not cause any observable side effects.\n", "     * <li>The computation is <i>consistent with equals</i>; that is,\n", "     *     {@link Objects#equal Objects.equal}{@code (k1, k2) &&}\n", "     *     {@link Objects#equal}{@code (v1, v2)} implies that {@code\n", "     *     Objects.equal(transformer.transform(k1, v1),\n", "     *     transformer.transform(k2, v2))}.\n", "     * </ul>\n", "     *\n", "     * @throws NullPointerException if the key or value is null and this\n", "     *     transformer does not accept null arguments\n", "     */\n", "    V2 transformEntry(@Nullable K key, @Nullable V1 value);\n", "  }\n", "\n", "  /**\n", "   * Views a function as an entry transformer that ignores the entry key.\n", "   */\n", "  static <K, V1, V2> EntryTransformer<K, V1, V2> asEntryTransformer(\n", "      final Function<? super V1, V2> function) {\n", "    checkNotNull(function);\n", "    return new EntryTransformer<K, V1, V2>() {\n", "      @Override\n", "      public V2 transformEntry(K key, V1 value) {\n", "        return function.apply(value);\n", "      }\n", "    };\n", "  }\n", "\n", "  static <K, V1, V2> Function<V1, V2> asValueToValueFunction(\n", "      final EntryTransformer<? super K, V1, V2> transformer, final K key) {\n", "    checkNotNull(transformer);\n", "    return new Function<V1, V2>() {\n", "      @Override\n", "      public V2 apply(@Nullable V1 v1) {\n", "        return transformer.transformEntry(key, v1);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Views an entry transformer as a function from {@code Entry} to values.\n", "   */\n", "  static <K, V1, V2> Function<Entry<K, V1>, V2> asEntryToValueFunction(\n", "      final EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "    checkNotNull(transformer);\n", "    return new Function<Entry<K, V1>, V2>() {\n", "      @Override\n", "      public V2 apply(Entry<K, V1> entry) {\n", "        return transformer.transformEntry(entry.getKey(), entry.getValue());\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a view of an entry transformed by the specified transformer.\n", "   */\n", "  static <V2, K, V1> Entry<K, V2> transformEntry(\n", "      final EntryTransformer<? super K, ? super V1, V2> transformer, final Entry<K, V1> entry) {\n", "    checkNotNull(transformer);\n", "    checkNotNull(entry);\n", "    return new AbstractMapEntry<K, V2>() {\n", "      @Override\n", "      public K getKey() {\n", "        return entry.getKey();\n", "      }\n", "\n", "      @Override\n", "      public V2 getValue() {\n", "        return transformer.transformEntry(entry.getKey(), entry.getValue());\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Views an entry transformer as a function from entries to entries.\n", "   */\n", "  static <K, V1, V2> Function<Entry<K, V1>, Entry<K, V2>> asEntryToEntryFunction(\n", "      final EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "    checkNotNull(transformer);\n", "    return new Function<Entry<K, V1>, Entry<K, V2>>() {\n", "      @Override\n", "      public Entry<K, V2> apply(final Entry<K, V1> entry) {\n", "        return transformEntry(transformer, entry);\n", "      }\n", "    };\n", "  }\n", "\n", "  static class TransformedEntriesMap<K, V1, V2> extends IteratorBasedAbstractMap<K, V2> {\n", "    final Map<K, V1> fromMap;\n", "    final EntryTransformer<? super K, ? super V1, V2> transformer;\n", "\n", "    TransformedEntriesMap(\n", "        Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "      this.fromMap = checkNotNull(fromMap);\n", "      this.transformer = checkNotNull(transformer);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return fromMap.size();\n", "    }\n", "\n", "    @Override\n", "    public boolean containsKey(Object key) {\n", "      return fromMap.containsKey(key);\n", "    }\n", "\n", "    // safe as long as the user followed the <b>Warning</b> in the javadoc\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public V2 get(Object key) {\n", "      V1 value = fromMap.get(key);\n", "      return (value != null || fromMap.containsKey(key))\n", "          ? transformer.transformEntry((K) key, value)\n", "          : null;\n", "    }\n", "\n", "    // safe as long as the user followed the <b>Warning</b> in the javadoc\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public V2 remove(Object key) {\n", "      return fromMap.containsKey(key)\n", "          ? transformer.transformEntry((K) key, fromMap.remove(key))\n", "          : null;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      fromMap.clear();\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      return fromMap.keySet();\n", "    }\n", "\n", "    @Override\n", "    Iterator<Entry<K, V2>> entryIterator() {\n", "      return Iterators.transform(\n", "          fromMap.entrySet().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n", "    }\n", "\n", "    @Override\n", "    public Collection<V2> values() {\n", "      return new Values<K, V2>(this);\n", "    }\n", "  }\n", "\n", "  static class TransformedEntriesSortedMap<K, V1, V2> extends TransformedEntriesMap<K, V1, V2>\n", "      implements SortedMap<K, V2> {\n", "\n", "    protected SortedMap<K, V1> fromMap() {\n", "      return (SortedMap<K, V1>) fromMap;\n", "    }\n", "\n", "    TransformedEntriesSortedMap(\n", "        SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "      super(fromMap, transformer);\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super K> comparator() {\n", "      return fromMap().comparator();\n", "    }\n", "\n", "    @Override\n", "    public K firstKey() {\n", "      return fromMap().firstKey();\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V2> headMap(K toKey) {\n", "      return transformEntries(fromMap().headMap(toKey), transformer);\n", "    }\n", "\n", "    @Override\n", "    public K lastKey() {\n", "      return fromMap().lastKey();\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V2> subMap(K fromKey, K toKey) {\n", "      return transformEntries(fromMap().subMap(fromKey, toKey), transformer);\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V2> tailMap(K fromKey) {\n", "      return transformEntries(fromMap().tailMap(fromKey), transformer);\n", "    }\n", "  }\n", "\n", "  static <K> Predicate<Entry<K, ?>> keyPredicateOnEntries(Predicate<? super K> keyPredicate) {\n", "    return compose(keyPredicate, Maps.<K>keyFunction());\n", "  }\n", "\n", "  static <V> Predicate<Entry<?, V>> valuePredicateOnEntries(Predicate<? super V> valuePredicate) {\n", "    return compose(valuePredicate, Maps.<V>valueFunction());\n", "  }\n", "\n", "  /**\n", "   * Returns a map containing the mappings in {@code unfiltered} whose keys\n", "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n", "   * changes to one affect the other.\n", "   *\n", "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n", "   * values()} views have iterators that don't support {@code remove()}, but all\n", "   * other methods are supported by the map and its views. When given a key that\n", "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n", "   * on the filtered map or its views, only mappings whose keys satisfy the\n", "   * filter will be removed from the underlying map.\n", "   *\n", "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n", "   * unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered map's methods, such as {@code size()},\n", "   * iterate across every key/value mapping in the underlying map and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered map and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n", "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n", "   * inconsistent with equals.\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> Map<K, V> filterKeys(\n", "      Map<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n", "    if (unfiltered instanceof SortedMap) {\n", "      return filterKeys((SortedMap<K, V>) unfiltered, keyPredicate);\n", "    } else if (unfiltered instanceof BiMap) {\n", "      return filterKeys((BiMap<K, V>) unfiltered, keyPredicate);\n", "    }\n", "    checkNotNull(keyPredicate);\n", "    Predicate<Entry<K, ?>> entryPredicate = keyPredicateOnEntries(keyPredicate);\n", "    return (unfiltered instanceof AbstractFilteredMap)\n", "        ? filterFiltered((AbstractFilteredMap<K, V>) unfiltered, entryPredicate)\n", "        : new FilteredKeyMap<K, V>(checkNotNull(unfiltered), keyPredicate, entryPredicate);\n", "  }\n", "\n", "  /**\n", "   * Returns a sorted map containing the mappings in {@code unfiltered} whose\n", "   * keys satisfy a predicate. The returned map is a live view of {@code\n", "   * unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n", "   * values()} views have iterators that don't support {@code remove()}, but all\n", "   * other methods are supported by the map and its views. When given a key that\n", "   * doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n", "   * on the filtered map or its views, only mappings whose keys satisfy the\n", "   * filter will be removed from the underlying map.\n", "   *\n", "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n", "   * unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered map's methods, such as {@code size()},\n", "   * iterate across every key/value mapping in the underlying map and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered map and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n", "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n", "   * inconsistent with equals.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> SortedMap<K, V> filterKeys(\n", "      SortedMap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n", "    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n", "    // performance.\n", "    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n", "  }\n", "\n", "  /**\n", "   * Returns a bimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate.\n", "   * The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n", "   * iterators that don't support {@code remove()}, but all other methods are supported by the\n", "   * bimap and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code\n", "   * put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n", "   * IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n", "   * bimap or its views, only mappings that satisfy the filter will be removed from the underlying\n", "   * bimap.\n", "   *\n", "   * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key in\n", "   * the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i>\n", "   * needed, it may be faster to copy the filtered bimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n", "   * documented at {@link Predicate#apply}.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> BiMap<K, V> filterKeys(\n", "      BiMap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n", "    checkNotNull(keyPredicate);\n", "    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n", "  }\n", "\n", "  /**\n", "   * Returns a map containing the mappings in {@code unfiltered} whose values\n", "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n", "   * changes to one affect the other.\n", "   *\n", "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n", "   * values()} views have iterators that don't support {@code remove()}, but all\n", "   * other methods are supported by the map and its views. When given a value\n", "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n", "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n", "   * IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n", "   * on the filtered map or its views, only mappings whose values satisfy the\n", "   * filter will be removed from the underlying map.\n", "   *\n", "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n", "   * unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered map's methods, such as {@code size()},\n", "   * iterate across every key/value mapping in the underlying map and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered map and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n", "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n", "   * inconsistent with equals.\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> Map<K, V> filterValues(\n", "      Map<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n", "    if (unfiltered instanceof SortedMap) {\n", "      return filterValues((SortedMap<K, V>) unfiltered, valuePredicate);\n", "    } else if (unfiltered instanceof BiMap) {\n", "      return filterValues((BiMap<K, V>) unfiltered, valuePredicate);\n", "    }\n", "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n", "  }\n", "\n", "  /**\n", "   * Returns a sorted map containing the mappings in {@code unfiltered} whose\n", "   * values satisfy a predicate. The returned map is a live view of {@code\n", "   * unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n", "   * values()} views have iterators that don't support {@code remove()}, but all\n", "   * other methods are supported by the map and its views. When given a value\n", "   * that doesn't satisfy the predicate, the map's {@code put()}, {@code\n", "   * putAll()}, and {@link Entry#setValue} methods throw an {@link\n", "   * IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n", "   * on the filtered map or its views, only mappings whose values satisfy the\n", "   * filter will be removed from the underlying map.\n", "   *\n", "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n", "   * unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered map's methods, such as {@code size()},\n", "   * iterate across every key/value mapping in the underlying map and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered map and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n", "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n", "   * inconsistent with equals.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> SortedMap<K, V> filterValues(\n", "      SortedMap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n", "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n", "  }\n", "\n", "  /**\n", "   * Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a\n", "   * predicate. The returned bimap is a live view of {@code unfiltered}; changes to one affect the\n", "   * other.\n", "   *\n", "   * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n", "   * iterators that don't support {@code remove()}, but all other methods are supported by the\n", "   * bimap and its views. When given a value that doesn't satisfy the predicate, the bimap's\n", "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link\n", "   * IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method\n", "   * that throws an {@link IllegalArgumentException} when the provided value doesn't satisfy the\n", "   * predicate.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n", "   * bimap or its views, only mappings that satisfy the filter will be removed from the underlying\n", "   * bimap.\n", "   *\n", "   * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every value in\n", "   * the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i>\n", "   * needed, it may be faster to copy the filtered bimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n", "   * documented at {@link Predicate#apply}.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> BiMap<K, V> filterValues(\n", "      BiMap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n", "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n", "  }\n", "\n", "  /**\n", "   * Returns a map containing the mappings in {@code unfiltered} that satisfy a\n", "   * predicate. The returned map is a live view of {@code unfiltered}; changes\n", "   * to one affect the other.\n", "   *\n", "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n", "   * values()} views have iterators that don't support {@code remove()}, but all\n", "   * other methods are supported by the map and its views. When given a\n", "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n", "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n", "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n", "   * throws an {@link IllegalArgumentException} when the existing key and the\n", "   * provided value don't satisfy the predicate.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n", "   * on the filtered map or its views, only mappings that satisfy the filter\n", "   * will be removed from the underlying map.\n", "   *\n", "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n", "   * unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered map's methods, such as {@code size()},\n", "   * iterate across every key/value mapping in the underlying map and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered map and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}.\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> Map<K, V> filterEntries(\n", "      Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    if (unfiltered instanceof SortedMap) {\n", "      return filterEntries((SortedMap<K, V>) unfiltered, entryPredicate);\n", "    } else if (unfiltered instanceof BiMap) {\n", "      return filterEntries((BiMap<K, V>) unfiltered, entryPredicate);\n", "    }\n", "    checkNotNull(entryPredicate);\n", "    return (unfiltered instanceof AbstractFilteredMap)\n", "        ? filterFiltered((AbstractFilteredMap<K, V>) unfiltered, entryPredicate)\n", "        : new FilteredEntryMap<K, V>(checkNotNull(unfiltered), entryPredicate);\n", "  }\n", "\n", "  /**\n", "   * Returns a sorted map containing the mappings in {@code unfiltered} that\n", "   * satisfy a predicate. The returned map is a live view of {@code unfiltered};\n", "   * changes to one affect the other.\n", "   *\n", "   * <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code\n", "   * values()} views have iterators that don't support {@code remove()}, but all\n", "   * other methods are supported by the map and its views. When given a\n", "   * key/value pair that doesn't satisfy the predicate, the map's {@code put()}\n", "   * and {@code putAll()} methods throw an {@link IllegalArgumentException}.\n", "   * Similarly, the map's entries have a {@link Entry#setValue} method that\n", "   * throws an {@link IllegalArgumentException} when the existing key and the\n", "   * provided value don't satisfy the predicate.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called\n", "   * on the filtered map or its views, only mappings that satisfy the filter\n", "   * will be removed from the underlying map.\n", "   *\n", "   * <p>The returned map isn't threadsafe or serializable, even if {@code\n", "   * unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered map's methods, such as {@code size()},\n", "   * iterate across every key/value mapping in the underlying map and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered map and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> SortedMap<K, V> filterEntries(\n", "      SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    return Platform.mapsFilterSortedMap(unfiltered, entryPredicate);\n", "  }\n", "\n", "  static <K, V> SortedMap<K, V> filterSortedIgnoreNavigable(\n", "      SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    checkNotNull(entryPredicate);\n", "    return (unfiltered instanceof FilteredEntrySortedMap)\n", "        ? filterFiltered((FilteredEntrySortedMap<K, V>) unfiltered, entryPredicate)\n", "        : new FilteredEntrySortedMap<K, V>(checkNotNull(unfiltered), entryPredicate);\n", "  }\n", "\n", "  /**\n", "   * Returns a bimap containing the mappings in {@code unfiltered} that satisfy a predicate. The\n", "   * returned bimap is a live view of {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have\n", "   * iterators that don't support {@code remove()}, but all other methods are supported by the bimap\n", "   * and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's\n", "   * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an\n", "   * {@link IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue}\n", "   * method that throws an {@link IllegalArgumentException} when the existing key and the provided\n", "   * value don't satisfy the predicate.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered\n", "   * bimap or its views, only mappings that satisfy the filter will be removed from the underlying\n", "   * bimap.\n", "   *\n", "   * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every\n", "   * key/value mapping in the underlying bimap and determine which satisfy the filter. When a live\n", "   * view is <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as\n", "   * documented at {@link Predicate#apply}.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> BiMap<K, V> filterEntries(\n", "      BiMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    checkNotNull(unfiltered);\n", "    checkNotNull(entryPredicate);\n", "    return (unfiltered instanceof FilteredEntryBiMap)\n", "        ? filterFiltered((FilteredEntryBiMap<K, V>) unfiltered, entryPredicate)\n", "        : new FilteredEntryBiMap<K, V>(unfiltered, entryPredicate);\n", "  }\n", "\n", "  /**\n", "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n", "   * filtering a filtered map.\n", "   */\n", "  private static <K, V> Map<K, V> filterFiltered(\n", "      AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    return new FilteredEntryMap<K, V>(\n", "        map.unfiltered, Predicates.<Entry<K, V>>and(map.predicate, entryPredicate));\n", "  }\n", "\n", "  private abstract static class AbstractFilteredMap<K, V> extends ViewCachingAbstractMap<K, V> {\n", "    final Map<K, V> unfiltered;\n", "    final Predicate<? super Entry<K, V>> predicate;\n", "\n", "    AbstractFilteredMap(Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {\n", "      this.unfiltered = unfiltered;\n", "      this.predicate = predicate;\n", "    }\n", "\n", "    boolean apply(@Nullable Object key, @Nullable V value) {\n", "      // This method is called only when the key is in the map, implying that\n", "      // key is a K.\n", "      @SuppressWarnings(\"unchecked\")\n", "      K k = (K) key;\n", "      return predicate.apply(Maps.immutableEntry(k, value));\n", "    }\n", "\n", "    @Override\n", "    public V put(K key, V value) {\n", "      checkArgument(apply(key, value));\n", "      return unfiltered.put(key, value);\n", "    }\n", "\n", "    @Override\n", "    public void putAll(Map<? extends K, ? extends V> map) {\n", "      for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n", "        checkArgument(apply(entry.getKey(), entry.getValue()));\n", "      }\n", "      unfiltered.putAll(map);\n", "    }\n", "\n", "    @Override\n", "    public boolean containsKey(Object key) {\n", "      return unfiltered.containsKey(key) && apply(key, unfiltered.get(key));\n", "    }\n", "\n", "    @Override\n", "    public V get(Object key) {\n", "      V value = unfiltered.get(key);\n", "      return ((value != null) && apply(key, value)) ? value : null;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return entrySet().isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public V remove(Object key) {\n", "      return containsKey(key) ? unfiltered.remove(key) : null;\n", "    }\n", "\n", "    @Override\n", "    Collection<V> createValues() {\n", "      return new FilteredMapValues<K, V>(this, unfiltered, predicate);\n", "    }\n", "  }\n", "\n", "  private static final class FilteredMapValues<K, V> extends Maps.Values<K, V> {\n", "    Map<K, V> unfiltered;\n", "    Predicate<? super Entry<K, V>> predicate;\n", "\n", "    FilteredMapValues(\n", "        Map<K, V> filteredMap, Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {\n", "      super(filteredMap);\n", "      this.unfiltered = unfiltered;\n", "      this.predicate = predicate;\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      return Iterables.removeFirstMatching(\n", "              unfiltered.entrySet(),\n", "              Predicates.<Entry<K, V>>and(predicate, Maps.<V>valuePredicateOnEntries(equalTo(o))))\n", "          != null;\n", "    }\n", "\n", "    private boolean removeIf(Predicate<? super V> valuePredicate) {\n", "      return Iterables.removeIf(\n", "          unfiltered.entrySet(),\n", "          Predicates.<Entry<K, V>>and(predicate, Maps.<V>valuePredicateOnEntries(valuePredicate)));\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> collection) {\n", "      return removeIf(in(collection));\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> collection) {\n", "      return removeIf(not(in(collection)));\n", "    }\n", "\n", "    @Override\n", "    public Object[] toArray() {\n", "      // creating an ArrayList so filtering happens once\n", "      return Lists.newArrayList(iterator()).toArray();\n", "    }\n", "\n", "    @Override\n", "    public <T> T[] toArray(T[] array) {\n", "      return Lists.newArrayList(iterator()).toArray(array);\n", "    }\n", "  }\n", "\n", "  private static class FilteredKeyMap<K, V> extends AbstractFilteredMap<K, V> {\n", "    Predicate<? super K> keyPredicate;\n", "\n", "    FilteredKeyMap(\n", "        Map<K, V> unfiltered,\n", "        Predicate<? super K> keyPredicate,\n", "        Predicate<? super Entry<K, V>> entryPredicate) {\n", "      super(unfiltered, entryPredicate);\n", "      this.keyPredicate = keyPredicate;\n", "    }\n", "\n", "    @Override\n", "    protected Set<Entry<K, V>> createEntrySet() {\n", "      return Sets.filter(unfiltered.entrySet(), predicate);\n", "    }\n", "\n", "    @Override\n", "    Set<K> createKeySet() {\n", "      return Sets.filter(unfiltered.keySet(), keyPredicate);\n", "    }\n", "\n", "    // The cast is called only when the key is in the unfiltered map, implying\n", "    // that key is a K.\n", "    @Override\n", "    @SuppressWarnings(\"unchecked\")\n", "    public boolean containsKey(Object key) {\n", "      return unfiltered.containsKey(key) && keyPredicate.apply((K) key);\n", "    }\n", "  }\n", "\n", "  static class FilteredEntryMap<K, V> extends AbstractFilteredMap<K, V> {\n", "    /**\n", "     * Entries in this set satisfy the predicate, but they don't validate the\n", "     * input to {@code Entry.setValue()}.\n", "     */\n", "    final Set<Entry<K, V>> filteredEntrySet;\n", "\n", "    FilteredEntryMap(Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n", "      super(unfiltered, entryPredicate);\n", "      filteredEntrySet = Sets.filter(unfiltered.entrySet(), predicate);\n", "    }\n", "\n", "    @Override\n", "    protected Set<Entry<K, V>> createEntrySet() {\n", "      return new EntrySet();\n", "    }\n", "\n", "    @WeakOuter\n", "    private class EntrySet extends ForwardingSet<Entry<K, V>> {\n", "      @Override\n", "      protected Set<Entry<K, V>> delegate() {\n", "        return filteredEntrySet;\n", "      }\n", "\n", "      @Override\n", "      public Iterator<Entry<K, V>> iterator() {\n", "        return new TransformedIterator<Entry<K, V>, Entry<K, V>>(filteredEntrySet.iterator()) {\n", "          @Override\n", "          Entry<K, V> transform(final Entry<K, V> entry) {\n", "            return new ForwardingMapEntry<K, V>() {\n", "              @Override\n", "              protected Entry<K, V> delegate() {\n", "                return entry;\n", "              }\n", "\n", "              @Override\n", "              public V setValue(V newValue) {\n", "                checkArgument(apply(getKey(), newValue));\n", "                return super.setValue(newValue);\n", "              }\n", "            };\n", "          }\n", "        };\n", "      }\n", "    }\n", "\n", "    @Override\n", "    Set<K> createKeySet() {\n", "      return new KeySet();\n", "    }\n", "\n", "    @WeakOuter\n", "    class KeySet extends Maps.KeySet<K, V> {\n", "      KeySet() {\n", "        super(FilteredEntryMap.this);\n", "      }\n", "\n", "      @Override\n", "      public boolean remove(Object o) {\n", "        if (containsKey(o)) {\n", "          unfiltered.remove(o);\n", "          return true;\n", "        }\n", "        return false;\n", "      }\n", "\n", "      private boolean removeIf(Predicate<? super K> keyPredicate) {\n", "        return Iterables.removeIf(\n", "            unfiltered.entrySet(),\n", "            Predicates.<Entry<K, V>>and(predicate, Maps.<K>keyPredicateOnEntries(keyPredicate)));\n", "      }\n", "\n", "      @Override\n", "      public boolean removeAll(Collection<?> c) {\n", "        return removeIf(in(c));\n", "      }\n", "\n", "      @Override\n", "      public boolean retainAll(Collection<?> c) {\n", "        return removeIf(not(in(c)));\n", "      }\n", "\n", "      @Override\n", "      public Object[] toArray() {\n", "        // creating an ArrayList so filtering happens once\n", "        return Lists.newArrayList(iterator()).toArray();\n", "      }\n", "\n", "      @Override\n", "      public <T> T[] toArray(T[] array) {\n", "        return Lists.newArrayList(iterator()).toArray(array);\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n", "   * filtering a filtered sorted map.\n", "   */\n", "  private static <K, V> SortedMap<K, V> filterFiltered(\n", "      FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n", "    return new FilteredEntrySortedMap<K, V>(map.sortedMap(), predicate);\n", "  }\n", "\n", "  private static class FilteredEntrySortedMap<K, V> extends FilteredEntryMap<K, V>\n", "      implements SortedMap<K, V> {\n", "\n", "    FilteredEntrySortedMap(\n", "        SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n", "      super(unfiltered, entryPredicate);\n", "    }\n", "\n", "    SortedMap<K, V> sortedMap() {\n", "      return (SortedMap<K, V>) unfiltered;\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<K> keySet() {\n", "      return (SortedSet<K>) super.keySet();\n", "    }\n", "\n", "    @Override\n", "    SortedSet<K> createKeySet() {\n", "      return new SortedKeySet();\n", "    }\n", "\n", "    @WeakOuter\n", "    class SortedKeySet extends KeySet implements SortedSet<K> {\n", "      @Override\n", "      public Comparator<? super K> comparator() {\n", "        return sortedMap().comparator();\n", "      }\n", "\n", "      @Override\n", "      public SortedSet<K> subSet(K fromElement, K toElement) {\n", "        return (SortedSet<K>) subMap(fromElement, toElement).keySet();\n", "      }\n", "\n", "      @Override\n", "      public SortedSet<K> headSet(K toElement) {\n", "        return (SortedSet<K>) headMap(toElement).keySet();\n", "      }\n", "\n", "      @Override\n", "      public SortedSet<K> tailSet(K fromElement) {\n", "        return (SortedSet<K>) tailMap(fromElement).keySet();\n", "      }\n", "\n", "      @Override\n", "      public K first() {\n", "        return firstKey();\n", "      }\n", "\n", "      @Override\n", "      public K last() {\n", "        return lastKey();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super K> comparator() {\n", "      return sortedMap().comparator();\n", "    }\n", "\n", "    @Override\n", "    public K firstKey() {\n", "      // correctly throws NoSuchElementException when filtered map is empty.\n", "      return keySet().iterator().next();\n", "    }\n", "\n", "    @Override\n", "    public K lastKey() {\n", "      SortedMap<K, V> headMap = sortedMap();\n", "      while (true) {\n", "        // correctly throws NoSuchElementException when filtered map is empty.\n", "        K key = headMap.lastKey();\n", "        if (apply(key, unfiltered.get(key))) {\n", "          return key;\n", "        }\n", "        headMap = sortedMap().headMap(key);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> headMap(K toKey) {\n", "      return new FilteredEntrySortedMap<K, V>(sortedMap().headMap(toKey), predicate);\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n", "      return new FilteredEntrySortedMap<K, V>(sortedMap().subMap(fromKey, toKey), predicate);\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> tailMap(K fromKey) {\n", "      return new FilteredEntrySortedMap<K, V>(sortedMap().tailMap(fromKey), predicate);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when\n", "   * filtering a filtered map.\n", "   */\n", "  private static <K, V> BiMap<K, V> filterFiltered(\n", "      FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n", "    return new FilteredEntryBiMap<K, V>(map.unfiltered(), predicate);\n", "  }\n", "\n", "  static final class FilteredEntryBiMap<K, V> extends FilteredEntryMap<K, V>\n", "      implements BiMap<K, V> {\n", "    private final BiMap<V, K> inverse;\n", "\n", "    private static <K, V> Predicate<Entry<V, K>> inversePredicate(\n", "        final Predicate<? super Entry<K, V>> forwardPredicate) {\n", "      return new Predicate<Entry<V, K>>() {\n", "        @Override\n", "        public boolean apply(Entry<V, K> input) {\n", "          return forwardPredicate.apply(Maps.immutableEntry(input.getValue(), input.getKey()));\n", "        }\n", "      };\n", "    }\n", "\n", "    FilteredEntryBiMap(BiMap<K, V> delegate, Predicate<? super Entry<K, V>> predicate) {\n", "      super(delegate, predicate);\n", "      this.inverse =\n", "          new FilteredEntryBiMap<V, K>(delegate.inverse(), inversePredicate(predicate), this);\n", "    }\n", "\n", "    private FilteredEntryBiMap(\n", "        BiMap<K, V> delegate, Predicate<? super Entry<K, V>> predicate, BiMap<V, K> inverse) {\n", "      super(delegate, predicate);\n", "      this.inverse = inverse;\n", "    }\n", "\n", "    BiMap<K, V> unfiltered() {\n", "      return (BiMap<K, V>) unfiltered;\n", "    }\n", "\n", "    @Override\n", "    public V forcePut(@Nullable K key, @Nullable V value) {\n", "      checkArgument(apply(key, value));\n", "      return unfiltered().forcePut(key, value);\n", "    }\n", "\n", "    @Override\n", "    public BiMap<V, K> inverse() {\n", "      return inverse;\n", "    }\n", "\n", "    @Override\n", "    public Set<V> values() {\n", "      return inverse.keySet();\n", "    }\n", "  }\n", "\n", "  @Nullable\n", "  private static <K, V> Entry<K, V> unmodifiableOrNull(@Nullable Entry<K, V> entry) {\n", "    return (entry == null) ? null : Maps.unmodifiableEntry(entry);\n", "  }\n", "\n", "  /**\n", "   * {@code AbstractMap} extension that makes it easy to cache customized keySet, values,\n", "   * and entrySet views.\n", "   */\n", "  @GwtCompatible\n", "  abstract static class ViewCachingAbstractMap<K, V> extends AbstractMap<K, V> {\n", "    /**\n", "     * Creates the entry set to be returned by {@link #entrySet()}. This method\n", "     * is invoked at most once on a given map, at the time when {@code entrySet}\n", "     * is first called.\n", "     */\n", "    abstract Set<Entry<K, V>> createEntrySet();\n", "\n", "    private transient Set<Entry<K, V>> entrySet;\n", "\n", "    @Override\n", "    public Set<Entry<K, V>> entrySet() {\n", "      Set<Entry<K, V>> result = entrySet;\n", "      return (result == null) ? entrySet = createEntrySet() : result;\n", "    }\n", "\n", "    private transient Set<K> keySet;\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      Set<K> result = keySet;\n", "      return (result == null) ? keySet = createKeySet() : result;\n", "    }\n", "\n", "    Set<K> createKeySet() {\n", "      return new KeySet<K, V>(this);\n", "    }\n", "\n", "    private transient Collection<V> values;\n", "\n", "    @Override\n", "    public Collection<V> values() {\n", "      Collection<V> result = values;\n", "      return (result == null) ? values = createValues() : result;\n", "    }\n", "\n", "    Collection<V> createValues() {\n", "      return new Values<K, V>(this);\n", "    }\n", "  }\n", "\n", "  abstract static class IteratorBasedAbstractMap<K, V> extends AbstractMap<K, V> {\n", "    @Override\n", "    public abstract int size();\n", "\n", "    abstract Iterator<Entry<K, V>> entryIterator();\n", "\n", "    @Override\n", "    public Set<Entry<K, V>> entrySet() {\n", "      return new EntrySet<K, V>() {\n", "        @Override\n", "        Map<K, V> map() {\n", "          return IteratorBasedAbstractMap.this;\n", "        }\n", "\n", "        @Override\n", "        public Iterator<Entry<K, V>> iterator() {\n", "          return entryIterator();\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      Iterators.clear(entryIterator());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Delegates to {@link Map#get}. Returns {@code null} on {@code\n", "   * ClassCastException} and {@code NullPointerException}.\n", "   */\n", "  static <V> V safeGet(Map<?, V> map, @Nullable Object key) {\n", "    checkNotNull(map);\n", "    try {\n", "      return map.get(key);\n", "    } catch (ClassCastException e) {\n", "      return null;\n", "    } catch (NullPointerException e) {\n", "      return null;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Delegates to {@link Map#containsKey}. Returns {@code false} on {@code\n", "   * ClassCastException} and {@code NullPointerException}.\n", "   */\n", "  static boolean safeContainsKey(Map<?, ?> map, Object key) {\n", "    checkNotNull(map);\n", "    try {\n", "      return map.containsKey(key);\n", "    } catch (ClassCastException e) {\n", "      return false;\n", "    } catch (NullPointerException e) {\n", "      return false;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Delegates to {@link Map#remove}. Returns {@code null} on {@code\n", "   * ClassCastException} and {@code NullPointerException}.\n", "   */\n", "  static <V> V safeRemove(Map<?, V> map, Object key) {\n", "    checkNotNull(map);\n", "    try {\n", "      return map.remove(key);\n", "    } catch (ClassCastException e) {\n", "      return null;\n", "    } catch (NullPointerException e) {\n", "      return null;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * An admittedly inefficient implementation of {@link Map#containsKey}.\n", "   */\n", "  static boolean containsKeyImpl(Map<?, ?> map, @Nullable Object key) {\n", "    return Iterators.contains(keyIterator(map.entrySet().iterator()), key);\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link Map#containsValue}.\n", "   */\n", "  static boolean containsValueImpl(Map<?, ?> map, @Nullable Object value) {\n", "    return Iterators.contains(valueIterator(map.entrySet().iterator()), value);\n", "  }\n", "\n", "  /**\n", "   * Implements {@code Collection.contains} safely for forwarding collections of\n", "   * map entries. If {@code o} is an instance of {@code Map.Entry}, it is\n", "   * wrapped using {@link #unmodifiableEntry} to protect against a possible\n", "   * nefarious equals method.\n", "   *\n", "   * <p>Note that {@code c} is the backing (delegate) collection, rather than\n", "   * the forwarding collection.\n", "   *\n", "   * @param c the delegate (unwrapped) collection of map entries\n", "   * @param o the object that might be contained in {@code c}\n", "   * @return {@code true} if {@code c} contains {@code o}\n", "   */\n", "  static <K, V> boolean containsEntryImpl(Collection<Entry<K, V>> c, Object o) {\n", "    if (!(o instanceof Entry)) {\n", "      return false;\n", "    }\n", "    return c.contains(unmodifiableEntry((Entry<?, ?>) o));\n", "  }\n", "\n", "  /**\n", "   * Implements {@code Collection.remove} safely for forwarding collections of\n", "   * map entries. If {@code o} is an instance of {@code Map.Entry}, it is\n", "   * wrapped using {@link #unmodifiableEntry} to protect against a possible\n", "   * nefarious equals method.\n", "   *\n", "   * <p>Note that {@code c} is backing (delegate) collection, rather than the\n", "   * forwarding collection.\n", "   *\n", "   * @param c the delegate (unwrapped) collection of map entries\n", "   * @param o the object to remove from {@code c}\n", "   * @return {@code true} if {@code c} was changed\n", "   */\n", "  static <K, V> boolean removeEntryImpl(Collection<Entry<K, V>> c, Object o) {\n", "    if (!(o instanceof Entry)) {\n", "      return false;\n", "    }\n", "    return c.remove(unmodifiableEntry((Entry<?, ?>) o));\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link Map#equals}.\n", "   */\n", "  static boolean equalsImpl(Map<?, ?> map, Object object) {\n", "    if (map == object) {\n", "      return true;\n", "    } else if (object instanceof Map) {\n", "      Map<?, ?> o = (Map<?, ?>) object;\n", "      return map.entrySet().equals(o.entrySet());\n", "    }\n", "    return false;\n", "  }\n", "\n", "  static final MapJoiner STANDARD_JOINER = Collections2.STANDARD_JOINER.withKeyValueSeparator(\"=\");\n", "\n", "  /**\n", "   * An implementation of {@link Map#toString}.\n", "   */\n", "  static String toStringImpl(Map<?, ?> map) {\n", "    StringBuilder sb = Collections2.newStringBuilderForCollection(map.size()).append('{');\n", "    STANDARD_JOINER.appendTo(sb, map);\n", "    return sb.append('}').toString();\n", "  }\n", "\n", "  /**\n", "   * An implementation of {@link Map#putAll}.\n", "   */\n", "  static <K, V> void putAllImpl(Map<K, V> self, Map<? extends K, ? extends V> map) {\n", "    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n", "      self.put(entry.getKey(), entry.getValue());\n", "    }\n", "  }\n", "\n", "  static class KeySet<K, V> extends Sets.ImprovedAbstractSet<K> {\n", "    @Weak final Map<K, V> map;\n", "\n", "    KeySet(Map<K, V> map) {\n", "      this.map = checkNotNull(map);\n", "    }\n", "\n", "    Map<K, V> map() {\n", "      return map;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<K> iterator() {\n", "      return keyIterator(map().entrySet().iterator());\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return map().size();\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return map().isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object o) {\n", "      return map().containsKey(o);\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      if (contains(o)) {\n", "        map().remove(o);\n", "        return true;\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      map().clear();\n", "    }\n", "  }\n", "\n", "  @Nullable\n", "  static <K> K keyOrNull(@Nullable Entry<K, ?> entry) {\n", "    return (entry == null) ? null : entry.getKey();\n", "  }\n", "\n", "  @Nullable\n", "  static <V> V valueOrNull(@Nullable Entry<?, V> entry) {\n", "    return (entry == null) ? null : entry.getValue();\n", "  }\n", "\n", "  static class SortedKeySet<K, V> extends KeySet<K, V> implements SortedSet<K> {\n", "    SortedKeySet(SortedMap<K, V> map) {\n", "      super(map);\n", "    }\n", "\n", "    @Override\n", "    SortedMap<K, V> map() {\n", "      return (SortedMap<K, V>) super.map();\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super K> comparator() {\n", "      return map().comparator();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<K> subSet(K fromElement, K toElement) {\n", "      return new SortedKeySet<K, V>(map().subMap(fromElement, toElement));\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<K> headSet(K toElement) {\n", "      return new SortedKeySet<K, V>(map().headMap(toElement));\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<K> tailSet(K fromElement) {\n", "      return new SortedKeySet<K, V>(map().tailMap(fromElement));\n", "    }\n", "\n", "    @Override\n", "    public K first() {\n", "      return map().firstKey();\n", "    }\n", "\n", "    @Override\n", "    public K last() {\n", "      return map().lastKey();\n", "    }\n", "  }\n", "\n", "  static class Values<K, V> extends AbstractCollection<V> {\n", "    @Weak final Map<K, V> map;\n", "\n", "    Values(Map<K, V> map) {\n", "      this.map = checkNotNull(map);\n", "    }\n", "\n", "    final Map<K, V> map() {\n", "      return map;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<V> iterator() {\n", "      return valueIterator(map().entrySet().iterator());\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      try {\n", "        return super.remove(o);\n", "      } catch (UnsupportedOperationException e) {\n", "        for (Entry<K, V> entry : map().entrySet()) {\n", "          if (Objects.equal(o, entry.getValue())) {\n", "            map().remove(entry.getKey());\n", "            return true;\n", "          }\n", "        }\n", "        return false;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> c) {\n", "      try {\n", "        return super.removeAll(checkNotNull(c));\n", "      } catch (UnsupportedOperationException e) {\n", "        Set<K> toRemove = Sets.newHashSet();\n", "        for (Entry<K, V> entry : map().entrySet()) {\n", "          if (c.contains(entry.getValue())) {\n", "            toRemove.add(entry.getKey());\n", "          }\n", "        }\n", "        return map().keySet().removeAll(toRemove);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> c) {\n", "      try {\n", "        return super.retainAll(checkNotNull(c));\n", "      } catch (UnsupportedOperationException e) {\n", "        Set<K> toRetain = Sets.newHashSet();\n", "        for (Entry<K, V> entry : map().entrySet()) {\n", "          if (c.contains(entry.getValue())) {\n", "            toRetain.add(entry.getKey());\n", "          }\n", "        }\n", "        return map().keySet().retainAll(toRetain);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return map().size();\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return map().isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(@Nullable Object o) {\n", "      return map().containsValue(o);\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      map().clear();\n", "    }\n", "  }\n", "\n", "  abstract static class EntrySet<K, V> extends Sets.ImprovedAbstractSet<Entry<K, V>> {\n", "    abstract Map<K, V> map();\n", "\n", "    @Override\n", "    public int size() {\n", "      return map().size();\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      map().clear();\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object o) {\n", "      if (o instanceof Entry) {\n", "        Entry<?, ?> entry = (Entry<?, ?>) o;\n", "        Object key = entry.getKey();\n", "        V value = Maps.safeGet(map(), key);\n", "        return Objects.equal(value, entry.getValue()) && (value != null || map().containsKey(key));\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return map().isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      if (contains(o)) {\n", "        Entry<?, ?> entry = (Entry<?, ?>) o;\n", "        return map().keySet().remove(entry.getKey());\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> c) {\n", "      try {\n", "        return super.removeAll(checkNotNull(c));\n", "      } catch (UnsupportedOperationException e) {\n", "        // if the iterators don't support remove\n", "        return Sets.removeAllImpl(this, c.iterator());\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> c) {\n", "      try {\n", "        return super.retainAll(checkNotNull(c));\n", "      } catch (UnsupportedOperationException e) {\n", "        // if the iterators don't support remove\n", "        Set<Object> keys = Sets.newHashSetWithExpectedSize(c.size());\n", "        for (Object o : c) {\n", "          if (contains(o)) {\n", "            Entry<?, ?> entry = (Entry<?, ?>) o;\n", "            keys.add(entry.getKey());\n", "          }\n", "        }\n", "        return map().keySet().retainAll(keys);\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a map from the ith element of list to i.\n", "   */\n", "  static <E> ImmutableMap<E, Integer> indexMap(Collection<E> list) {\n", "    ImmutableMap.Builder<E, Integer> builder = new ImmutableMap.Builder<E, Integer>(list.size());\n", "    int i = 0;\n", "    for (E e : list) {\n", "      builder.put(e, i++);\n", "    }\n", "    return builder.build();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958]}}, {"39": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Multimaps.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Predicate;\n", "import com.google.common.base.Predicates;\n", "import com.google.common.base.Supplier;\n", "import com.google.common.collect.Maps.EntryTransformer;\n", "import com.google.j2objc.annotations.Weak;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractCollection;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.HashSet;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.NoSuchElementException;\n", "import java.util.Set;\n", "import java.util.SortedSet;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Provides static methods acting on or generating a {@code Multimap}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps\">\n", " * {@code Multimaps}</a>.\n", " *\n", " * @author Jared Levy\n", " * @author Robert Konigsberg\n", " * @author Mike Bostock\n", " * @author Louis Wasserman\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Multimaps {\n", "  private Multimaps() {}\n", "\n", "  /**\n", "   * Creates a new {@code Multimap} backed by {@code map}, whose internal value\n", "   * collections are generated by {@code factory}.\n", "   *\n", "   * <b>Warning: do not use</b> this method when the collections returned by\n", "   * {@code factory} implement either {@link List} or {@code Set}! Use the more\n", "   * specific method {@link #newListMultimap}, {@link #newSetMultimap} or {@link\n", "   * #newSortedSetMultimap} instead, to avoid very surprising behavior from\n", "   * {@link Multimap#equals}.\n", "   *\n", "   * <p>The {@code factory}-generated and {@code map} classes determine the\n", "   * multimap iteration order. They also specify the behavior of the\n", "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n", "   * multimap and its returned views. However, the multimap's {@code get}\n", "   * method returns instances of a different class than {@code factory.get()}\n", "   * does.\n", "   *\n", "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n", "   * collections generated by {@code factory}, and the multimap contents are all\n", "   * serializable.\n", "   *\n", "   * <p>The multimap is not threadsafe when any concurrent operations update the\n", "   * multimap, even if {@code map} and the instances generated by\n", "   * {@code factory} are. Concurrent read operations will work correctly. To\n", "   * allow concurrent update operations, wrap the multimap with a call to\n", "   * {@link #synchronizedMultimap}.\n", "   *\n", "   * <p>Call this method only when the simpler methods\n", "   * {@link ArrayListMultimap#create()}, {@link HashMultimap#create()},\n", "   * {@link LinkedHashMultimap#create()}, {@link LinkedListMultimap#create()},\n", "   * {@link TreeMultimap#create()}, and\n", "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n", "   *\n", "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n", "   * the collections returned by {@code factory}. Those objects should not be\n", "   * manually updated and they should not use soft, weak, or phantom references.\n", "   *\n", "   * @param map place to store the mapping from each key to its corresponding\n", "   *     values\n", "   * @param factory supplier of new, empty collections that will each hold all\n", "   *     values for a given key\n", "   * @throws IllegalArgumentException if {@code map} is not empty\n", "   */\n", "  public static <K, V> Multimap<K, V> newMultimap(\n", "      Map<K, Collection<V>> map, final Supplier<? extends Collection<V>> factory) {\n", "    return new CustomMultimap<K, V>(map, factory);\n", "  }\n", "\n", "  private static class CustomMultimap<K, V> extends AbstractMapBasedMultimap<K, V> {\n", "    transient Supplier<? extends Collection<V>> factory;\n", "\n", "    CustomMultimap(Map<K, Collection<V>> map, Supplier<? extends Collection<V>> factory) {\n", "      super(map);\n", "      this.factory = checkNotNull(factory);\n", "    }\n", "\n", "    @Override\n", "    protected Collection<V> createCollection() {\n", "      return factory.get();\n", "    }\n", "\n", "    // can't use Serialization writeMultimap and populateMultimap methods since\n", "    // there's no way to generate the empty backing map.\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code ListMultimap} that uses the provided map and factory.\n", "   * It can generate a multimap based on arbitrary {@link Map} and {@link List}\n", "   * classes.\n", "   *\n", "   * <p>The {@code factory}-generated and {@code map} classes determine the\n", "   * multimap iteration order. They also specify the behavior of the\n", "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n", "   * multimap and its returned views. The multimap's {@code get}, {@code\n", "   * removeAll}, and {@code replaceValues} methods return {@code RandomAccess}\n", "   * lists if the factory does. However, the multimap's {@code get} method\n", "   * returns instances of a different class than does {@code factory.get()}.\n", "   *\n", "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n", "   * lists generated by {@code factory}, and the multimap contents are all\n", "   * serializable.\n", "   *\n", "   * <p>The multimap is not threadsafe when any concurrent operations update the\n", "   * multimap, even if {@code map} and the instances generated by\n", "   * {@code factory} are. Concurrent read operations will work correctly. To\n", "   * allow concurrent update operations, wrap the multimap with a call to\n", "   * {@link #synchronizedListMultimap}.\n", "   *\n", "   * <p>Call this method only when the simpler methods\n", "   * {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}\n", "   * won't suffice.\n", "   *\n", "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n", "   * the lists returned by {@code factory}. Those objects should not be manually\n", "   * updated, they should be empty when provided, and they should not use soft,\n", "   * weak, or phantom references.\n", "   *\n", "   * @param map place to store the mapping from each key to its corresponding\n", "   *     values\n", "   * @param factory supplier of new, empty lists that will each hold all values\n", "   *     for a given key\n", "   * @throws IllegalArgumentException if {@code map} is not empty\n", "   */\n", "  public static <K, V> ListMultimap<K, V> newListMultimap(\n", "      Map<K, Collection<V>> map, final Supplier<? extends List<V>> factory) {\n", "    return new CustomListMultimap<K, V>(map, factory);\n", "  }\n", "\n", "  private static class CustomListMultimap<K, V> extends AbstractListMultimap<K, V> {\n", "    transient Supplier<? extends List<V>> factory;\n", "\n", "    CustomListMultimap(Map<K, Collection<V>> map, Supplier<? extends List<V>> factory) {\n", "      super(map);\n", "      this.factory = checkNotNull(factory);\n", "    }\n", "\n", "    @Override\n", "    protected List<V> createCollection() {\n", "      return factory.get();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code SetMultimap} that uses the provided map and factory.\n", "   * It can generate a multimap based on arbitrary {@link Map} and {@link Set}\n", "   * classes.\n", "   *\n", "   * <p>The {@code factory}-generated and {@code map} classes determine the\n", "   * multimap iteration order. They also specify the behavior of the\n", "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n", "   * multimap and its returned views. However, the multimap's {@code get}\n", "   * method returns instances of a different class than {@code factory.get()}\n", "   * does.\n", "   *\n", "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n", "   * sets generated by {@code factory}, and the multimap contents are all\n", "   * serializable.\n", "   *\n", "   * <p>The multimap is not threadsafe when any concurrent operations update the\n", "   * multimap, even if {@code map} and the instances generated by\n", "   * {@code factory} are. Concurrent read operations will work correctly. To\n", "   * allow concurrent update operations, wrap the multimap with a call to\n", "   * {@link #synchronizedSetMultimap}.\n", "   *\n", "   * <p>Call this method only when the simpler methods\n", "   * {@link HashMultimap#create()}, {@link LinkedHashMultimap#create()},\n", "   * {@link TreeMultimap#create()}, and\n", "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n", "   *\n", "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n", "   * the sets returned by {@code factory}. Those objects should not be manually\n", "   * updated and they should not use soft, weak, or phantom references.\n", "   *\n", "   * @param map place to store the mapping from each key to its corresponding\n", "   *     values\n", "   * @param factory supplier of new, empty sets that will each hold all values\n", "   *     for a given key\n", "   * @throws IllegalArgumentException if {@code map} is not empty\n", "   */\n", "  public static <K, V> SetMultimap<K, V> newSetMultimap(\n", "      Map<K, Collection<V>> map, final Supplier<? extends Set<V>> factory) {\n", "    return new CustomSetMultimap<K, V>(map, factory);\n", "  }\n", "\n", "  private static class CustomSetMultimap<K, V> extends AbstractSetMultimap<K, V> {\n", "    transient Supplier<? extends Set<V>> factory;\n", "\n", "    CustomSetMultimap(Map<K, Collection<V>> map, Supplier<? extends Set<V>> factory) {\n", "      super(map);\n", "      this.factory = checkNotNull(factory);\n", "    }\n", "\n", "    @Override\n", "    protected Set<V> createCollection() {\n", "      return factory.get();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code SortedSetMultimap} that uses the provided map and\n", "   * factory. It can generate a multimap based on arbitrary {@link Map} and\n", "   * {@link SortedSet} classes.\n", "   *\n", "   * <p>The {@code factory}-generated and {@code map} classes determine the\n", "   * multimap iteration order. They also specify the behavior of the\n", "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n", "   * multimap and its returned views. However, the multimap's {@code get}\n", "   * method returns instances of a different class than {@code factory.get()}\n", "   * does.\n", "   *\n", "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n", "   * sets generated by {@code factory}, and the multimap contents are all\n", "   * serializable.\n", "   *\n", "   * <p>The multimap is not threadsafe when any concurrent operations update the\n", "   * multimap, even if {@code map} and the instances generated by\n", "   * {@code factory} are. Concurrent read operations will work correctly. To\n", "   * allow concurrent update operations, wrap the multimap with a call to\n", "   * {@link #synchronizedSortedSetMultimap}.\n", "   *\n", "   * <p>Call this method only when the simpler methods\n", "   * {@link TreeMultimap#create()} and\n", "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n", "   *\n", "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n", "   * the sets returned by {@code factory}. Those objects should not be manually\n", "   * updated and they should not use soft, weak, or phantom references.\n", "   *\n", "   * @param map place to store the mapping from each key to its corresponding\n", "   *     values\n", "   * @param factory supplier of new, empty sorted sets that will each hold\n", "   *     all values for a given key\n", "   * @throws IllegalArgumentException if {@code map} is not empty\n", "   */\n", "  public static <K, V> SortedSetMultimap<K, V> newSortedSetMultimap(\n", "      Map<K, Collection<V>> map, final Supplier<? extends SortedSet<V>> factory) {\n", "    return new CustomSortedSetMultimap<K, V>(map, factory);\n", "  }\n", "\n", "  private static class CustomSortedSetMultimap<K, V> extends AbstractSortedSetMultimap<K, V> {\n", "    transient Supplier<? extends SortedSet<V>> factory;\n", "    transient Comparator<? super V> valueComparator;\n", "\n", "    CustomSortedSetMultimap(Map<K, Collection<V>> map, Supplier<? extends SortedSet<V>> factory) {\n", "      super(map);\n", "      this.factory = checkNotNull(factory);\n", "      valueComparator = factory.get().comparator();\n", "    }\n", "\n", "    @Override\n", "    protected SortedSet<V> createCollection() {\n", "      return factory.get();\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super V> valueComparator() {\n", "      return valueComparator;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Copies each key-value mapping in {@code source} into {@code dest}, with\n", "   * its key and value reversed.\n", "   *\n", "   * <p>If {@code source} is an {@link ImmutableMultimap}, consider using\n", "   * {@link ImmutableMultimap#inverse} instead.\n", "   *\n", "   * @param source any multimap\n", "   * @param dest the multimap to copy into; usually empty\n", "   * @return {@code dest}\n", "   */\n", "  public static <K, V, M extends Multimap<K, V>> M invertFrom(\n", "      Multimap<? extends V, ? extends K> source, M dest) {\n", "    checkNotNull(dest);\n", "    for (Map.Entry<? extends V, ? extends K> entry : source.entries()) {\n", "      dest.put(entry.getValue(), entry.getKey());\n", "    }\n", "    return dest;\n", "  }\n", "\n", "  /**\n", "   * Returns a synchronized (thread-safe) multimap backed by the specified\n", "   * multimap. In order to guarantee serial access, it is critical that\n", "   * <b>all</b> access to the backing multimap is accomplished through the\n", "   * returned multimap.\n", "   *\n", "   * <p>It is imperative that the user manually synchronize on the returned\n", "   * multimap when accessing any of its collection views: <pre>   {@code\n", "   *\n", "   *   Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n", "   *       HashMultimap.<K, V>create());\n", "   *   ...\n", "   *   Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n", "   *   ...\n", "   *   synchronized (multimap) {  // Synchronizing on multimap, not values!\n", "   *     Iterator<V> i = values.iterator(); // Must be in synchronized block\n", "   *     while (i.hasNext()) {\n", "   *       foo(i.next());\n", "   *     }\n", "   *   }}</pre>\n", "   *\n", "   * <p>Failure to follow this advice may result in non-deterministic behavior.\n", "   *\n", "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n", "   * {@link Multimap#replaceValues} methods return collections that aren't\n", "   * synchronized.\n", "   *\n", "   * <p>The returned multimap will be serializable if the specified multimap is\n", "   * serializable.\n", "   *\n", "   * @param multimap the multimap to be wrapped in a synchronized view\n", "   * @return a synchronized view of the specified multimap\n", "   */\n", "  public static <K, V> Multimap<K, V> synchronizedMultimap(Multimap<K, V> multimap) {\n", "    return Synchronized.multimap(multimap, null);\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified multimap. Query operations on\n", "   * the returned multimap \"read through\" to the specified multimap, and\n", "   * attempts to modify the returned multimap, either directly or through the\n", "   * multimap's views, result in an {@code UnsupportedOperationException}.\n", "   *\n", "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n", "   * {@link Multimap#replaceValues} methods return collections that are\n", "   * modifiable.\n", "   *\n", "   * <p>The returned multimap will be serializable if the specified multimap is\n", "   * serializable.\n", "   *\n", "   * @param delegate the multimap for which an unmodifiable view is to be\n", "   *     returned\n", "   * @return an unmodifiable view of the specified multimap\n", "   */\n", "  public static <K, V> Multimap<K, V> unmodifiableMultimap(Multimap<K, V> delegate) {\n", "    if (delegate instanceof UnmodifiableMultimap || delegate instanceof ImmutableMultimap) {\n", "      return delegate;\n", "    }\n", "    return new UnmodifiableMultimap<K, V>(delegate);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   * @since 10.0\n", "   */\n", "  @Deprecated\n", "  public static <K, V> Multimap<K, V> unmodifiableMultimap(ImmutableMultimap<K, V> delegate) {\n", "    return checkNotNull(delegate);\n", "  }\n", "\n", "  private static class UnmodifiableMultimap<K, V> extends ForwardingMultimap<K, V>\n", "      implements Serializable {\n", "    final Multimap<K, V> delegate;\n", "    transient Collection<Entry<K, V>> entries;\n", "    transient Multiset<K> keys;\n", "    transient Set<K> keySet;\n", "    transient Collection<V> values;\n", "    transient Map<K, Collection<V>> map;\n", "\n", "    UnmodifiableMultimap(final Multimap<K, V> delegate) {\n", "      this.delegate = checkNotNull(delegate);\n", "    }\n", "\n", "    @Override\n", "    protected Multimap<K, V> delegate() {\n", "      return delegate;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Map<K, Collection<V>> asMap() {\n", "      Map<K, Collection<V>> result = map;\n", "      if (result == null) {\n", "        result = map =\n", "            Collections.unmodifiableMap(\n", "                Maps.transformValues(\n", "                    delegate.asMap(),\n", "                    new Function<Collection<V>, Collection<V>>() {\n", "                      @Override\n", "                      public Collection<V> apply(Collection<V> collection) {\n", "                        return unmodifiableValueCollection(collection);\n", "                      }\n", "                    }));\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public Collection<Entry<K, V>> entries() {\n", "      Collection<Entry<K, V>> result = entries;\n", "      if (result == null) {\n", "        entries = result = unmodifiableEntries(delegate.entries());\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> get(K key) {\n", "      return unmodifiableValueCollection(delegate.get(key));\n", "    }\n", "\n", "    @Override\n", "    public Multiset<K> keys() {\n", "      Multiset<K> result = keys;\n", "      if (result == null) {\n", "        keys = result = Multisets.unmodifiableMultiset(delegate.keys());\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      Set<K> result = keySet;\n", "      if (result == null) {\n", "        keySet = result = Collections.unmodifiableSet(delegate.keySet());\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public boolean put(K key, V value) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public boolean putAll(K key, Iterable<? extends V> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public boolean putAll(Multimap<? extends K, ? extends V> multimap) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object key, Object value) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> removeAll(Object key) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> values() {\n", "      Collection<V> result = values;\n", "      if (result == null) {\n", "        values = result = Collections.unmodifiableCollection(delegate.values());\n", "      }\n", "      return result;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static class UnmodifiableListMultimap<K, V> extends UnmodifiableMultimap<K, V>\n", "      implements ListMultimap<K, V> {\n", "    UnmodifiableListMultimap(ListMultimap<K, V> delegate) {\n", "      super(delegate);\n", "    }\n", "\n", "    @Override\n", "    public ListMultimap<K, V> delegate() {\n", "      return (ListMultimap<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public List<V> get(K key) {\n", "      return Collections.unmodifiableList(delegate().get(key));\n", "    }\n", "\n", "    @Override\n", "    public List<V> removeAll(Object key) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public List<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static class UnmodifiableSetMultimap<K, V> extends UnmodifiableMultimap<K, V>\n", "      implements SetMultimap<K, V> {\n", "    UnmodifiableSetMultimap(SetMultimap<K, V> delegate) {\n", "      super(delegate);\n", "    }\n", "\n", "    @Override\n", "    public SetMultimap<K, V> delegate() {\n", "      return (SetMultimap<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public Set<V> get(K key) {\n", "      /*\n", "       * Note that this doesn't return a SortedSet when delegate is a\n", "       * SortedSetMultiset, unlike (SortedSet<V>) super.get().\n", "       */\n", "      return Collections.unmodifiableSet(delegate().get(key));\n", "    }\n", "\n", "    @Override\n", "    public Set<Map.Entry<K, V>> entries() {\n", "      return Maps.unmodifiableEntrySet(delegate().entries());\n", "    }\n", "\n", "    @Override\n", "    public Set<V> removeAll(Object key) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Set<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static class UnmodifiableSortedSetMultimap<K, V> extends UnmodifiableSetMultimap<K, V>\n", "      implements SortedSetMultimap<K, V> {\n", "    UnmodifiableSortedSetMultimap(SortedSetMultimap<K, V> delegate) {\n", "      super(delegate);\n", "    }\n", "\n", "    @Override\n", "    public SortedSetMultimap<K, V> delegate() {\n", "      return (SortedSetMultimap<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> get(K key) {\n", "      return Collections.unmodifiableSortedSet(delegate().get(key));\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> removeAll(Object key) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super V> valueComparator() {\n", "      return delegate().valueComparator();\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the\n", "   * specified multimap.\n", "   *\n", "   * <p>You must follow the warnings described in {@link #synchronizedMultimap}.\n", "   *\n", "   * <p>The returned multimap will be serializable if the specified multimap is\n", "   * serializable.\n", "   *\n", "   * @param multimap the multimap to be wrapped\n", "   * @return a synchronized view of the specified multimap\n", "   */\n", "  public static <K, V> SetMultimap<K, V> synchronizedSetMultimap(SetMultimap<K, V> multimap) {\n", "    return Synchronized.setMultimap(multimap, null);\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified {@code SetMultimap}. Query\n", "   * operations on the returned multimap \"read through\" to the specified\n", "   * multimap, and attempts to modify the returned multimap, either directly or\n", "   * through the multimap's views, result in an\n", "   * {@code UnsupportedOperationException}.\n", "   *\n", "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n", "   * {@link Multimap#replaceValues} methods return collections that are\n", "   * modifiable.\n", "   *\n", "   * <p>The returned multimap will be serializable if the specified multimap is\n", "   * serializable.\n", "   *\n", "   * @param delegate the multimap for which an unmodifiable view is to be\n", "   *     returned\n", "   * @return an unmodifiable view of the specified multimap\n", "   */\n", "  public static <K, V> SetMultimap<K, V> unmodifiableSetMultimap(SetMultimap<K, V> delegate) {\n", "    if (delegate instanceof UnmodifiableSetMultimap || delegate instanceof ImmutableSetMultimap) {\n", "      return delegate;\n", "    }\n", "    return new UnmodifiableSetMultimap<K, V>(delegate);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   * @since 10.0\n", "   */\n", "  @Deprecated\n", "  public static <K, V> SetMultimap<K, V> unmodifiableSetMultimap(\n", "      ImmutableSetMultimap<K, V> delegate) {\n", "    return checkNotNull(delegate);\n", "  }\n", "\n", "  /**\n", "   * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by\n", "   * the specified multimap.\n", "   *\n", "   * <p>You must follow the warnings described in {@link #synchronizedMultimap}.\n", "   *\n", "   * <p>The returned multimap will be serializable if the specified multimap is\n", "   * serializable.\n", "   *\n", "   * @param multimap the multimap to be wrapped\n", "   * @return a synchronized view of the specified multimap\n", "   */\n", "  public static <K, V> SortedSetMultimap<K, V> synchronizedSortedSetMultimap(\n", "      SortedSetMultimap<K, V> multimap) {\n", "    return Synchronized.sortedSetMultimap(multimap, null);\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified {@code SortedSetMultimap}.\n", "   * Query operations on the returned multimap \"read through\" to the specified\n", "   * multimap, and attempts to modify the returned multimap, either directly or\n", "   * through the multimap's views, result in an\n", "   * {@code UnsupportedOperationException}.\n", "   *\n", "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n", "   * {@link Multimap#replaceValues} methods return collections that are\n", "   * modifiable.\n", "   *\n", "   * <p>The returned multimap will be serializable if the specified multimap is\n", "   * serializable.\n", "   *\n", "   * @param delegate the multimap for which an unmodifiable view is to be\n", "   *     returned\n", "   * @return an unmodifiable view of the specified multimap\n", "   */\n", "  public static <K, V> SortedSetMultimap<K, V> unmodifiableSortedSetMultimap(\n", "      SortedSetMultimap<K, V> delegate) {\n", "    if (delegate instanceof UnmodifiableSortedSetMultimap) {\n", "      return delegate;\n", "    }\n", "    return new UnmodifiableSortedSetMultimap<K, V>(delegate);\n", "  }\n", "\n", "  /**\n", "   * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the\n", "   * specified multimap.\n", "   *\n", "   * <p>You must follow the warnings described in {@link #synchronizedMultimap}.\n", "   *\n", "   * @param multimap the multimap to be wrapped\n", "   * @return a synchronized view of the specified multimap\n", "   */\n", "  public static <K, V> ListMultimap<K, V> synchronizedListMultimap(ListMultimap<K, V> multimap) {\n", "    return Synchronized.listMultimap(multimap, null);\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified {@code ListMultimap}. Query\n", "   * operations on the returned multimap \"read through\" to the specified\n", "   * multimap, and attempts to modify the returned multimap, either directly or\n", "   * through the multimap's views, result in an\n", "   * {@code UnsupportedOperationException}.\n", "   *\n", "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n", "   * {@link Multimap#replaceValues} methods return collections that are\n", "   * modifiable.\n", "   *\n", "   * <p>The returned multimap will be serializable if the specified multimap is\n", "   * serializable.\n", "   *\n", "   * @param delegate the multimap for which an unmodifiable view is to be\n", "   *     returned\n", "   * @return an unmodifiable view of the specified multimap\n", "   */\n", "  public static <K, V> ListMultimap<K, V> unmodifiableListMultimap(ListMultimap<K, V> delegate) {\n", "    if (delegate instanceof UnmodifiableListMultimap || delegate instanceof ImmutableListMultimap) {\n", "      return delegate;\n", "    }\n", "    return new UnmodifiableListMultimap<K, V>(delegate);\n", "  }\n", "\n", "  /**\n", "   * Simply returns its argument.\n", "   *\n", "   * @deprecated no need to use this\n", "   * @since 10.0\n", "   */\n", "  @Deprecated\n", "  public static <K, V> ListMultimap<K, V> unmodifiableListMultimap(\n", "      ImmutableListMultimap<K, V> delegate) {\n", "    return checkNotNull(delegate);\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified collection, preserving the\n", "   * interface for instances of {@code SortedSet}, {@code Set}, {@code List} and\n", "   * {@code Collection}, in that order of preference.\n", "   *\n", "   * @param collection the collection for which to return an unmodifiable view\n", "   * @return an unmodifiable view of the collection\n", "   */\n", "  private static <V> Collection<V> unmodifiableValueCollection(Collection<V> collection) {\n", "    if (collection instanceof SortedSet) {\n", "      return Collections.unmodifiableSortedSet((SortedSet<V>) collection);\n", "    } else if (collection instanceof Set) {\n", "      return Collections.unmodifiableSet((Set<V>) collection);\n", "    } else if (collection instanceof List) {\n", "      return Collections.unmodifiableList((List<V>) collection);\n", "    }\n", "    return Collections.unmodifiableCollection(collection);\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable view of the specified collection of entries. The\n", "   * {@link Entry#setValue} operation throws an {@link\n", "   * UnsupportedOperationException}. If the specified collection is a {@code\n", "   * Set}, the returned collection is also a {@code Set}.\n", "   *\n", "   * @param entries the entries for which to return an unmodifiable view\n", "   * @return an unmodifiable view of the entries\n", "   */\n", "  private static <K, V> Collection<Entry<K, V>> unmodifiableEntries(\n", "      Collection<Entry<K, V>> entries) {\n", "    if (entries instanceof Set) {\n", "      return Maps.unmodifiableEntrySet((Set<Entry<K, V>>) entries);\n", "    }\n", "    return new Maps.UnmodifiableEntries<K, V>(Collections.unmodifiableCollection(entries));\n", "  }\n", "\n", "  /**\n", "   * Returns {@link ListMultimap#asMap multimap.asMap()}, with its type\n", "   * corrected from {@code Map<K, Collection<V>>} to {@code Map<K, List<V>>}.\n", "   *\n", "   * @since 15.0\n", "   */\n", "  @Beta\n", "  @SuppressWarnings(\"unchecked\")\n", "  // safe by specification of ListMultimap.asMap()\n", "  public static <K, V> Map<K, List<V>> asMap(ListMultimap<K, V> multimap) {\n", "    return (Map<K, List<V>>) (Map<K, ?>) multimap.asMap();\n", "  }\n", "\n", "  /**\n", "   * Returns {@link SetMultimap#asMap multimap.asMap()}, with its type corrected\n", "   * from {@code Map<K, Collection<V>>} to {@code Map<K, Set<V>>}.\n", "   *\n", "   * @since 15.0\n", "   */\n", "  @Beta\n", "  @SuppressWarnings(\"unchecked\")\n", "  // safe by specification of SetMultimap.asMap()\n", "  public static <K, V> Map<K, Set<V>> asMap(SetMultimap<K, V> multimap) {\n", "    return (Map<K, Set<V>>) (Map<K, ?>) multimap.asMap();\n", "  }\n", "\n", "  /**\n", "   * Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type\n", "   * corrected from {@code Map<K, Collection<V>>} to\n", "   * {@code Map<K, SortedSet<V>>}.\n", "   *\n", "   * @since 15.0\n", "   */\n", "  @Beta\n", "  @SuppressWarnings(\"unchecked\")\n", "  // safe by specification of SortedSetMultimap.asMap()\n", "  public static <K, V> Map<K, SortedSet<V>> asMap(SortedSetMultimap<K, V> multimap) {\n", "    return (Map<K, SortedSet<V>>) (Map<K, ?>) multimap.asMap();\n", "  }\n", "\n", "  /**\n", "   * Returns {@link Multimap#asMap multimap.asMap()}. This is provided for\n", "   * parity with the other more strongly-typed {@code asMap()} implementations.\n", "   *\n", "   * @since 15.0\n", "   */\n", "  @Beta\n", "  public static <K, V> Map<K, Collection<V>> asMap(Multimap<K, V> multimap) {\n", "    return multimap.asMap();\n", "  }\n", "\n", "  /**\n", "   * Returns a multimap view of the specified map. The multimap is backed by the\n", "   * map, so changes to the map are reflected in the multimap, and vice versa.\n", "   * If the map is modified while an iteration over one of the multimap's\n", "   * collection views is in progress (except through the iterator's own {@code\n", "   * remove} operation, or through the {@code setValue} operation on a map entry\n", "   * returned by the iterator), the results of the iteration are undefined.\n", "   *\n", "   * <p>The multimap supports mapping removal, which removes the corresponding\n", "   * mapping from the map. It does not support any operations which might add\n", "   * mappings, such as {@code put}, {@code putAll} or {@code replaceValues}.\n", "   *\n", "   * <p>The returned multimap will be serializable if the specified map is\n", "   * serializable.\n", "   *\n", "   * @param map the backing map for the returned multimap view\n", "   */\n", "  public static <K, V> SetMultimap<K, V> forMap(Map<K, V> map) {\n", "    return new MapMultimap<K, V>(map);\n", "  }\n", "\n", "  /** @see Multimaps#forMap */\n", "  private static class MapMultimap<K, V> extends AbstractMultimap<K, V>\n", "      implements SetMultimap<K, V>, Serializable {\n", "    final Map<K, V> map;\n", "\n", "    MapMultimap(Map<K, V> map) {\n", "      this.map = checkNotNull(map);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return map.size();\n", "    }\n", "\n", "    @Override\n", "    public boolean containsKey(Object key) {\n", "      return map.containsKey(key);\n", "    }\n", "\n", "    @Override\n", "    public boolean containsValue(Object value) {\n", "      return map.containsValue(value);\n", "    }\n", "\n", "    @Override\n", "    public boolean containsEntry(Object key, Object value) {\n", "      return map.entrySet().contains(Maps.immutableEntry(key, value));\n", "    }\n", "\n", "    @Override\n", "    public Set<V> get(final K key) {\n", "      return new Sets.ImprovedAbstractSet<V>() {\n", "        @Override\n", "        public Iterator<V> iterator() {\n", "          return new Iterator<V>() {\n", "            int i;\n", "\n", "            @Override\n", "            public boolean hasNext() {\n", "              return (i == 0) && map.containsKey(key);\n", "            }\n", "\n", "            @Override\n", "            public V next() {\n", "              if (!hasNext()) {\n", "                throw new NoSuchElementException();\n", "              }\n", "              i++;\n", "              return map.get(key);\n", "            }\n", "\n", "            @Override\n", "            public void remove() {\n", "              checkRemove(i == 1);\n", "              i = -1;\n", "              map.remove(key);\n", "            }\n", "          };\n", "        }\n", "\n", "        @Override\n", "        public int size() {\n", "          return map.containsKey(key) ? 1 : 0;\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public boolean put(K key, V value) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public boolean putAll(K key, Iterable<? extends V> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public boolean putAll(Multimap<? extends K, ? extends V> multimap) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public Set<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object key, Object value) {\n", "      return map.entrySet().remove(Maps.immutableEntry(key, value));\n", "    }\n", "\n", "    @Override\n", "    public Set<V> removeAll(Object key) {\n", "      Set<V> values = new HashSet<V>(2);\n", "      if (!map.containsKey(key)) {\n", "        return values;\n", "      }\n", "      values.add(map.remove(key));\n", "      return values;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      map.clear();\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      return map.keySet();\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> values() {\n", "      return map.values();\n", "    }\n", "\n", "    @Override\n", "    public Set<Entry<K, V>> entries() {\n", "      return map.entrySet();\n", "    }\n", "\n", "    @Override\n", "    Iterator<Entry<K, V>> entryIterator() {\n", "      return map.entrySet().iterator();\n", "    }\n", "\n", "    @Override\n", "    Map<K, Collection<V>> createAsMap() {\n", "      return new AsMap<K, V>(this);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return map.hashCode();\n", "    }\n", "\n", "    private static final long serialVersionUID = 7845222491160860175L;\n", "  }\n", "\n", "  /**\n", "   * Returns a view of a multimap where each value is transformed by a function.\n", "   * All other properties of the multimap, such as iteration order, are left\n", "   * intact. For example, the code: <pre>   {@code\n", "   *\n", "   * Multimap<String, Integer> multimap =\n", "   *     ImmutableSetMultimap.of(\"a\", 2, \"b\", -3, \"b\", -3, \"a\", 4, \"c\", 6);\n", "   * Function<Integer, String> square = new Function<Integer, String>() {\n", "   *     public String apply(Integer in) {\n", "   *       return Integer.toString(in * in);\n", "   *     }\n", "   * };\n", "   * Multimap<String, String> transformed =\n", "   *     Multimaps.transformValues(multimap, square);\n", "   *   System.out.println(transformed);}</pre>\n", "   *\n", "   * ... prints {@code {a=[4, 16], b=[9, 9], c=[36]}}.\n", "   *\n", "   * <p>Changes in the underlying multimap are reflected in this view.\n", "   * Conversely, this view supports removal operations, and these are reflected\n", "   * in the underlying multimap.\n", "   *\n", "   * <p>It's acceptable for the underlying multimap to contain null keys, and\n", "   * even null values provided that the function is capable of accepting null\n", "   * input.  The transformed multimap might contain null values, if the function\n", "   * sometimes gives a null result.\n", "   *\n", "   * <p>The returned multimap is not thread-safe or serializable, even if the\n", "   * underlying multimap is.  The {@code equals} and {@code hashCode} methods\n", "   * of the returned multimap are meaningless, since there is not a definition\n", "   * of {@code equals} or {@code hashCode} for general collections, and\n", "   * {@code get()} will return a general {@code Collection} as opposed to a\n", "   * {@code List} or a {@code Set}.\n", "   *\n", "   * <p>The function is applied lazily, invoked when needed. This is necessary\n", "   * for the returned multimap to be a view, but it means that the function will\n", "   * be applied many times for bulk operations like\n", "   * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n", "   * perform well, {@code function} should be fast. To avoid lazy evaluation\n", "   * when the returned multimap doesn't need to be a view, copy the returned\n", "   * multimap into a new multimap of your choosing.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  public static <K, V1, V2> Multimap<K, V2> transformValues(\n", "      Multimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {\n", "    checkNotNull(function);\n", "    EntryTransformer<K, V1, V2> transformer = Maps.asEntryTransformer(function);\n", "    return transformEntries(fromMultimap, transformer);\n", "  }\n", "\n", "  /**\n", "   * Returns a view of a multimap whose values are derived from the original\n", "   * multimap's entries. In contrast to {@link #transformValues}, this method's\n", "   * entry-transformation logic may depend on the key as well as the value.\n", "   *\n", "   * <p>All other properties of the transformed multimap, such as iteration\n", "   * order, are left intact. For example, the code: <pre>   {@code\n", "   *\n", "   *   SetMultimap<String, Integer> multimap =\n", "   *       ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n", "   *   EntryTransformer<String, Integer, String> transformer =\n", "   *       new EntryTransformer<String, Integer, String>() {\n", "   *         public String transformEntry(String key, Integer value) {\n", "   *            return (value >= 0) ? key : \"no\" + key;\n", "   *         }\n", "   *       };\n", "   *   Multimap<String, String> transformed =\n", "   *       Multimaps.transformEntries(multimap, transformer);\n", "   *   System.out.println(transformed);}</pre>\n", "   *\n", "   * ... prints {@code {a=[a, a], b=[nob]}}.\n", "   *\n", "   * <p>Changes in the underlying multimap are reflected in this view.\n", "   * Conversely, this view supports removal operations, and these are reflected\n", "   * in the underlying multimap.\n", "   *\n", "   * <p>It's acceptable for the underlying multimap to contain null keys and\n", "   * null values provided that the transformer is capable of accepting null\n", "   * inputs. The transformed multimap might contain null values if the\n", "   * transformer sometimes gives a null result.\n", "   *\n", "   * <p>The returned multimap is not thread-safe or serializable, even if the\n", "   * underlying multimap is.  The {@code equals} and {@code hashCode} methods\n", "   * of the returned multimap are meaningless, since there is not a definition\n", "   * of {@code equals} or {@code hashCode} for general collections, and\n", "   * {@code get()} will return a general {@code Collection} as opposed to a\n", "   * {@code List} or a {@code Set}.\n", "   *\n", "   * <p>The transformer is applied lazily, invoked when needed. This is\n", "   * necessary for the returned multimap to be a view, but it means that the\n", "   * transformer will be applied many times for bulk operations like {@link\n", "   * Multimap#containsValue} and {@link Object#toString}. For this to perform\n", "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the\n", "   * returned multimap doesn't need to be a view, copy the returned multimap\n", "   * into a new multimap of your choosing.\n", "   *\n", "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n", "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n", "   * that {@code k2} is also of type {@code K}. Using an {@code\n", "   * EntryTransformer} key type for which this may not hold, such as {@code\n", "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n", "   * the transformed multimap.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  public static <K, V1, V2> Multimap<K, V2> transformEntries(\n", "      Multimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "    return new TransformedEntriesMultimap<K, V1, V2>(fromMap, transformer);\n", "  }\n", "\n", "  private static class TransformedEntriesMultimap<K, V1, V2> extends AbstractMultimap<K, V2> {\n", "    final Multimap<K, V1> fromMultimap;\n", "    final EntryTransformer<? super K, ? super V1, V2> transformer;\n", "\n", "    TransformedEntriesMultimap(\n", "        Multimap<K, V1> fromMultimap,\n", "        final EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "      this.fromMultimap = checkNotNull(fromMultimap);\n", "      this.transformer = checkNotNull(transformer);\n", "    }\n", "\n", "    Collection<V2> transform(K key, Collection<V1> values) {\n", "      Function<? super V1, V2> function = Maps.asValueToValueFunction(transformer, key);\n", "      if (values instanceof List) {\n", "        return Lists.transform((List<V1>) values, function);\n", "      } else {\n", "        return Collections2.transform(values, function);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    Map<K, Collection<V2>> createAsMap() {\n", "      return Maps.transformEntries(\n", "          fromMultimap.asMap(),\n", "          new EntryTransformer<K, Collection<V1>, Collection<V2>>() {\n", "            @Override\n", "            public Collection<V2> transformEntry(K key, Collection<V1> value) {\n", "              return transform(key, value);\n", "            }\n", "          });\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      fromMultimap.clear();\n", "    }\n", "\n", "    @Override\n", "    public boolean containsKey(Object key) {\n", "      return fromMultimap.containsKey(key);\n", "    }\n", "\n", "    @Override\n", "    Iterator<Entry<K, V2>> entryIterator() {\n", "      return Iterators.transform(\n", "          fromMultimap.entries().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n", "    }\n", "\n", "    @Override\n", "    public Collection<V2> get(final K key) {\n", "      return transform(key, fromMultimap.get(key));\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return fromMultimap.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      return fromMultimap.keySet();\n", "    }\n", "\n", "    @Override\n", "    public Multiset<K> keys() {\n", "      return fromMultimap.keys();\n", "    }\n", "\n", "    @Override\n", "    public boolean put(K key, V2 value) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public boolean putAll(K key, Iterable<? extends V2> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public boolean putAll(Multimap<? extends K, ? extends V2> multimap) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public boolean remove(Object key, Object value) {\n", "      return get((K) key).remove(value);\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public Collection<V2> removeAll(Object key) {\n", "      return transform((K) key, fromMultimap.removeAll(key));\n", "    }\n", "\n", "    @Override\n", "    public Collection<V2> replaceValues(K key, Iterable<? extends V2> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return fromMultimap.size();\n", "    }\n", "\n", "    @Override\n", "    Collection<V2> createValues() {\n", "      return Collections2.transform(\n", "          fromMultimap.entries(), Maps.<K, V1, V2>asEntryToValueFunction(transformer));\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a view of a {@code ListMultimap} where each value is transformed by\n", "   * a function. All other properties of the multimap, such as iteration order,\n", "   * are left intact. For example, the code: <pre>   {@code\n", "   *\n", "   *   ListMultimap<String, Integer> multimap\n", "   *        = ImmutableListMultimap.of(\"a\", 4, \"a\", 16, \"b\", 9);\n", "   *   Function<Integer, Double> sqrt =\n", "   *       new Function<Integer, Double>() {\n", "   *         public Double apply(Integer in) {\n", "   *           return Math.sqrt((int) in);\n", "   *         }\n", "   *       };\n", "   *   ListMultimap<String, Double> transformed = Multimaps.transformValues(map,\n", "   *       sqrt);\n", "   *   System.out.println(transformed);}</pre>\n", "   *\n", "   * ... prints {@code {a=[2.0, 4.0], b=[3.0]}}.\n", "   *\n", "   * <p>Changes in the underlying multimap are reflected in this view.\n", "   * Conversely, this view supports removal operations, and these are reflected\n", "   * in the underlying multimap.\n", "   *\n", "   * <p>It's acceptable for the underlying multimap to contain null keys, and\n", "   * even null values provided that the function is capable of accepting null\n", "   * input.  The transformed multimap might contain null values, if the function\n", "   * sometimes gives a null result.\n", "   *\n", "   * <p>The returned multimap is not thread-safe or serializable, even if the\n", "   * underlying multimap is.\n", "   *\n", "   * <p>The function is applied lazily, invoked when needed. This is necessary\n", "   * for the returned multimap to be a view, but it means that the function will\n", "   * be applied many times for bulk operations like\n", "   * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n", "   * perform well, {@code function} should be fast. To avoid lazy evaluation\n", "   * when the returned multimap doesn't need to be a view, copy the returned\n", "   * multimap into a new multimap of your choosing.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  public static <K, V1, V2> ListMultimap<K, V2> transformValues(\n", "      ListMultimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {\n", "    checkNotNull(function);\n", "    EntryTransformer<K, V1, V2> transformer = Maps.asEntryTransformer(function);\n", "    return transformEntries(fromMultimap, transformer);\n", "  }\n", "\n", "  /**\n", "   * Returns a view of a {@code ListMultimap} whose values are derived from the\n", "   * original multimap's entries. In contrast to\n", "   * {@link #transformValues(ListMultimap, Function)}, this method's\n", "   * entry-transformation logic may depend on the key as well as the value.\n", "   *\n", "   * <p>All other properties of the transformed multimap, such as iteration\n", "   * order, are left intact. For example, the code: <pre>   {@code\n", "   *\n", "   *   Multimap<String, Integer> multimap =\n", "   *       ImmutableMultimap.of(\"a\", 1, \"a\", 4, \"b\", 6);\n", "   *   EntryTransformer<String, Integer, String> transformer =\n", "   *       new EntryTransformer<String, Integer, String>() {\n", "   *         public String transformEntry(String key, Integer value) {\n", "   *           return key + value;\n", "   *         }\n", "   *       };\n", "   *   Multimap<String, String> transformed =\n", "   *       Multimaps.transformEntries(multimap, transformer);\n", "   *   System.out.println(transformed);}</pre>\n", "   *\n", "   * ... prints {@code {\"a\"=[\"a1\", \"a4\"], \"b\"=[\"b6\"]}}.\n", "   *\n", "   * <p>Changes in the underlying multimap are reflected in this view.\n", "   * Conversely, this view supports removal operations, and these are reflected\n", "   * in the underlying multimap.\n", "   *\n", "   * <p>It's acceptable for the underlying multimap to contain null keys and\n", "   * null values provided that the transformer is capable of accepting null\n", "   * inputs. The transformed multimap might contain null values if the\n", "   * transformer sometimes gives a null result.\n", "   *\n", "   * <p>The returned multimap is not thread-safe or serializable, even if the\n", "   * underlying multimap is.\n", "   *\n", "   * <p>The transformer is applied lazily, invoked when needed. This is\n", "   * necessary for the returned multimap to be a view, but it means that the\n", "   * transformer will be applied many times for bulk operations like {@link\n", "   * Multimap#containsValue} and {@link Object#toString}. For this to perform\n", "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the\n", "   * returned multimap doesn't need to be a view, copy the returned multimap\n", "   * into a new multimap of your choosing.\n", "   *\n", "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n", "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n", "   * that {@code k2} is also of type {@code K}. Using an {@code\n", "   * EntryTransformer} key type for which this may not hold, such as {@code\n", "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n", "   * the transformed multimap.\n", "   *\n", "   * @since 7.0\n", "   */\n", "  public static <K, V1, V2> ListMultimap<K, V2> transformEntries(\n", "      ListMultimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "    return new TransformedEntriesListMultimap<K, V1, V2>(fromMap, transformer);\n", "  }\n", "\n", "  private static final class TransformedEntriesListMultimap<K, V1, V2>\n", "      extends TransformedEntriesMultimap<K, V1, V2> implements ListMultimap<K, V2> {\n", "\n", "    TransformedEntriesListMultimap(\n", "        ListMultimap<K, V1> fromMultimap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n", "      super(fromMultimap, transformer);\n", "    }\n", "\n", "    @Override\n", "    List<V2> transform(K key, Collection<V1> values) {\n", "      return Lists.transform((List<V1>) values, Maps.asValueToValueFunction(transformer, key));\n", "    }\n", "\n", "    @Override\n", "    public List<V2> get(K key) {\n", "      return transform(key, fromMultimap.get(key));\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public List<V2> removeAll(Object key) {\n", "      return transform((K) key, fromMultimap.removeAll(key));\n", "    }\n", "\n", "    @Override\n", "    public List<V2> replaceValues(K key, Iterable<? extends V2> values) {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Creates an index {@code ImmutableListMultimap} that contains the results of\n", "   * applying a specified function to each item in an {@code Iterable} of\n", "   * values. Each value will be stored as a value in the resulting multimap,\n", "   * yielding a multimap with the same size as the input iterable. The key used\n", "   * to store that value in the multimap will be the result of calling the\n", "   * function on that value. The resulting multimap is created as an immutable\n", "   * snapshot. In the returned multimap, keys appear in the order they are first\n", "   * encountered, and the values corresponding to each key appear in the same\n", "   * order as they are encountered.\n", "   *\n", "   * <p>For example, <pre>   {@code\n", "   *\n", "   *   List<String> badGuys =\n", "   *       Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n", "   *   Function<String, Integer> stringLengthFunction = ...;\n", "   *   Multimap<Integer, String> index =\n", "   *       Multimaps.index(badGuys, stringLengthFunction);\n", "   *   System.out.println(index);}</pre>\n", "   *\n", "   * <p>prints <pre>   {@code\n", "   *\n", "   *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>\n", "   *\n", "   * <p>The returned multimap is serializable if its keys and values are all\n", "   * serializable.\n", "   *\n", "   * @param values the values to use when constructing the {@code\n", "   *     ImmutableListMultimap}\n", "   * @param keyFunction the function used to produce the key for each value\n", "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the\n", "   *     function {@code keyFunction} on each value in the input collection to\n", "   *     that value\n", "   * @throws NullPointerException if any of the following cases is true:\n", "   *     <ul>\n", "   *     <li>{@code values} is null\n", "   *     <li>{@code keyFunction} is null\n", "   *     <li>An element in {@code values} is null\n", "   *     <li>{@code keyFunction} returns {@code null} for any element of {@code\n", "   *         values}\n", "   *     </ul>\n", "   */\n", "  public static <K, V> ImmutableListMultimap<K, V> index(\n", "      Iterable<V> values, Function<? super V, K> keyFunction) {\n", "    return index(values.iterator(), keyFunction);\n", "  }\n", "\n", "  /**\n", "   * Creates an index {@code ImmutableListMultimap} that contains the results of\n", "   * applying a specified function to each item in an {@code Iterator} of\n", "   * values. Each value will be stored as a value in the resulting multimap,\n", "   * yielding a multimap with the same size as the input iterator. The key used\n", "   * to store that value in the multimap will be the result of calling the\n", "   * function on that value. The resulting multimap is created as an immutable\n", "   * snapshot. In the returned multimap, keys appear in the order they are first\n", "   * encountered, and the values corresponding to each key appear in the same\n", "   * order as they are encountered.\n", "   *\n", "   * <p>For example, <pre>   {@code\n", "   *\n", "   *   List<String> badGuys =\n", "   *       Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n", "   *   Function<String, Integer> stringLengthFunction = ...;\n", "   *   Multimap<Integer, String> index =\n", "   *       Multimaps.index(badGuys.iterator(), stringLengthFunction);\n", "   *   System.out.println(index);}</pre>\n", "   *\n", "   * <p>prints <pre>   {@code\n", "   *\n", "   *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>\n", "   *\n", "   * <p>The returned multimap is serializable if its keys and values are all\n", "   * serializable.\n", "   *\n", "   * @param values the values to use when constructing the {@code\n", "   *     ImmutableListMultimap}\n", "   * @param keyFunction the function used to produce the key for each value\n", "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the\n", "   *     function {@code keyFunction} on each value in the input collection to\n", "   *     that value\n", "   * @throws NullPointerException if any of the following cases is true:\n", "   *     <ul>\n", "   *     <li>{@code values} is null\n", "   *     <li>{@code keyFunction} is null\n", "   *     <li>An element in {@code values} is null\n", "   *     <li>{@code keyFunction} returns {@code null} for any element of {@code\n", "   *         values}\n", "   *     </ul>\n", "   * @since 10.0\n", "   */\n", "  public static <K, V> ImmutableListMultimap<K, V> index(\n", "      Iterator<V> values, Function<? super V, K> keyFunction) {\n", "    checkNotNull(keyFunction);\n", "    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n", "    while (values.hasNext()) {\n", "      V value = values.next();\n", "      checkNotNull(value, values);\n", "      builder.put(keyFunction.apply(value), value);\n", "    }\n", "    return builder.build();\n", "  }\n", "\n", "  static class Keys<K, V> extends AbstractMultiset<K> {\n", "    @Weak final Multimap<K, V> multimap;\n", "\n", "    Keys(Multimap<K, V> multimap) {\n", "      this.multimap = multimap;\n", "    }\n", "\n", "    @Override\n", "    Iterator<Multiset.Entry<K>> entryIterator() {\n", "      return new TransformedIterator<Map.Entry<K, Collection<V>>, Multiset.Entry<K>>(\n", "          multimap.asMap().entrySet().iterator()) {\n", "        @Override\n", "        Multiset.Entry<K> transform(final Map.Entry<K, Collection<V>> backingEntry) {\n", "          return new Multisets.AbstractEntry<K>() {\n", "            @Override\n", "            public K getElement() {\n", "              return backingEntry.getKey();\n", "            }\n", "\n", "            @Override\n", "            public int getCount() {\n", "              return backingEntry.getValue().size();\n", "            }\n", "          };\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    int distinctElements() {\n", "      return multimap.asMap().size();\n", "    }\n", "\n", "    @Override\n", "    Set<Multiset.Entry<K>> createEntrySet() {\n", "      return new KeysEntrySet();\n", "    }\n", "\n", "    @WeakOuter\n", "    class KeysEntrySet extends Multisets.EntrySet<K> {\n", "      @Override\n", "      Multiset<K> multiset() {\n", "        return Keys.this;\n", "      }\n", "\n", "      @Override\n", "      public Iterator<Multiset.Entry<K>> iterator() {\n", "        return entryIterator();\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return distinctElements();\n", "      }\n", "\n", "      @Override\n", "      public boolean isEmpty() {\n", "        return multimap.isEmpty();\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(@Nullable Object o) {\n", "        if (o instanceof Multiset.Entry) {\n", "          Multiset.Entry<?> entry = (Multiset.Entry<?>) o;\n", "          Collection<V> collection = multimap.asMap().get(entry.getElement());\n", "          return collection != null && collection.size() == entry.getCount();\n", "        }\n", "        return false;\n", "      }\n", "\n", "      @Override\n", "      public boolean remove(@Nullable Object o) {\n", "        if (o instanceof Multiset.Entry) {\n", "          Multiset.Entry<?> entry = (Multiset.Entry<?>) o;\n", "          Collection<V> collection = multimap.asMap().get(entry.getElement());\n", "          if (collection != null && collection.size() == entry.getCount()) {\n", "            collection.clear();\n", "            return true;\n", "          }\n", "        }\n", "        return false;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(@Nullable Object element) {\n", "      return multimap.containsKey(element);\n", "    }\n", "\n", "    @Override\n", "    public Iterator<K> iterator() {\n", "      return Maps.keyIterator(multimap.entries().iterator());\n", "    }\n", "\n", "    @Override\n", "    public int count(@Nullable Object element) {\n", "      Collection<V> values = Maps.safeGet(multimap.asMap(), element);\n", "      return (values == null) ? 0 : values.size();\n", "    }\n", "\n", "    @Override\n", "    public int remove(@Nullable Object element, int occurrences) {\n", "      checkNonnegative(occurrences, \"occurrences\");\n", "      if (occurrences == 0) {\n", "        return count(element);\n", "      }\n", "\n", "      Collection<V> values = Maps.safeGet(multimap.asMap(), element);\n", "\n", "      if (values == null) {\n", "        return 0;\n", "      }\n", "\n", "      int oldCount = values.size();\n", "      if (occurrences >= oldCount) {\n", "        values.clear();\n", "      } else {\n", "        Iterator<V> iterator = values.iterator();\n", "        for (int i = 0; i < occurrences; i++) {\n", "          iterator.next();\n", "          iterator.remove();\n", "        }\n", "      }\n", "      return oldCount;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      multimap.clear();\n", "    }\n", "\n", "    @Override\n", "    public Set<K> elementSet() {\n", "      return multimap.keySet();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * A skeleton implementation of {@link Multimap#entries()}.\n", "   */\n", "  abstract static class Entries<K, V> extends AbstractCollection<Map.Entry<K, V>> {\n", "    abstract Multimap<K, V> multimap();\n", "\n", "    @Override\n", "    public int size() {\n", "      return multimap().size();\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(@Nullable Object o) {\n", "      if (o instanceof Map.Entry) {\n", "        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n", "        return multimap().containsEntry(entry.getKey(), entry.getValue());\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(@Nullable Object o) {\n", "      if (o instanceof Map.Entry) {\n", "        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n", "        return multimap().remove(entry.getKey(), entry.getValue());\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      multimap().clear();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * A skeleton implementation of {@link Multimap#asMap()}.\n", "   */\n", "  static final class AsMap<K, V> extends Maps.ViewCachingAbstractMap<K, Collection<V>> {\n", "    @Weak private final Multimap<K, V> multimap;\n", "\n", "    AsMap(Multimap<K, V> multimap) {\n", "      this.multimap = checkNotNull(multimap);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return multimap.keySet().size();\n", "    }\n", "\n", "    @Override\n", "    protected Set<Entry<K, Collection<V>>> createEntrySet() {\n", "      return new EntrySet();\n", "    }\n", "\n", "    void removeValuesForKey(Object key) {\n", "      multimap.keySet().remove(key);\n", "    }\n", "\n", "    @WeakOuter\n", "    class EntrySet extends Maps.EntrySet<K, Collection<V>> {\n", "      @Override\n", "      Map<K, Collection<V>> map() {\n", "        return AsMap.this;\n", "      }\n", "\n", "      @Override\n", "      public Iterator<Entry<K, Collection<V>>> iterator() {\n", "        return Maps.asMapEntryIterator(\n", "            multimap.keySet(),\n", "            new Function<K, Collection<V>>() {\n", "              @Override\n", "              public Collection<V> apply(K key) {\n", "                return multimap.get(key);\n", "              }\n", "            });\n", "      }\n", "\n", "      @Override\n", "      public boolean remove(Object o) {\n", "        if (!contains(o)) {\n", "          return false;\n", "        }\n", "        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n", "        removeValuesForKey(entry.getKey());\n", "        return true;\n", "      }\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public Collection<V> get(Object key) {\n", "      return containsKey(key) ? multimap.get((K) key) : null;\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> remove(Object key) {\n", "      return containsKey(key) ? multimap.removeAll(key) : null;\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      return multimap.keySet();\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return multimap.isEmpty();\n", "    }\n", "\n", "    @Override\n", "    public boolean containsKey(Object key) {\n", "      return multimap.containsKey(key);\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      multimap.clear();\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n", "   * satisfy a predicate. The returned multimap is a live view of\n", "   * {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting multimap's views have iterators that don't support\n", "   * {@code remove()}, but all other methods are supported by the multimap and\n", "   * its views. When adding a key that doesn't satisfy the predicate, the\n", "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n", "   * the filtered multimap or its views, only mappings whose keys satisfy the\n", "   * filter will be removed from the underlying multimap.\n", "   *\n", "   * <p>The returned multimap isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n", "   * across every key/value mapping in the underlying multimap and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered multimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n", "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n", "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n", "   * with equals.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> Multimap<K, V> filterKeys(\n", "      Multimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n", "    if (unfiltered instanceof SetMultimap) {\n", "      return filterKeys((SetMultimap<K, V>) unfiltered, keyPredicate);\n", "    } else if (unfiltered instanceof ListMultimap) {\n", "      return filterKeys((ListMultimap<K, V>) unfiltered, keyPredicate);\n", "    } else if (unfiltered instanceof FilteredKeyMultimap) {\n", "      FilteredKeyMultimap<K, V> prev = (FilteredKeyMultimap<K, V>) unfiltered;\n", "      return new FilteredKeyMultimap<K, V>(\n", "          prev.unfiltered, Predicates.and(prev.keyPredicate, keyPredicate));\n", "    } else if (unfiltered instanceof FilteredMultimap) {\n", "      FilteredMultimap<K, V> prev = (FilteredMultimap<K, V>) unfiltered;\n", "      return filterFiltered(prev, Maps.<K>keyPredicateOnEntries(keyPredicate));\n", "    } else {\n", "      return new FilteredKeyMultimap<K, V>(unfiltered, keyPredicate);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n", "   * satisfy a predicate. The returned multimap is a live view of\n", "   * {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting multimap's views have iterators that don't support\n", "   * {@code remove()}, but all other methods are supported by the multimap and\n", "   * its views. When adding a key that doesn't satisfy the predicate, the\n", "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n", "   * the filtered multimap or its views, only mappings whose keys satisfy the\n", "   * filter will be removed from the underlying multimap.\n", "   *\n", "   * <p>The returned multimap isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n", "   * across every key/value mapping in the underlying multimap and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered multimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n", "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n", "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n", "   * with equals.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> SetMultimap<K, V> filterKeys(\n", "      SetMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n", "    if (unfiltered instanceof FilteredKeySetMultimap) {\n", "      FilteredKeySetMultimap<K, V> prev = (FilteredKeySetMultimap<K, V>) unfiltered;\n", "      return new FilteredKeySetMultimap<K, V>(\n", "          prev.unfiltered(), Predicates.and(prev.keyPredicate, keyPredicate));\n", "    } else if (unfiltered instanceof FilteredSetMultimap) {\n", "      FilteredSetMultimap<K, V> prev = (FilteredSetMultimap<K, V>) unfiltered;\n", "      return filterFiltered(prev, Maps.<K>keyPredicateOnEntries(keyPredicate));\n", "    } else {\n", "      return new FilteredKeySetMultimap<K, V>(unfiltered, keyPredicate);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n", "   * satisfy a predicate. The returned multimap is a live view of\n", "   * {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting multimap's views have iterators that don't support\n", "   * {@code remove()}, but all other methods are supported by the multimap and\n", "   * its views. When adding a key that doesn't satisfy the predicate, the\n", "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n", "   * the filtered multimap or its views, only mappings whose keys satisfy the\n", "   * filter will be removed from the underlying multimap.\n", "   *\n", "   * <p>The returned multimap isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n", "   * across every key/value mapping in the underlying multimap and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered multimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n", "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n", "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n", "   * with equals.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> ListMultimap<K, V> filterKeys(\n", "      ListMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n", "    if (unfiltered instanceof FilteredKeyListMultimap) {\n", "      FilteredKeyListMultimap<K, V> prev = (FilteredKeyListMultimap<K, V>) unfiltered;\n", "      return new FilteredKeyListMultimap<K, V>(\n", "          prev.unfiltered(), Predicates.and(prev.keyPredicate, keyPredicate));\n", "    } else {\n", "      return new FilteredKeyListMultimap<K, V>(unfiltered, keyPredicate);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a multimap containing the mappings in {@code unfiltered} whose values\n", "   * satisfy a predicate. The returned multimap is a live view of\n", "   * {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting multimap's views have iterators that don't support\n", "   * {@code remove()}, but all other methods are supported by the multimap and\n", "   * its views. When adding a value that doesn't satisfy the predicate, the\n", "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n", "   * the filtered multimap or its views, only mappings whose value satisfy the\n", "   * filter will be removed from the underlying multimap.\n", "   *\n", "   * <p>The returned multimap isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n", "   * across every key/value mapping in the underlying multimap and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered multimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n", "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n", "   * inconsistent with equals.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> Multimap<K, V> filterValues(\n", "      Multimap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n", "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n", "  }\n", "\n", "  /**\n", "   * Returns a multimap containing the mappings in {@code unfiltered} whose values\n", "   * satisfy a predicate. The returned multimap is a live view of\n", "   * {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting multimap's views have iterators that don't support\n", "   * {@code remove()}, but all other methods are supported by the multimap and\n", "   * its views. When adding a value that doesn't satisfy the predicate, the\n", "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n", "   * the filtered multimap or its views, only mappings whose value satisfy the\n", "   * filter will be removed from the underlying multimap.\n", "   *\n", "   * <p>The returned multimap isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n", "   * across every key/value mapping in the underlying multimap and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered multimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n", "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n", "   * inconsistent with equals.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> SetMultimap<K, V> filterValues(\n", "      SetMultimap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n", "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n", "  }\n", "\n", "  /**\n", "   * Returns a multimap containing the mappings in {@code unfiltered} that\n", "   * satisfy a predicate. The returned multimap is a live view of\n", "   * {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting multimap's views have iterators that don't support\n", "   * {@code remove()}, but all other methods are supported by the multimap and\n", "   * its views. When adding a key/value pair that doesn't satisfy the predicate,\n", "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n", "   * the filtered multimap or its views, only mappings whose keys satisfy the\n", "   * filter will be removed from the underlying multimap.\n", "   *\n", "   * <p>The returned multimap isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n", "   * across every key/value mapping in the underlying multimap and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered multimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}.\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> Multimap<K, V> filterEntries(\n", "      Multimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    checkNotNull(entryPredicate);\n", "    if (unfiltered instanceof SetMultimap) {\n", "      return filterEntries((SetMultimap<K, V>) unfiltered, entryPredicate);\n", "    }\n", "    return (unfiltered instanceof FilteredMultimap)\n", "        ? filterFiltered((FilteredMultimap<K, V>) unfiltered, entryPredicate)\n", "        : new FilteredEntryMultimap<K, V>(checkNotNull(unfiltered), entryPredicate);\n", "  }\n", "\n", "  /**\n", "   * Returns a multimap containing the mappings in {@code unfiltered} that\n", "   * satisfy a predicate. The returned multimap is a live view of\n", "   * {@code unfiltered}; changes to one affect the other.\n", "   *\n", "   * <p>The resulting multimap's views have iterators that don't support\n", "   * {@code remove()}, but all other methods are supported by the multimap and\n", "   * its views. When adding a key/value pair that doesn't satisfy the predicate,\n", "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n", "   * methods throw an {@link IllegalArgumentException}.\n", "   *\n", "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n", "   * the filtered multimap or its views, only mappings whose keys satisfy the\n", "   * filter will be removed from the underlying multimap.\n", "   *\n", "   * <p>The returned multimap isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n", "   * across every key/value mapping in the underlying multimap and determine\n", "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n", "   * faster to copy the filtered multimap and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n", "   * equals</i>, as documented at {@link Predicate#apply}.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <K, V> SetMultimap<K, V> filterEntries(\n", "      SetMultimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    checkNotNull(entryPredicate);\n", "    return (unfiltered instanceof FilteredSetMultimap)\n", "        ? filterFiltered((FilteredSetMultimap<K, V>) unfiltered, entryPredicate)\n", "        : new FilteredEntrySetMultimap<K, V>(checkNotNull(unfiltered), entryPredicate);\n", "  }\n", "\n", "  /**\n", "   * Support removal operations when filtering a filtered multimap. Since a\n", "   * filtered multimap has iterators that don't support remove, passing one to\n", "   * the FilteredEntryMultimap constructor would lead to a multimap whose removal\n", "   * operations would fail. This method combines the predicates to avoid that\n", "   * problem.\n", "   */\n", "  private static <K, V> Multimap<K, V> filterFiltered(\n", "      FilteredMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    Predicate<Entry<K, V>> predicate = Predicates.and(multimap.entryPredicate(), entryPredicate);\n", "    return new FilteredEntryMultimap<K, V>(multimap.unfiltered(), predicate);\n", "  }\n", "\n", "  /**\n", "   * Support removal operations when filtering a filtered multimap. Since a filtered multimap has\n", "   * iterators that don't support remove, passing one to the FilteredEntryMultimap constructor would\n", "   * lead to a multimap whose removal operations would fail. This method combines the predicates to\n", "   * avoid that problem.\n", "   */\n", "  private static <K, V> SetMultimap<K, V> filterFiltered(\n", "      FilteredSetMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate) {\n", "    Predicate<Entry<K, V>> predicate = Predicates.and(multimap.entryPredicate(), entryPredicate);\n", "    return new FilteredEntrySetMultimap<K, V>(multimap.unfiltered(), predicate);\n", "  }\n", "\n", "  static boolean equalsImpl(Multimap<?, ?> multimap, @Nullable Object object) {\n", "    if (object == multimap) {\n", "      return true;\n", "    }\n", "    if (object instanceof Multimap) {\n", "      Multimap<?, ?> that = (Multimap<?, ?>) object;\n", "      return multimap.asMap().equals(that.asMap());\n", "    }\n", "    return false;\n", "  }\n", "\n", "  // TODO(jlevy): Create methods that filter a SortedSetMultimap.\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050]}}, {"40": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ObjectArrays.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkPositionIndexes;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.Collection;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to object arrays.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class ObjectArrays {\n", "  static final Object[] EMPTY_ARRAY = new Object[0];\n", "\n", "  private ObjectArrays() {}\n", "\n", "  /**\n", "   * Returns a new array of the given length with the same type as a reference\n", "   * array.\n", "   *\n", "   * @param reference any array of the desired type\n", "   * @param length the length of the new array\n", "   */\n", "  public static <T> T[] newArray(T[] reference, int length) {\n", "    return Platform.newArray(reference, length);\n", "  }\n", "\n", "  /**\n", "   * Returns a new array that prepends {@code element} to {@code array}.\n", "   *\n", "   * @param element the element to prepend to the front of {@code array}\n", "   * @param array the array of elements to append\n", "   * @return an array whose size is one larger than {@code array}, with\n", "   *     {@code element} occupying the first position, and the\n", "   *     elements of {@code array} occupying the remaining elements.\n", "   */\n", "  public static <T> T[] concat(@Nullable T element, T[] array) {\n", "    T[] result = newArray(array, array.length + 1);\n", "    result[0] = element;\n", "    System.arraycopy(array, 0, result, 1, array.length);\n", "    return result;\n", "  }\n", "\n", "  /**\n", "   * Returns a new array that appends {@code element} to {@code array}.\n", "   *\n", "   * @param array the array of elements to prepend\n", "   * @param element the element to append to the end\n", "   * @return an array whose size is one larger than {@code array}, with\n", "   *     the same contents as {@code array}, plus {@code element} occupying the\n", "   *     last position.\n", "   */\n", "  public static <T> T[] concat(T[] array, @Nullable T element) {\n", "    T[] result = arraysCopyOf(array, array.length + 1);\n", "    result[array.length] = element;\n", "    return result;\n", "  }\n", "\n", "  /** GWT safe version of Arrays.copyOf. */\n", "  static <T> T[] arraysCopyOf(T[] original, int newLength) {\n", "    T[] copy = newArray(original, newLength);\n", "    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing all of the elements in the specified\n", "   * collection; the runtime type of the returned array is that of the specified\n", "   * array. If the collection fits in the specified array, it is returned\n", "   * therein. Otherwise, a new array is allocated with the runtime type of the\n", "   * specified array and the size of the specified collection.\n", "   *\n", "   * <p>If the collection fits in the specified array with room to spare (i.e.,\n", "   * the array has more elements than the collection), the element in the array\n", "   * immediately following the end of the collection is set to {@code null}.\n", "   * This is useful in determining the length of the collection <i>only</i> if\n", "   * the caller knows that the collection does not contain any null elements.\n", "   *\n", "   * <p>This method returns the elements in the order they are returned by the\n", "   * collection's iterator.\n", "   *\n", "   * <p>TODO(kevinb): support concurrently modified collections?\n", "   *\n", "   * @param c the collection for which to return an array of elements\n", "   * @param array the array in which to place the collection elements\n", "   * @throws ArrayStoreException if the runtime type of the specified array is\n", "   *     not a supertype of the runtime type of every element in the specified\n", "   *     collection\n", "   */\n", "  static <T> T[] toArrayImpl(Collection<?> c, T[] array) {\n", "    int size = c.size();\n", "    if (array.length < size) {\n", "      array = newArray(array, size);\n", "    }\n", "    fillArray(c, array);\n", "    if (array.length > size) {\n", "      array[size] = null;\n", "    }\n", "    return array;\n", "  }\n", "\n", "  /**\n", "   * Implementation of {@link Collection#toArray(Object[])} for collections backed by an object\n", "   * array. the runtime type of the returned array is that of the specified array. If the collection\n", "   * fits in the specified array, it is returned therein. Otherwise, a new array is allocated with\n", "   * the runtime type of the specified array and the size of the specified collection.\n", "   *\n", "   * <p>If the collection fits in the specified array with room to spare (i.e., the array has more\n", "   * elements than the collection), the element in the array immediately following the end of the\n", "   * collection is set to {@code null}. This is useful in determining the length of the collection\n", "   * <i>only</i> if the caller knows that the collection does not contain any null elements.\n", "   */\n", "  static <T> T[] toArrayImpl(Object[] src, int offset, int len, T[] dst) {\n", "    checkPositionIndexes(offset, offset + len, src.length);\n", "    if (dst.length < len) {\n", "      dst = newArray(dst, len);\n", "    } else if (dst.length > len) {\n", "      dst[len] = null;\n", "    }\n", "    System.arraycopy(src, offset, dst, 0, len);\n", "    return dst;\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing all of the elements in the specified\n", "   * collection. This method returns the elements in the order they are returned\n", "   * by the collection's iterator. The returned array is \"safe\" in that no\n", "   * references to it are maintained by the collection. The caller is thus free\n", "   * to modify the returned array.\n", "   *\n", "   * <p>This method assumes that the collection size doesn't change while the\n", "   * method is running.\n", "   *\n", "   * <p>TODO(kevinb): support concurrently modified collections?\n", "   *\n", "   * @param c the collection for which to return an array of elements\n", "   */\n", "  static Object[] toArrayImpl(Collection<?> c) {\n", "    return fillArray(c, new Object[c.size()]);\n", "  }\n", "\n", "  /**\n", "   * Returns a copy of the specified subrange of the specified array that is literally an Object[],\n", "   * and not e.g. a {@code String[]}.\n", "   */\n", "  static Object[] copyAsObjectArray(Object[] elements, int offset, int length) {\n", "    checkPositionIndexes(offset, offset + length, elements.length);\n", "    if (length == 0) {\n", "      return EMPTY_ARRAY;\n", "    }\n", "    Object[] result = new Object[length];\n", "    System.arraycopy(elements, offset, result, 0, length);\n", "    return result;\n", "  }\n", "\n", "  private static Object[] fillArray(Iterable<?> elements, Object[] array) {\n", "    int i = 0;\n", "    for (Object element : elements) {\n", "      array[i++] = element;\n", "    }\n", "    return array;\n", "  }\n", "\n", "  /**\n", "   * Swaps {@code array[i]} with {@code array[j]}.\n", "   */\n", "  static void swap(Object[] array, int i, int j) {\n", "    Object temp = array[i];\n", "    array[i] = array[j];\n", "    array[j] = temp;\n", "  }\n", "\n", "  static Object[] checkElementsNotNull(Object... array) {\n", "    return checkElementsNotNull(array, array.length);\n", "  }\n", "\n", "  static Object[] checkElementsNotNull(Object[] array, int length) {\n", "    for (int i = 0; i < length; i++) {\n", "      checkElementNotNull(array[i], i);\n", "    }\n", "    return array;\n", "  }\n", "\n", "  // We do this instead of Preconditions.checkNotNull to save boxing and array\n", "  // creation cost.\n", "  static Object checkElementNotNull(Object element, int index) {\n", "    if (element == null) {\n", "      throw new NullPointerException(\"at index \" + index);\n", "    }\n", "    return element;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215]}}, {"41": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/RegularContiguousSet.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.BoundType.CLOSED;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.Collection;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * An implementation of {@link ContiguousSet} that contains one or more elements.\n", " *\n", " * @author Gregory Kick\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"unchecked\") // allow ungenerified Comparable types\n", "final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C> {\n", "  private final Range<C> range;\n", "\n", "  RegularContiguousSet(Range<C> range, DiscreteDomain<C> domain) {\n", "    super(domain);\n", "    this.range = range;\n", "  }\n", "\n", "  private ContiguousSet<C> intersectionInCurrentDomain(Range<C> other) {\n", "    return (range.isConnected(other))\n", "        ? ContiguousSet.create(range.intersection(other), domain)\n", "        : new EmptyContiguousSet<C>(domain);\n", "  }\n", "\n", "  @Override\n", "  ContiguousSet<C> headSetImpl(C toElement, boolean inclusive) {\n", "    return intersectionInCurrentDomain(Range.upTo(toElement, BoundType.forBoolean(inclusive)));\n", "  }\n", "\n", "  @Override\n", "  ContiguousSet<C> subSetImpl(\n", "      C fromElement, boolean fromInclusive, C toElement, boolean toInclusive) {\n", "    if (fromElement.compareTo(toElement) == 0 && !fromInclusive && !toInclusive) {\n", "      // Range would reject our attempt to create (x, x).\n", "      return new EmptyContiguousSet<C>(domain);\n", "    }\n", "    return intersectionInCurrentDomain(\n", "        Range.range(\n", "            fromElement, BoundType.forBoolean(fromInclusive),\n", "            toElement, BoundType.forBoolean(toInclusive)));\n", "  }\n", "\n", "  @Override\n", "  ContiguousSet<C> tailSetImpl(C fromElement, boolean inclusive) {\n", "    return intersectionInCurrentDomain(Range.downTo(fromElement, BoundType.forBoolean(inclusive)));\n", "  }\n", "\n", "  @Override\n", "  public UnmodifiableIterator<C> iterator() {\n", "    return new AbstractSequentialIterator<C>(first()) {\n", "      final C last = last();\n", "\n", "      @Override\n", "      protected C computeNext(C previous) {\n", "        return equalsOrThrow(previous, last) ? null : domain.next(previous);\n", "      }\n", "    };\n", "  }\n", "\n", "  private static boolean equalsOrThrow(Comparable<?> left, @Nullable Comparable<?> right) {\n", "    return right != null && Range.compareOrThrow(left, right) == 0;\n", "  }\n", "\n", "  @Override\n", "  boolean isPartialView() {\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public C first() {\n", "    return range.lowerBound.leastValueAbove(domain);\n", "  }\n", "\n", "  @Override\n", "  public C last() {\n", "    return range.upperBound.greatestValueBelow(domain);\n", "  }\n", "\n", "  @Override\n", "  public int size() {\n", "    long distance = domain.distance(first(), last());\n", "    return (distance >= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) distance + 1;\n", "  }\n", "\n", "  @Override\n", "  public boolean contains(@Nullable Object object) {\n", "    if (object == null) {\n", "      return false;\n", "    }\n", "    try {\n", "      return range.contains((C) object);\n", "    } catch (ClassCastException e) {\n", "      return false;\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public boolean containsAll(Collection<?> targets) {\n", "    return Collections2.containsAllImpl(this, targets);\n", "  }\n", "\n", "  @Override\n", "  public boolean isEmpty() {\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public ContiguousSet<C> intersection(ContiguousSet<C> other) {\n", "    checkNotNull(other);\n", "    checkArgument(this.domain.equals(other.domain));\n", "    if (other.isEmpty()) {\n", "      return other;\n", "    } else {\n", "      C lowerEndpoint = Ordering.natural().max(this.first(), other.first());\n", "      C upperEndpoint = Ordering.natural().min(this.last(), other.last());\n", "      return (lowerEndpoint.compareTo(upperEndpoint) < 0)\n", "          ? ContiguousSet.create(Range.closed(lowerEndpoint, upperEndpoint), domain)\n", "          : new EmptyContiguousSet<C>(domain);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public Range<C> range() {\n", "    return range(CLOSED, CLOSED);\n", "  }\n", "\n", "  @Override\n", "  public Range<C> range(BoundType lowerBoundType, BoundType upperBoundType) {\n", "    return Range.create(\n", "        range.lowerBound.withLowerBoundType(lowerBoundType, domain),\n", "        range.upperBound.withUpperBoundType(upperBoundType, domain));\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object object) {\n", "    if (object == this) {\n", "      return true;\n", "    } else if (object instanceof RegularContiguousSet) {\n", "      RegularContiguousSet<?> that = (RegularContiguousSet<?>) object;\n", "      if (this.domain.equals(that.domain)) {\n", "        return this.first().equals(that.first()) && this.last().equals(that.last());\n", "      }\n", "    }\n", "    return super.equals(object);\n", "  }\n", "\n", "  // copied to make sure not to use the GWT-emulated version\n", "  @Override\n", "  public int hashCode() {\n", "    return Sets.hashCodeImpl(this);\n", "  }\n", "\n", "  private static final long serialVersionUID = 0;\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178]}}, {"42": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/RegularImmutableAsList.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.j2objc.annotations.Weak;\n", "\n", "/**\n", " * An {@link ImmutableAsList} implementation specialized for when the delegate collection is\n", " * already backed by an {@code ImmutableList} or array.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"serial\") // uses writeReplace, not default serialization\n", "class RegularImmutableAsList<E> extends ImmutableAsList<E> {\n", "  @Weak private final ImmutableCollection<E> delegate;\n", "  private final ImmutableList<? extends E> delegateList;\n", "\n", "  RegularImmutableAsList(ImmutableCollection<E> delegate, ImmutableList<? extends E> delegateList) {\n", "    this.delegate = delegate;\n", "    this.delegateList = delegateList;\n", "  }\n", "\n", "  RegularImmutableAsList(ImmutableCollection<E> delegate, Object[] array) {\n", "    this(delegate, ImmutableList.<E>asImmutableList(array));\n", "  }\n", "\n", "  @Override\n", "  ImmutableCollection<E> delegateCollection() {\n", "    return delegate;\n", "  }\n", "\n", "  ImmutableList<? extends E> delegateList() {\n", "    return delegateList;\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // safe covariant cast!\n", "  @Override\n", "  public UnmodifiableListIterator<E> listIterator(int index) {\n", "    return (UnmodifiableListIterator<E>) delegateList.listIterator(index);\n", "  }\n", "\n", "  @Override\n", "  public E get(int index) {\n", "    return delegateList.get(index);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]}}, {"43": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Sets.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Predicate;\n", "import com.google.common.base.Predicates;\n", "import com.google.common.collect.Collections2.FilteredCollection;\n", "\n", "import java.util.AbstractSet;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.EnumSet;\n", "import java.util.HashSet;\n", "import java.util.Iterator;\n", "import java.util.LinkedHashSet;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.NoSuchElementException;\n", "import java.util.Set;\n", "import java.util.SortedSet;\n", "import java.util.TreeSet;\n", "import java.util.concurrent.ConcurrentHashMap;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to {@link Set} instances. Also see this\n", " * class's counterparts {@link Lists}, {@link Maps} and {@link Queues}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets\">\n", " * {@code Sets}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " * @author Chris Povirk\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Sets {\n", "  private Sets() {}\n", "\n", "  /**\n", "   * {@link AbstractSet} substitute without the potentially-quadratic\n", "   * {@code removeAll} implementation.\n", "   */\n", "  abstract static class ImprovedAbstractSet<E> extends AbstractSet<E> {\n", "    @Override\n", "    public boolean removeAll(Collection<?> c) {\n", "      return removeAllImpl(this, c);\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> c) {\n", "      return super.retainAll(checkNotNull(c)); // GWT compatibility\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable set instance containing the given enum elements.\n", "   * Internally, the returned set will be backed by an {@link EnumSet}.\n", "   *\n", "   * <p>The iteration order of the returned set follows the enum's iteration\n", "   * order, not the order in which the elements are provided to the method.\n", "   *\n", "   * @param anElement one of the elements the set should contain\n", "   * @param otherElements the rest of the elements the set should contain\n", "   * @return an immutable set containing those elements, minus duplicates\n", "   */\n", "  // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028\n", "  @GwtCompatible(serializable = true)\n", "  public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(\n", "      E anElement, E... otherElements) {\n", "    return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));\n", "  }\n", "\n", "  /**\n", "   * Returns an immutable set instance containing the given enum elements.\n", "   * Internally, the returned set will be backed by an {@link EnumSet}.\n", "   *\n", "   * <p>The iteration order of the returned set follows the enum's iteration\n", "   * order, not the order in which the elements appear in the given collection.\n", "   *\n", "   * @param elements the elements, all of the same {@code enum} type, that the\n", "   *     set should contain\n", "   * @return an immutable set containing those elements, minus duplicates\n", "   */\n", "  // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028\n", "  @GwtCompatible(serializable = true)\n", "  public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(Iterable<E> elements) {\n", "    if (elements instanceof ImmutableEnumSet) {\n", "      return (ImmutableEnumSet<E>) elements;\n", "    } else if (elements instanceof Collection) {\n", "      Collection<E> collection = (Collection<E>) elements;\n", "      if (collection.isEmpty()) {\n", "        return ImmutableSet.of();\n", "      } else {\n", "        return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));\n", "      }\n", "    } else {\n", "      Iterator<E> itr = elements.iterator();\n", "      if (itr.hasNext()) {\n", "        EnumSet<E> enumSet = EnumSet.of(itr.next());\n", "        Iterators.addAll(enumSet, itr);\n", "        return ImmutableEnumSet.asImmutable(enumSet);\n", "      } else {\n", "        return ImmutableSet.of();\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a new, <i>mutable</i> {@code EnumSet} instance containing the given elements in their\n", "   * natural order. This method behaves identically to {@link EnumSet#copyOf(Collection)}, but also\n", "   * accepts non-{@code Collection} iterables and empty iterables.\n", "   */\n", "  public static <E extends Enum<E>> EnumSet<E> newEnumSet(\n", "      Iterable<E> iterable, Class<E> elementType) {\n", "    EnumSet<E> set = EnumSet.noneOf(elementType);\n", "    Iterables.addAll(set, iterable);\n", "    return set;\n", "  }\n", "\n", "  // HashSet\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, initially empty {@code HashSet} instance.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If\n", "   * {@code E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly\n", "   * consider using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to\n", "   * get deterministic iteration behavior.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n", "   * deprecated. Instead, use the {@code HashSet} constructor directly, taking advantage of the new\n", "   * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n", "   */\n", "  public static <E> HashSet<E> newHashSet() {\n", "    return new HashSet<E>();\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code HashSet} instance initially containing the given elements.\n", "   *\n", "   * <p><b>Note:</b> if elements are non-null and won't be added or removed after this point, use\n", "   * {@link ImmutableSet#of()} or {@link ImmutableSet#copyOf(Object[])} instead. If {@code E} is an\n", "   * {@link Enum} type, use {@link EnumSet#of(Enum, Enum[])} instead. Otherwise, strongly consider\n", "   * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get\n", "   * deterministic iteration behavior.\n", "   *\n", "   * <p>This method is just a small convenience, either for {@code newHashSet(}{@link Arrays#asList\n", "   * asList}{@code (...))}, or for creating an empty set then calling {@link Collections#addAll}.\n", "   * This method is not actually very useful and will likely be deprecated in the future.\n", "   */\n", "  public static <E> HashSet<E> newHashSet(E... elements) {\n", "    HashSet<E> set = newHashSetWithExpectedSize(elements.length);\n", "    Collections.addAll(set, elements);\n", "    return set;\n", "  }\n", "\n", "  /**\n", "   * Creates a {@code HashSet} instance, with a high enough initial table size that it <i>should</i>\n", "   * hold {@code expectedSize} elements without resizing. This behavior cannot be broadly\n", "   * guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the\n", "   * method isn't inadvertently <i>oversizing</i> the returned set.\n", "   *\n", "   * @param expectedSize the number of elements you expect to add to the\n", "   *        returned set\n", "   * @return a new, empty {@code HashSet} with enough capacity to hold {@code\n", "   *         expectedSize} elements without resizing\n", "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n", "   */\n", "  public static <E> HashSet<E> newHashSetWithExpectedSize(int expectedSize) {\n", "    return new HashSet<E>(Maps.capacity(expectedSize));\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin\n", "   * convenience for creating an empty set then calling {@link Collection#addAll} or {@link\n", "   * Iterables#addAll}.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n", "   * ImmutableSet#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link\n", "   * FluentIterable} and call {@code elements.toSet()}.)\n", "   *\n", "   * <p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link #newEnumSet(Iterable, Class)}\n", "   * instead.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link Collection}, you don't\n", "   * need this method. Instead, use the {@code HashSet} constructor directly, taking advantage of\n", "   * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n", "   *\n", "   * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n", "   */\n", "  public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements) {\n", "    return (elements instanceof Collection)\n", "        ? new HashSet<E>(Collections2.cast(elements))\n", "        : newHashSet(elements.iterator());\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin\n", "   * convenience for creating an empty set and then calling {@link Iterators#addAll}.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n", "   * ImmutableSet#copyOf(Iterator)} instead.\n", "   *\n", "   * <p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an {@link EnumSet}\n", "   * instead.\n", "   *\n", "   * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n", "   */\n", "  public static <E> HashSet<E> newHashSet(Iterator<? extends E> elements) {\n", "    HashSet<E> set = newHashSet();\n", "    Iterators.addAll(set, elements);\n", "    return set;\n", "  }\n", "\n", "  /**\n", "   * Creates a thread-safe set backed by a hash map. The set is backed by a\n", "   * {@link ConcurrentHashMap} instance, and thus carries the same concurrency\n", "   * guarantees.\n", "   *\n", "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be\n", "   * used as an element. The set is serializable.\n", "   *\n", "   * @return a new, empty thread-safe {@code Set}\n", "   * @since 15.0\n", "   */\n", "  public static <E> Set<E> newConcurrentHashSet() {\n", "    return newSetFromMap(new ConcurrentHashMap<E, Boolean>());\n", "  }\n", "\n", "  /**\n", "   * Creates a thread-safe set backed by a hash map and containing the given\n", "   * elements. The set is backed by a {@link ConcurrentHashMap} instance, and\n", "   * thus carries the same concurrency guarantees.\n", "   *\n", "   * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be\n", "   * used as an element. The set is serializable.\n", "   *\n", "   * @param elements the elements that the set should contain\n", "   * @return a new thread-safe set containing those elements (minus duplicates)\n", "   * @throws NullPointerException if {@code elements} or any of its contents is\n", "   *      null\n", "   * @since 15.0\n", "   */\n", "  public static <E> Set<E> newConcurrentHashSet(Iterable<? extends E> elements) {\n", "    Set<E> set = newConcurrentHashSet();\n", "    Iterables.addAll(set, elements);\n", "    return set;\n", "  }\n", "\n", "  // LinkedHashSet\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty {@code LinkedHashSet} instance.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableSet#of()} instead.\n", "   *\n", "   * @return a new, empty {@code LinkedHashSet}\n", "   */\n", "  public static <E> LinkedHashSet<E> newLinkedHashSet() {\n", "    return new LinkedHashSet<E>();\n", "  }\n", "\n", "  /**\n", "   * Creates a {@code LinkedHashSet} instance, with a high enough \"initial\n", "   * capacity\" that it <i>should</i> hold {@code expectedSize} elements without\n", "   * growth. This behavior cannot be broadly guaranteed, but it is observed to\n", "   * be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't\n", "   * inadvertently <i>oversizing</i> the returned set.\n", "   *\n", "   * @param expectedSize the number of elements you expect to add to the\n", "   *        returned set\n", "   * @return a new, empty {@code LinkedHashSet} with enough capacity to hold\n", "   *         {@code expectedSize} elements without resizing\n", "   * @throws IllegalArgumentException if {@code expectedSize} is negative\n", "   * @since 11.0\n", "   */\n", "  public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {\n", "    return new LinkedHashSet<E>(Maps.capacity(expectedSize));\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code LinkedHashSet} instance containing the\n", "   * given elements in order.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required and the elements are\n", "   * non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.\n", "   *\n", "   * @param elements the elements that the set should contain, in order\n", "   * @return a new {@code LinkedHashSet} containing those elements (minus\n", "   *     duplicates)\n", "   */\n", "  public static <E> LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements) {\n", "    if (elements instanceof Collection) {\n", "      return new LinkedHashSet<E>(Collections2.cast(elements));\n", "    }\n", "    LinkedHashSet<E> set = newLinkedHashSet();\n", "    Iterables.addAll(set, elements);\n", "    return set;\n", "  }\n", "\n", "  // TreeSet\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty {@code TreeSet} instance sorted by the\n", "   * natural sort ordering of its elements.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableSortedSet#of()} instead.\n", "   *\n", "   * @return a new, empty {@code TreeSet}\n", "   */\n", "  public static <E extends Comparable> TreeSet<E> newTreeSet() {\n", "    return new TreeSet<E>();\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i> {@code TreeSet} instance containing the given\n", "   * elements sorted by their natural ordering.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@link\n", "   * ImmutableSortedSet#copyOf(Iterable)} instead.\n", "   *\n", "   * <p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit\n", "   * comparator, this method has different behavior than\n", "   * {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code TreeSet} with\n", "   * that comparator.\n", "   *\n", "   * @param elements the elements that the set should contain\n", "   * @return a new {@code TreeSet} containing those elements (minus duplicates)\n", "   */\n", "  public static <E extends Comparable> TreeSet<E> newTreeSet(Iterable<? extends E> elements) {\n", "    TreeSet<E> set = newTreeSet();\n", "    Iterables.addAll(set, elements);\n", "    return set;\n", "  }\n", "\n", "  /**\n", "   * Creates a <i>mutable</i>, empty {@code TreeSet} instance with the given\n", "   * comparator.\n", "   *\n", "   * <p><b>Note:</b> if mutability is not required, use {@code\n", "   * ImmutableSortedSet.orderedBy(comparator).build()} instead.\n", "   *\n", "   * @param comparator the comparator to use to sort the set\n", "   * @return a new, empty {@code TreeSet}\n", "   * @throws NullPointerException if {@code comparator} is null\n", "   */\n", "  public static <E> TreeSet<E> newTreeSet(Comparator<? super E> comparator) {\n", "    return new TreeSet<E>(checkNotNull(comparator));\n", "  }\n", "\n", "  /**\n", "   * Creates an empty {@code Set} that uses identity to determine equality. It\n", "   * compares object references, instead of calling {@code equals}, to\n", "   * determine whether a provided object matches an element in the set. For\n", "   * example, {@code contains} returns {@code false} when passed an object that\n", "   * equals a set member, but isn't the same instance. This behavior is similar\n", "   * to the way {@code IdentityHashMap} handles key lookups.\n", "   *\n", "   * @since 8.0\n", "   */\n", "  public static <E> Set<E> newIdentityHashSet() {\n", "    return Sets.newSetFromMap(Maps.<E, Boolean>newIdentityHashMap());\n", "  }\n", "\n", "  /**\n", "   * Creates an {@code EnumSet} consisting of all enum values that are not in\n", "   * the specified collection. If the collection is an {@link EnumSet}, this\n", "   * method has the same behavior as {@link EnumSet#complementOf}. Otherwise,\n", "   * the specified collection must contain at least one element, in order to\n", "   * determine the element type. If the collection could be empty, use\n", "   * {@link #complementOf(Collection, Class)} instead of this method.\n", "   *\n", "   * @param collection the collection whose complement should be stored in the\n", "   *     enum set\n", "   * @return a new, modifiable {@code EnumSet} containing all values of the enum\n", "   *     that aren't present in the given collection\n", "   * @throws IllegalArgumentException if {@code collection} is not an\n", "   *     {@code EnumSet} instance and contains no elements\n", "   */\n", "  public static <E extends Enum<E>> EnumSet<E> complementOf(Collection<E> collection) {\n", "    if (collection instanceof EnumSet) {\n", "      return EnumSet.complementOf((EnumSet<E>) collection);\n", "    }\n", "    checkArgument(\n", "        !collection.isEmpty(), \"collection is empty; use the other version of this method\");\n", "    Class<E> type = collection.iterator().next().getDeclaringClass();\n", "    return makeComplementByHand(collection, type);\n", "  }\n", "\n", "  /**\n", "   * Creates an {@code EnumSet} consisting of all enum values that are not in\n", "   * the specified collection. This is equivalent to\n", "   * {@link EnumSet#complementOf}, but can act on any input collection, as long\n", "   * as the elements are of enum type.\n", "   *\n", "   * @param collection the collection whose complement should be stored in the\n", "   *     {@code EnumSet}\n", "   * @param type the type of the elements in the set\n", "   * @return a new, modifiable {@code EnumSet} initially containing all the\n", "   *     values of the enum not present in the given collection\n", "   */\n", "  public static <E extends Enum<E>> EnumSet<E> complementOf(\n", "      Collection<E> collection, Class<E> type) {\n", "    checkNotNull(collection);\n", "    return (collection instanceof EnumSet)\n", "        ? EnumSet.complementOf((EnumSet<E>) collection)\n", "        : makeComplementByHand(collection, type);\n", "  }\n", "\n", "  private static <E extends Enum<E>> EnumSet<E> makeComplementByHand(\n", "      Collection<E> collection, Class<E> type) {\n", "    EnumSet<E> result = EnumSet.allOf(type);\n", "    result.removeAll(collection);\n", "    return result;\n", "  }\n", "\n", "  /**\n", "   * Returns a set backed by the specified map. The resulting set displays\n", "   * the same ordering, concurrency, and performance characteristics as the\n", "   * backing map. In essence, this factory method provides a {@link Set}\n", "   * implementation corresponding to any {@link Map} implementation. There is no\n", "   * need to use this method on a {@link Map} implementation that already has a\n", "   * corresponding {@link Set} implementation (such as {@link java.util.HashMap}\n", "   * or {@link java.util.TreeMap}).\n", "   *\n", "   * <p>Each method invocation on the set returned by this method results in\n", "   * exactly one method invocation on the backing map or its {@code keySet}\n", "   * view, with one exception. The {@code addAll} method is implemented as a\n", "   * sequence of {@code put} invocations on the backing map.\n", "   *\n", "   * <p>The specified map must be empty at the time this method is invoked,\n", "   * and should not be accessed directly after this method returns. These\n", "   * conditions are ensured if the map is created empty, passed directly\n", "   * to this method, and no reference to the map is retained, as illustrated\n", "   * in the following code fragment: <pre>  {@code\n", "   *\n", "   *   Set<Object> identityHashSet = Sets.newSetFromMap(\n", "   *       new IdentityHashMap<Object, Boolean>());}</pre>\n", "   *\n", "   * <p>The returned set is serializable if the backing map is.\n", "   *\n", "   * @param map the backing map\n", "   * @return the set backed by the map\n", "   * @throws IllegalArgumentException if {@code map} is not empty\n", "   * @deprecated Use {@link Collections#newSetFromMap} instead. This method\n", "   *     will be removed in August 2017.\n", "   */\n", "  @Deprecated\n", "  public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {\n", "    return Platform.newSetFromMap(map);\n", "  }\n", "\n", "  /**\n", "   * An unmodifiable view of a set which may be backed by other sets; this view\n", "   * will change as the backing sets do. Contains methods to copy the data into\n", "   * a new set which will then remain stable. There is usually no reason to\n", "   * retain a reference of type {@code SetView}; typically, you either use it\n", "   * as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or\n", "   * {@link #copyInto} and forget the {@code SetView} itself.\n", "   *\n", "   * @since 2.0\n", "   */\n", "  public abstract static class SetView<E> extends AbstractSet<E> {\n", "    private SetView() {} // no subclasses but our own\n", "\n", "    /**\n", "     * Returns an immutable copy of the current contents of this set view.\n", "     * Does not support null elements.\n", "     *\n", "     * <p><b>Warning:</b> this may have unexpected results if a backing set of\n", "     * this view uses a nonstandard notion of equivalence, for example if it is\n", "     * a {@link TreeSet} using a comparator that is inconsistent with {@link\n", "     * Object#equals(Object)}.\n", "     */\n", "    public ImmutableSet<E> immutableCopy() {\n", "      return ImmutableSet.copyOf(this);\n", "    }\n", "\n", "    /**\n", "     * Copies the current contents of this set view into an existing set. This\n", "     * method has equivalent behavior to {@code set.addAll(this)}, assuming that\n", "     * all the sets involved are based on the same notion of equivalence.\n", "     *\n", "     * @return a reference to {@code set}, for convenience\n", "     */\n", "    // Note: S should logically extend Set<? super E> but can't due to either\n", "    // some javac bug or some weirdness in the spec, not sure which.\n", "    public <S extends Set<E>> S copyInto(S set) {\n", "      set.addAll(this);\n", "      return set;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable <b>view</b> of the union of two sets. The returned\n", "   * set contains all elements that are contained in either backing set.\n", "   * Iterating over the returned set iterates first over all the elements of\n", "   * {@code set1}, then over each element of {@code set2}, in order, that is not\n", "   * contained in {@code set1}.\n", "   *\n", "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based on\n", "   * different equivalence relations (as {@link HashSet}, {@link TreeSet}, and\n", "   * the {@link Map#keySet} of an {@code IdentityHashMap} all are).\n", "   *\n", "   * <p><b>Note:</b> The returned view performs better when {@code set1} is the\n", "   * smaller of the two sets. If you have reason to believe one of your sets\n", "   * will generally be smaller than the other, pass it first.\n", "   *\n", "   * <p>Further, note that the current implementation is not suitable for nested\n", "   * {@code union} views, i.e. the following should be avoided when in a loop:\n", "   * {@code union = Sets.union(union, anotherSet);}, since iterating over the resulting\n", "   * set has a cubic complexity to the depth of the nesting.\n", "   */\n", "  public static <E> SetView<E> union(final Set<? extends E> set1, final Set<? extends E> set2) {\n", "    checkNotNull(set1, \"set1\");\n", "    checkNotNull(set2, \"set2\");\n", "\n", "    final Set<? extends E> set2minus1 = difference(set2, set1);\n", "\n", "    return new SetView<E>() {\n", "      @Override\n", "      public int size() {\n", "        return set1.size() + set2minus1.size();\n", "      }\n", "\n", "      @Override\n", "      public boolean isEmpty() {\n", "        return set1.isEmpty() && set2.isEmpty();\n", "      }\n", "\n", "      @Override\n", "      public Iterator<E> iterator() {\n", "        return Iterators.unmodifiableIterator(\n", "            Iterators.concat(set1.iterator(), set2minus1.iterator()));\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object object) {\n", "        return set1.contains(object) || set2.contains(object);\n", "      }\n", "\n", "      @Override\n", "      public <S extends Set<E>> S copyInto(S set) {\n", "        set.addAll(set1);\n", "        set.addAll(set2);\n", "        return set;\n", "      }\n", "\n", "      @Override\n", "      public ImmutableSet<E> immutableCopy() {\n", "        return new ImmutableSet.Builder<E>().addAll(set1).addAll(set2).build();\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable <b>view</b> of the intersection of two sets. The\n", "   * returned set contains all elements that are contained by both backing sets.\n", "   * The iteration order of the returned set matches that of {@code set1}.\n", "   *\n", "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n", "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n", "   * and the keySet of an {@code IdentityHashMap} all are).\n", "   *\n", "   * <p><b>Note:</b> The returned view performs slightly better when {@code\n", "   * set1} is the smaller of the two sets. If you have reason to believe one of\n", "   * your sets will generally be smaller than the other, pass it first.\n", "   * Unfortunately, since this method sets the generic type of the returned set\n", "   * based on the type of the first set passed, this could in rare cases force\n", "   * you to make a cast, for example: <pre>   {@code\n", "   *\n", "   *   Set<Object> aFewBadObjects = ...\n", "   *   Set<String> manyBadStrings = ...\n", "   *\n", "   *   // impossible for a non-String to be in the intersection\n", "   *   SuppressWarnings(\"unchecked\")\n", "   *   Set<String> badStrings = (Set) Sets.intersection(\n", "   *       aFewBadObjects, manyBadStrings);}</pre>\n", "   *\n", "   * <p>This is unfortunate, but should come up only very rarely.\n", "   */\n", "  public static <E> SetView<E> intersection(final Set<E> set1, final Set<?> set2) {\n", "    checkNotNull(set1, \"set1\");\n", "    checkNotNull(set2, \"set2\");\n", "\n", "    final Predicate<Object> inSet2 = Predicates.in(set2);\n", "    return new SetView<E>() {\n", "      @Override\n", "      public Iterator<E> iterator() {\n", "        return Iterators.filter(set1.iterator(), inSet2);\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return Iterators.size(iterator());\n", "      }\n", "\n", "      @Override\n", "      public boolean isEmpty() {\n", "        return !iterator().hasNext();\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object object) {\n", "        return set1.contains(object) && set2.contains(object);\n", "      }\n", "\n", "      @Override\n", "      public boolean containsAll(Collection<?> collection) {\n", "        return set1.containsAll(collection) && set2.containsAll(collection);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable <b>view</b> of the difference of two sets. The\n", "   * returned set contains all elements that are contained by {@code set1} and\n", "   * not contained by {@code set2}. {@code set2} may also contain elements not\n", "   * present in {@code set1}; these are simply ignored. The iteration order of\n", "   * the returned set matches that of {@code set1}.\n", "   *\n", "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n", "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n", "   * and the keySet of an {@code IdentityHashMap} all are).\n", "   */\n", "  public static <E> SetView<E> difference(final Set<E> set1, final Set<?> set2) {\n", "    checkNotNull(set1, \"set1\");\n", "    checkNotNull(set2, \"set2\");\n", "\n", "    final Predicate<Object> notInSet2 = Predicates.not(Predicates.in(set2));\n", "    return new SetView<E>() {\n", "      @Override\n", "      public Iterator<E> iterator() {\n", "        return Iterators.filter(set1.iterator(), notInSet2);\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return Iterators.size(iterator());\n", "      }\n", "\n", "      @Override\n", "      public boolean isEmpty() {\n", "        return set2.containsAll(set1);\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object element) {\n", "        return set1.contains(element) && !set2.contains(element);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns an unmodifiable <b>view</b> of the symmetric difference of two\n", "   * sets. The returned set contains all elements that are contained in either\n", "   * {@code set1} or {@code set2} but not in both. The iteration order of the\n", "   * returned set is undefined.\n", "   *\n", "   * <p>Results are undefined if {@code set1} and {@code set2} are sets based\n", "   * on different equivalence relations (as {@code HashSet}, {@code TreeSet},\n", "   * and the keySet of an {@code IdentityHashMap} all are).\n", "   *\n", "   * @since 3.0\n", "   */\n", "  public static <E> SetView<E> symmetricDifference(\n", "      final Set<? extends E> set1, final Set<? extends E> set2) {\n", "    checkNotNull(set1, \"set1\");\n", "    checkNotNull(set2, \"set2\");\n", "\n", "    return new SetView<E>() {\n", "      @Override\n", "      public Iterator<E> iterator() {\n", "        final Iterator<? extends E> itr1 = set1.iterator();\n", "        final Iterator<? extends E> itr2 = set2.iterator();\n", "        return new AbstractIterator<E>() {\n", "          @Override\n", "          public E computeNext() {\n", "            while (itr1.hasNext()) {\n", "              E elem1 = itr1.next();\n", "              if (!set2.contains(elem1)) {\n", "                return elem1;\n", "              }\n", "            }\n", "            while (itr2.hasNext()) {\n", "              E elem2 = itr2.next();\n", "              if (!set1.contains(elem2)) {\n", "                return elem2;\n", "              }\n", "            }\n", "            return endOfData();\n", "          }\n", "        };\n", "      }\n", "\n", "      @Override\n", "      public int size() {\n", "        return Iterators.size(iterator());\n", "      }\n", "\n", "      @Override\n", "      public boolean isEmpty() {\n", "        return set1.equals(set2);\n", "      }\n", "\n", "      @Override\n", "      public boolean contains(Object element) {\n", "        return set1.contains(element) ^ set2.contains(element);\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns the elements of {@code unfiltered} that satisfy a predicate. The\n", "   * returned set is a live view of {@code unfiltered}; changes to one affect\n", "   * the other.\n", "   *\n", "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n", "   * other set methods are supported. When given an element that doesn't satisfy\n", "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n", "   * an {@link IllegalArgumentException}. When methods such as {@code\n", "   * removeAll()} and {@code clear()} are called on the filtered set, only\n", "   * elements that satisfy the filter will be removed from the underlying set.\n", "   *\n", "   * <p>The returned set isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate\n", "   * across every element in the underlying set and determine which elements\n", "   * satisfy the filter. When a live view is <i>not</i> needed, it may be faster\n", "   * to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n", "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n", "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n", "   * with equals. (See {@link Iterables#filter(Iterable, Class)} for related\n", "   * functionality.)\n", "   */\n", "  // TODO(kevinb): how to omit that last sentence when building GWT javadoc?\n", "  @CheckReturnValue\n", "  public static <E> Set<E> filter(Set<E> unfiltered, Predicate<? super E> predicate) {\n", "    if (unfiltered instanceof SortedSet) {\n", "      return filter((SortedSet<E>) unfiltered, predicate);\n", "    }\n", "    if (unfiltered instanceof FilteredSet) {\n", "      // Support clear(), removeAll(), and retainAll() when filtering a filtered\n", "      // collection.\n", "      FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;\n", "      Predicate<E> combinedPredicate = Predicates.<E>and(filtered.predicate, predicate);\n", "      return new FilteredSet<E>((Set<E>) filtered.unfiltered, combinedPredicate);\n", "    }\n", "\n", "    return new FilteredSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n", "  }\n", "\n", "  private static class FilteredSet<E> extends FilteredCollection<E> implements Set<E> {\n", "    FilteredSet(Set<E> unfiltered, Predicate<? super E> predicate) {\n", "      super(unfiltered, predicate);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      return equalsImpl(this, object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return hashCodeImpl(this);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that\n", "   * satisfy a predicate. The returned set is a live view of {@code unfiltered};\n", "   * changes to one affect the other.\n", "   *\n", "   * <p>The resulting set's iterator does not support {@code remove()}, but all\n", "   * other set methods are supported. When given an element that doesn't satisfy\n", "   * the predicate, the set's {@code add()} and {@code addAll()} methods throw\n", "   * an {@link IllegalArgumentException}. When methods such as\n", "   * {@code removeAll()} and {@code clear()} are called on the filtered set,\n", "   * only elements that satisfy the filter will be removed from the underlying\n", "   * set.\n", "   *\n", "   * <p>The returned set isn't threadsafe or serializable, even if\n", "   * {@code unfiltered} is.\n", "   *\n", "   * <p>Many of the filtered set's methods, such as {@code size()}, iterate across\n", "   * every element in the underlying set and determine which elements satisfy\n", "   * the filter. When a live view is <i>not</i> needed, it may be faster to copy\n", "   * {@code Iterables.filter(unfiltered, predicate)} and use the copy.\n", "   *\n", "   * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,\n", "   * as documented at {@link Predicate#apply}. Do not provide a predicate such as\n", "   * {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with\n", "   * equals. (See {@link Iterables#filter(Iterable, Class)} for related\n", "   * functionality.)\n", "   *\n", "   * @since 11.0\n", "   */\n", "  @CheckReturnValue\n", "  public static <E> SortedSet<E> filter(SortedSet<E> unfiltered, Predicate<? super E> predicate) {\n", "    return Platform.setsFilterSortedSet(unfiltered, predicate);\n", "  }\n", "\n", "  static <E> SortedSet<E> filterSortedIgnoreNavigable(\n", "      SortedSet<E> unfiltered, Predicate<? super E> predicate) {\n", "    if (unfiltered instanceof FilteredSet) {\n", "      // Support clear(), removeAll(), and retainAll() when filtering a filtered\n", "      // collection.\n", "      FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;\n", "      Predicate<E> combinedPredicate = Predicates.<E>and(filtered.predicate, predicate);\n", "      return new FilteredSortedSet<E>((SortedSet<E>) filtered.unfiltered, combinedPredicate);\n", "    }\n", "\n", "    return new FilteredSortedSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n", "  }\n", "\n", "  private static class FilteredSortedSet<E> extends FilteredSet<E> implements SortedSet<E> {\n", "\n", "    FilteredSortedSet(SortedSet<E> unfiltered, Predicate<? super E> predicate) {\n", "      super(unfiltered, predicate);\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super E> comparator() {\n", "      return ((SortedSet<E>) unfiltered).comparator();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> subSet(E fromElement, E toElement) {\n", "      return new FilteredSortedSet<E>(\n", "          ((SortedSet<E>) unfiltered).subSet(fromElement, toElement), predicate);\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> headSet(E toElement) {\n", "      return new FilteredSortedSet<E>(((SortedSet<E>) unfiltered).headSet(toElement), predicate);\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> tailSet(E fromElement) {\n", "      return new FilteredSortedSet<E>(((SortedSet<E>) unfiltered).tailSet(fromElement), predicate);\n", "    }\n", "\n", "    @Override\n", "    public E first() {\n", "      return iterator().next();\n", "    }\n", "\n", "    @Override\n", "    public E last() {\n", "      SortedSet<E> sortedUnfiltered = (SortedSet<E>) unfiltered;\n", "      while (true) {\n", "        E element = sortedUnfiltered.last();\n", "        if (predicate.apply(element)) {\n", "          return element;\n", "        }\n", "        sortedUnfiltered = sortedUnfiltered.headSet(element);\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns every possible list that can be formed by choosing one element\n", "   * from each of the given sets in order; the \"n-ary\n", "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n", "   * product</a>\" of the sets. For example: <pre>   {@code\n", "   *\n", "   *   Sets.cartesianProduct(ImmutableList.of(\n", "   *       ImmutableSet.of(1, 2),\n", "   *       ImmutableSet.of(\"A\", \"B\", \"C\")))}</pre>\n", "   *\n", "   * <p>returns a set containing six lists:\n", "   *\n", "   * <ul>\n", "   * <li>{@code ImmutableList.of(1, \"A\")}\n", "   * <li>{@code ImmutableList.of(1, \"B\")}\n", "   * <li>{@code ImmutableList.of(1, \"C\")}\n", "   * <li>{@code ImmutableList.of(2, \"A\")}\n", "   * <li>{@code ImmutableList.of(2, \"B\")}\n", "   * <li>{@code ImmutableList.of(2, \"C\")}\n", "   * </ul>\n", "   *\n", "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n", "   * order for Cartesian products that you would get from nesting for loops:\n", "   * <pre>   {@code\n", "   *\n", "   *   for (B b0 : sets.get(0)) {\n", "   *     for (B b1 : sets.get(1)) {\n", "   *       ...\n", "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n", "   *       // operate on tuple\n", "   *     }\n", "   *   }}</pre>\n", "   *\n", "   * <p>Note that if any input set is empty, the Cartesian product will also be\n", "   * empty. If no sets at all are provided (an empty list), the resulting\n", "   * Cartesian product has one element, an empty list (counter-intuitive, but\n", "   * mathematically consistent).\n", "   *\n", "   * <p><i>Performance notes:</i> while the cartesian product of sets of size\n", "   * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory\n", "   * consumption is much smaller. When the cartesian set is constructed, the\n", "   * input sets are merely copied. Only as the resulting set is iterated are the\n", "   * individual lists created, and these are not retained after iteration.\n", "   *\n", "   * @param sets the sets to choose elements from, in the order that\n", "   *     the elements chosen from those sets should appear in the resulting\n", "   *     lists\n", "   * @param <B> any common base class shared by all axes (often just {@link\n", "   *     Object})\n", "   * @return the Cartesian product, as an immutable set containing immutable\n", "   *     lists\n", "   * @throws NullPointerException if {@code sets}, any one of the {@code sets},\n", "   *     or any element of a provided set is null\n", "   * @since 2.0\n", "   */\n", "  public static <B> Set<List<B>> cartesianProduct(List<? extends Set<? extends B>> sets) {\n", "    return CartesianSet.create(sets);\n", "  }\n", "\n", "  /**\n", "   * Returns every possible list that can be formed by choosing one element\n", "   * from each of the given sets in order; the \"n-ary\n", "   * <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n", "   * product</a>\" of the sets. For example: <pre>   {@code\n", "   *\n", "   *   Sets.cartesianProduct(\n", "   *       ImmutableSet.of(1, 2),\n", "   *       ImmutableSet.of(\"A\", \"B\", \"C\"))}</pre>\n", "   *\n", "   * <p>returns a set containing six lists:\n", "   *\n", "   * <ul>\n", "   * <li>{@code ImmutableList.of(1, \"A\")}\n", "   * <li>{@code ImmutableList.of(1, \"B\")}\n", "   * <li>{@code ImmutableList.of(1, \"C\")}\n", "   * <li>{@code ImmutableList.of(2, \"A\")}\n", "   * <li>{@code ImmutableList.of(2, \"B\")}\n", "   * <li>{@code ImmutableList.of(2, \"C\")}\n", "   * </ul>\n", "   *\n", "   * <p>The result is guaranteed to be in the \"traditional\", lexicographical\n", "   * order for Cartesian products that you would get from nesting for loops:\n", "   * <pre>   {@code\n", "   *\n", "   *   for (B b0 : sets.get(0)) {\n", "   *     for (B b1 : sets.get(1)) {\n", "   *       ...\n", "   *       ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n", "   *       // operate on tuple\n", "   *     }\n", "   *   }}</pre>\n", "   *\n", "   * <p>Note that if any input set is empty, the Cartesian product will also be\n", "   * empty. If no sets at all are provided (an empty list), the resulting\n", "   * Cartesian product has one element, an empty list (counter-intuitive, but\n", "   * mathematically consistent).\n", "   *\n", "   * <p><i>Performance notes:</i> while the cartesian product of sets of size\n", "   * {@code m, n, p} is a set of size {@code m x n x p}, its actual memory\n", "   * consumption is much smaller. When the cartesian set is constructed, the\n", "   * input sets are merely copied. Only as the resulting set is iterated are the\n", "   * individual lists created, and these are not retained after iteration.\n", "   *\n", "   * @param sets the sets to choose elements from, in the order that\n", "   *     the elements chosen from those sets should appear in the resulting\n", "   *     lists\n", "   * @param <B> any common base class shared by all axes (often just {@link\n", "   *     Object})\n", "   * @return the Cartesian product, as an immutable set containing immutable\n", "   *     lists\n", "   * @throws NullPointerException if {@code sets}, any one of the {@code sets},\n", "   *     or any element of a provided set is null\n", "   * @since 2.0\n", "   */\n", "  public static <B> Set<List<B>> cartesianProduct(Set<? extends B>... sets) {\n", "    return cartesianProduct(Arrays.asList(sets));\n", "  }\n", "\n", "  private static final class CartesianSet<E> extends ForwardingCollection<List<E>>\n", "      implements Set<List<E>> {\n", "    private transient final ImmutableList<ImmutableSet<E>> axes;\n", "    private transient final CartesianList<E> delegate;\n", "\n", "    static <E> Set<List<E>> create(List<? extends Set<? extends E>> sets) {\n", "      ImmutableList.Builder<ImmutableSet<E>> axesBuilder =\n", "          new ImmutableList.Builder<ImmutableSet<E>>(sets.size());\n", "      for (Set<? extends E> set : sets) {\n", "        ImmutableSet<E> copy = ImmutableSet.copyOf(set);\n", "        if (copy.isEmpty()) {\n", "          return ImmutableSet.of();\n", "        }\n", "        axesBuilder.add(copy);\n", "      }\n", "      final ImmutableList<ImmutableSet<E>> axes = axesBuilder.build();\n", "      ImmutableList<List<E>> listAxes =\n", "          new ImmutableList<List<E>>() {\n", "            @Override\n", "            public int size() {\n", "              return axes.size();\n", "            }\n", "\n", "            @Override\n", "            public List<E> get(int index) {\n", "              return axes.get(index).asList();\n", "            }\n", "\n", "            @Override\n", "            boolean isPartialView() {\n", "              return true;\n", "            }\n", "          };\n", "      return new CartesianSet<E>(axes, new CartesianList<E>(listAxes));\n", "    }\n", "\n", "    private CartesianSet(ImmutableList<ImmutableSet<E>> axes, CartesianList<E> delegate) {\n", "      this.axes = axes;\n", "      this.delegate = delegate;\n", "    }\n", "\n", "    @Override\n", "    protected Collection<List<E>> delegate() {\n", "      return delegate;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      // Warning: this is broken if size() == 0, so it is critical that we\n", "      // substitute an empty ImmutableSet to the user in place of this\n", "      if (object instanceof CartesianSet) {\n", "        CartesianSet<?> that = (CartesianSet<?>) object;\n", "        return this.axes.equals(that.axes);\n", "      }\n", "      return super.equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      // Warning: this is broken if size() == 0, so it is critical that we\n", "      // substitute an empty ImmutableSet to the user in place of this\n", "\n", "      // It's a weird formula, but tests prove it works.\n", "      int adjust = size() - 1;\n", "      for (int i = 0; i < axes.size(); i++) {\n", "        adjust *= 31;\n", "        adjust = ~~adjust;\n", "        // in GWT, we have to deal with integer overflow carefully\n", "      }\n", "      int hash = 1;\n", "      for (Set<E> axis : axes) {\n", "        hash = 31 * hash + (size() / axis.size() * axis.hashCode());\n", "\n", "        hash = ~~hash;\n", "      }\n", "      hash += adjust;\n", "      return ~~hash;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns the set of all possible subsets of {@code set}. For example,\n", "   * {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},\n", "   * {1}, {2}, {1, 2}}}.\n", "   *\n", "   * <p>Elements appear in these subsets in the same iteration order as they\n", "   * appeared in the input set. The order in which these subsets appear in the\n", "   * outer set is undefined. Note that the power set of the empty set is not the\n", "   * empty set, but a one-element set containing the empty set.\n", "   *\n", "   * <p>The returned set and its constituent sets use {@code equals} to decide\n", "   * whether two elements are identical, even if the input set uses a different\n", "   * concept of equivalence.\n", "   *\n", "   * <p><i>Performance notes:</i> while the power set of a set with size {@code\n", "   * n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the\n", "   * power set is constructed, the input set is merely copied. Only as the\n", "   * power set is iterated are the individual subsets created, and these subsets\n", "   * themselves occupy only a small constant amount of memory.\n", "   *\n", "   * @param set the set of elements to construct a power set from\n", "   * @return the power set, as an immutable set of immutable sets\n", "   * @throws IllegalArgumentException if {@code set} has more than 30 unique\n", "   *     elements (causing the power set size to exceed the {@code int} range)\n", "   * @throws NullPointerException if {@code set} is or contains {@code null}\n", "   * @see <a href=\"http://en.wikipedia.org/wiki/Power_set\">Power set article at\n", "   *      Wikipedia</a>\n", "   * @since 4.0\n", "   */\n", "  @GwtCompatible(serializable = false)\n", "  public static <E> Set<Set<E>> powerSet(Set<E> set) {\n", "    return new PowerSet<E>(set);\n", "  }\n", "\n", "  private static final class SubSet<E> extends AbstractSet<E> {\n", "    private final ImmutableMap<E, Integer> inputSet;\n", "    private final int mask;\n", "\n", "    SubSet(ImmutableMap<E, Integer> inputSet, int mask) {\n", "      this.inputSet = inputSet;\n", "      this.mask = mask;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<E> iterator() {\n", "      return new UnmodifiableIterator<E>() {\n", "        final ImmutableList<E> elements = inputSet.keySet().asList();\n", "        int remainingSetBits = mask;\n", "\n", "        @Override\n", "        public boolean hasNext() {\n", "          return remainingSetBits != 0;\n", "        }\n", "\n", "        @Override\n", "        public E next() {\n", "          int index = Integer.numberOfTrailingZeros(remainingSetBits);\n", "          if (index == 32) {\n", "            throw new NoSuchElementException();\n", "          }\n", "          remainingSetBits &= ~(1 << index);\n", "          return elements.get(index);\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return Integer.bitCount(mask);\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(@Nullable Object o) {\n", "      Integer index = inputSet.get(o);\n", "      return index != null && (mask & (1 << index)) != 0;\n", "    }\n", "  }\n", "\n", "  private static final class PowerSet<E> extends AbstractSet<Set<E>> {\n", "    final ImmutableMap<E, Integer> inputSet;\n", "\n", "    PowerSet(Set<E> input) {\n", "      this.inputSet = Maps.indexMap(input);\n", "      checkArgument(\n", "          inputSet.size() <= 30, \"Too many elements to create power set: %s > 30\", inputSet.size());\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return 1 << inputSet.size();\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public Iterator<Set<E>> iterator() {\n", "      return new AbstractIndexedListIterator<Set<E>>(size()) {\n", "        @Override\n", "        protected Set<E> get(final int setBits) {\n", "          return new SubSet<E>(inputSet, setBits);\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(@Nullable Object obj) {\n", "      if (obj instanceof Set) {\n", "        Set<?> set = (Set<?>) obj;\n", "        return inputSet.keySet().containsAll(set);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object obj) {\n", "      if (obj instanceof PowerSet) {\n", "        PowerSet<?> that = (PowerSet<?>) obj;\n", "        return inputSet.equals(that.inputSet);\n", "      }\n", "      return super.equals(obj);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      /*\n", "       * The sum of the sums of the hash codes in each subset is just the sum of\n", "       * each input element's hash code times the number of sets that element\n", "       * appears in. Each element appears in exactly half of the 2^n sets, so:\n", "       */\n", "      return inputSet.keySet().hashCode() << (inputSet.size() - 1);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"powerSet(\" + inputSet + \")\";\n", "    }\n", "  }\n", "\n", "  /**\n", "   * An implementation for {@link Set#hashCode()}.\n", "   */\n", "  static int hashCodeImpl(Set<?> s) {\n", "    int hashCode = 0;\n", "    for (Object o : s) {\n", "      hashCode += o != null ? o.hashCode() : 0;\n", "\n", "      hashCode = ~~hashCode;\n", "      // Needed to deal with unusual integer overflow in GWT.\n", "    }\n", "    return hashCode;\n", "  }\n", "\n", "  /**\n", "   * An implementation for {@link Set#equals(Object)}.\n", "   */\n", "  static boolean equalsImpl(Set<?> s, @Nullable Object object) {\n", "    if (s == object) {\n", "      return true;\n", "    }\n", "    if (object instanceof Set) {\n", "      Set<?> o = (Set<?>) object;\n", "\n", "      try {\n", "        return s.size() == o.size() && s.containsAll(o);\n", "      } catch (NullPointerException ignored) {\n", "        return false;\n", "      } catch (ClassCastException ignored) {\n", "        return false;\n", "      }\n", "    }\n", "    return false;\n", "  }\n", "\n", "  /**\n", "   * Remove each element in an iterable from a set.\n", "   */\n", "  static boolean removeAllImpl(Set<?> set, Iterator<?> iterator) {\n", "    boolean changed = false;\n", "    while (iterator.hasNext()) {\n", "      changed |= set.remove(iterator.next());\n", "    }\n", "    return changed;\n", "  }\n", "\n", "  static boolean removeAllImpl(Set<?> set, Collection<?> collection) {\n", "    checkNotNull(collection); // for GWT\n", "    if (collection instanceof Multiset) {\n", "      collection = ((Multiset<?>) collection).elementSet();\n", "    }\n", "    /*\n", "     * AbstractSet.removeAll(List) has quadratic behavior if the list size\n", "     * is just less than the set's size.  We augment the test by\n", "     * assuming that sets have fast contains() performance, and other\n", "     * collections don't.  See\n", "     * http://code.google.com/p/guava-libraries/issues/detail?id=1013\n", "     */\n", "    if (collection instanceof Set && collection.size() > set.size()) {\n", "      return Iterators.removeAll(set.iterator(), collection);\n", "    } else {\n", "      return removeAllImpl(set, collection.iterator());\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294]}}, {"44": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/SortedMultisets.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n", " * use this file except in compliance with the License. You may obtain a copy of\n", " * the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n", " * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n", " * License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.BoundType.CLOSED;\n", "import static com.google.common.collect.BoundType.OPEN;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Multiset.Entry;\n", "import com.google.j2objc.annotations.Weak;\n", "\n", "import java.util.Comparator;\n", "import java.util.NoSuchElementException;\n", "import java.util.SortedSet;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Provides static utility methods for creating and working with\n", " * {@link SortedMultiset} instances.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "final class SortedMultisets {\n", "  private SortedMultisets() {}\n", "\n", "  /**\n", "   * A skeleton implementation for {@link SortedMultiset#elementSet}.\n", "   */\n", "  static class ElementSet<E> extends Multisets.ElementSet<E> implements SortedSet<E> {\n", "    @Weak private final SortedMultiset<E> multiset;\n", "\n", "    ElementSet(SortedMultiset<E> multiset) {\n", "      this.multiset = multiset;\n", "    }\n", "\n", "    @Override\n", "    final SortedMultiset<E> multiset() {\n", "      return multiset;\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super E> comparator() {\n", "      return multiset().comparator();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> subSet(E fromElement, E toElement) {\n", "      return multiset().subMultiset(fromElement, CLOSED, toElement, OPEN).elementSet();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> headSet(E toElement) {\n", "      return multiset().headMultiset(toElement, OPEN).elementSet();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> tailSet(E fromElement) {\n", "      return multiset().tailMultiset(fromElement, CLOSED).elementSet();\n", "    }\n", "\n", "    @Override\n", "    public E first() {\n", "      return getElementOrThrow(multiset().firstEntry());\n", "    }\n", "\n", "    @Override\n", "    public E last() {\n", "      return getElementOrThrow(multiset().lastEntry());\n", "    }\n", "  }\n", "\n", "  private static <E> E getElementOrThrow(Entry<E> entry) {\n", "    if (entry == null) {\n", "      throw new NoSuchElementException();\n", "    }\n", "    return entry.getElement();\n", "  }\n", "\n", "  private static <E> E getElementOrNull(@Nullable Entry<E> entry) {\n", "    return (entry == null) ? null : entry.getElement();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]}}, {"45": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Synchronized.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "\n", "import java.io.Serializable;\n", "import java.util.Collection;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Queue;\n", "import java.util.RandomAccess;\n", "import java.util.Set;\n", "import java.util.SortedMap;\n", "import java.util.SortedSet;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Synchronized collection views. The returned synchronized collection views are\n", " * serializable if the backing collection and the mutex are serializable.\n", " *\n", " * <p>If {@code null} is passed as the {@code mutex} parameter to any of this\n", " * class's top-level methods or inner class constructors, the created object\n", " * uses itself as the synchronization mutex.\n", " *\n", " * <p>This class should be used by other collection classes only.\n", " *\n", " * @author Mike Bostock\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "final class Synchronized {\n", "  private Synchronized() {}\n", "\n", "  static class SynchronizedObject implements Serializable {\n", "    final Object delegate;\n", "    final Object mutex;\n", "\n", "    SynchronizedObject(Object delegate, @Nullable Object mutex) {\n", "      this.delegate = checkNotNull(delegate);\n", "      this.mutex = (mutex == null) ? this : mutex;\n", "    }\n", "\n", "    Object delegate() {\n", "      return delegate;\n", "    }\n", "\n", "    // No equals and hashCode; see ForwardingObject for details.\n", "\n", "    @Override\n", "    public String toString() {\n", "      synchronized (mutex) {\n", "        return delegate.toString();\n", "      }\n", "    }\n", "\n", "    // Serialization invokes writeObject only when it's private.\n", "    // The SynchronizedObject subclasses don't need a writeObject method since\n", "    // they don't contain any non-transient member variables, while the\n", "    // following writeObject() handles the SynchronizedObject members.\n", "  }\n", "\n", "  private static <E> Collection<E> collection(Collection<E> collection, @Nullable Object mutex) {\n", "    return new SynchronizedCollection<E>(collection, mutex);\n", "  }\n", "\n", "  @VisibleForTesting\n", "  static class SynchronizedCollection<E> extends SynchronizedObject implements Collection<E> {\n", "    private SynchronizedCollection(Collection<E> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    Collection<E> delegate() {\n", "      return (Collection<E>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public boolean add(E e) {\n", "      synchronized (mutex) {\n", "        return delegate().add(e);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean addAll(Collection<? extends E> c) {\n", "      synchronized (mutex) {\n", "        return delegate().addAll(c);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      synchronized (mutex) {\n", "        delegate().clear();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object o) {\n", "      synchronized (mutex) {\n", "        return delegate().contains(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean containsAll(Collection<?> c) {\n", "      synchronized (mutex) {\n", "        return delegate().containsAll(c);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      synchronized (mutex) {\n", "        return delegate().isEmpty();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Iterator<E> iterator() {\n", "      return delegate().iterator(); // manually synchronized\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      synchronized (mutex) {\n", "        return delegate().remove(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> c) {\n", "      synchronized (mutex) {\n", "        return delegate().removeAll(c);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> c) {\n", "      synchronized (mutex) {\n", "        return delegate().retainAll(c);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      synchronized (mutex) {\n", "        return delegate().size();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Object[] toArray() {\n", "      synchronized (mutex) {\n", "        return delegate().toArray();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public <T> T[] toArray(T[] a) {\n", "      synchronized (mutex) {\n", "        return delegate().toArray(a);\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  @VisibleForTesting\n", "  static <E> Set<E> set(Set<E> set, @Nullable Object mutex) {\n", "    return new SynchronizedSet<E>(set, mutex);\n", "  }\n", "\n", "  static class SynchronizedSet<E> extends SynchronizedCollection<E> implements Set<E> {\n", "\n", "    SynchronizedSet(Set<E> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    Set<E> delegate() {\n", "      return (Set<E>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object o) {\n", "      if (o == this) {\n", "        return true;\n", "      }\n", "      synchronized (mutex) {\n", "        return delegate().equals(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      synchronized (mutex) {\n", "        return delegate().hashCode();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static <E> SortedSet<E> sortedSet(SortedSet<E> set, @Nullable Object mutex) {\n", "    return new SynchronizedSortedSet<E>(set, mutex);\n", "  }\n", "\n", "  static class SynchronizedSortedSet<E> extends SynchronizedSet<E> implements SortedSet<E> {\n", "    SynchronizedSortedSet(SortedSet<E> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    SortedSet<E> delegate() {\n", "      return (SortedSet<E>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super E> comparator() {\n", "      synchronized (mutex) {\n", "        return delegate().comparator();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> subSet(E fromElement, E toElement) {\n", "      synchronized (mutex) {\n", "        return sortedSet(delegate().subSet(fromElement, toElement), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> headSet(E toElement) {\n", "      synchronized (mutex) {\n", "        return sortedSet(delegate().headSet(toElement), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<E> tailSet(E fromElement) {\n", "      synchronized (mutex) {\n", "        return sortedSet(delegate().tailSet(fromElement), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public E first() {\n", "      synchronized (mutex) {\n", "        return delegate().first();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public E last() {\n", "      synchronized (mutex) {\n", "        return delegate().last();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static <E> List<E> list(List<E> list, @Nullable Object mutex) {\n", "    return (list instanceof RandomAccess)\n", "        ? new SynchronizedRandomAccessList<E>(list, mutex)\n", "        : new SynchronizedList<E>(list, mutex);\n", "  }\n", "\n", "  private static class SynchronizedList<E> extends SynchronizedCollection<E> implements List<E> {\n", "    SynchronizedList(List<E> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    List<E> delegate() {\n", "      return (List<E>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public void add(int index, E element) {\n", "      synchronized (mutex) {\n", "        delegate().add(index, element);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean addAll(int index, Collection<? extends E> c) {\n", "      synchronized (mutex) {\n", "        return delegate().addAll(index, c);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public E get(int index) {\n", "      synchronized (mutex) {\n", "        return delegate().get(index);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int indexOf(Object o) {\n", "      synchronized (mutex) {\n", "        return delegate().indexOf(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexOf(Object o) {\n", "      synchronized (mutex) {\n", "        return delegate().lastIndexOf(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public ListIterator<E> listIterator() {\n", "      return delegate().listIterator(); // manually synchronized\n", "    }\n", "\n", "    @Override\n", "    public ListIterator<E> listIterator(int index) {\n", "      return delegate().listIterator(index); // manually synchronized\n", "    }\n", "\n", "    @Override\n", "    public E remove(int index) {\n", "      synchronized (mutex) {\n", "        return delegate().remove(index);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public E set(int index, E element) {\n", "      synchronized (mutex) {\n", "        return delegate().set(index, element);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public List<E> subList(int fromIndex, int toIndex) {\n", "      synchronized (mutex) {\n", "        return list(delegate().subList(fromIndex, toIndex), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object o) {\n", "      if (o == this) {\n", "        return true;\n", "      }\n", "      synchronized (mutex) {\n", "        return delegate().equals(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      synchronized (mutex) {\n", "        return delegate().hashCode();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static class SynchronizedRandomAccessList<E> extends SynchronizedList<E>\n", "      implements RandomAccess {\n", "    SynchronizedRandomAccessList(List<E> list, @Nullable Object mutex) {\n", "      super(list, mutex);\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static <E> Multiset<E> multiset(Multiset<E> multiset, @Nullable Object mutex) {\n", "    if (multiset instanceof SynchronizedMultiset || multiset instanceof ImmutableMultiset) {\n", "      return multiset;\n", "    }\n", "    return new SynchronizedMultiset<E>(multiset, mutex);\n", "  }\n", "\n", "  private static class SynchronizedMultiset<E> extends SynchronizedCollection<E>\n", "      implements Multiset<E> {\n", "    transient Set<E> elementSet;\n", "    transient Set<Entry<E>> entrySet;\n", "\n", "    SynchronizedMultiset(Multiset<E> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    Multiset<E> delegate() {\n", "      return (Multiset<E>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public int count(Object o) {\n", "      synchronized (mutex) {\n", "        return delegate().count(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int add(E e, int n) {\n", "      synchronized (mutex) {\n", "        return delegate().add(e, n);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int remove(Object o, int n) {\n", "      synchronized (mutex) {\n", "        return delegate().remove(o, n);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int setCount(E element, int count) {\n", "      synchronized (mutex) {\n", "        return delegate().setCount(element, count);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean setCount(E element, int oldCount, int newCount) {\n", "      synchronized (mutex) {\n", "        return delegate().setCount(element, oldCount, newCount);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<E> elementSet() {\n", "      synchronized (mutex) {\n", "        if (elementSet == null) {\n", "          elementSet = typePreservingSet(delegate().elementSet(), mutex);\n", "        }\n", "        return elementSet;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<Entry<E>> entrySet() {\n", "      synchronized (mutex) {\n", "        if (entrySet == null) {\n", "          entrySet = typePreservingSet(delegate().entrySet(), mutex);\n", "        }\n", "        return entrySet;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object o) {\n", "      if (o == this) {\n", "        return true;\n", "      }\n", "      synchronized (mutex) {\n", "        return delegate().equals(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      synchronized (mutex) {\n", "        return delegate().hashCode();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static <K, V> Multimap<K, V> multimap(Multimap<K, V> multimap, @Nullable Object mutex) {\n", "    if (multimap instanceof SynchronizedMultimap || multimap instanceof ImmutableMultimap) {\n", "      return multimap;\n", "    }\n", "    return new SynchronizedMultimap<K, V>(multimap, mutex);\n", "  }\n", "\n", "  private static class SynchronizedMultimap<K, V> extends SynchronizedObject\n", "      implements Multimap<K, V> {\n", "    transient Set<K> keySet;\n", "    transient Collection<V> valuesCollection;\n", "    transient Collection<Map.Entry<K, V>> entries;\n", "    transient Map<K, Collection<V>> asMap;\n", "    transient Multiset<K> keys;\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    Multimap<K, V> delegate() {\n", "      return (Multimap<K, V>) super.delegate();\n", "    }\n", "\n", "    SynchronizedMultimap(Multimap<K, V> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      synchronized (mutex) {\n", "        return delegate().size();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      synchronized (mutex) {\n", "        return delegate().isEmpty();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean containsKey(Object key) {\n", "      synchronized (mutex) {\n", "        return delegate().containsKey(key);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean containsValue(Object value) {\n", "      synchronized (mutex) {\n", "        return delegate().containsValue(value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean containsEntry(Object key, Object value) {\n", "      synchronized (mutex) {\n", "        return delegate().containsEntry(key, value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> get(K key) {\n", "      synchronized (mutex) {\n", "        return typePreservingCollection(delegate().get(key), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean put(K key, V value) {\n", "      synchronized (mutex) {\n", "        return delegate().put(key, value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean putAll(K key, Iterable<? extends V> values) {\n", "      synchronized (mutex) {\n", "        return delegate().putAll(key, values);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean putAll(Multimap<? extends K, ? extends V> multimap) {\n", "      synchronized (mutex) {\n", "        return delegate().putAll(multimap);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      synchronized (mutex) {\n", "        return delegate().replaceValues(key, values); // copy not synchronized\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object key, Object value) {\n", "      synchronized (mutex) {\n", "        return delegate().remove(key, value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> removeAll(Object key) {\n", "      synchronized (mutex) {\n", "        return delegate().removeAll(key); // copy not synchronized\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      synchronized (mutex) {\n", "        delegate().clear();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      synchronized (mutex) {\n", "        if (keySet == null) {\n", "          keySet = typePreservingSet(delegate().keySet(), mutex);\n", "        }\n", "        return keySet;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> values() {\n", "      synchronized (mutex) {\n", "        if (valuesCollection == null) {\n", "          valuesCollection = collection(delegate().values(), mutex);\n", "        }\n", "        return valuesCollection;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Collection<Map.Entry<K, V>> entries() {\n", "      synchronized (mutex) {\n", "        if (entries == null) {\n", "          entries = typePreservingCollection(delegate().entries(), mutex);\n", "        }\n", "        return entries;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Map<K, Collection<V>> asMap() {\n", "      synchronized (mutex) {\n", "        if (asMap == null) {\n", "          asMap = new SynchronizedAsMap<K, V>(delegate().asMap(), mutex);\n", "        }\n", "        return asMap;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Multiset<K> keys() {\n", "      synchronized (mutex) {\n", "        if (keys == null) {\n", "          keys = multiset(delegate().keys(), mutex);\n", "        }\n", "        return keys;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object o) {\n", "      if (o == this) {\n", "        return true;\n", "      }\n", "      synchronized (mutex) {\n", "        return delegate().equals(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      synchronized (mutex) {\n", "        return delegate().hashCode();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static <K, V> ListMultimap<K, V> listMultimap(\n", "      ListMultimap<K, V> multimap, @Nullable Object mutex) {\n", "    if (multimap instanceof SynchronizedListMultimap || multimap instanceof ImmutableListMultimap) {\n", "      return multimap;\n", "    }\n", "    return new SynchronizedListMultimap<K, V>(multimap, mutex);\n", "  }\n", "\n", "  private static class SynchronizedListMultimap<K, V> extends SynchronizedMultimap<K, V>\n", "      implements ListMultimap<K, V> {\n", "    SynchronizedListMultimap(ListMultimap<K, V> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    ListMultimap<K, V> delegate() {\n", "      return (ListMultimap<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public List<V> get(K key) {\n", "      synchronized (mutex) {\n", "        return list(delegate().get(key), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public List<V> removeAll(Object key) {\n", "      synchronized (mutex) {\n", "        return delegate().removeAll(key); // copy not synchronized\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public List<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      synchronized (mutex) {\n", "        return delegate().replaceValues(key, values); // copy not synchronized\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static <K, V> SetMultimap<K, V> setMultimap(SetMultimap<K, V> multimap, @Nullable Object mutex) {\n", "    if (multimap instanceof SynchronizedSetMultimap || multimap instanceof ImmutableSetMultimap) {\n", "      return multimap;\n", "    }\n", "    return new SynchronizedSetMultimap<K, V>(multimap, mutex);\n", "  }\n", "\n", "  private static class SynchronizedSetMultimap<K, V> extends SynchronizedMultimap<K, V>\n", "      implements SetMultimap<K, V> {\n", "    transient Set<Map.Entry<K, V>> entrySet;\n", "\n", "    SynchronizedSetMultimap(SetMultimap<K, V> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    SetMultimap<K, V> delegate() {\n", "      return (SetMultimap<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public Set<V> get(K key) {\n", "      synchronized (mutex) {\n", "        return set(delegate().get(key), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<V> removeAll(Object key) {\n", "      synchronized (mutex) {\n", "        return delegate().removeAll(key); // copy not synchronized\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      synchronized (mutex) {\n", "        return delegate().replaceValues(key, values); // copy not synchronized\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<Map.Entry<K, V>> entries() {\n", "      synchronized (mutex) {\n", "        if (entrySet == null) {\n", "          entrySet = set(delegate().entries(), mutex);\n", "        }\n", "        return entrySet;\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static <K, V> SortedSetMultimap<K, V> sortedSetMultimap(\n", "      SortedSetMultimap<K, V> multimap, @Nullable Object mutex) {\n", "    if (multimap instanceof SynchronizedSortedSetMultimap) {\n", "      return multimap;\n", "    }\n", "    return new SynchronizedSortedSetMultimap<K, V>(multimap, mutex);\n", "  }\n", "\n", "  private static class SynchronizedSortedSetMultimap<K, V> extends SynchronizedSetMultimap<K, V>\n", "      implements SortedSetMultimap<K, V> {\n", "    SynchronizedSortedSetMultimap(SortedSetMultimap<K, V> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    SortedSetMultimap<K, V> delegate() {\n", "      return (SortedSetMultimap<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> get(K key) {\n", "      synchronized (mutex) {\n", "        return sortedSet(delegate().get(key), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> removeAll(Object key) {\n", "      synchronized (mutex) {\n", "        return delegate().removeAll(key); // copy not synchronized\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedSet<V> replaceValues(K key, Iterable<? extends V> values) {\n", "      synchronized (mutex) {\n", "        return delegate().replaceValues(key, values); // copy not synchronized\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super V> valueComparator() {\n", "      synchronized (mutex) {\n", "        return delegate().valueComparator();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static <E> Collection<E> typePreservingCollection(\n", "      Collection<E> collection, @Nullable Object mutex) {\n", "    if (collection instanceof SortedSet) {\n", "      return sortedSet((SortedSet<E>) collection, mutex);\n", "    }\n", "    if (collection instanceof Set) {\n", "      return set((Set<E>) collection, mutex);\n", "    }\n", "    if (collection instanceof List) {\n", "      return list((List<E>) collection, mutex);\n", "    }\n", "    return collection(collection, mutex);\n", "  }\n", "\n", "  private static <E> Set<E> typePreservingSet(Set<E> set, @Nullable Object mutex) {\n", "    if (set instanceof SortedSet) {\n", "      return sortedSet((SortedSet<E>) set, mutex);\n", "    } else {\n", "      return set(set, mutex);\n", "    }\n", "  }\n", "\n", "  private static class SynchronizedAsMapEntries<K, V>\n", "      extends SynchronizedSet<Map.Entry<K, Collection<V>>> {\n", "    SynchronizedAsMapEntries(Set<Map.Entry<K, Collection<V>>> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    public Iterator<Map.Entry<K, Collection<V>>> iterator() {\n", "      // Must be manually synchronized.\n", "      return new TransformedIterator<Map.Entry<K, Collection<V>>, Map.Entry<K, Collection<V>>>(\n", "          super.iterator()) {\n", "        @Override\n", "        Map.Entry<K, Collection<V>> transform(final Map.Entry<K, Collection<V>> entry) {\n", "          return new ForwardingMapEntry<K, Collection<V>>() {\n", "            @Override\n", "            protected Map.Entry<K, Collection<V>> delegate() {\n", "              return entry;\n", "            }\n", "\n", "            @Override\n", "            public Collection<V> getValue() {\n", "              return typePreservingCollection(entry.getValue(), mutex);\n", "            }\n", "          };\n", "        }\n", "      };\n", "    }\n", "\n", "    // See Collections.CheckedMap.CheckedEntrySet for details on attacks.\n", "\n", "    @Override\n", "    public Object[] toArray() {\n", "      synchronized (mutex) {\n", "        return ObjectArrays.toArrayImpl(delegate());\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public <T> T[] toArray(T[] array) {\n", "      synchronized (mutex) {\n", "        return ObjectArrays.toArrayImpl(delegate(), array);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object o) {\n", "      synchronized (mutex) {\n", "        return Maps.containsEntryImpl(delegate(), o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean containsAll(Collection<?> c) {\n", "      synchronized (mutex) {\n", "        return Collections2.containsAllImpl(delegate(), c);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object o) {\n", "      if (o == this) {\n", "        return true;\n", "      }\n", "      synchronized (mutex) {\n", "        return Sets.equalsImpl(delegate(), o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean remove(Object o) {\n", "      synchronized (mutex) {\n", "        return Maps.removeEntryImpl(delegate(), o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean removeAll(Collection<?> c) {\n", "      synchronized (mutex) {\n", "        return Iterators.removeAll(delegate().iterator(), c);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean retainAll(Collection<?> c) {\n", "      synchronized (mutex) {\n", "        return Iterators.retainAll(delegate().iterator(), c);\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  @VisibleForTesting\n", "  static <K, V> Map<K, V> map(Map<K, V> map, @Nullable Object mutex) {\n", "    return new SynchronizedMap<K, V>(map, mutex);\n", "  }\n", "\n", "  private static class SynchronizedMap<K, V> extends SynchronizedObject implements Map<K, V> {\n", "    transient Set<K> keySet;\n", "    transient Collection<V> values;\n", "    transient Set<Map.Entry<K, V>> entrySet;\n", "\n", "    SynchronizedMap(Map<K, V> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    Map<K, V> delegate() {\n", "      return (Map<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public void clear() {\n", "      synchronized (mutex) {\n", "        delegate().clear();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean containsKey(Object key) {\n", "      synchronized (mutex) {\n", "        return delegate().containsKey(key);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean containsValue(Object value) {\n", "      synchronized (mutex) {\n", "        return delegate().containsValue(value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<Map.Entry<K, V>> entrySet() {\n", "      synchronized (mutex) {\n", "        if (entrySet == null) {\n", "          entrySet = set(delegate().entrySet(), mutex);\n", "        }\n", "        return entrySet;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V get(Object key) {\n", "      synchronized (mutex) {\n", "        return delegate().get(key);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      synchronized (mutex) {\n", "        return delegate().isEmpty();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<K> keySet() {\n", "      synchronized (mutex) {\n", "        if (keySet == null) {\n", "          keySet = set(delegate().keySet(), mutex);\n", "        }\n", "        return keySet;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V put(K key, V value) {\n", "      synchronized (mutex) {\n", "        return delegate().put(key, value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public void putAll(Map<? extends K, ? extends V> map) {\n", "      synchronized (mutex) {\n", "        delegate().putAll(map);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V remove(Object key) {\n", "      synchronized (mutex) {\n", "        return delegate().remove(key);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      synchronized (mutex) {\n", "        return delegate().size();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> values() {\n", "      synchronized (mutex) {\n", "        if (values == null) {\n", "          values = collection(delegate().values(), mutex);\n", "        }\n", "        return values;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object o) {\n", "      if (o == this) {\n", "        return true;\n", "      }\n", "      synchronized (mutex) {\n", "        return delegate().equals(o);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      synchronized (mutex) {\n", "        return delegate().hashCode();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static <K, V> SortedMap<K, V> sortedMap(SortedMap<K, V> sortedMap, @Nullable Object mutex) {\n", "    return new SynchronizedSortedMap<K, V>(sortedMap, mutex);\n", "  }\n", "\n", "  static class SynchronizedSortedMap<K, V> extends SynchronizedMap<K, V>\n", "      implements SortedMap<K, V> {\n", "\n", "    SynchronizedSortedMap(SortedMap<K, V> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    SortedMap<K, V> delegate() {\n", "      return (SortedMap<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public Comparator<? super K> comparator() {\n", "      synchronized (mutex) {\n", "        return delegate().comparator();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public K firstKey() {\n", "      synchronized (mutex) {\n", "        return delegate().firstKey();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> headMap(K toKey) {\n", "      synchronized (mutex) {\n", "        return sortedMap(delegate().headMap(toKey), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public K lastKey() {\n", "      synchronized (mutex) {\n", "        return delegate().lastKey();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n", "      synchronized (mutex) {\n", "        return sortedMap(delegate().subMap(fromKey, toKey), mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public SortedMap<K, V> tailMap(K fromKey) {\n", "      synchronized (mutex) {\n", "        return sortedMap(delegate().tailMap(fromKey), mutex);\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static <K, V> BiMap<K, V> biMap(BiMap<K, V> bimap, @Nullable Object mutex) {\n", "    if (bimap instanceof SynchronizedBiMap || bimap instanceof ImmutableBiMap) {\n", "      return bimap;\n", "    }\n", "    return new SynchronizedBiMap<K, V>(bimap, mutex, null);\n", "  }\n", "\n", "  @VisibleForTesting\n", "  static class SynchronizedBiMap<K, V> extends SynchronizedMap<K, V>\n", "      implements BiMap<K, V>, Serializable {\n", "    private transient Set<V> valueSet;\n", "    private transient BiMap<V, K> inverse;\n", "\n", "    private SynchronizedBiMap(\n", "        BiMap<K, V> delegate, @Nullable Object mutex, @Nullable BiMap<V, K> inverse) {\n", "      super(delegate, mutex);\n", "      this.inverse = inverse;\n", "    }\n", "\n", "    @Override\n", "    BiMap<K, V> delegate() {\n", "      return (BiMap<K, V>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public Set<V> values() {\n", "      synchronized (mutex) {\n", "        if (valueSet == null) {\n", "          valueSet = set(delegate().values(), mutex);\n", "        }\n", "        return valueSet;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public V forcePut(K key, V value) {\n", "      synchronized (mutex) {\n", "        return delegate().forcePut(key, value);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public BiMap<V, K> inverse() {\n", "      synchronized (mutex) {\n", "        if (inverse == null) {\n", "          inverse = new SynchronizedBiMap<V, K>(delegate().inverse(), mutex, this);\n", "        }\n", "        return inverse;\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static class SynchronizedAsMap<K, V> extends SynchronizedMap<K, Collection<V>> {\n", "    transient Set<Map.Entry<K, Collection<V>>> asMapEntrySet;\n", "    transient Collection<Collection<V>> asMapValues;\n", "\n", "    SynchronizedAsMap(Map<K, Collection<V>> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    public Collection<V> get(Object key) {\n", "      synchronized (mutex) {\n", "        Collection<V> collection = super.get(key);\n", "        return (collection == null) ? null : typePreservingCollection(collection, mutex);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Set<Map.Entry<K, Collection<V>>> entrySet() {\n", "      synchronized (mutex) {\n", "        if (asMapEntrySet == null) {\n", "          asMapEntrySet = new SynchronizedAsMapEntries<K, V>(delegate().entrySet(), mutex);\n", "        }\n", "        return asMapEntrySet;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public Collection<Collection<V>> values() {\n", "      synchronized (mutex) {\n", "        if (asMapValues == null) {\n", "          asMapValues = new SynchronizedAsMapValues<V>(delegate().values(), mutex);\n", "        }\n", "        return asMapValues;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean containsValue(Object o) {\n", "      // values() and its contains() method are both synchronized.\n", "      return values().contains(o);\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static class SynchronizedAsMapValues<V> extends SynchronizedCollection<Collection<V>> {\n", "    SynchronizedAsMapValues(Collection<Collection<V>> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    public Iterator<Collection<V>> iterator() {\n", "      // Must be manually synchronized.\n", "      return new TransformedIterator<Collection<V>, Collection<V>>(super.iterator()) {\n", "        @Override\n", "        Collection<V> transform(Collection<V> from) {\n", "          return typePreservingCollection(from, mutex);\n", "        }\n", "      };\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static <E> Queue<E> queue(Queue<E> queue, @Nullable Object mutex) {\n", "    return (queue instanceof SynchronizedQueue) ? queue : new SynchronizedQueue<E>(queue, mutex);\n", "  }\n", "\n", "  private static class SynchronizedQueue<E> extends SynchronizedCollection<E> implements Queue<E> {\n", "\n", "    SynchronizedQueue(Queue<E> delegate, @Nullable Object mutex) {\n", "      super(delegate, mutex);\n", "    }\n", "\n", "    @Override\n", "    Queue<E> delegate() {\n", "      return (Queue<E>) super.delegate();\n", "    }\n", "\n", "    @Override\n", "    public E element() {\n", "      synchronized (mutex) {\n", "        return delegate().element();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean offer(E e) {\n", "      synchronized (mutex) {\n", "        return delegate().offer(e);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public E peek() {\n", "      synchronized (mutex) {\n", "        return delegate().peek();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public E poll() {\n", "      synchronized (mutex) {\n", "        return delegate().poll();\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public E remove() {\n", "      synchronized (mutex) {\n", "        return delegate().remove();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307]}}, {"46": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeMultimap.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.Collection;\n", "import java.util.Comparator;\n", "import java.util.SortedSet;\n", "import java.util.TreeMap;\n", "import java.util.TreeSet;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Implementation of {@code Multimap} whose keys and values are ordered by\n", " * their natural ordering or by supplied comparators. In all cases, this\n", " * implementation uses {@link Comparable#compareTo} or {@link\n", " * Comparator#compare} instead of {@link Object#equals} to determine\n", " * equivalence of instances.\n", " *\n", " * <p><b>Warning:</b> The comparators or comparables used must be <i>consistent\n", " * with equals</i> as explained by the {@link Comparable} class specification.\n", " * Otherwise, the resulting multiset will violate the general contract of {@link\n", " * SetMultimap}, which it is specified in terms of {@link Object#equals}.\n", " *\n", " * <p>The collections returned by {@code keySet} and {@code asMap} iterate\n", " * through the keys according to the key comparator ordering or the natural\n", " * ordering of the keys. Similarly, {@code get}, {@code removeAll}, and {@code\n", " * replaceValues} return collections that iterate through the values according\n", " * to the value comparator ordering or the natural ordering of the values. The\n", " * collections generated by {@code entries}, {@code keys}, and {@code values}\n", " * iterate across the keys according to the above key ordering, and for each\n", " * key they iterate across the values according to the value ordering.\n", " *\n", " * <p>The multimap does not store duplicate key-value pairs. Adding a new\n", " * key-value pair equal to an existing key-value pair has no effect.\n", " *\n", " * <p>Null keys and values are permitted (provided, of course, that the\n", " * respective comparators support them). All optional multimap methods are\n", " * supported, and all returned views are modifiable.\n", " *\n", " * <p>This class is not threadsafe when any concurrent operations update the\n", " * multimap. Concurrent read operations will work correctly. To allow concurrent\n", " * update operations, wrap your multimap with a call to {@link\n", " * Multimaps#synchronizedSortedSetMultimap}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap\">\n", " * {@code Multimap}</a>.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " * @since 2.0\n", " */\n", "@GwtCompatible(serializable = true, emulated = true)\n", "public class TreeMultimap<K, V> extends AbstractSortedKeySortedSetMultimap<K, V> {\n", "  private transient Comparator<? super K> keyComparator;\n", "  private transient Comparator<? super V> valueComparator;\n", "\n", "  /**\n", "   * Creates an empty {@code TreeMultimap} ordered by the natural ordering of\n", "   * its keys and values.\n", "   */\n", "  public static <K extends Comparable, V extends Comparable> TreeMultimap<K, V> create() {\n", "    return new TreeMultimap<K, V>(Ordering.natural(), Ordering.natural());\n", "  }\n", "\n", "  /**\n", "   * Creates an empty {@code TreeMultimap} instance using explicit comparators.\n", "   * Neither comparator may be null; use {@link Ordering#natural()} to specify\n", "   * natural order.\n", "   *\n", "   * @param keyComparator the comparator that determines the key ordering\n", "   * @param valueComparator the comparator that determines the value ordering\n", "   */\n", "  public static <K, V> TreeMultimap<K, V> create(\n", "      Comparator<? super K> keyComparator, Comparator<? super V> valueComparator) {\n", "    return new TreeMultimap<K, V>(checkNotNull(keyComparator), checkNotNull(valueComparator));\n", "  }\n", "\n", "  /**\n", "   * Constructs a {@code TreeMultimap}, ordered by the natural ordering of its\n", "   * keys and values, with the same mappings as the specified multimap.\n", "   *\n", "   * @param multimap the multimap whose contents are copied to this multimap\n", "   */\n", "  public static <K extends Comparable, V extends Comparable> TreeMultimap<K, V> create(\n", "      Multimap<? extends K, ? extends V> multimap) {\n", "    return new TreeMultimap<K, V>(Ordering.natural(), Ordering.natural(), multimap);\n", "  }\n", "\n", "  TreeMultimap(Comparator<? super K> keyComparator, Comparator<? super V> valueComparator) {\n", "    super(new TreeMap<K, Collection<V>>(keyComparator));\n", "    this.keyComparator = keyComparator;\n", "    this.valueComparator = valueComparator;\n", "  }\n", "\n", "  private TreeMultimap(\n", "      Comparator<? super K> keyComparator,\n", "      Comparator<? super V> valueComparator,\n", "      Multimap<? extends K, ? extends V> multimap) {\n", "    this(keyComparator, valueComparator);\n", "    putAll(multimap);\n", "  }\n", "\n", "  /**\n", "   * {@inheritDoc}\n", "   *\n", "   * <p>Creates an empty {@code TreeSet} for a collection of values for one key.\n", "   *\n", "   * @return a new {@code TreeSet} containing a collection of values for one\n", "   *     key\n", "   */\n", "  @Override\n", "  SortedSet<V> createCollection() {\n", "    return new TreeSet<V>(valueComparator);\n", "  }\n", "\n", "  @Override\n", "  Collection<V> createCollection(@Nullable K key) {\n", "    if (key == null) {\n", "      keyComparator().compare(key, key);\n", "    }\n", "    return super.createCollection(key);\n", "  }\n", "\n", "  /**\n", "   * Returns the comparator that orders the multimap keys.\n", "   */\n", "  public Comparator<? super K> keyComparator() {\n", "    return keyComparator;\n", "  }\n", "\n", "  @Override\n", "  public Comparator<? super V> valueComparator() {\n", "    return valueComparator;\n", "  }\n", "\n", "  /*\n", "   * The following @GwtIncompatible methods override the methods in\n", "   * AbstractSortedKeySortedSetMultimap, so GWT will fall back to the ASKSSM implementations,\n", "   * which return SortedSets and SortedMaps.\n", "   */\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162]}}, {"47": "guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/TreeMultiset.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.MoreObjects;\n", "import com.google.common.primitives.Ints;\n", "\n", "import java.io.Serializable;\n", "import java.util.Comparator;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "import java.util.NoSuchElementException;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A multiset which maintains the ordering of its elements, according to either their natural order\n", " * or an explicit {@link Comparator}. In all cases, this implementation uses\n", " * {@link Comparable#compareTo} or {@link Comparator#compare} instead of {@link Object#equals} to\n", " * determine equivalence of instances.\n", " *\n", " * <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as explained by the\n", " * {@link Comparable} class specification. Otherwise, the resulting multiset will violate the\n", " * {@link java.util.Collection} contract, which is specified in terms of {@link Object#equals}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset\">\n", " * {@code Multiset}</a>.\n", " *\n", " * @author Louis Wasserman\n", " * @author Jared Levy\n", " * @since 2.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class TreeMultiset<E> extends AbstractSortedMultiset<E> implements Serializable {\n", "\n", "  /**\n", "   * Creates a new, empty multiset, sorted according to the elements' natural order. All elements\n", "   * inserted into the multiset must implement the {@code Comparable} interface. Furthermore, all\n", "   * such elements must be <i>mutually comparable</i>: {@code e1.compareTo(e2)} must not throw a\n", "   * {@code ClassCastException} for any elements {@code e1} and {@code e2} in the multiset. If the\n", "   * user attempts to add an element to the multiset that violates this constraint (for example,\n", "   * the user attempts to add a string element to a set whose elements are integers), the\n", "   * {@code add(Object)} call will throw a {@code ClassCastException}.\n", "   *\n", "   * <p>The type specification is {@code <E extends Comparable>}, instead of the more specific\n", "   * {@code <E extends Comparable<? super E>>}, to support classes defined without generics.\n", "   */\n", "  public static <E extends Comparable> TreeMultiset<E> create() {\n", "    return new TreeMultiset<E>(Ordering.natural());\n", "  }\n", "\n", "  /**\n", "   * Creates a new, empty multiset, sorted according to the specified comparator. All elements\n", "   * inserted into the multiset must be <i>mutually comparable</i> by the specified comparator:\n", "   * {@code comparator.compare(e1,\n", "   * e2)} must not throw a {@code ClassCastException} for any elements {@code e1} and {@code e2} in\n", "   * the multiset. If the user attempts to add an element to the multiset that violates this\n", "   * constraint, the {@code add(Object)} call will throw a {@code ClassCastException}.\n", "   *\n", "   * @param comparator\n", "   *          the comparator that will be used to sort this multiset. A null value indicates that\n", "   *          the elements' <i>natural ordering</i> should be used.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public static <E> TreeMultiset<E> create(@Nullable Comparator<? super E> comparator) {\n", "    return (comparator == null)\n", "        ? new TreeMultiset<E>((Comparator) Ordering.natural())\n", "        : new TreeMultiset<E>(comparator);\n", "  }\n", "\n", "  /**\n", "   * Creates an empty multiset containing the given initial elements, sorted according to the\n", "   * elements' natural order.\n", "   *\n", "   * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.\n", "   *\n", "   * <p>The type specification is {@code <E extends Comparable>}, instead of the more specific\n", "   * {@code <E extends Comparable<? super E>>}, to support classes defined without generics.\n", "   */\n", "  public static <E extends Comparable> TreeMultiset<E> create(Iterable<? extends E> elements) {\n", "    TreeMultiset<E> multiset = create();\n", "    Iterables.addAll(multiset, elements);\n", "    return multiset;\n", "  }\n", "\n", "  private final transient Reference<AvlNode<E>> rootReference;\n", "  private final transient GeneralRange<E> range;\n", "  private final transient AvlNode<E> header;\n", "\n", "  TreeMultiset(Reference<AvlNode<E>> rootReference, GeneralRange<E> range, AvlNode<E> endLink) {\n", "    super(range.comparator());\n", "    this.rootReference = rootReference;\n", "    this.range = range;\n", "    this.header = endLink;\n", "  }\n", "\n", "  TreeMultiset(Comparator<? super E> comparator) {\n", "    super(comparator);\n", "    this.range = GeneralRange.all(comparator);\n", "    this.header = new AvlNode<E>(null, 1);\n", "    successor(header, header);\n", "    this.rootReference = new Reference<AvlNode<E>>();\n", "  }\n", "\n", "  /**\n", "   * A function which can be summed across a subtree.\n", "   */\n", "  private enum Aggregate {\n", "    SIZE {\n", "      @Override\n", "      int nodeAggregate(AvlNode<?> node) {\n", "        return node.elemCount;\n", "      }\n", "\n", "      @Override\n", "      long treeAggregate(@Nullable AvlNode<?> root) {\n", "        return (root == null) ? 0 : root.totalCount;\n", "      }\n", "    },\n", "    DISTINCT {\n", "      @Override\n", "      int nodeAggregate(AvlNode<?> node) {\n", "        return 1;\n", "      }\n", "\n", "      @Override\n", "      long treeAggregate(@Nullable AvlNode<?> root) {\n", "        return (root == null) ? 0 : root.distinctElements;\n", "      }\n", "    };\n", "\n", "    abstract int nodeAggregate(AvlNode<?> node);\n", "\n", "    abstract long treeAggregate(@Nullable AvlNode<?> root);\n", "  }\n", "\n", "  private long aggregateForEntries(Aggregate aggr) {\n", "    AvlNode<E> root = rootReference.get();\n", "    long total = aggr.treeAggregate(root);\n", "    if (range.hasLowerBound()) {\n", "      total -= aggregateBelowRange(aggr, root);\n", "    }\n", "    if (range.hasUpperBound()) {\n", "      total -= aggregateAboveRange(aggr, root);\n", "    }\n", "    return total;\n", "  }\n", "\n", "  private long aggregateBelowRange(Aggregate aggr, @Nullable AvlNode<E> node) {\n", "    if (node == null) {\n", "      return 0;\n", "    }\n", "    int cmp = comparator().compare(range.getLowerEndpoint(), node.elem);\n", "    if (cmp < 0) {\n", "      return aggregateBelowRange(aggr, node.left);\n", "    } else if (cmp == 0) {\n", "      switch (range.getLowerBoundType()) {\n", "        case OPEN:\n", "          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.left);\n", "        case CLOSED:\n", "          return aggr.treeAggregate(node.left);\n", "        default:\n", "          throw new AssertionError();\n", "      }\n", "    } else {\n", "      return aggr.treeAggregate(node.left)\n", "          + aggr.nodeAggregate(node)\n", "          + aggregateBelowRange(aggr, node.right);\n", "    }\n", "  }\n", "\n", "  private long aggregateAboveRange(Aggregate aggr, @Nullable AvlNode<E> node) {\n", "    if (node == null) {\n", "      return 0;\n", "    }\n", "    int cmp = comparator().compare(range.getUpperEndpoint(), node.elem);\n", "    if (cmp > 0) {\n", "      return aggregateAboveRange(aggr, node.right);\n", "    } else if (cmp == 0) {\n", "      switch (range.getUpperBoundType()) {\n", "        case OPEN:\n", "          return aggr.nodeAggregate(node) + aggr.treeAggregate(node.right);\n", "        case CLOSED:\n", "          return aggr.treeAggregate(node.right);\n", "        default:\n", "          throw new AssertionError();\n", "      }\n", "    } else {\n", "      return aggr.treeAggregate(node.right)\n", "          + aggr.nodeAggregate(node)\n", "          + aggregateAboveRange(aggr, node.left);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public int size() {\n", "    return Ints.saturatedCast(aggregateForEntries(Aggregate.SIZE));\n", "  }\n", "\n", "  @Override\n", "  int distinctElements() {\n", "    return Ints.saturatedCast(aggregateForEntries(Aggregate.DISTINCT));\n", "  }\n", "\n", "  @Override\n", "  public int count(@Nullable Object element) {\n", "    try {\n", "      @SuppressWarnings(\"unchecked\")\n", "      E e = (E) element;\n", "      AvlNode<E> root = rootReference.get();\n", "      if (!range.contains(e) || root == null) {\n", "        return 0;\n", "      }\n", "      return root.count(comparator(), e);\n", "    } catch (ClassCastException e) {\n", "      return 0;\n", "    } catch (NullPointerException e) {\n", "      return 0;\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public int add(@Nullable E element, int occurrences) {\n", "    checkNonnegative(occurrences, \"occurrences\");\n", "    if (occurrences == 0) {\n", "      return count(element);\n", "    }\n", "    checkArgument(range.contains(element));\n", "    AvlNode<E> root = rootReference.get();\n", "    if (root == null) {\n", "      comparator().compare(element, element);\n", "      AvlNode<E> newRoot = new AvlNode<E>(element, occurrences);\n", "      successor(header, newRoot, header);\n", "      rootReference.checkAndSet(root, newRoot);\n", "      return 0;\n", "    }\n", "    int[] result = new int[1]; // used as a mutable int reference to hold result\n", "    AvlNode<E> newRoot = root.add(comparator(), element, occurrences, result);\n", "    rootReference.checkAndSet(root, newRoot);\n", "    return result[0];\n", "  }\n", "\n", "  @Override\n", "  public int remove(@Nullable Object element, int occurrences) {\n", "    checkNonnegative(occurrences, \"occurrences\");\n", "    if (occurrences == 0) {\n", "      return count(element);\n", "    }\n", "    AvlNode<E> root = rootReference.get();\n", "    int[] result = new int[1]; // used as a mutable int reference to hold result\n", "    AvlNode<E> newRoot;\n", "    try {\n", "      @SuppressWarnings(\"unchecked\")\n", "      E e = (E) element;\n", "      if (!range.contains(e) || root == null) {\n", "        return 0;\n", "      }\n", "      newRoot = root.remove(comparator(), e, occurrences, result);\n", "    } catch (ClassCastException e) {\n", "      return 0;\n", "    } catch (NullPointerException e) {\n", "      return 0;\n", "    }\n", "    rootReference.checkAndSet(root, newRoot);\n", "    return result[0];\n", "  }\n", "\n", "  @Override\n", "  public int setCount(@Nullable E element, int count) {\n", "    checkNonnegative(count, \"count\");\n", "    if (!range.contains(element)) {\n", "      checkArgument(count == 0);\n", "      return 0;\n", "    }\n", "\n", "    AvlNode<E> root = rootReference.get();\n", "    if (root == null) {\n", "      if (count > 0) {\n", "        add(element, count);\n", "      }\n", "      return 0;\n", "    }\n", "    int[] result = new int[1]; // used as a mutable int reference to hold result\n", "    AvlNode<E> newRoot = root.setCount(comparator(), element, count, result);\n", "    rootReference.checkAndSet(root, newRoot);\n", "    return result[0];\n", "  }\n", "\n", "  @Override\n", "  public boolean setCount(@Nullable E element, int oldCount, int newCount) {\n", "    checkNonnegative(newCount, \"newCount\");\n", "    checkNonnegative(oldCount, \"oldCount\");\n", "    checkArgument(range.contains(element));\n", "\n", "    AvlNode<E> root = rootReference.get();\n", "    if (root == null) {\n", "      if (oldCount == 0) {\n", "        if (newCount > 0) {\n", "          add(element, newCount);\n", "        }\n", "        return true;\n", "      } else {\n", "        return false;\n", "      }\n", "    }\n", "    int[] result = new int[1]; // used as a mutable int reference to hold result\n", "    AvlNode<E> newRoot = root.setCount(comparator(), element, oldCount, newCount, result);\n", "    rootReference.checkAndSet(root, newRoot);\n", "    return result[0] == oldCount;\n", "  }\n", "\n", "  private Entry<E> wrapEntry(final AvlNode<E> baseEntry) {\n", "    return new Multisets.AbstractEntry<E>() {\n", "      @Override\n", "      public E getElement() {\n", "        return baseEntry.getElement();\n", "      }\n", "\n", "      @Override\n", "      public int getCount() {\n", "        int result = baseEntry.getCount();\n", "        if (result == 0) {\n", "          return count(getElement());\n", "        } else {\n", "          return result;\n", "        }\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns the first node in the tree that is in range.\n", "   */\n", "  @Nullable\n", "  private AvlNode<E> firstNode() {\n", "    AvlNode<E> root = rootReference.get();\n", "    if (root == null) {\n", "      return null;\n", "    }\n", "    AvlNode<E> node;\n", "    if (range.hasLowerBound()) {\n", "      E endpoint = range.getLowerEndpoint();\n", "      node = rootReference.get().ceiling(comparator(), endpoint);\n", "      if (node == null) {\n", "        return null;\n", "      }\n", "      if (range.getLowerBoundType() == BoundType.OPEN\n", "          && comparator().compare(endpoint, node.getElement()) == 0) {\n", "        node = node.succ;\n", "      }\n", "    } else {\n", "      node = header.succ;\n", "    }\n", "    return (node == header || !range.contains(node.getElement())) ? null : node;\n", "  }\n", "\n", "  @Nullable\n", "  private AvlNode<E> lastNode() {\n", "    AvlNode<E> root = rootReference.get();\n", "    if (root == null) {\n", "      return null;\n", "    }\n", "    AvlNode<E> node;\n", "    if (range.hasUpperBound()) {\n", "      E endpoint = range.getUpperEndpoint();\n", "      node = rootReference.get().floor(comparator(), endpoint);\n", "      if (node == null) {\n", "        return null;\n", "      }\n", "      if (range.getUpperBoundType() == BoundType.OPEN\n", "          && comparator().compare(endpoint, node.getElement()) == 0) {\n", "        node = node.pred;\n", "      }\n", "    } else {\n", "      node = header.pred;\n", "    }\n", "    return (node == header || !range.contains(node.getElement())) ? null : node;\n", "  }\n", "\n", "  @Override\n", "  Iterator<Entry<E>> entryIterator() {\n", "    return new Iterator<Entry<E>>() {\n", "      AvlNode<E> current = firstNode();\n", "      Entry<E> prevEntry;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        if (current == null) {\n", "          return false;\n", "        } else if (range.tooHigh(current.getElement())) {\n", "          current = null;\n", "          return false;\n", "        } else {\n", "          return true;\n", "        }\n", "      }\n", "\n", "      @Override\n", "      public Entry<E> next() {\n", "        if (!hasNext()) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        Entry<E> result = wrapEntry(current);\n", "        prevEntry = result;\n", "        if (current.succ == header) {\n", "          current = null;\n", "        } else {\n", "          current = current.succ;\n", "        }\n", "        return result;\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        checkRemove(prevEntry != null);\n", "        setCount(prevEntry.getElement(), 0);\n", "        prevEntry = null;\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  Iterator<Entry<E>> descendingEntryIterator() {\n", "    return new Iterator<Entry<E>>() {\n", "      AvlNode<E> current = lastNode();\n", "      Entry<E> prevEntry = null;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        if (current == null) {\n", "          return false;\n", "        } else if (range.tooLow(current.getElement())) {\n", "          current = null;\n", "          return false;\n", "        } else {\n", "          return true;\n", "        }\n", "      }\n", "\n", "      @Override\n", "      public Entry<E> next() {\n", "        if (!hasNext()) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        Entry<E> result = wrapEntry(current);\n", "        prevEntry = result;\n", "        if (current.pred == header) {\n", "          current = null;\n", "        } else {\n", "          current = current.pred;\n", "        }\n", "        return result;\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        checkRemove(prevEntry != null);\n", "        setCount(prevEntry.getElement(), 0);\n", "        prevEntry = null;\n", "      }\n", "    };\n", "  }\n", "\n", "  @Override\n", "  public SortedMultiset<E> headMultiset(@Nullable E upperBound, BoundType boundType) {\n", "    return new TreeMultiset<E>(\n", "        rootReference,\n", "        range.intersect(GeneralRange.upTo(comparator(), upperBound, boundType)),\n", "        header);\n", "  }\n", "\n", "  @Override\n", "  public SortedMultiset<E> tailMultiset(@Nullable E lowerBound, BoundType boundType) {\n", "    return new TreeMultiset<E>(\n", "        rootReference,\n", "        range.intersect(GeneralRange.downTo(comparator(), lowerBound, boundType)),\n", "        header);\n", "  }\n", "\n", "  static int distinctElements(@Nullable AvlNode<?> node) {\n", "    return (node == null) ? 0 : node.distinctElements;\n", "  }\n", "\n", "  private static final class Reference<T> {\n", "    @Nullable private T value;\n", "\n", "    @Nullable\n", "    public T get() {\n", "      return value;\n", "    }\n", "\n", "    public void checkAndSet(@Nullable T expected, T newValue) {\n", "      if (value != expected) {\n", "        throw new ConcurrentModificationException();\n", "      }\n", "      value = newValue;\n", "    }\n", "  }\n", "\n", "  private static final class AvlNode<E> extends Multisets.AbstractEntry<E> {\n", "    @Nullable private final E elem;\n", "\n", "    // elemCount is 0 iff this node has been deleted.\n", "    private int elemCount;\n", "\n", "    private int distinctElements;\n", "    private long totalCount;\n", "    private int height;\n", "    private AvlNode<E> left;\n", "    private AvlNode<E> right;\n", "    private AvlNode<E> pred;\n", "    private AvlNode<E> succ;\n", "\n", "    AvlNode(@Nullable E elem, int elemCount) {\n", "      checkArgument(elemCount > 0);\n", "      this.elem = elem;\n", "      this.elemCount = elemCount;\n", "      this.totalCount = elemCount;\n", "      this.distinctElements = 1;\n", "      this.height = 1;\n", "      this.left = null;\n", "      this.right = null;\n", "    }\n", "\n", "    public int count(Comparator<? super E> comparator, E e) {\n", "      int cmp = comparator.compare(e, elem);\n", "      if (cmp < 0) {\n", "        return (left == null) ? 0 : left.count(comparator, e);\n", "      } else if (cmp > 0) {\n", "        return (right == null) ? 0 : right.count(comparator, e);\n", "      } else {\n", "        return elemCount;\n", "      }\n", "    }\n", "\n", "    private AvlNode<E> addRightChild(E e, int count) {\n", "      right = new AvlNode<E>(e, count);\n", "      successor(this, right, succ);\n", "      height = Math.max(2, height);\n", "      distinctElements++;\n", "      totalCount += count;\n", "      return this;\n", "    }\n", "\n", "    private AvlNode<E> addLeftChild(E e, int count) {\n", "      left = new AvlNode<E>(e, count);\n", "      successor(pred, left, this);\n", "      height = Math.max(2, height);\n", "      distinctElements++;\n", "      totalCount += count;\n", "      return this;\n", "    }\n", "\n", "    AvlNode<E> add(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n", "      /*\n", "       * It speeds things up considerably to unconditionally add count to totalCount here,\n", "       * but that destroys failure atomicity in the case of count overflow. =(\n", "       */\n", "      int cmp = comparator.compare(e, elem);\n", "      if (cmp < 0) {\n", "        AvlNode<E> initLeft = left;\n", "        if (initLeft == null) {\n", "          result[0] = 0;\n", "          return addLeftChild(e, count);\n", "        }\n", "        int initHeight = initLeft.height;\n", "\n", "        left = initLeft.add(comparator, e, count, result);\n", "        if (result[0] == 0) {\n", "          distinctElements++;\n", "        }\n", "        this.totalCount += count;\n", "        return (left.height == initHeight) ? this : rebalance();\n", "      } else if (cmp > 0) {\n", "        AvlNode<E> initRight = right;\n", "        if (initRight == null) {\n", "          result[0] = 0;\n", "          return addRightChild(e, count);\n", "        }\n", "        int initHeight = initRight.height;\n", "\n", "        right = initRight.add(comparator, e, count, result);\n", "        if (result[0] == 0) {\n", "          distinctElements++;\n", "        }\n", "        this.totalCount += count;\n", "        return (right.height == initHeight) ? this : rebalance();\n", "      }\n", "\n", "      // adding count to me!  No rebalance possible.\n", "      result[0] = elemCount;\n", "      long resultCount = (long) elemCount + count;\n", "      checkArgument(resultCount <= Integer.MAX_VALUE);\n", "      this.elemCount += count;\n", "      this.totalCount += count;\n", "      return this;\n", "    }\n", "\n", "    AvlNode<E> remove(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n", "      int cmp = comparator.compare(e, elem);\n", "      if (cmp < 0) {\n", "        AvlNode<E> initLeft = left;\n", "        if (initLeft == null) {\n", "          result[0] = 0;\n", "          return this;\n", "        }\n", "\n", "        left = initLeft.remove(comparator, e, count, result);\n", "\n", "        if (result[0] > 0) {\n", "          if (count >= result[0]) {\n", "            this.distinctElements--;\n", "            this.totalCount -= result[0];\n", "          } else {\n", "            this.totalCount -= count;\n", "          }\n", "        }\n", "        return (result[0] == 0) ? this : rebalance();\n", "      } else if (cmp > 0) {\n", "        AvlNode<E> initRight = right;\n", "        if (initRight == null) {\n", "          result[0] = 0;\n", "          return this;\n", "        }\n", "\n", "        right = initRight.remove(comparator, e, count, result);\n", "\n", "        if (result[0] > 0) {\n", "          if (count >= result[0]) {\n", "            this.distinctElements--;\n", "            this.totalCount -= result[0];\n", "          } else {\n", "            this.totalCount -= count;\n", "          }\n", "        }\n", "        return rebalance();\n", "      }\n", "\n", "      // removing count from me!\n", "      result[0] = elemCount;\n", "      if (count >= elemCount) {\n", "        return deleteMe();\n", "      } else {\n", "        this.elemCount -= count;\n", "        this.totalCount -= count;\n", "        return this;\n", "      }\n", "    }\n", "\n", "    AvlNode<E> setCount(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n", "      int cmp = comparator.compare(e, elem);\n", "      if (cmp < 0) {\n", "        AvlNode<E> initLeft = left;\n", "        if (initLeft == null) {\n", "          result[0] = 0;\n", "          return (count > 0) ? addLeftChild(e, count) : this;\n", "        }\n", "\n", "        left = initLeft.setCount(comparator, e, count, result);\n", "\n", "        if (count == 0 && result[0] != 0) {\n", "          this.distinctElements--;\n", "        } else if (count > 0 && result[0] == 0) {\n", "          this.distinctElements++;\n", "        }\n", "\n", "        this.totalCount += count - result[0];\n", "        return rebalance();\n", "      } else if (cmp > 0) {\n", "        AvlNode<E> initRight = right;\n", "        if (initRight == null) {\n", "          result[0] = 0;\n", "          return (count > 0) ? addRightChild(e, count) : this;\n", "        }\n", "\n", "        right = initRight.setCount(comparator, e, count, result);\n", "\n", "        if (count == 0 && result[0] != 0) {\n", "          this.distinctElements--;\n", "        } else if (count > 0 && result[0] == 0) {\n", "          this.distinctElements++;\n", "        }\n", "\n", "        this.totalCount += count - result[0];\n", "        return rebalance();\n", "      }\n", "\n", "      // setting my count\n", "      result[0] = elemCount;\n", "      if (count == 0) {\n", "        return deleteMe();\n", "      }\n", "      this.totalCount += count - elemCount;\n", "      this.elemCount = count;\n", "      return this;\n", "    }\n", "\n", "    AvlNode<E> setCount(\n", "        Comparator<? super E> comparator,\n", "        @Nullable E e,\n", "        int expectedCount,\n", "        int newCount,\n", "        int[] result) {\n", "      int cmp = comparator.compare(e, elem);\n", "      if (cmp < 0) {\n", "        AvlNode<E> initLeft = left;\n", "        if (initLeft == null) {\n", "          result[0] = 0;\n", "          if (expectedCount == 0 && newCount > 0) {\n", "            return addLeftChild(e, newCount);\n", "          }\n", "          return this;\n", "        }\n", "\n", "        left = initLeft.setCount(comparator, e, expectedCount, newCount, result);\n", "\n", "        if (result[0] == expectedCount) {\n", "          if (newCount == 0 && result[0] != 0) {\n", "            this.distinctElements--;\n", "          } else if (newCount > 0 && result[0] == 0) {\n", "            this.distinctElements++;\n", "          }\n", "          this.totalCount += newCount - result[0];\n", "        }\n", "        return rebalance();\n", "      } else if (cmp > 0) {\n", "        AvlNode<E> initRight = right;\n", "        if (initRight == null) {\n", "          result[0] = 0;\n", "          if (expectedCount == 0 && newCount > 0) {\n", "            return addRightChild(e, newCount);\n", "          }\n", "          return this;\n", "        }\n", "\n", "        right = initRight.setCount(comparator, e, expectedCount, newCount, result);\n", "\n", "        if (result[0] == expectedCount) {\n", "          if (newCount == 0 && result[0] != 0) {\n", "            this.distinctElements--;\n", "          } else if (newCount > 0 && result[0] == 0) {\n", "            this.distinctElements++;\n", "          }\n", "          this.totalCount += newCount - result[0];\n", "        }\n", "        return rebalance();\n", "      }\n", "\n", "      // setting my count\n", "      result[0] = elemCount;\n", "      if (expectedCount == elemCount) {\n", "        if (newCount == 0) {\n", "          return deleteMe();\n", "        }\n", "        this.totalCount += newCount - elemCount;\n", "        this.elemCount = newCount;\n", "      }\n", "      return this;\n", "    }\n", "\n", "    private AvlNode<E> deleteMe() {\n", "      int oldElemCount = this.elemCount;\n", "      this.elemCount = 0;\n", "      successor(pred, succ);\n", "      if (left == null) {\n", "        return right;\n", "      } else if (right == null) {\n", "        return left;\n", "      } else if (left.height >= right.height) {\n", "        AvlNode<E> newTop = pred;\n", "        // newTop is the maximum node in my left subtree\n", "        newTop.left = left.removeMax(newTop);\n", "        newTop.right = right;\n", "        newTop.distinctElements = distinctElements - 1;\n", "        newTop.totalCount = totalCount - oldElemCount;\n", "        return newTop.rebalance();\n", "      } else {\n", "        AvlNode<E> newTop = succ;\n", "        newTop.right = right.removeMin(newTop);\n", "        newTop.left = left;\n", "        newTop.distinctElements = distinctElements - 1;\n", "        newTop.totalCount = totalCount - oldElemCount;\n", "        return newTop.rebalance();\n", "      }\n", "    }\n", "\n", "    // Removes the minimum node from this subtree to be reused elsewhere\n", "    private AvlNode<E> removeMin(AvlNode<E> node) {\n", "      if (left == null) {\n", "        return right;\n", "      } else {\n", "        left = left.removeMin(node);\n", "        distinctElements--;\n", "        totalCount -= node.elemCount;\n", "        return rebalance();\n", "      }\n", "    }\n", "\n", "    // Removes the maximum node from this subtree to be reused elsewhere\n", "    private AvlNode<E> removeMax(AvlNode<E> node) {\n", "      if (right == null) {\n", "        return left;\n", "      } else {\n", "        right = right.removeMax(node);\n", "        distinctElements--;\n", "        totalCount -= node.elemCount;\n", "        return rebalance();\n", "      }\n", "    }\n", "\n", "    private void recomputeMultiset() {\n", "      this.distinctElements =\n", "          1 + TreeMultiset.distinctElements(left) + TreeMultiset.distinctElements(right);\n", "      this.totalCount = elemCount + totalCount(left) + totalCount(right);\n", "    }\n", "\n", "    private void recomputeHeight() {\n", "      this.height = 1 + Math.max(height(left), height(right));\n", "    }\n", "\n", "    private void recompute() {\n", "      recomputeMultiset();\n", "      recomputeHeight();\n", "    }\n", "\n", "    private AvlNode<E> rebalance() {\n", "      switch (balanceFactor()) {\n", "        case -2:\n", "          if (right.balanceFactor() > 0) {\n", "            right = right.rotateRight();\n", "          }\n", "          return rotateLeft();\n", "        case 2:\n", "          if (left.balanceFactor() < 0) {\n", "            left = left.rotateLeft();\n", "          }\n", "          return rotateRight();\n", "        default:\n", "          recomputeHeight();\n", "          return this;\n", "      }\n", "    }\n", "\n", "    private int balanceFactor() {\n", "      return height(left) - height(right);\n", "    }\n", "\n", "    private AvlNode<E> rotateLeft() {\n", "      checkState(right != null);\n", "      AvlNode<E> newTop = right;\n", "      this.right = newTop.left;\n", "      newTop.left = this;\n", "      newTop.totalCount = this.totalCount;\n", "      newTop.distinctElements = this.distinctElements;\n", "      this.recompute();\n", "      newTop.recomputeHeight();\n", "      return newTop;\n", "    }\n", "\n", "    private AvlNode<E> rotateRight() {\n", "      checkState(left != null);\n", "      AvlNode<E> newTop = left;\n", "      this.left = newTop.right;\n", "      newTop.right = this;\n", "      newTop.totalCount = this.totalCount;\n", "      newTop.distinctElements = this.distinctElements;\n", "      this.recompute();\n", "      newTop.recomputeHeight();\n", "      return newTop;\n", "    }\n", "\n", "    private static long totalCount(@Nullable AvlNode<?> node) {\n", "      return (node == null) ? 0 : node.totalCount;\n", "    }\n", "\n", "    private static int height(@Nullable AvlNode<?> node) {\n", "      return (node == null) ? 0 : node.height;\n", "    }\n", "\n", "    @Nullable\n", "    private AvlNode<E> ceiling(Comparator<? super E> comparator, E e) {\n", "      int cmp = comparator.compare(e, elem);\n", "      if (cmp < 0) {\n", "        return (left == null) ? this : MoreObjects.firstNonNull(left.ceiling(comparator, e), this);\n", "      } else if (cmp == 0) {\n", "        return this;\n", "      } else {\n", "        return (right == null) ? null : right.ceiling(comparator, e);\n", "      }\n", "    }\n", "\n", "    @Nullable\n", "    private AvlNode<E> floor(Comparator<? super E> comparator, E e) {\n", "      int cmp = comparator.compare(e, elem);\n", "      if (cmp > 0) {\n", "        return (right == null) ? this : MoreObjects.firstNonNull(right.floor(comparator, e), this);\n", "      } else if (cmp == 0) {\n", "        return this;\n", "      } else {\n", "        return (left == null) ? null : left.floor(comparator, e);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public E getElement() {\n", "      return elem;\n", "    }\n", "\n", "    @Override\n", "    public int getCount() {\n", "      return elemCount;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return Multisets.immutableEntry(getElement(), getCount()).toString();\n", "    }\n", "  }\n", "\n", "  private static <T> void successor(AvlNode<T> a, AvlNode<T> b) {\n", "    a.succ = b;\n", "    b.pred = a;\n", "  }\n", "\n", "  private static <T> void successor(AvlNode<T> a, AvlNode<T> b, AvlNode<T> c) {\n", "    successor(a, b);\n", "    successor(b, c);\n", "  }\n", "\n", "  /*\n", "   * TODO(jlevy): Decide whether entrySet() should return entries with an equals() method that\n", "   * calls the comparator to compare the two keys. If that change is made,\n", "   * AbstractMultiset.equals() can simply check whether two multisets have equal entry sets.\n", "   */\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957]}}, {"48": "guava-gwt/src-super/com/google/common/io/super/com/google/common/io/BaseEncoding.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.io;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkPositionIndexes;\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.math.IntMath.divide;\n", "import static com.google.common.math.IntMath.log2;\n", "import static java.math.RoundingMode.CEILING;\n", "import static java.math.RoundingMode.FLOOR;\n", "import static java.math.RoundingMode.UNNECESSARY;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Ascii;\n", "import com.google.common.base.CharMatcher;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A binary encoding scheme for reversibly translating between byte sequences and printable ASCII\n", " * strings. This class includes several constants for encoding schemes specified by <a\n", " * href=\"http://tools.ietf.org/html/rfc4648\">RFC 4648</a>. For example, the expression:\n", " *\n", " * <pre>   {@code\n", " *   BaseEncoding.base32().encode(\"foo\".getBytes(Charsets.US_ASCII))}</pre>\n", " *\n", " * <p>returns the string {@code \"MZXW6===\"}, and <pre>   {@code\n", " *  byte[] decoded = BaseEncoding.base32().decode(\"MZXW6===\");}</pre>\n", " *\n", " * <p>...returns the ASCII bytes of the string {@code \"foo\"}.\n", " *\n", " * <p>By default, {@code BaseEncoding}'s behavior is relatively strict and in accordance with\n", " * RFC 4648.  Decoding rejects characters in the wrong case, though padding is optional.\n", " * To modify encoding and decoding behavior, use configuration methods to obtain a new encoding\n", " * with modified behavior:\n", " *\n", " * <pre>   {@code\n", " *  BaseEncoding.base16().lowerCase().decode(\"deadbeef\");}</pre>\n", " *\n", " * <p>Warning: BaseEncoding instances are immutable.  Invoking a configuration method has no effect\n", " * on the receiving instance; you must store and use the new encoding instance it returns, instead.\n", " *\n", " * <pre>   {@code\n", " *   // Do NOT do this\n", " *   BaseEncoding hex = BaseEncoding.base16();\n", " *   hex.lowerCase(); // does nothing!\n", " *   return hex.decode(\"deadbeef\"); // throws an IllegalArgumentException}</pre>\n", " *\n", " * <p>It is guaranteed that {@code encoding.decode(encoding.encode(x))} is always equal to\n", " * {@code x}, but the reverse does not necessarily hold.\n", " *\n", " * <p>\n", " * <table>\n", " * <tr>\n", " * <th>Encoding\n", " * <th>Alphabet\n", " * <th>{@code char:byte} ratio\n", " * <th>Default padding\n", " * <th>Comments\n", " * <tr>\n", " * <td>{@link #base16()}\n", " * <td>0-9 A-F\n", " * <td>2.00\n", " * <td>N/A\n", " * <td>Traditional hexadecimal.  Defaults to upper case.\n", " * <tr>\n", " * <td>{@link #base32()}\n", " * <td>A-Z 2-7\n", " * <td>1.60\n", " * <td>=\n", " * <td>Human-readable; no possibility of mixing up 0/O or 1/I.  Defaults to upper case.\n", " * <tr>\n", " * <td>{@link #base32Hex()}\n", " * <td>0-9 A-V\n", " * <td>1.60\n", " * <td>=\n", " * <td>\"Numerical\" base 32; extended from the traditional hex alphabet.  Defaults to upper case.\n", " * <tr>\n", " * <td>{@link #base64()}\n", " * <td>A-Z a-z 0-9 + /\n", " * <td>1.33\n", " * <td>=\n", " * <td>\n", " * <tr>\n", " * <td>{@link #base64Url()}\n", " * <td>A-Z a-z 0-9 - _\n", " * <td>1.33\n", " * <td>=\n", " * <td>Safe to use as filenames, or to pass in URLs without escaping\n", " * </table>\n", " *\n", " * <p>\n", " * All instances of this class are immutable, so they may be stored safely as static constants.\n", " *\n", " * @author Louis Wasserman\n", " * @since 14.0\n", " */\n", "@Beta\n", "@GwtCompatible(emulated = true)\n", "public abstract class BaseEncoding {\n", "  // TODO(lowasser): consider making encodeTo(Appendable, byte[], int, int) public.\n", "\n", "  BaseEncoding() {}\n", "\n", "  /**\n", "   * Exception indicating invalid base-encoded input encountered while decoding.\n", "   *\n", "   * @author Louis Wasserman\n", "   * @since 15.0\n", "   */\n", "  public static final class DecodingException extends IOException {\n", "    DecodingException(String message) {\n", "      super(message);\n", "    }\n", "\n", "    DecodingException(Throwable cause) {\n", "      super(cause);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Encodes the specified byte array, and returns the encoded {@code String}.\n", "   */\n", "  public String encode(byte[] bytes) {\n", "    return encode(bytes, 0, bytes.length);\n", "  }\n", "\n", "  /**\n", "   * Encodes the specified range of the specified byte array, and returns the encoded\n", "   * {@code String}.\n", "   */\n", "  public final String encode(byte[] bytes, int off, int len) {\n", "    checkPositionIndexes(off, off + len, bytes.length);\n", "    StringBuilder result = new StringBuilder(maxEncodedSize(len));\n", "    try {\n", "      encodeTo(result, bytes, off, len);\n", "    } catch (IOException impossible) {\n", "      throw new AssertionError(impossible);\n", "    }\n", "    return result.toString();\n", "  }\n", "\n", "  // TODO(lowasser): document the extent of leniency, probably after adding ignore(CharMatcher)\n", "\n", "  private static byte[] extract(byte[] result, int length) {\n", "    if (length == result.length) {\n", "      return result;\n", "    } else {\n", "      byte[] trunc = new byte[length];\n", "      System.arraycopy(result, 0, trunc, 0, length);\n", "      return trunc;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Decodes the specified character sequence, and returns the resulting {@code byte[]}.\n", "   * This is the inverse operation to {@link #encode(byte[])}.\n", "   *\n", "   * @throws IllegalArgumentException if the input is not a valid encoded string according to this\n", "   *         encoding.\n", "   */\n", "  public final byte[] decode(CharSequence chars) {\n", "    try {\n", "      return decodeChecked(chars);\n", "    } catch (DecodingException badInput) {\n", "      throw new IllegalArgumentException(badInput);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Decodes the specified character sequence, and returns the resulting {@code byte[]}.\n", "   * This is the inverse operation to {@link #encode(byte[])}.\n", "   *\n", "   * @throws DecodingException if the input is not a valid encoded string according to this\n", "   *         encoding.\n", "   */\n", "  final byte[] decodeChecked(CharSequence chars) throws DecodingException {\n", "    chars = padding().trimTrailingFrom(chars);\n", "    byte[] tmp = new byte[maxDecodedSize(chars.length())];\n", "    int len = decodeTo(tmp, chars);\n", "    return extract(tmp, len);\n", "  }\n", "\n", "  // Implementations for encoding/decoding\n", "\n", "  abstract int maxEncodedSize(int bytes);\n", "\n", "  abstract void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException;\n", "\n", "  abstract int maxDecodedSize(int chars);\n", "\n", "  abstract int decodeTo(byte[] target, CharSequence chars) throws DecodingException;\n", "\n", "  abstract CharMatcher padding();\n", "\n", "  // Modified encoding generators\n", "\n", "  /**\n", "   * Returns an encoding that behaves equivalently to this encoding, but omits any padding\n", "   * characters as specified by <a href=\"http://tools.ietf.org/html/rfc4648#section-3.2\">RFC 4648\n", "   * section 3.2</a>, Padding of Encoded Data.\n", "   */\n", "  @CheckReturnValue\n", "  public abstract BaseEncoding omitPadding();\n", "\n", "  /**\n", "   * Returns an encoding that behaves equivalently to this encoding, but uses an alternate character\n", "   * for padding.\n", "   *\n", "   * @throws IllegalArgumentException if this padding character is already used in the alphabet or a\n", "   *         separator\n", "   */\n", "  @CheckReturnValue\n", "  public abstract BaseEncoding withPadChar(char padChar);\n", "\n", "  /**\n", "   * Returns an encoding that behaves equivalently to this encoding, but adds a separator string\n", "   * after every {@code n} characters. Any occurrences of any characters that occur in the separator\n", "   * are skipped over in decoding.\n", "   *\n", "   * @throws IllegalArgumentException if any alphabet or padding characters appear in the separator\n", "   *         string, or if {@code n <= 0}\n", "   * @throws UnsupportedOperationException if this encoding already uses a separator\n", "   */\n", "  @CheckReturnValue\n", "  public abstract BaseEncoding withSeparator(String separator, int n);\n", "\n", "  /**\n", "   * Returns an encoding that behaves equivalently to this encoding, but encodes and decodes with\n", "   * uppercase letters. Padding and separator characters remain in their original case.\n", "   *\n", "   * @throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and\n", "   *         lower-case characters\n", "   */\n", "  @CheckReturnValue\n", "  public abstract BaseEncoding upperCase();\n", "\n", "  /**\n", "   * Returns an encoding that behaves equivalently to this encoding, but encodes and decodes with\n", "   * lowercase letters. Padding and separator characters remain in their original case.\n", "   *\n", "   * @throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and\n", "   *         lower-case characters\n", "   */\n", "  @CheckReturnValue\n", "  public abstract BaseEncoding lowerCase();\n", "\n", "  private static final BaseEncoding BASE64 = new Base64Encoding(\n", "      \"base64()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", '=');\n", "\n", "  /**\n", "   * The \"base64\" base encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-4\">RFC 4648 section 4</a>, Base 64 Encoding.\n", "   * (This is the same as the base 64 encoding from <a\n", "   * href=\"http://tools.ietf.org/html/rfc3548#section-3\">RFC 3548</a>.)\n", "   *\n", "   * <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()\n", "   * omitted} or {@linkplain #withPadChar(char) replaced}.\n", "   *\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n", "   */\n", "  public static BaseEncoding base64() {\n", "    return BASE64;\n", "  }\n", "\n", "  private static final BaseEncoding BASE64_URL = new Base64Encoding(\n", "      \"base64Url()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", '=');\n", "\n", "  /**\n", "   * The \"base64url\" encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-5\">RFC 4648 section 5</a>, Base 64 Encoding\n", "   * with URL and Filename Safe Alphabet, also sometimes referred to as the \"web safe Base64.\"\n", "   * (This is the same as the base 64 encoding with URL and filename safe alphabet from <a\n", "   * href=\"http://tools.ietf.org/html/rfc3548#section-4\">RFC 3548</a>.)\n", "   *\n", "   * <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()\n", "   * omitted} or {@linkplain #withPadChar(char) replaced}.\n", "   *\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n", "   */\n", "  public static BaseEncoding base64Url() {\n", "    return BASE64_URL;\n", "  }\n", "\n", "  private static final BaseEncoding BASE32 =\n", "      new StandardBaseEncoding(\"base32()\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", '=');\n", "\n", "  /**\n", "   * The \"base32\" encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-6\">RFC 4648 section 6</a>, Base 32 Encoding.\n", "   * (This is the same as the base 32 encoding from <a\n", "   * href=\"http://tools.ietf.org/html/rfc3548#section-5\">RFC 3548</a>.)\n", "   *\n", "   * <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()\n", "   * omitted} or {@linkplain #withPadChar(char) replaced}.\n", "   *\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n", "   */\n", "  public static BaseEncoding base32() {\n", "    return BASE32;\n", "  }\n", "\n", "  private static final BaseEncoding BASE32_HEX =\n", "      new StandardBaseEncoding(\"base32Hex()\", \"0123456789ABCDEFGHIJKLMNOPQRSTUV\", '=');\n", "\n", "  /**\n", "   * The \"base32hex\" encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-7\">RFC 4648 section 7</a>, Base 32 Encoding\n", "   * with Extended Hex Alphabet.  There is no corresponding encoding in RFC 3548.\n", "   *\n", "   * <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()\n", "   * omitted} or {@linkplain #withPadChar(char) replaced}.\n", "   *\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n", "   */\n", "  public static BaseEncoding base32Hex() {\n", "    return BASE32_HEX;\n", "  }\n", "\n", "  private static final BaseEncoding BASE16 = new Base16Encoding(\"base16()\", \"0123456789ABCDEF\");\n", "\n", "  /**\n", "   * The \"base16\" encoding specified by <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-8\">RFC 4648 section 8</a>, Base 16 Encoding.\n", "   * (This is the same as the base 16 encoding from <a\n", "   * href=\"http://tools.ietf.org/html/rfc3548#section-6\">RFC 3548</a>.) This is commonly known as\n", "   * \"hexadecimal\" format.\n", "   *\n", "   * <p>No padding is necessary in base 16, so {@link #withPadChar(char)} and\n", "   * {@link #omitPadding()} have no effect.\n", "   *\n", "   * <p>No line feeds are added by default, as per <a\n", "   * href=\"http://tools.ietf.org/html/rfc4648#section-3.1\"> RFC 4648 section 3.1</a>, Line Feeds in\n", "   * Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.\n", "   */\n", "  public static BaseEncoding base16() {\n", "    return BASE16;\n", "  }\n", "\n", "  private static final class Alphabet extends CharMatcher {\n", "    private final String name;\n", "    // this is meant to be immutable -- don't modify it!\n", "    private final char[] chars;\n", "    final int mask;\n", "    final int bitsPerChar;\n", "    final int charsPerChunk;\n", "    final int bytesPerChunk;\n", "    private final byte[] decodabet;\n", "    private final boolean[] validPadding;\n", "\n", "    Alphabet(String name, char[] chars) {\n", "      this.name = checkNotNull(name);\n", "      this.chars = checkNotNull(chars);\n", "      try {\n", "        this.bitsPerChar = log2(chars.length, UNNECESSARY);\n", "      } catch (ArithmeticException e) {\n", "        throw new IllegalArgumentException(\"Illegal alphabet length \" + chars.length, e);\n", "      }\n", "\n", "      /*\n", "       * e.g. for base64, bitsPerChar == 6, charsPerChunk == 4, and bytesPerChunk == 3. This makes\n", "       * for the smallest chunk size that still has charsPerChunk * bitsPerChar be a multiple of 8.\n", "       */\n", "      int gcd = Math.min(8, Integer.lowestOneBit(bitsPerChar));\n", "      this.charsPerChunk = 8 / gcd;\n", "      this.bytesPerChunk = bitsPerChar / gcd;\n", "\n", "      this.mask = chars.length - 1;\n", "\n", "      byte[] decodabet = new byte[Ascii.MAX + 1];\n", "      Arrays.fill(decodabet, (byte) -1);\n", "      for (int i = 0; i < chars.length; i++) {\n", "        char c = chars[i];\n", "        checkArgument(CharMatcher.ASCII.matches(c), \"Non-ASCII character: %s\", c);\n", "        checkArgument(decodabet[c] == -1, \"Duplicate character: %s\", c);\n", "        decodabet[c] = (byte) i;\n", "      }\n", "      this.decodabet = decodabet;\n", "\n", "      boolean[] validPadding = new boolean[charsPerChunk];\n", "      for (int i = 0; i < bytesPerChunk; i++) {\n", "        validPadding[divide(i * 8, bitsPerChar, CEILING)] = true;\n", "      }\n", "      this.validPadding = validPadding;\n", "    }\n", "\n", "    char encode(int bits) {\n", "      return chars[bits];\n", "    }\n", "\n", "    boolean isValidPaddingStartPosition(int index) {\n", "      return validPadding[index % charsPerChunk];\n", "    }\n", "\n", "    int decode(char ch) throws DecodingException {\n", "      if (ch > Ascii.MAX || decodabet[ch] == -1) {\n", "        throw new DecodingException(\"Unrecognized character: \"\n", "            + (CharMatcher.INVISIBLE.matches(ch) ? \"0x\" + Integer.toHexString(ch) : ch));\n", "      }\n", "      return decodabet[ch];\n", "    }\n", "\n", "    private boolean hasLowerCase() {\n", "      for (char c : chars) {\n", "        if (Ascii.isLowerCase(c)) {\n", "          return true;\n", "        }\n", "      }\n", "      return false;\n", "    }\n", "\n", "    private boolean hasUpperCase() {\n", "      for (char c : chars) {\n", "        if (Ascii.isUpperCase(c)) {\n", "          return true;\n", "        }\n", "      }\n", "      return false;\n", "    }\n", "\n", "    Alphabet upperCase() {\n", "      if (!hasLowerCase()) {\n", "        return this;\n", "      } else {\n", "        checkState(!hasUpperCase(), \"Cannot call upperCase() on a mixed-case alphabet\");\n", "        char[] upperCased = new char[chars.length];\n", "        for (int i = 0; i < chars.length; i++) {\n", "          upperCased[i] = Ascii.toUpperCase(chars[i]);\n", "        }\n", "        return new Alphabet(name + \".upperCase()\", upperCased);\n", "      }\n", "    }\n", "\n", "    Alphabet lowerCase() {\n", "      if (!hasUpperCase()) {\n", "        return this;\n", "      } else {\n", "        checkState(!hasLowerCase(), \"Cannot call lowerCase() on a mixed-case alphabet\");\n", "        char[] lowerCased = new char[chars.length];\n", "        for (int i = 0; i < chars.length; i++) {\n", "          lowerCased[i] = Ascii.toLowerCase(chars[i]);\n", "        }\n", "        return new Alphabet(name + \".lowerCase()\", lowerCased);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public boolean matches(char c) {\n", "      return CharMatcher.ASCII.matches(c) && decodabet[c] != -1;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return name;\n", "    }\n", "  }\n", "\n", "  static class StandardBaseEncoding extends BaseEncoding {\n", "    // TODO(lowasser): provide a useful toString\n", "    final Alphabet alphabet;\n", "\n", "    @Nullable\n", "    final Character paddingChar;\n", "\n", "    StandardBaseEncoding(String name, String alphabetChars, @Nullable Character paddingChar) {\n", "      this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);\n", "    }\n", "\n", "    StandardBaseEncoding(Alphabet alphabet, @Nullable Character paddingChar) {\n", "      this.alphabet = checkNotNull(alphabet);\n", "      checkArgument(paddingChar == null || !alphabet.matches(paddingChar),\n", "          \"Padding character %s was already in alphabet\", paddingChar);\n", "      this.paddingChar = paddingChar;\n", "    }\n", "\n", "    @Override\n", "    CharMatcher padding() {\n", "      return (paddingChar == null) ? CharMatcher.NONE : CharMatcher.is(paddingChar.charValue());\n", "    }\n", "\n", "    @Override\n", "    int maxEncodedSize(int bytes) {\n", "      return alphabet.charsPerChunk * divide(bytes, alphabet.bytesPerChunk, CEILING);\n", "    }\n", "\n", "    @Override\n", "    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n", "      checkNotNull(target);\n", "      checkPositionIndexes(off, off + len, bytes.length);\n", "      for (int i = 0; i < len; i += alphabet.bytesPerChunk) {\n", "        encodeChunkTo(target, bytes, off + i, Math.min(alphabet.bytesPerChunk, len - i));\n", "      }\n", "    }\n", "\n", "    void encodeChunkTo(Appendable target, byte[] bytes, int off, int len)\n", "        throws IOException {\n", "      checkNotNull(target);\n", "      checkPositionIndexes(off, off + len, bytes.length);\n", "      checkArgument(len <= alphabet.bytesPerChunk);\n", "      long bitBuffer = 0;\n", "      for (int i = 0; i < len; ++i) {\n", "        bitBuffer |= bytes[off + i] & 0xFF;\n", "        bitBuffer <<= 8; // Add additional zero byte in the end.\n", "      }\n", "      // Position of first character is length of bitBuffer minus bitsPerChar.\n", "      final int bitOffset = (len + 1) * 8 - alphabet.bitsPerChar;\n", "      int bitsProcessed = 0;\n", "      while (bitsProcessed < len * 8) {\n", "        int charIndex = (int) (bitBuffer >>> (bitOffset - bitsProcessed)) & alphabet.mask;\n", "        target.append(alphabet.encode(charIndex));\n", "        bitsProcessed += alphabet.bitsPerChar;\n", "      }\n", "      if (paddingChar != null) {\n", "        while (bitsProcessed < alphabet.bytesPerChunk * 8) {\n", "          target.append(paddingChar.charValue());\n", "          bitsProcessed += alphabet.bitsPerChar;\n", "        }\n", "      }\n", "    }\n", "\n", "    @Override\n", "    int maxDecodedSize(int chars) {\n", "      return (int) ((alphabet.bitsPerChar * (long) chars + 7L) / 8L);\n", "    }\n", "\n", "    @Override\n", "    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {\n", "      checkNotNull(target);\n", "      chars = padding().trimTrailingFrom(chars);\n", "      if (!alphabet.isValidPaddingStartPosition(chars.length())) {\n", "        throw new DecodingException(\"Invalid input length \" + chars.length());\n", "      }\n", "      int bytesWritten = 0;\n", "      for (int charIdx = 0; charIdx < chars.length(); charIdx += alphabet.charsPerChunk) {\n", "        long chunk = 0;\n", "        int charsProcessed = 0;\n", "        for (int i = 0; i < alphabet.charsPerChunk; i++) {\n", "          chunk <<= alphabet.bitsPerChar;\n", "          if (charIdx + i < chars.length()) {\n", "            chunk |= alphabet.decode(chars.charAt(charIdx + charsProcessed++));\n", "          }\n", "        }\n", "        final int minOffset = alphabet.bytesPerChunk * 8 - charsProcessed * alphabet.bitsPerChar;\n", "        for (int offset = (alphabet.bytesPerChunk - 1) * 8; offset >= minOffset; offset -= 8) {\n", "          target[bytesWritten++] = (byte) ((chunk >>> offset) & 0xFF);\n", "        }\n", "      }\n", "      return bytesWritten;\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding omitPadding() {\n", "      return (paddingChar == null) ? this : newInstance(alphabet, null);\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding withPadChar(char padChar) {\n", "      if (8 % alphabet.bitsPerChar == 0 ||\n", "          (paddingChar != null && paddingChar.charValue() == padChar)) {\n", "        return this;\n", "      } else {\n", "        return newInstance(alphabet, padChar);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding withSeparator(String separator, int afterEveryChars) {\n", "      checkArgument(padding().or(alphabet).matchesNoneOf(separator),\n", "          \"Separator (%s) cannot contain alphabet or padding characters\", separator);\n", "      return new SeparatedBaseEncoding(this, separator, afterEveryChars);\n", "    }\n", "\n", "    private transient BaseEncoding upperCase;\n", "    private transient BaseEncoding lowerCase;\n", "\n", "    @Override\n", "    public BaseEncoding upperCase() {\n", "      BaseEncoding result = upperCase;\n", "      if (result == null) {\n", "        Alphabet upper = alphabet.upperCase();\n", "        result = upperCase =\n", "            (upper == alphabet) ? this : newInstance(upper, paddingChar);\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding lowerCase() {\n", "      BaseEncoding result = lowerCase;\n", "      if (result == null) {\n", "        Alphabet lower = alphabet.lowerCase();\n", "        result = lowerCase =\n", "            (lower == alphabet) ? this : newInstance(lower, paddingChar);\n", "      }\n", "      return result;\n", "    }\n", "\n", "    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {\n", "      return new StandardBaseEncoding(alphabet, paddingChar);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      StringBuilder builder = new StringBuilder(\"BaseEncoding.\");\n", "      builder.append(alphabet.toString());\n", "      if (8 % alphabet.bitsPerChar != 0) {\n", "        if (paddingChar == null) {\n", "          builder.append(\".omitPadding()\");\n", "        } else {\n", "          builder.append(\".withPadChar(\").append(paddingChar).append(')');\n", "        }\n", "      }\n", "      return builder.toString();\n", "    }\n", "  }\n", "\n", "  static final class Base16Encoding extends StandardBaseEncoding {\n", "    final char[] encoding = new char[512];\n", "\n", "    Base16Encoding(String name, String alphabetChars) {\n", "      this(new Alphabet(name, alphabetChars.toCharArray()));\n", "    }\n", "\n", "    private Base16Encoding(Alphabet alphabet) {\n", "      super(alphabet, null);\n", "      checkArgument(alphabet.chars.length == 16);\n", "      for (int i = 0; i < 256; ++i) {\n", "        encoding[i] = alphabet.encode(i >>> 4);\n", "        encoding[i | 0x100] = alphabet.encode(i & 0xF);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n", "      checkNotNull(target);\n", "      checkPositionIndexes(off, off + len, bytes.length);\n", "      for (int i = 0; i < len; ++i) {\n", "        int b = bytes[off + i] & 0xFF;\n", "        target.append(encoding[b]);\n", "        target.append(encoding[b | 0x100]);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {\n", "      checkNotNull(target);\n", "      if (chars.length() % 2 == 1) {\n", "        throw new DecodingException(\"Invalid input length \" + chars.length());\n", "      }\n", "      int bytesWritten = 0;\n", "      for (int i = 0; i < chars.length(); i += 2) {\n", "        int decoded = alphabet.decode(chars.charAt(i)) << 4 | alphabet.decode(chars.charAt(i + 1));\n", "        target[bytesWritten++] = (byte) decoded;\n", "      }\n", "      return bytesWritten;\n", "    }\n", "\n", "    @Override\n", "    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {\n", "      return new Base16Encoding(alphabet);\n", "    }\n", "  }\n", "\n", "  static final class Base64Encoding extends StandardBaseEncoding {\n", "    Base64Encoding(String name, String alphabetChars, @Nullable Character paddingChar) {\n", "      this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);\n", "    }\n", "\n", "    private Base64Encoding(Alphabet alphabet, @Nullable Character paddingChar) {\n", "      super(alphabet, paddingChar);\n", "      checkArgument(alphabet.chars.length == 64);\n", "    }\n", "\n", "    @Override\n", "    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n", "      checkNotNull(target);\n", "      checkPositionIndexes(off, off + len, bytes.length);\n", "      int i = off;\n", "      for (int remaining = len; remaining >= 3; remaining -= 3) {\n", "        int chunk = (bytes[i++] & 0xFF) << 16 | (bytes[i++] & 0xFF) << 8 | bytes[i++] & 0xFF;\n", "        target.append(alphabet.encode(chunk >>> 18));\n", "        target.append(alphabet.encode((chunk >>> 12) & 0x3F));\n", "        target.append(alphabet.encode((chunk >>> 6) & 0x3F));\n", "        target.append(alphabet.encode(chunk & 0x3F));\n", "      }\n", "      if (i < off + len) {\n", "        encodeChunkTo(target, bytes, i, off + len - i);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {\n", "      checkNotNull(target);\n", "      chars = padding().trimTrailingFrom(chars);\n", "      if (!alphabet.isValidPaddingStartPosition(chars.length())) {\n", "        throw new DecodingException(\"Invalid input length \" + chars.length());\n", "      }\n", "      int bytesWritten = 0;\n", "      for (int i = 0; i < chars.length();) {\n", "        int chunk = alphabet.decode(chars.charAt(i++)) << 18;\n", "        chunk |= alphabet.decode(chars.charAt(i++)) << 12;\n", "        target[bytesWritten++] = (byte) (chunk >>> 16);\n", "        if (i < chars.length()) {\n", "          chunk |= alphabet.decode(chars.charAt(i++)) << 6;\n", "          target[bytesWritten++] = (byte) ((chunk >>> 8) & 0xFF);\n", "          if (i < chars.length()) {\n", "            chunk |= alphabet.decode(chars.charAt(i++));\n", "            target[bytesWritten++] = (byte) (chunk & 0xFF);\n", "          }\n", "        }\n", "      }\n", "      return bytesWritten;\n", "    }\n", "\n", "    @Override\n", "    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {\n", "      return new Base64Encoding(alphabet, paddingChar);\n", "    }\n", "  }\n", "\n", "  static Appendable separatingAppendable(\n", "      final Appendable delegate, final String separator, final int afterEveryChars) {\n", "    checkNotNull(delegate);\n", "    checkNotNull(separator);\n", "    checkArgument(afterEveryChars > 0);\n", "    return new Appendable() {\n", "      int charsUntilSeparator = afterEveryChars;\n", "\n", "      @Override\n", "      public Appendable append(char c) throws IOException {\n", "        if (charsUntilSeparator == 0) {\n", "          delegate.append(separator);\n", "          charsUntilSeparator = afterEveryChars;\n", "        }\n", "        delegate.append(c);\n", "        charsUntilSeparator--;\n", "        return this;\n", "      }\n", "\n", "      @Override\n", "      public Appendable append(CharSequence chars, int off, int len) throws IOException {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "\n", "      @Override\n", "      public Appendable append(CharSequence chars) throws IOException {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "    };\n", "  }\n", "\n", "  static final class SeparatedBaseEncoding extends BaseEncoding {\n", "    private final BaseEncoding delegate;\n", "    private final String separator;\n", "    private final int afterEveryChars;\n", "    private final CharMatcher separatorChars;\n", "\n", "    SeparatedBaseEncoding(BaseEncoding delegate, String separator, int afterEveryChars) {\n", "      this.delegate = checkNotNull(delegate);\n", "      this.separator = checkNotNull(separator);\n", "      this.afterEveryChars = afterEveryChars;\n", "      checkArgument(\n", "          afterEveryChars > 0, \"Cannot add a separator after every %s chars\", afterEveryChars);\n", "      this.separatorChars = CharMatcher.anyOf(separator).precomputed();\n", "    }\n", "\n", "    @Override\n", "    CharMatcher padding() {\n", "      return delegate.padding();\n", "    }\n", "\n", "    @Override\n", "    int maxEncodedSize(int bytes) {\n", "      int unseparatedSize = delegate.maxEncodedSize(bytes);\n", "      return unseparatedSize + separator.length()\n", "          * divide(Math.max(0, unseparatedSize - 1), afterEveryChars, FLOOR);\n", "    }\n", "\n", "    @Override\n", "    void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {\n", "      delegate.encodeTo(separatingAppendable(target, separator, afterEveryChars), bytes, off, len);\n", "    }\n", "\n", "    @Override\n", "    int maxDecodedSize(int chars) {\n", "      return delegate.maxDecodedSize(chars);\n", "    }\n", "\n", "    @Override\n", "    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {\n", "      return delegate.decodeTo(target, separatorChars.removeFrom(chars));\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding omitPadding() {\n", "      return delegate.omitPadding().withSeparator(separator, afterEveryChars);\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding withPadChar(char padChar) {\n", "      return delegate.withPadChar(padChar).withSeparator(separator, afterEveryChars);\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding withSeparator(String separator, int afterEveryChars) {\n", "      throw new UnsupportedOperationException(\"Already have a separator\");\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding upperCase() {\n", "      return delegate.upperCase().withSeparator(separator, afterEveryChars);\n", "    }\n", "\n", "    @Override\n", "    public BaseEncoding lowerCase() {\n", "      return delegate.lowerCase().withSeparator(separator, afterEveryChars);\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return delegate.toString() +\n", "          \".withSeparator(\\\"\" + separator + \"\\\", \" + afterEveryChars + \")\";\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852]}}, {"49": "guava-gwt/src-super/com/google/common/math/super/com/google/common/math/BigIntegerMath.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.math;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.math.MathPreconditions.checkNonNegative;\n", "import static com.google.common.math.MathPreconditions.checkPositive;\n", "import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;\n", "import static java.math.RoundingMode.CEILING;\n", "import static java.math.RoundingMode.FLOOR;\n", "import static java.math.RoundingMode.HALF_EVEN;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "\n", "import java.math.BigInteger;\n", "import java.math.RoundingMode;\n", "import java.util.ArrayList;\n", "import java.util.List;\n", "\n", "/**\n", " * A class for arithmetic on values of type {@code BigInteger}.\n", " *\n", " * <p>The implementations of many methods in this class are based on material from Henry S. Warren,\n", " * Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).\n", " *\n", " * <p>Similar functionality for {@code int} and for {@code long} can be found in\n", " * {@link IntMath} and {@link LongMath} respectively.\n", " *\n", " * @author Louis Wasserman\n", " * @since 11.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class BigIntegerMath {\n", "  /**\n", "   * Returns {@code true} if {@code x} represents a power of two.\n", "   */\n", "  public static boolean isPowerOfTwo(BigInteger x) {\n", "    checkNotNull(x);\n", "    return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1;\n", "  }\n", "\n", "  /**\n", "   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n", "   *\n", "   * @throws IllegalArgumentException if {@code x <= 0}\n", "   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n", "   *         is not a power of two\n", "   */\n", "  @SuppressWarnings(\"fallthrough\")\n", "  // TODO(kevinb): remove after this warning is disabled globally\n", "  public static int log2(BigInteger x, RoundingMode mode) {\n", "    checkPositive(\"x\", checkNotNull(x));\n", "    int logFloor = x.bitLength() - 1;\n", "    switch (mode) {\n", "      case UNNECESSARY:\n", "        checkRoundingUnnecessary(isPowerOfTwo(x)); // fall through\n", "      case DOWN:\n", "      case FLOOR:\n", "        return logFloor;\n", "\n", "      case UP:\n", "      case CEILING:\n", "        return isPowerOfTwo(x) ? logFloor : logFloor + 1;\n", "\n", "      case HALF_DOWN:\n", "      case HALF_UP:\n", "      case HALF_EVEN:\n", "        if (logFloor < SQRT2_PRECOMPUTE_THRESHOLD) {\n", "          BigInteger halfPower = SQRT2_PRECOMPUTED_BITS.shiftRight(\n", "              SQRT2_PRECOMPUTE_THRESHOLD - logFloor);\n", "          if (x.compareTo(halfPower) <= 0) {\n", "            return logFloor;\n", "          } else {\n", "            return logFloor + 1;\n", "          }\n", "        }\n", "        /*\n", "         * Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n", "         *\n", "         * To determine which side of logFloor.5 the logarithm is, we compare x^2 to 2^(2 *\n", "         * logFloor + 1).\n", "         */\n", "        BigInteger x2 = x.pow(2);\n", "        int logX2Floor = x2.bitLength() - 1;\n", "        return (logX2Floor < 2 * logFloor + 1) ? logFloor : logFloor + 1;\n", "\n", "      default:\n", "        throw new AssertionError();\n", "    }\n", "  }\n", "\n", "  /*\n", "   * The maximum number of bits in a square root for which we'll precompute an explicit half power\n", "   * of two. This can be any value, but higher values incur more class load time and linearly\n", "   * increasing memory consumption.\n", "   */\n", "  @VisibleForTesting static final int SQRT2_PRECOMPUTE_THRESHOLD = 256;\n", "\n", "  @VisibleForTesting static final BigInteger SQRT2_PRECOMPUTED_BITS =\n", "      new BigInteger(\"16a09e667f3bcc908b2fb1366ea957d3e3adec17512775099da2f590b0667322a\", 16);\n", "\n", "  private static final double LN_10 = Math.log(10);\n", "  private static final double LN_2 = Math.log(2);\n", "\n", "  /**\n", "   * Returns {@code n!}, that is, the product of the first {@code n} positive\n", "   * integers, or {@code 1} if {@code n == 0}.\n", "   *\n", "   * <p><b>Warning:</b> the result takes <i>O(n log n)</i> space, so use cautiously.\n", "   *\n", "   * <p>This uses an efficient binary recursive algorithm to compute the factorial\n", "   * with balanced multiplies.  It also removes all the 2s from the intermediate\n", "   * products (shifting them back in at the end).\n", "   *\n", "   * @throws IllegalArgumentException if {@code n < 0}\n", "   */\n", "  public static BigInteger factorial(int n) {\n", "    checkNonNegative(\"n\", n);\n", "\n", "    // If the factorial is small enough, just use LongMath to do it.\n", "    if (n < LongMath.factorials.length) {\n", "      return BigInteger.valueOf(LongMath.factorials[n]);\n", "    }\n", "\n", "    // Pre-allocate space for our list of intermediate BigIntegers.\n", "    int approxSize = IntMath.divide(n * IntMath.log2(n, CEILING), Long.SIZE, CEILING);\n", "    ArrayList<BigInteger> bignums = new ArrayList<BigInteger>(approxSize);\n", "\n", "    // Start from the pre-computed maximum long factorial.\n", "    int startingNumber = LongMath.factorials.length;\n", "    long product = LongMath.factorials[startingNumber - 1];\n", "    // Strip off 2s from this value.\n", "    int shift = Long.numberOfTrailingZeros(product);\n", "    product >>= shift;\n", "\n", "    // Use floor(log2(num)) + 1 to prevent overflow of multiplication.\n", "    int productBits = LongMath.log2(product, FLOOR) + 1;\n", "    int bits = LongMath.log2(startingNumber, FLOOR) + 1;\n", "    // Check for the next power of two boundary, to save us a CLZ operation.\n", "    int nextPowerOfTwo = 1 << (bits - 1);\n", "\n", "    // Iteratively multiply the longs as big as they can go.\n", "    for (long num = startingNumber; num <= n; num++) {\n", "      // Check to see if the floor(log2(num)) + 1 has changed.\n", "      if ((num & nextPowerOfTwo) != 0) {\n", "        nextPowerOfTwo <<= 1;\n", "        bits++;\n", "      }\n", "      // Get rid of the 2s in num.\n", "      int tz = Long.numberOfTrailingZeros(num);\n", "      long normalizedNum = num >> tz;\n", "      shift += tz;\n", "      // Adjust floor(log2(num)) + 1.\n", "      int normalizedBits = bits - tz;\n", "      // If it won't fit in a long, then we store off the intermediate product.\n", "      if (normalizedBits + productBits >= Long.SIZE) {\n", "        bignums.add(BigInteger.valueOf(product));\n", "        product = 1;\n", "        productBits = 0;\n", "      }\n", "      product *= normalizedNum;\n", "      productBits = LongMath.log2(product, FLOOR) + 1;\n", "    }\n", "    // Check for leftovers.\n", "    if (product > 1) {\n", "      bignums.add(BigInteger.valueOf(product));\n", "    }\n", "    // Efficiently multiply all the intermediate products together.\n", "    return listProduct(bignums).shiftLeft(shift);\n", "  }\n", "\n", "  static BigInteger listProduct(List<BigInteger> nums) {\n", "    return listProduct(nums, 0, nums.size());\n", "  }\n", "\n", "  static BigInteger listProduct(List<BigInteger> nums, int start, int end) {\n", "    switch (end - start) {\n", "      case 0:\n", "        return BigInteger.ONE;\n", "      case 1:\n", "        return nums.get(start);\n", "      case 2:\n", "        return nums.get(start).multiply(nums.get(start + 1));\n", "      case 3:\n", "        return nums.get(start).multiply(nums.get(start + 1)).multiply(nums.get(start + 2));\n", "      default:\n", "        // Otherwise, split the list in half and recursively do this.\n", "        int m = (end + start) >>> 1;\n", "        return listProduct(nums, start, m).multiply(listProduct(nums, m, end));\n", "    }\n", "  }\n", "\n", " /**\n", "   * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and\n", "   * {@code k}, that is, {@code n! / (k! (n - k)!)}.\n", "   *\n", "   * <p><b>Warning:</b> the result can take as much as <i>O(k log n)</i> space.\n", "   *\n", "   * @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}\n", "   */\n", "  public static BigInteger binomial(int n, int k) {\n", "    checkNonNegative(\"n\", n);\n", "    checkNonNegative(\"k\", k);\n", "    checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n", "    if (k > (n >> 1)) {\n", "      k = n - k;\n", "    }\n", "    if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {\n", "      return BigInteger.valueOf(LongMath.binomial(n, k));\n", "    }\n", "\n", "    BigInteger accum = BigInteger.ONE;\n", "\n", "    long numeratorAccum = n;\n", "    long denominatorAccum = 1;\n", "\n", "    int bits = LongMath.log2(n, RoundingMode.CEILING);\n", "\n", "    int numeratorBits = bits;\n", "\n", "    for (int i = 1; i < k; i++) {\n", "      int p = n - i;\n", "      int q = i + 1;\n", "\n", "      // log2(p) >= bits - 1, because p >= n/2\n", "\n", "      if (numeratorBits + bits >= Long.SIZE - 1) {\n", "        // The numerator is as big as it can get without risking overflow.\n", "        // Multiply numeratorAccum / denominatorAccum into accum.\n", "        accum = accum\n", "            .multiply(BigInteger.valueOf(numeratorAccum))\n", "            .divide(BigInteger.valueOf(denominatorAccum));\n", "        numeratorAccum = p;\n", "        denominatorAccum = q;\n", "        numeratorBits = bits;\n", "      } else {\n", "        // We can definitely multiply into the long accumulators without overflowing them.\n", "        numeratorAccum *= p;\n", "        denominatorAccum *= q;\n", "        numeratorBits += bits;\n", "      }\n", "    }\n", "    return accum\n", "        .multiply(BigInteger.valueOf(numeratorAccum))\n", "        .divide(BigInteger.valueOf(denominatorAccum));\n", "  }\n", "\n", "  // Returns true if BigInteger.valueOf(x.longValue()).equals(x).\n", "\n", "  private BigIntegerMath() {}\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268]}}, {"50": "guava-gwt/src-super/com/google/common/math/super/com/google/common/math/DoubleMath.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.math;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.math.MathPreconditions.checkNonNegative;\n", "import static java.lang.Math.log;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "import com.google.common.primitives.Booleans;\n", "\n", "/**\n", " * A class for arithmetic on doubles that is not covered by {@link java.lang.Math}.\n", " *\n", " * @author Louis Wasserman\n", " * @since 11.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class DoubleMath {\n", "  /*\n", "   * This method returns a value y such that rounding y DOWN (towards zero) gives the same result\n", "   * as rounding x according to the specified mode.\n", "   */\n", "\n", "  private static final double MIN_INT_AS_DOUBLE = -0x1p31;\n", "  private static final double MAX_INT_AS_DOUBLE = 0x1p31 - 1.0;\n", "\n", "  private static final double MIN_LONG_AS_DOUBLE = -0x1p63;\n", "  /*\n", "   * We cannot store Long.MAX_VALUE as a double without losing precision.  Instead, we store\n", "   * Long.MAX_VALUE + 1 == -Long.MIN_VALUE, and then offset all comparisons by 1.\n", "   */\n", "  private static final double MAX_LONG_AS_DOUBLE_PLUS_ONE = 0x1p63;\n", "\n", "  /**\n", "   * Returns the base 2 logarithm of a double value.\n", "   *\n", "   * <p>Special cases:\n", "   * <ul>\n", "   * <li>If {@code x} is NaN or less than zero, the result is NaN.\n", "   * <li>If {@code x} is positive infinity, the result is positive infinity.\n", "   * <li>If {@code x} is positive or negative zero, the result is negative infinity.\n", "   * </ul>\n", "   *\n", "   * <p>The computed result is within 1 ulp of the exact result.\n", "   *\n", "   * <p>If the result of this method will be immediately rounded to an {@code int},\n", "   * {@link #log2(double, RoundingMode)} is faster.\n", "   */\n", "  public static double log2(double x) {\n", "    return log(x) / LN_2; // surprisingly within 1 ulp according to tests\n", "  }\n", "\n", "  private static final double LN_2 = log(2);\n", "\n", "  /**\n", "   * Returns {@code n!}, that is, the product of the first {@code n} positive\n", "   * integers, {@code 1} if {@code n == 0}, or {@code n!}, or\n", "   * {@link Double#POSITIVE_INFINITY} if {@code n! > Double.MAX_VALUE}.\n", "   *\n", "   * <p>The result is within 1 ulp of the true value.\n", "   *\n", "   * @throws IllegalArgumentException if {@code n < 0}\n", "   */\n", "  public static double factorial(int n) {\n", "    checkNonNegative(\"n\", n);\n", "    if (n > MAX_FACTORIAL) {\n", "      return Double.POSITIVE_INFINITY;\n", "    } else {\n", "      // Multiplying the last (n & 0xf) values into their own accumulator gives a more accurate\n", "      // result than multiplying by everySixteenthFactorial[n >> 4] directly.\n", "      double accum = 1.0;\n", "      for (int i = 1 + (n & ~0xf); i <= n; i++) {\n", "        accum *= i;\n", "      }\n", "      return accum * everySixteenthFactorial[n >> 4];\n", "    }\n", "  }\n", "\n", "  @VisibleForTesting\n", "  static final int MAX_FACTORIAL = 170;\n", "\n", "  @VisibleForTesting\n", "  static final double[] everySixteenthFactorial = {\n", "      0x1.0p0,\n", "      0x1.30777758p44,\n", "      0x1.956ad0aae33a4p117,\n", "      0x1.ee69a78d72cb6p202,\n", "      0x1.fe478ee34844ap295,\n", "      0x1.c619094edabffp394,\n", "      0x1.3638dd7bd6347p498,\n", "      0x1.7cac197cfe503p605,\n", "      0x1.1e5dfc140e1e5p716,\n", "      0x1.8ce85fadb707ep829,\n", "      0x1.95d5f3d928edep945};\n", "\n", "  /**\n", "   * Returns {@code true} if {@code a} and {@code b} are within {@code tolerance} of each other.\n", "   *\n", "   * <p>Technically speaking, this is equivalent to\n", "   * {@code Math.abs(a - b) <= tolerance || Double.valueOf(a).equals(Double.valueOf(b))}.\n", "   *\n", "   * <p>Notable special cases include:\n", "   * <ul>\n", "   * <li>All NaNs are fuzzily equal.\n", "   * <li>If {@code a == b}, then {@code a} and {@code b} are always fuzzily equal.\n", "   * <li>Positive and negative zero are always fuzzily equal.\n", "   * <li>If {@code tolerance} is zero, and neither {@code a} nor {@code b} is NaN, then\n", "   * {@code a} and {@code b} are fuzzily equal if and only if {@code a == b}.\n", "   * <li>With {@link Double#POSITIVE_INFINITY} tolerance, all non-NaN values are fuzzily equal.\n", "   * <li>With finite tolerance, {@code Double.POSITIVE_INFINITY} and {@code\n", "   * Double.NEGATIVE_INFINITY} are fuzzily equal only to themselves.\n", "   * </li>\n", "   *\n", "   * <p>This is reflexive and symmetric, but <em>not</em> transitive, so it is <em>not</em> an\n", "   * equivalence relation and <em>not</em> suitable for use in {@link Object#equals}\n", "   * implementations.\n", "   *\n", "   * @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN\n", "   * @since 13.0\n", "   */\n", "  public static boolean fuzzyEquals(double a, double b, double tolerance) {\n", "    MathPreconditions.checkNonNegative(\"tolerance\", tolerance);\n", "    return\n", "          Math.copySign(a - b, 1.0) <= tolerance\n", "           // copySign(x, 1.0) is a branch-free version of abs(x), but with different NaN semantics\n", "          || (a == b) // needed to ensure that infinities equal themselves\n", "          || (Double.isNaN(a) && Double.isNaN(b));\n", "  }\n", "\n", "  /**\n", "   * Compares {@code a} and {@code b} \"fuzzily,\" with a tolerance for nearly-equal values.\n", "   *\n", "   * <p>This method is equivalent to\n", "   * {@code fuzzyEquals(a, b, tolerance) ? 0 : Double.compare(a, b)}. In particular, like\n", "   * {@link Double#compare(double, double)}, it treats all NaN values as equal and greater than all\n", "   * other values (including {@link Double#POSITIVE_INFINITY}).\n", "   *\n", "   * <p>This is <em>not</em> a total ordering and is <em>not</em> suitable for use in\n", "   * {@link Comparable#compareTo} implementations.  In particular, it is not transitive.\n", "   *\n", "   * @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN\n", "   * @since 13.0\n", "   */\n", "  public static int fuzzyCompare(double a, double b, double tolerance) {\n", "    if (fuzzyEquals(a, b, tolerance)) {\n", "      return 0;\n", "    } else if (a < b) {\n", "      return -1;\n", "    } else if (a > b) {\n", "      return 1;\n", "    } else {\n", "      return Booleans.compare(Double.isNaN(a), Double.isNaN(b));\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns the <a href=\"http://en.wikipedia.org/wiki/Arithmetic_mean\">arithmetic mean</a> of\n", "   * {@code values}.\n", "   *\n", "   * <p>If these values are a sample drawn from a population, this is also an unbiased estimator of\n", "   * the arithmetic mean of the population.\n", "   *\n", "   * @param values a nonempty series of values\n", "   * @throws IllegalArgumentException if {@code values} is empty\n", "   */\n", "  public static double mean(int... values) {\n", "    checkArgument(values.length > 0, \"Cannot take mean of 0 values\");\n", "    // The upper bound on the the length of an array and the bounds on the int values mean that, in\n", "    // this case only, we can compute the sum as a long without risking overflow or loss of\n", "    // precision. So we do that, as it's slightly quicker than the Knuth algorithm.\n", "    long sum = 0;\n", "    for (int index = 0; index < values.length; ++index) {\n", "      sum += values[index];\n", "    }\n", "    return (double) sum / values.length;\n", "  }\n", "\n", "  /**\n", "   * Returns the <a href=\"http://en.wikipedia.org/wiki/Arithmetic_mean\">arithmetic mean</a> of\n", "   * {@code values}.\n", "   *\n", "   * <p>If these values are a sample drawn from a population, this is also an unbiased estimator of\n", "   * the arithmetic mean of the population.\n", "   *\n", "   * @param values a nonempty series of values, which will be converted to {@code double} values\n", "   *     (this may cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))\n", "   * @throws IllegalArgumentException if {@code values} is empty\n", "   */\n", "  public static double mean(long... values) {\n", "    checkArgument(values.length > 0, \"Cannot take mean of 0 values\");\n", "    long count = 1;\n", "    double mean = values[0];\n", "    for (int index = 1; index < values.length; ++index) {\n", "      count++;\n", "      // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)\n", "      mean += (values[index] - mean) / count;\n", "    }\n", "    return mean;\n", "  }\n", "\n", "  private DoubleMath() {}\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219]}}, {"51": "guava-gwt/src-super/com/google/common/math/super/com/google/common/math/IntMath.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.math;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.math.MathPreconditions.checkNoOverflow;\n", "import static com.google.common.math.MathPreconditions.checkNonNegative;\n", "import static com.google.common.math.MathPreconditions.checkPositive;\n", "import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;\n", "import static java.lang.Math.abs;\n", "import static java.lang.Math.min;\n", "import static java.math.RoundingMode.HALF_EVEN;\n", "import static java.math.RoundingMode.HALF_UP;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "\n", "import java.math.RoundingMode;\n", "\n", "/**\n", " * A class for arithmetic on values of type {@code int}. Where possible, methods are defined and\n", " * named analogously to their {@code BigInteger} counterparts.\n", " *\n", " * <p>The implementations of many methods in this class are based on material from Henry S. Warren,\n", " * Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).\n", " *\n", " * <p>Similar functionality for {@code long} and for {@link BigInteger} can be found in\n", " * {@link LongMath} and {@link BigIntegerMath} respectively.  For other common operations on\n", " * {@code int} values, see {@link com.google.common.primitives.Ints}.\n", " *\n", " * @author Louis Wasserman\n", " * @since 11.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class IntMath {\n", "  // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||\n", "\n", "  /**\n", "   * Returns {@code true} if {@code x} represents a power of two.\n", "   *\n", "   * <p>This differs from {@code Integer.bitCount(x) == 1}, because\n", "   * {@code Integer.bitCount(Integer.MIN_VALUE) == 1}, but {@link Integer#MIN_VALUE} is not a power\n", "   * of two.\n", "   */\n", "  public static boolean isPowerOfTwo(int x) {\n", "    return x > 0 & (x & (x - 1)) == 0;\n", "  }\n", "  \n", "  /**\n", "   * Returns 1 if {@code x < y} as unsigned integers, and 0 otherwise. Assumes that x - y fits into\n", "   * a signed int. The implementation is branch-free, and benchmarks suggest it is measurably (if\n", "   * narrowly) faster than the straightforward ternary expression.\n", "   */\n", "  @VisibleForTesting\n", "  static int lessThanBranchFree(int x, int y) {\n", "    // The double negation is optimized away by normal Java, but is necessary for GWT\n", "    // to make sure bit twiddling works as expected.\n", "    return ~~(x - y) >>> (Integer.SIZE - 1);\n", "  }\n", "\n", "  /**\n", "   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n", "   *\n", "   * @throws IllegalArgumentException if {@code x <= 0}\n", "   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n", "   *         is not a power of two\n", "   */\n", "  @SuppressWarnings(\"fallthrough\")\n", "  // TODO(kevinb): remove after this warning is disabled globally\n", "  public static int log2(int x, RoundingMode mode) {\n", "    checkPositive(\"x\", x);\n", "    switch (mode) {\n", "      case UNNECESSARY:\n", "        checkRoundingUnnecessary(isPowerOfTwo(x));\n", "        // fall through\n", "      case DOWN:\n", "      case FLOOR:\n", "        return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);\n", "\n", "      case UP:\n", "      case CEILING:\n", "        return Integer.SIZE - Integer.numberOfLeadingZeros(x - 1);\n", "\n", "      case HALF_DOWN:\n", "      case HALF_UP:\n", "      case HALF_EVEN:\n", "        // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n", "        int leadingZeros = Integer.numberOfLeadingZeros(x);\n", "        int cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n", "          // floor(2^(logFloor + 0.5))\n", "        int logFloor = (Integer.SIZE - 1) - leadingZeros;\n", "        return logFloor + lessThanBranchFree(cmp, x);\n", "\n", "      default:\n", "        throw new AssertionError();\n", "    }\n", "  }\n", "\n", "  /** The biggest half power of two that can fit in an unsigned int. */\n", "  @VisibleForTesting static final int MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333;\n", "\n", "  private static int log10Floor(int x) {\n", "    /*\n", "     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation.\n", "     *\n", "     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))),\n", "     * we can narrow the possible floor(log10(x)) values to two.  For example, if floor(log2(x))\n", "     * is 6, then 64 <= x < 128, so floor(log10(x)) is either 1 or 2.\n", "     */\n", "    int y = maxLog10ForLeadingZeros[Integer.numberOfLeadingZeros(x)];\n", "    /*\n", "     * y is the higher of the two possible values of floor(log10(x)). If x < 10^y, then we want the\n", "     * lower of the two possible values, or y - 1, otherwise, we want y.\n", "     */\n", "    return y - lessThanBranchFree(x, powersOf10[y]);\n", "  }\n", "\n", "  // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))\n", "  @VisibleForTesting static final byte[] maxLog10ForLeadingZeros = {9, 9, 9, 8, 8, 8,\n", "    7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0};\n", "\n", "  @VisibleForTesting static final int[] powersOf10 = {1, 10, 100, 1000, 10000,\n", "    100000, 1000000, 10000000, 100000000, 1000000000};\n", "\n", "  // halfPowersOf10[i] = largest int less than 10^(i + 0.5)\n", "  @VisibleForTesting static final int[] halfPowersOf10 =\n", "      {3, 31, 316, 3162, 31622, 316227, 3162277, 31622776, 316227766, Integer.MAX_VALUE};\n", "\n", "  private static int sqrtFloor(int x) {\n", "    // There is no loss of precision in converting an int to a double, according to\n", "    // http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#5.1.2\n", "    return (int) Math.sqrt(x);\n", "  }\n", "\n", "  /**\n", "   * Returns the result of dividing {@code p} by {@code q}, rounding using the specified\n", "   * {@code RoundingMode}.\n", "   *\n", "   * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n", "   *         is not an integer multiple of {@code b}\n", "   */\n", "  @SuppressWarnings(\"fallthrough\")\n", "  public static int divide(int p, int q, RoundingMode mode) {\n", "    checkNotNull(mode);\n", "    if (q == 0) {\n", "      throw new ArithmeticException(\"/ by zero\"); // for GWT\n", "    }\n", "    int div = p / q;\n", "    int rem = p - q * div; // equal to p % q\n", "\n", "    if (rem == 0) {\n", "      return div;\n", "    }\n", "\n", "    /*\n", "     * Normal Java division rounds towards 0, consistently with RoundingMode.DOWN. We just have to\n", "     * deal with the cases where rounding towards 0 is wrong, which typically depends on the sign of\n", "     * p / q.\n", "     *\n", "     * signum is 1 if p and q are both nonnegative or both negative, and -1 otherwise.\n", "     */\n", "    int signum = 1 | ((p ^ q) >> (Integer.SIZE - 1));\n", "    boolean increment;\n", "    switch (mode) {\n", "      case UNNECESSARY:\n", "        checkRoundingUnnecessary(rem == 0);\n", "        // fall through\n", "      case DOWN:\n", "        increment = false;\n", "        break;\n", "      case UP:\n", "        increment = true;\n", "        break;\n", "      case CEILING:\n", "        increment = signum > 0;\n", "        break;\n", "      case FLOOR:\n", "        increment = signum < 0;\n", "        break;\n", "      case HALF_EVEN:\n", "      case HALF_DOWN:\n", "      case HALF_UP:\n", "        int absRem = abs(rem);\n", "        int cmpRemToHalfDivisor = absRem - (abs(q) - absRem);\n", "        // subtracting two nonnegative ints can't overflow\n", "        // cmpRemToHalfDivisor has the same sign as compare(abs(rem), abs(q) / 2).\n", "        if (cmpRemToHalfDivisor == 0) { // exactly on the half mark\n", "          increment = (mode == HALF_UP || (mode == HALF_EVEN & (div & 1) != 0));\n", "        } else {\n", "          increment = cmpRemToHalfDivisor > 0; // closer to the UP value\n", "        }\n", "        break;\n", "      default:\n", "        throw new AssertionError();\n", "    }\n", "    return increment ? div + signum : div;\n", "  }\n", "\n", "  /**\n", "   * Returns {@code x mod m}, a non-negative value less than {@code m}.\n", "   * This differs from {@code x % m}, which might be negative.\n", "   *\n", "   * <p>For example:<pre> {@code\n", "   *\n", "   * mod(7, 4) == 3\n", "   * mod(-7, 4) == 1\n", "   * mod(-1, 4) == 3\n", "   * mod(-8, 4) == 0\n", "   * mod(8, 4) == 0}</pre>\n", "   *\n", "   * @throws ArithmeticException if {@code m <= 0}\n", "   * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3\">\n", "   *      Remainder Operator</a>\n", "   */\n", "  public static int mod(int x, int m) {\n", "    if (m <= 0) {\n", "      throw new ArithmeticException(\"Modulus \" + m + \" must be > 0\");\n", "    }\n", "    int result = x % m;\n", "    return (result >= 0) ? result : result + m;\n", "  }\n", "\n", "  /**\n", "   * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if\n", "   * {@code a == 0 && b == 0}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}\n", "   */\n", "  public static int gcd(int a, int b) {\n", "    /*\n", "     * The reason we require both arguments to be >= 0 is because otherwise, what do you return on\n", "     * gcd(0, Integer.MIN_VALUE)? BigInteger.gcd would return positive 2^31, but positive 2^31\n", "     * isn't an int.\n", "     */\n", "    checkNonNegative(\"a\", a);\n", "    checkNonNegative(\"b\", b);\n", "    if (a == 0) {\n", "      // 0 % b == 0, so b divides a, but the converse doesn't hold.\n", "      // BigInteger.gcd is consistent with this decision.\n", "      return b;\n", "    } else if (b == 0) {\n", "      return a; // similar logic\n", "    }\n", "    /*\n", "     * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm.\n", "     * This is >40% faster than the Euclidean algorithm in benchmarks.\n", "     */\n", "    int aTwos = Integer.numberOfTrailingZeros(a);\n", "    a >>= aTwos; // divide out all 2s\n", "    int bTwos = Integer.numberOfTrailingZeros(b);\n", "    b >>= bTwos; // divide out all 2s\n", "    while (a != b) { // both a, b are odd\n", "      // The key to the binary GCD algorithm is as follows:\n", "      // Both a and b are odd.  Assume a > b; then gcd(a - b, b) = gcd(a, b).\n", "      // But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two.\n", "\n", "      // We bend over backwards to avoid branching, adapting a technique from\n", "      // http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax\n", "\n", "      int delta = a - b; // can't overflow, since a and b are nonnegative\n", "\n", "      int minDeltaOrZero = delta & (delta >> (Integer.SIZE - 1));\n", "      // equivalent to Math.min(delta, 0)\n", "\n", "      a = delta - minDeltaOrZero - minDeltaOrZero; // sets a to Math.abs(a - b)\n", "      // a is now nonnegative and even\n", "\n", "      b += minDeltaOrZero; // sets b to min(old a, b)\n", "      a >>= Integer.numberOfTrailingZeros(a); // divide out all 2s, since 2 doesn't divide b\n", "    }\n", "    return a << min(aTwos, bTwos);\n", "  }\n", "\n", "  /**\n", "   * Returns the sum of {@code a} and {@code b}, provided it does not overflow.\n", "   *\n", "   * @throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic\n", "   */\n", "  public static int checkedAdd(int a, int b) {\n", "    long result = (long) a + b;\n", "    checkNoOverflow(result == (int) result);\n", "    return (int) result;\n", "  }\n", "\n", "  /**\n", "   * Returns the difference of {@code a} and {@code b}, provided it does not overflow.\n", "   *\n", "   * @throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic\n", "   */\n", "  public static int checkedSubtract(int a, int b) {\n", "    long result = (long) a - b;\n", "    checkNoOverflow(result == (int) result);\n", "    return (int) result;\n", "  }\n", "\n", "  /**\n", "   * Returns the product of {@code a} and {@code b}, provided it does not overflow.\n", "   *\n", "   * @throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic\n", "   */\n", "  public static int checkedMultiply(int a, int b) {\n", "    long result = (long) a * b;\n", "    checkNoOverflow(result == (int) result);\n", "    return (int) result;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@code b} to the {@code k}th power, provided it does not overflow.\n", "   *\n", "   * <p>{@link #pow} may be faster, but does not check for overflow.\n", "   *\n", "   * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed\n", "   *         {@code int} arithmetic\n", "   */\n", "  public static int checkedPow(int b, int k) {\n", "    checkNonNegative(\"exponent\", k);\n", "    switch (b) {\n", "      case 0:\n", "        return (k == 0) ? 1 : 0;\n", "      case 1:\n", "        return 1;\n", "      case (-1):\n", "        return ((k & 1) == 0) ? 1 : -1;\n", "      case 2:\n", "        checkNoOverflow(k < Integer.SIZE - 1);\n", "        return 1 << k;\n", "      case (-2):\n", "        checkNoOverflow(k < Integer.SIZE);\n", "        return ((k & 1) == 0) ? 1 << k : -1 << k;\n", "      default:\n", "        // continue below to handle the general case\n", "    }\n", "    int accum = 1;\n", "    while (true) {\n", "      switch (k) {\n", "        case 0:\n", "          return accum;\n", "        case 1:\n", "          return checkedMultiply(accum, b);\n", "        default:\n", "          if ((k & 1) != 0) {\n", "            accum = checkedMultiply(accum, b);\n", "          }\n", "          k >>= 1;\n", "          if (k > 0) {\n", "            checkNoOverflow(-FLOOR_SQRT_MAX_INT <= b & b <= FLOOR_SQRT_MAX_INT);\n", "            b *= b;\n", "          }\n", "      }\n", "    }\n", "  }\n", "\n", "  @VisibleForTesting static final int FLOOR_SQRT_MAX_INT = 46340;\n", "\n", "  /**\n", "   * Returns {@code n!}, that is, the product of the first {@code n} positive\n", "   * integers, {@code 1} if {@code n == 0}, or {@link Integer#MAX_VALUE} if the\n", "   * result does not fit in a {@code int}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code n < 0}\n", "   */\n", "  public static int factorial(int n) {\n", "    checkNonNegative(\"n\", n);\n", "    return (n < factorials.length) ? factorials[n] : Integer.MAX_VALUE;\n", "  }\n", "\n", "  private static final int[] factorials = {\n", "      1,\n", "      1,\n", "      1 * 2,\n", "      1 * 2 * 3,\n", "      1 * 2 * 3 * 4,\n", "      1 * 2 * 3 * 4 * 5,\n", "      1 * 2 * 3 * 4 * 5 * 6,\n", "      1 * 2 * 3 * 4 * 5 * 6 * 7,\n", "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8,\n", "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,\n", "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,\n", "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,\n", "      1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12};\n", "\n", "  // binomial(biggestBinomials[k], k) fits in an int, but not binomial(biggestBinomials[k]+1,k).\n", "  @VisibleForTesting static int[] biggestBinomials = {\n", "    Integer.MAX_VALUE,\n", "    Integer.MAX_VALUE,\n", "    65536,\n", "    2345,\n", "    477,\n", "    193,\n", "    110,\n", "    75,\n", "    58,\n", "    49,\n", "    43,\n", "    39,\n", "    37,\n", "    35,\n", "    34,\n", "    34,\n", "    33\n", "  };\n", "\n", "  /**\n", "   * Returns the arithmetic mean of {@code x} and {@code y}, rounded towards\n", "   * negative infinity. This method is overflow resilient.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  public static int mean(int x, int y) {\n", "    // Efficient method for computing the arithmetic mean.\n", "    // The alternative (x + y) / 2 fails for large values.\n", "    // The alternative (x + y) >>> 1 fails for negative values.\n", "    return (x & y) + ((x ^ y) >> 1);\n", "  }\n", "\n", "  private IntMath() {}\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432]}}, {"52": "guava-gwt/src-super/com/google/common/math/super/com/google/common/math/LongMath.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.math;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.math.MathPreconditions.checkNonNegative;\n", "import static com.google.common.math.MathPreconditions.checkPositive;\n", "import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;\n", "import static java.lang.Math.min;\n", "import static java.math.RoundingMode.HALF_EVEN;\n", "import static java.math.RoundingMode.HALF_UP;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.annotations.VisibleForTesting;\n", "import com.google.common.primitives.UnsignedLongs;\n", "\n", "import java.math.RoundingMode;\n", "\n", "/**\n", " * A class for arithmetic on values of type {@code long}. Where possible, methods are defined and\n", " * named analogously to their {@code BigInteger} counterparts.\n", " *\n", " * <p>The implementations of many methods in this class are based on material from Henry S. Warren,\n", " * Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).\n", " *\n", " * <p>Similar functionality for {@code int} and for {@link BigInteger} can be found in\n", " * {@link IntMath} and {@link BigIntegerMath} respectively.  For other common operations on\n", " * {@code long} values, see {@link com.google.common.primitives.Longs}.\n", " *\n", " * @author Louis Wasserman\n", " * @since 11.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class LongMath {\n", "  // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||\n", "\n", "  /**\n", "   * Returns {@code true} if {@code x} represents a power of two.\n", "   *\n", "   * <p>This differs from {@code Long.bitCount(x) == 1}, because\n", "   * {@code Long.bitCount(Long.MIN_VALUE) == 1}, but {@link Long#MIN_VALUE} is not a power of two.\n", "   */\n", "  public static boolean isPowerOfTwo(long x) {\n", "    return x > 0 & (x & (x - 1)) == 0;\n", "  }\n", "  \n", "  /**\n", "   * Returns 1 if {@code x < y} as unsigned longs, and 0 otherwise.  Assumes that x - y fits into a\n", "   * signed long.  The implementation is branch-free, and benchmarks suggest it is measurably\n", "   * faster than the straightforward ternary expression.\n", "   */\n", "  @VisibleForTesting\n", "  static int lessThanBranchFree(long x, long y) {\n", "    // Returns the sign bit of x - y.\n", "    return (int) (~~(x - y) >>> (Long.SIZE - 1));\n", "  }\n", "\n", "  /**\n", "   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n", "   *\n", "   * @throws IllegalArgumentException if {@code x <= 0}\n", "   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n", "   *         is not a power of two\n", "   */\n", "  @SuppressWarnings(\"fallthrough\")\n", "  // TODO(kevinb): remove after this warning is disabled globally\n", "  public static int log2(long x, RoundingMode mode) {\n", "    checkPositive(\"x\", x);\n", "    switch (mode) {\n", "      case UNNECESSARY:\n", "        checkRoundingUnnecessary(isPowerOfTwo(x));\n", "        // fall through\n", "      case DOWN:\n", "      case FLOOR:\n", "        return (Long.SIZE - 1) - Long.numberOfLeadingZeros(x);\n", "\n", "      case UP:\n", "      case CEILING:\n", "        return Long.SIZE - Long.numberOfLeadingZeros(x - 1);\n", "\n", "      case HALF_DOWN:\n", "      case HALF_UP:\n", "      case HALF_EVEN:\n", "        // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n", "        int leadingZeros = Long.numberOfLeadingZeros(x);\n", "        long cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n", "        // floor(2^(logFloor + 0.5))\n", "        int logFloor = (Long.SIZE - 1) - leadingZeros;\n", "        return logFloor + lessThanBranchFree(cmp, x);\n", "\n", "      default:\n", "        throw new AssertionError(\"impossible\");\n", "    }\n", "  }\n", "\n", "  /** The biggest half power of two that fits into an unsigned long */\n", "  @VisibleForTesting static final long MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333F9DE6484L;\n", "\n", "  // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))\n", "  @VisibleForTesting static final byte[] maxLog10ForLeadingZeros = {\n", "      19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 12, 12,\n", "      12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4,\n", "      3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0 };\n", "\n", "  // halfPowersOf10[i] = largest long less than 10^(i + 0.5)\n", "\n", "  /**\n", "   * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if\n", "   * {@code a == 0 && b == 0}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}\n", "   */\n", "  public static long gcd(long a, long b) {\n", "    /*\n", "     * The reason we require both arguments to be >= 0 is because otherwise, what do you return on\n", "     * gcd(0, Long.MIN_VALUE)? BigInteger.gcd would return positive 2^63, but positive 2^63 isn't\n", "     * an int.\n", "     */\n", "    checkNonNegative(\"a\", a);\n", "    checkNonNegative(\"b\", b);\n", "    if (a == 0) {\n", "      // 0 % b == 0, so b divides a, but the converse doesn't hold.\n", "      // BigInteger.gcd is consistent with this decision.\n", "      return b;\n", "    } else if (b == 0) {\n", "      return a; // similar logic\n", "    }\n", "    /*\n", "     * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm.\n", "     * This is >60% faster than the Euclidean algorithm in benchmarks.\n", "     */\n", "    int aTwos = Long.numberOfTrailingZeros(a);\n", "    a >>= aTwos; // divide out all 2s\n", "    int bTwos = Long.numberOfTrailingZeros(b);\n", "    b >>= bTwos; // divide out all 2s\n", "    while (a != b) { // both a, b are odd\n", "      // The key to the binary GCD algorithm is as follows:\n", "      // Both a and b are odd.  Assume a > b; then gcd(a - b, b) = gcd(a, b).\n", "      // But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two.\n", "\n", "      // We bend over backwards to avoid branching, adapting a technique from\n", "      // http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax\n", "\n", "      long delta = a - b; // can't overflow, since a and b are nonnegative\n", "\n", "      long minDeltaOrZero = delta & (delta >> (Long.SIZE - 1));\n", "      // equivalent to Math.min(delta, 0)\n", "\n", "      a = delta - minDeltaOrZero - minDeltaOrZero; // sets a to Math.abs(a - b)\n", "      // a is now nonnegative and even\n", "\n", "      b += minDeltaOrZero; // sets b to min(old a, b)\n", "      a >>= Long.numberOfTrailingZeros(a); // divide out all 2s, since 2 doesn't divide b\n", "    }\n", "    return a << min(aTwos, bTwos);\n", "  }\n", "\n", "  @VisibleForTesting static final long FLOOR_SQRT_MAX_LONG = 3037000499L;\n", "\n", "  static final long[] factorials = {\n", "      1L,\n", "      1L,\n", "      1L * 2,\n", "      1L * 2 * 3,\n", "      1L * 2 * 3 * 4,\n", "      1L * 2 * 3 * 4 * 5,\n", "      1L * 2 * 3 * 4 * 5 * 6,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19,\n", "      1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20\n", "  };\n", "\n", "  /**\n", "   * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and\n", "   * {@code k}, or {@link Long#MAX_VALUE} if the result does not fit in a {@code long}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}\n", "   */\n", "  public static long binomial(int n, int k) {\n", "    checkNonNegative(\"n\", n);\n", "    checkNonNegative(\"k\", k);\n", "    checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n", "    if (k > (n >> 1)) {\n", "      k = n - k;\n", "    }\n", "    switch (k) {\n", "      case 0:\n", "        return 1;\n", "      case 1:\n", "        return n;\n", "      default:\n", "        if (n < factorials.length) {\n", "          return factorials[n] / (factorials[k] * factorials[n - k]);\n", "        } else if (k >= biggestBinomials.length || n > biggestBinomials[k]) {\n", "          return Long.MAX_VALUE;\n", "        } else if (k < biggestSimpleBinomials.length && n <= biggestSimpleBinomials[k]) {\n", "          // guaranteed not to overflow\n", "          long result = n--;\n", "          for (int i = 2; i <= k; n--, i++) {\n", "            result *= n;\n", "            result /= i;\n", "          }\n", "          return result;\n", "        } else {\n", "          int nBits = LongMath.log2(n, RoundingMode.CEILING);\n", "          \n", "          long result = 1;\n", "          long numerator = n--;\n", "          long denominator = 1;\n", "          \n", "          int numeratorBits = nBits;\n", "          // This is an upper bound on log2(numerator, ceiling).\n", "          \n", "          /*\n", "           * We want to do this in long math for speed, but want to avoid overflow. We adapt the\n", "           * technique previously used by BigIntegerMath: maintain separate numerator and\n", "           * denominator accumulators, multiplying the fraction into result when near overflow.\n", "           */\n", "          for (int i = 2; i <= k; i++, n--) {\n", "            if (numeratorBits + nBits < Long.SIZE - 1) {\n", "              // It's definitely safe to multiply into numerator and denominator.\n", "              numerator *= n;\n", "              denominator *= i;\n", "              numeratorBits += nBits;\n", "            } else {\n", "              // It might not be safe to multiply into numerator and denominator,\n", "              // so multiply (numerator / denominator) into result.\n", "              result = multiplyFraction(result, numerator, denominator);\n", "              numerator = n;\n", "              denominator = i;\n", "              numeratorBits = nBits;\n", "            }\n", "          }\n", "          return multiplyFraction(result, numerator, denominator);\n", "        }\n", "    }\n", "  }\n", "  \n", "  /**\n", "   * Returns (x * numerator / denominator), which is assumed to come out to an integral value.\n", "   */\n", "  static long multiplyFraction(long x, long numerator, long denominator) {\n", "    if (x == 1) {\n", "      return numerator / denominator;\n", "    }\n", "    long commonDivisor = gcd(x, denominator);\n", "    x /= commonDivisor;\n", "    denominator /= commonDivisor;\n", "    // We know gcd(x, denominator) = 1, and x * numerator / denominator is exact,\n", "    // so denominator must be a divisor of numerator.\n", "    return x * (numerator / denominator);\n", "  }\n", "\n", "  /*\n", "   * binomial(biggestBinomials[k], k) fits in a long, but not\n", "   * binomial(biggestBinomials[k] + 1, k).\n", "   */\n", "  static final int[] biggestBinomials =\n", "      {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, 3810779, 121977, 16175, 4337, 1733,\n", "          887, 534, 361, 265, 206, 169, 143, 125, 111, 101, 94, 88, 83, 79, 76, 74, 72, 70, 69, 68,\n", "          67, 67, 66, 66, 66, 66};\n", "\n", "  /*\n", "   * binomial(biggestSimpleBinomials[k], k) doesn't need to use the slower GCD-based impl,\n", "   * but binomial(biggestSimpleBinomials[k] + 1, k) does.\n", "   */\n", "  @VisibleForTesting static final int[] biggestSimpleBinomials =\n", "      {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, 2642246, 86251, 11724, 3218, 1313,\n", "          684, 419, 287, 214, 169, 139, 119, 105, 95, 87, 81, 76, 73, 70, 68, 66, 64, 63, 62, 62,\n", "          61, 61, 61};\n", "  // These values were generated by using checkedMultiply to see when the simple multiply/divide\n", "  // algorithm would lead to an overflow.\n", "\n", "  static boolean fitsInInt(long x) {\n", "    return (int) x == x;\n", "  }\n", "\n", "  /**\n", "   * Returns the arithmetic mean of {@code x} and {@code y}, rounded toward\n", "   * negative infinity. This method is resilient to overflow.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  public static long mean(long x, long y) {\n", "    // Efficient method for computing the arithmetic mean.\n", "    // The alternative (x + y) / 2 fails for large values.\n", "    // The alternative (x + y) >>> 1 fails for negative values.\n", "    return (x & y) + ((x ^ y) >> 1);\n", "  }\n", "  \n", "  /*\n", "   * If n <= millerRabinBases[i][0], then testing n against bases millerRabinBases[i][1..]\n", "   * suffices to prove its primality.  Values from miller-rabin.appspot.com.\n", "   * \n", "   * NOTE: We could get slightly better bases that would be treated as unsigned, but benchmarks\n", "   * showed negligible performance improvements.\n", "   */\n", "  private static final long[][] millerRabinBaseSets = {\n", "    {291830, 126401071349994536L},\n", "    {885594168, 725270293939359937L, 3569819667048198375L},\n", "    {273919523040L, 15, 7363882082L, 992620450144556L},\n", "    {47636622961200L, 2, 2570940, 211991001, 3749873356L},\n", "    {7999252175582850L,\n", "      2, 4130806001517L, 149795463772692060L, 186635894390467037L, 3967304179347715805L},\n", "    {585226005592931976L,\n", "      2, 123635709730000L, 9233062284813009L, 43835965440333360L, 761179012939631437L,\n", "      1263739024124850375L},\n", "    {Long.MAX_VALUE,\n", "        2, 325, 9375, 28178, 450775, 9780504, 1795265022}\n", "  };\n", "  \n", "  private enum MillerRabinTester {\n", "    /**\n", "     * Works for inputs <= FLOOR_SQRT_MAX_LONG.\n", "     */\n", "    SMALL {\n", "      @Override\n", "      long mulMod(long a, long b, long m) {\n", "        /* \n", "         * NOTE(lowasser, 2015-Feb-12): Benchmarks suggest that changing this to \n", "         * UnsignedLongs.remainder and increasing the threshold to 2^32 doesn't pay for itself,\n", "         * and adding another enum constant hurts performance further -- I suspect because\n", "         * bimorphic implementation is a sweet spot for the JVM.\n", "         */ \n", "        return (a * b) % m;\n", "      }\n", "      \n", "      @Override\n", "      long squareMod(long a, long m) {\n", "        return (a * a) % m;\n", "      }\n", "    },\n", "    /**\n", "     * Works for all nonnegative signed longs.\n", "     */\n", "    LARGE {\n", "      /**\n", "       * Returns (a + b) mod m.  Precondition: 0 <= a, b < m < 2^63.\n", "       */\n", "      private long plusMod(long a, long b, long m) {\n", "        return (a >= m - b) ? (a + b - m) : (a + b);\n", "      }\n", "\n", "      /**\n", "       * Returns (a * 2^32) mod m.  a may be any unsigned long.\n", "       */\n", "      private long times2ToThe32Mod(long a, long m) {\n", "        int remainingPowersOf2 = 32;\n", "        do {\n", "          int shift = Math.min(remainingPowersOf2, Long.numberOfLeadingZeros(a));\n", "          // shift is either the number of powers of 2 left to multiply a by, or the biggest shift\n", "          // possible while keeping a in an unsigned long.\n", "          a = UnsignedLongs.remainder(a << shift, m);\n", "          remainingPowersOf2 -= shift;\n", "        } while (remainingPowersOf2 > 0);\n", "        return a;\n", "      }\n", "\n", "      @Override\n", "      long mulMod(long a, long b, long m) {\n", "        long aHi = a >>> 32; // < 2^31\n", "        long bHi = b >>> 32; // < 2^31\n", "        long aLo = a & 0xFFFFFFFFL; // < 2^32\n", "        long bLo = b & 0xFFFFFFFFL; // < 2^32\n", "        \n", "        /*\n", "         * a * b == aHi * bHi * 2^64 + (aHi * bLo + aLo * bHi) * 2^63 + aLo * bLo.\n", "         *       == (aHi * bHi * 2^32 + aHi * bLo + aLo * bHi) * 2^32 + aLo * bLo\n", "         * \n", "         * We carry out this computation in modular arithmetic.  Since times2ToThe32Mod accepts\n", "         * any unsigned long, we don't have to do a mod on every operation, only when intermediate\n", "         * results can exceed 2^63.\n", "         */\n", "        long result = times2ToThe32Mod(aHi * bHi /* < 2^62 */, m); // < m < 2^63\n", "        result += aHi * bLo; // aHi * bLo < 2^63, result < 2^64\n", "        if (result < 0) {\n", "          result = UnsignedLongs.remainder(result, m);\n", "        }\n", "        // result < 2^63 again\n", "        result += aLo * bHi; // aLo * bHi < 2^63, result < 2^64\n", "        result = times2ToThe32Mod(result, m); // result < m < 2^63\n", "        return plusMod(\n", "            result,\n", "            UnsignedLongs.remainder(aLo * bLo /* < 2^64 */, m),\n", "            m);\n", "      }\n", "\n", "      @Override\n", "      long squareMod(long a, long m) {\n", "        long aHi = a >>> 32; // < 2^31\n", "        long aLo = a & 0xFFFFFFFFL; // < 2^32\n", "        \n", "        /*\n", "         * a^2 == aHi^2 * 2^64 + aHi * aLo * 2^33 + aLo^2\n", "         *     == (aHi^2 * 2^32 + aHi * aLo * 2) * 2^32 + aLo^2\n", "         * We carry out this computation in modular arithmetic.  Since times2ToThe32Mod accepts\n", "         * any unsigned long, we don't have to do a mod on every operation, only when intermediate\n", "         * results can exceed 2^63.  \n", "         */\n", "        long result = times2ToThe32Mod(aHi * aHi /* < 2^62 */, m); // < m < 2^63\n", "        long hiLo = aHi * aLo * 2;\n", "        if (hiLo < 0) {\n", "          hiLo = UnsignedLongs.remainder(hiLo, m);\n", "        }\n", "        // hiLo < 2^63\n", "        result += hiLo; // result < 2^64\n", "        result = times2ToThe32Mod(result, m); // result < m < 2^63\n", "        return plusMod(\n", "            result,\n", "            UnsignedLongs.remainder(aLo * aLo /* < 2^64 */, m),\n", "            m);\n", "      }\n", "    };\n", "    \n", "    static boolean test(long base, long n) {\n", "      // Since base will be considered % n, it's okay if base > FLOOR_SQRT_MAX_LONG,\n", "      // so long as n <= FLOOR_SQRT_MAX_LONG.\n", "      return ((n <= FLOOR_SQRT_MAX_LONG) ? SMALL : LARGE).testWitness(base, n);\n", "    }\n", "    \n", "    /**\n", "     * Returns a * b mod m.\n", "     */\n", "    abstract long mulMod(long a, long b, long m);\n", "    \n", "    /**\n", "     * Returns a^2 mod m.\n", "     */\n", "    abstract long squareMod(long a, long m);\n", "    \n", "    /**\n", "     * Returns a^p mod m.\n", "     */\n", "    private long powMod(long a, long p, long m) {\n", "      long res = 1;\n", "      for (; p != 0; p >>= 1) {\n", "        if ((p & 1) != 0) {\n", "          res = mulMod(res, a, m);\n", "        }\n", "        a = squareMod(a, m);\n", "      }\n", "      return res;\n", "    }\n", "    \n", "    /**\n", "     * Returns true if n is a strong probable prime relative to the specified base.\n", "     */\n", "    private boolean testWitness(long base, long n) {\n", "      int r = Long.numberOfTrailingZeros(n - 1);\n", "      long d = (n - 1) >> r;\n", "      base %= n;\n", "      if (base == 0) {\n", "        return true;\n", "      }\n", "      // Calculate a := base^d mod n.\n", "      long a = powMod(base, d, n);\n", "      // n passes this test if\n", "      //    base^d = 1 (mod n)\n", "      // or base^(2^j * d) = -1 (mod n) for some 0 <= j < r.\n", "      if (a == 1) {\n", "        return true;\n", "      }\n", "      int j = 0;\n", "      while (a != n - 1) {\n", "        if (++j == r) {\n", "          return false;\n", "        }\n", "        a = squareMod(a, n);\n", "      }\n", "      return true;\n", "    }\n", "  }\n", "\n", "  private LongMath() {}\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501]}}, {"53": "guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/Chars.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkElementIndex;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkPositionIndexes;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractList;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "import java.util.RandomAccess;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to {@code char} primitives, that are not\n", " * already found in either {@link Character} or {@link Arrays}.\n", " *\n", " * <p>All the operations in this class treat {@code char} values strictly\n", " * numerically; they are neither Unicode-aware nor locale-dependent.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/PrimitivesExplained\">\n", " * primitive utilities</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 1.0\n", " */\n", "@CheckReturnValue\n", "@GwtCompatible(emulated = true)\n", "public final class Chars {\n", "  private Chars() {}\n", "\n", "  /**\n", "   * The number of bytes required to represent a primitive {@code char}\n", "   * value.\n", "   */\n", "  public static final int BYTES = Character.SIZE / Byte.SIZE;\n", "\n", "  /**\n", "   * Returns a hash code for {@code value}; equal to the result of invoking\n", "   * {@code ((Character) value).hashCode()}.\n", "   *\n", "   * @param value a primitive {@code char} value\n", "   * @return a hash code for the value\n", "   */\n", "  public static int hashCode(char value) {\n", "    return value;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@code char} value that is equal to {@code value}, if possible.\n", "   *\n", "   * @param value any value in the range of the {@code char} type\n", "   * @return the {@code char} value that equals {@code value}\n", "   * @throws IllegalArgumentException if {@code value} is greater than {@link\n", "   *     Character#MAX_VALUE} or less than {@link Character#MIN_VALUE}\n", "   */\n", "  public static char checkedCast(long value) {\n", "    char result = (char) value;\n", "    if (result != value) {\n", "      // don't use checkArgument here, to avoid boxing\n", "      throw new IllegalArgumentException(\"Out of range: \" + value);\n", "    }\n", "    return result;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@code char} nearest in value to {@code value}.\n", "   *\n", "   * @param value any {@code long} value\n", "   * @return the same value cast to {@code char} if it is in the range of the\n", "   *     {@code char} type, {@link Character#MAX_VALUE} if it is too large,\n", "   *     or {@link Character#MIN_VALUE} if it is too small\n", "   */\n", "  public static char saturatedCast(long value) {\n", "    if (value > Character.MAX_VALUE) {\n", "      return Character.MAX_VALUE;\n", "    }\n", "    if (value < Character.MIN_VALUE) {\n", "      return Character.MIN_VALUE;\n", "    }\n", "    return (char) value;\n", "  }\n", "\n", "  /**\n", "   * Compares the two specified {@code char} values. The sign of the value\n", "   * returned is the same as that of {@code ((Character) a).compareTo(b)}.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> this method should be treated as\n", "   * deprecated; use the equivalent {@link Character#compare} method instead.\n", "   *\n", "   * @param a the first {@code char} to compare\n", "   * @param b the second {@code char} to compare\n", "   * @return a negative value if {@code a} is less than {@code b}; a positive\n", "   *     value if {@code a} is greater than {@code b}; or zero if they are equal\n", "   */\n", "  public static int compare(char a, char b) {\n", "    return a - b; // safe due to restricted range\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code target} is present as an element anywhere in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code char} values, possibly empty\n", "   * @param target a primitive {@code char} value\n", "   * @return {@code true} if {@code array[i] == target} for some value of {@code\n", "   *     i}\n", "   */\n", "  public static boolean contains(char[] array, char target) {\n", "    for (char value : array) {\n", "      if (value == target) {\n", "        return true;\n", "      }\n", "    }\n", "    return false;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the first appearance of the value {@code target} in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code char} values, possibly empty\n", "   * @param target a primitive {@code char} value\n", "   * @return the least index {@code i} for which {@code array[i] == target}, or\n", "   *     {@code -1} if no such index exists.\n", "   */\n", "  public static int indexOf(char[] array, char target) {\n", "    return indexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int indexOf(char[] array, char target, int start, int end) {\n", "    for (int i = start; i < end; i++) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the start position of the first occurrence of the specified {@code\n", "   * target} within {@code array}, or {@code -1} if there is no such occurrence.\n", "   *\n", "   * <p>More formally, returns the lowest index {@code i} such that {@code\n", "   * java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly\n", "   * the same elements as {@code target}.\n", "   *\n", "   * @param array the array to search for the sequence {@code target}\n", "   * @param target the array to search for as a sub-sequence of {@code array}\n", "   */\n", "  public static int indexOf(char[] array, char[] target) {\n", "    checkNotNull(array, \"array\");\n", "    checkNotNull(target, \"target\");\n", "    if (target.length == 0) {\n", "      return 0;\n", "    }\n", "\n", "    outer:\n", "    for (int i = 0; i < array.length - target.length + 1; i++) {\n", "      for (int j = 0; j < target.length; j++) {\n", "        if (array[i + j] != target[j]) {\n", "          continue outer;\n", "        }\n", "      }\n", "      return i;\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the last appearance of the value {@code target} in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code char} values, possibly empty\n", "   * @param target a primitive {@code char} value\n", "   * @return the greatest index {@code i} for which {@code array[i] == target},\n", "   *     or {@code -1} if no such index exists.\n", "   */\n", "  public static int lastIndexOf(char[] array, char target) {\n", "    return lastIndexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int lastIndexOf(char[] array, char target, int start, int end) {\n", "    for (int i = end - 1; i >= start; i--) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the least value present in {@code array}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code char} values\n", "   * @return the value present in {@code array} that is less than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static char min(char... array) {\n", "    checkArgument(array.length > 0);\n", "    char min = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      if (array[i] < min) {\n", "        min = array[i];\n", "      }\n", "    }\n", "    return min;\n", "  }\n", "\n", "  /**\n", "   * Returns the greatest value present in {@code array}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code char} values\n", "   * @return the value present in {@code array} that is greater than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static char max(char... array) {\n", "    checkArgument(array.length > 0);\n", "    char max = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      if (array[i] > max) {\n", "        max = array[i];\n", "      }\n", "    }\n", "    return max;\n", "  }\n", "\n", "  /**\n", "   * Returns the values from each provided array combined into a single array.\n", "   * For example, {@code concat(new char[] {a, b}, new char[] {}, new\n", "   * char[] {c}} returns the array {@code {a, b, c}}.\n", "   *\n", "   * @param arrays zero or more {@code char} arrays\n", "   * @return a single array containing all the values from the source arrays, in\n", "   *     order\n", "   */\n", "  public static char[] concat(char[]... arrays) {\n", "    int length = 0;\n", "    for (char[] array : arrays) {\n", "      length += array.length;\n", "    }\n", "    char[] result = new char[length];\n", "    int pos = 0;\n", "    for (char[] array : arrays) {\n", "      System.arraycopy(array, 0, result, pos, array.length);\n", "      pos += array.length;\n", "    }\n", "    return result;\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing the same values as {@code array}, but\n", "   * guaranteed to be of a specified minimum length. If {@code array} already\n", "   * has a length of at least {@code minLength}, it is returned directly.\n", "   * Otherwise, a new array of size {@code minLength + padding} is returned,\n", "   * containing the values of {@code array}, and zeroes in the remaining places.\n", "   *\n", "   * @param array the source array\n", "   * @param minLength the minimum length the returned array must guarantee\n", "   * @param padding an extra amount to \"grow\" the array by if growth is\n", "   *     necessary\n", "   * @throws IllegalArgumentException if {@code minLength} or {@code padding} is\n", "   *     negative\n", "   * @return an array containing the values of {@code array}, with guaranteed\n", "   *     minimum length {@code minLength}\n", "   */\n", "  public static char[] ensureCapacity(char[] array, int minLength, int padding) {\n", "    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n", "    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n", "    return (array.length < minLength)\n", "        ? copyOf(array, minLength + padding)\n", "        : array;\n", "  }\n", "\n", "  // Arrays.copyOf() requires Java 6\n", "  private static char[] copyOf(char[] original, int length) {\n", "    char[] copy = new char[length];\n", "    System.arraycopy(original, 0, copy, 0, Math.min(original.length, length));\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Returns a string containing the supplied {@code char} values separated\n", "   * by {@code separator}. For example, {@code join(\"-\", '1', '2', '3')} returns\n", "   * the string {@code \"1-2-3\"}.\n", "   *\n", "   * @param separator the text that should appear between consecutive values in\n", "   *     the resulting string (but not at the start or end)\n", "   * @param array an array of {@code char} values, possibly empty\n", "   */\n", "  public static String join(String separator, char... array) {\n", "    checkNotNull(separator);\n", "    int len = array.length;\n", "    if (len == 0) {\n", "      return \"\";\n", "    }\n", "\n", "    StringBuilder builder = new StringBuilder(len + separator.length() * (len - 1));\n", "    builder.append(array[0]);\n", "    for (int i = 1; i < len; i++) {\n", "      builder.append(separator).append(array[i]);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  /**\n", "   * Returns a comparator that compares two {@code char} arrays\n", "   * lexicographically. That is, it compares, using {@link\n", "   * #compare(char, char)}), the first pair of values that follow any\n", "   * common prefix, or when one array is a prefix of the other, treats the\n", "   * shorter array as the lesser. For example,\n", "   * {@code [] < ['a'] < ['a', 'b'] < ['b']}.\n", "   *\n", "   * <p>The returned comparator is inconsistent with {@link\n", "   * Object#equals(Object)} (since arrays support only identity equality), but\n", "   * it is consistent with {@link Arrays#equals(char[], char[])}.\n", "   *\n", "   * @see <a href=\"http://en.wikipedia.org/wiki/Lexicographical_order\">\n", "   *     Lexicographical order article at Wikipedia</a>\n", "   * @since 2.0\n", "   */\n", "  public static Comparator<char[]> lexicographicalComparator() {\n", "    return LexicographicalComparator.INSTANCE;\n", "  }\n", "\n", "  private enum LexicographicalComparator implements Comparator<char[]> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public int compare(char[] left, char[] right) {\n", "      int minLength = Math.min(left.length, right.length);\n", "      for (int i = 0; i < minLength; i++) {\n", "        int result = Chars.compare(left[i], right[i]);\n", "        if (result != 0) {\n", "          return result;\n", "        }\n", "      }\n", "      return left.length - right.length;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Copies a collection of {@code Character} instances into a new array of\n", "   * primitive {@code char} values.\n", "   *\n", "   * <p>Elements are copied from the argument collection as if by {@code\n", "   * collection.toArray()}.  Calling this method is as thread-safe as calling\n", "   * that method.\n", "   *\n", "   * @param collection a collection of {@code Character} objects\n", "   * @return an array containing the same values as {@code collection}, in the\n", "   *     same order, converted to primitives\n", "   * @throws NullPointerException if {@code collection} or any of its elements\n", "   *     is null\n", "   */\n", "  public static char[] toArray(Collection<Character> collection) {\n", "    if (collection instanceof CharArrayAsList) {\n", "      return ((CharArrayAsList) collection).toCharArray();\n", "    }\n", "\n", "    Object[] boxedArray = collection.toArray();\n", "    int len = boxedArray.length;\n", "    char[] array = new char[len];\n", "    for (int i = 0; i < len; i++) {\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[i] = (Character) checkNotNull(boxedArray[i]);\n", "    }\n", "    return array;\n", "  }\n", "\n", "  /**\n", "   * Returns a fixed-size list backed by the specified array, similar to {@link\n", "   * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},\n", "   * but any attempt to set a value to {@code null} will result in a {@link\n", "   * NullPointerException}.\n", "   *\n", "   * <p>The returned list maintains the values, but not the identities, of\n", "   * {@code Character} objects written to or read from it.  For example, whether\n", "   * {@code list.get(0) == list.get(0)} is true for the returned list is\n", "   * unspecified.\n", "   *\n", "   * @param backingArray the array to back the list\n", "   * @return a list view of the array\n", "   */\n", "  public static List<Character> asList(char... backingArray) {\n", "    if (backingArray.length == 0) {\n", "      return Collections.emptyList();\n", "    }\n", "    return new CharArrayAsList(backingArray);\n", "  }\n", "\n", "  @GwtCompatible\n", "  private static class CharArrayAsList extends AbstractList<Character>\n", "      implements RandomAccess, Serializable {\n", "    final char[] array;\n", "    final int start;\n", "    final int end;\n", "\n", "    CharArrayAsList(char[] array) {\n", "      this(array, 0, array.length);\n", "    }\n", "\n", "    CharArrayAsList(char[] array, int start, int end) {\n", "      this.array = array;\n", "      this.start = start;\n", "      this.end = end;\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return end - start;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public Character get(int index) {\n", "      checkElementIndex(index, size());\n", "      return array[start + index];\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      return (target instanceof Character)\n", "          && Chars.indexOf(array, (Character) target, start, end) != -1;\n", "    }\n", "\n", "    @Override\n", "    public int indexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Character) {\n", "        int i = Chars.indexOf(array, (Character) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Character) {\n", "        int i = Chars.lastIndexOf(array, (Character) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public Character set(int index, Character element) {\n", "      checkElementIndex(index, size());\n", "      char oldValue = array[start + index];\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[start + index] = checkNotNull(element);\n", "      return oldValue;\n", "    }\n", "\n", "    @Override\n", "    public List<Character> subList(int fromIndex, int toIndex) {\n", "      int size = size();\n", "      checkPositionIndexes(fromIndex, toIndex, size);\n", "      if (fromIndex == toIndex) {\n", "        return Collections.emptyList();\n", "      }\n", "      return new CharArrayAsList(array, start + fromIndex, start + toIndex);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      if (object == this) {\n", "        return true;\n", "      }\n", "      if (object instanceof CharArrayAsList) {\n", "        CharArrayAsList that = (CharArrayAsList) object;\n", "        int size = size();\n", "        if (that.size() != size) {\n", "          return false;\n", "        }\n", "        for (int i = 0; i < size; i++) {\n", "          if (array[start + i] != that.array[that.start + i]) {\n", "            return false;\n", "          }\n", "        }\n", "        return true;\n", "      }\n", "      return super.equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      int result = 1;\n", "      for (int i = start; i < end; i++) {\n", "        result = 31 * result + Chars.hashCode(array[i]);\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      StringBuilder builder = new StringBuilder(size() * 3);\n", "      builder.append('[').append(array[start]);\n", "      for (int i = start + 1; i < end; i++) {\n", "        builder.append(\", \").append(array[i]);\n", "      }\n", "      return builder.append(']').toString();\n", "    }\n", "\n", "    char[] toCharArray() {\n", "      // Arrays.copyOfRange() is not available under GWT\n", "      int size = size();\n", "      char[] result = new char[size];\n", "      System.arraycopy(array, start, result, 0, size);\n", "      return result;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553]}}, {"54": "guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/Doubles.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkElementIndex;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkPositionIndexes;\n", "import static java.lang.Double.NEGATIVE_INFINITY;\n", "import static java.lang.Double.POSITIVE_INFINITY;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractList;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "import java.util.RandomAccess;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to {@code double} primitives, that are not\n", " * already found in either {@link Double} or {@link Arrays}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/PrimitivesExplained\">\n", " * primitive utilities</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 1.0\n", " */\n", "@CheckReturnValue\n", "@GwtCompatible(emulated = true)\n", "public final class Doubles {\n", "  private Doubles() {}\n", "\n", "  /**\n", "   * The number of bytes required to represent a primitive {@code double}\n", "   * value.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  public static final int BYTES = Double.SIZE / Byte.SIZE;\n", "\n", "  /**\n", "   * Returns a hash code for {@code value}; equal to the result of invoking\n", "   * {@code ((Double) value).hashCode()}.\n", "   *\n", "   * @param value a primitive {@code double} value\n", "   * @return a hash code for the value\n", "   */\n", "  public static int hashCode(double value) {\n", "    return ((Double) value).hashCode();\n", "    // TODO(kevinb): do it this way when we can (GWT problem):\n", "    // long bits = Double.doubleToLongBits(value);\n", "    // return (int) (bits ^ (bits >>> 32));\n", "  }\n", "\n", "  /**\n", "   * Compares the two specified {@code double} values. The sign of the value\n", "   * returned is the same as that of <code>((Double) a).{@linkplain\n", "   * Double#compareTo compareTo}(b)</code>. As with that method, {@code NaN} is\n", "   * treated as greater than all other values, and {@code 0.0 > -0.0}.\n", "   *\n", "   * <p><b>Note:</b> this method simply delegates to the JDK method {@link\n", "   * Double#compare}. It is provided for consistency with the other primitive\n", "   * types, whose compare methods were not added to the JDK until JDK 7.\n", "   *\n", "   * @param a the first {@code double} to compare\n", "   * @param b the second {@code double} to compare\n", "   * @return a negative value if {@code a} is less than {@code b}; a positive\n", "   *     value if {@code a} is greater than {@code b}; or zero if they are equal\n", "   */\n", "  public static int compare(double a, double b) {\n", "    return Double.compare(a, b);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code value} represents a real number. This is\n", "   * equivalent to, but not necessarily implemented as,\n", "   * {@code !(Double.isInfinite(value) || Double.isNaN(value))}.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  public static boolean isFinite(double value) {\n", "    return NEGATIVE_INFINITY < value & value < POSITIVE_INFINITY;\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code target} is present as an element anywhere in\n", "   * {@code array}. Note that this always returns {@code false} when {@code\n", "   * target} is {@code NaN}.\n", "   *\n", "   * @param array an array of {@code double} values, possibly empty\n", "   * @param target a primitive {@code double} value\n", "   * @return {@code true} if {@code array[i] == target} for some value of {@code\n", "   *     i}\n", "   */\n", "  public static boolean contains(double[] array, double target) {\n", "    for (double value : array) {\n", "      if (value == target) {\n", "        return true;\n", "      }\n", "    }\n", "    return false;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the first appearance of the value {@code target} in\n", "   * {@code array}. Note that this always returns {@code -1} when {@code target}\n", "   * is {@code NaN}.\n", "   *\n", "   * @param array an array of {@code double} values, possibly empty\n", "   * @param target a primitive {@code double} value\n", "   * @return the least index {@code i} for which {@code array[i] == target}, or\n", "   *     {@code -1} if no such index exists.\n", "   */\n", "  public static int indexOf(double[] array, double target) {\n", "    return indexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int indexOf(double[] array, double target, int start, int end) {\n", "    for (int i = start; i < end; i++) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the start position of the first occurrence of the specified {@code\n", "   * target} within {@code array}, or {@code -1} if there is no such occurrence.\n", "   *\n", "   * <p>More formally, returns the lowest index {@code i} such that {@code\n", "   * java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly\n", "   * the same elements as {@code target}.\n", "   *\n", "   * <p>Note that this always returns {@code -1} when {@code target} contains\n", "   * {@code NaN}.\n", "   *\n", "   * @param array the array to search for the sequence {@code target}\n", "   * @param target the array to search for as a sub-sequence of {@code array}\n", "   */\n", "  public static int indexOf(double[] array, double[] target) {\n", "    checkNotNull(array, \"array\");\n", "    checkNotNull(target, \"target\");\n", "    if (target.length == 0) {\n", "      return 0;\n", "    }\n", "\n", "    outer:\n", "    for (int i = 0; i < array.length - target.length + 1; i++) {\n", "      for (int j = 0; j < target.length; j++) {\n", "        if (array[i + j] != target[j]) {\n", "          continue outer;\n", "        }\n", "      }\n", "      return i;\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the last appearance of the value {@code target} in\n", "   * {@code array}. Note that this always returns {@code -1} when {@code target}\n", "   * is {@code NaN}.\n", "   *\n", "   * @param array an array of {@code double} values, possibly empty\n", "   * @param target a primitive {@code double} value\n", "   * @return the greatest index {@code i} for which {@code array[i] == target},\n", "   *     or {@code -1} if no such index exists.\n", "   */\n", "  public static int lastIndexOf(double[] array, double target) {\n", "    return lastIndexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int lastIndexOf(double[] array, double target, int start, int end) {\n", "    for (int i = end - 1; i >= start; i--) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the least value present in {@code array}, using the same rules of\n", "   * comparison as {@link Math#min(double, double)}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code double} values\n", "   * @return the value present in {@code array} that is less than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static double min(double... array) {\n", "    checkArgument(array.length > 0);\n", "    double min = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      min = Math.min(min, array[i]);\n", "    }\n", "    return min;\n", "  }\n", "\n", "  /**\n", "   * Returns the greatest value present in {@code array}, using the same rules\n", "   * of comparison as {@link Math#max(double, double)}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code double} values\n", "   * @return the value present in {@code array} that is greater than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static double max(double... array) {\n", "    checkArgument(array.length > 0);\n", "    double max = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      max = Math.max(max, array[i]);\n", "    }\n", "    return max;\n", "  }\n", "\n", "  /**\n", "   * Returns the values from each provided array combined into a single array.\n", "   * For example, {@code concat(new double[] {a, b}, new double[] {}, new\n", "   * double[] {c}} returns the array {@code {a, b, c}}.\n", "   *\n", "   * @param arrays zero or more {@code double} arrays\n", "   * @return a single array containing all the values from the source arrays, in\n", "   *     order\n", "   */\n", "  public static double[] concat(double[]... arrays) {\n", "    int length = 0;\n", "    for (double[] array : arrays) {\n", "      length += array.length;\n", "    }\n", "    double[] result = new double[length];\n", "    int pos = 0;\n", "    for (double[] array : arrays) {\n", "      System.arraycopy(array, 0, result, pos, array.length);\n", "      pos += array.length;\n", "    }\n", "    return result;\n", "  }\n", "\n", "  private static final class DoubleConverter extends Converter<String, Double>\n", "      implements Serializable {\n", "    static final DoubleConverter INSTANCE = new DoubleConverter();\n", "\n", "    @Override\n", "    protected Double doForward(String value) {\n", "      return Double.valueOf(value);\n", "    }\n", "\n", "    @Override\n", "    protected String doBackward(Double value) {\n", "      return value.toString();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Doubles.stringConverter()\";\n", "    }\n", "\n", "    private Object readResolve() {\n", "      return INSTANCE;\n", "    }\n", "\n", "    private static final long serialVersionUID = 1;\n", "  }\n", "\n", "  /**\n", "   * Returns a serializable converter object that converts between strings and\n", "   * doubles using {@link Double#valueOf} and {@link Double#toString()}.\n", "   *\n", "   * @since 16.0\n", "   */\n", "  @Beta\n", "  public static Converter<String, Double> stringConverter() {\n", "    return DoubleConverter.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing the same values as {@code array}, but\n", "   * guaranteed to be of a specified minimum length. If {@code array} already\n", "   * has a length of at least {@code minLength}, it is returned directly.\n", "   * Otherwise, a new array of size {@code minLength + padding} is returned,\n", "   * containing the values of {@code array}, and zeroes in the remaining places.\n", "   *\n", "   * @param array the source array\n", "   * @param minLength the minimum length the returned array must guarantee\n", "   * @param padding an extra amount to \"grow\" the array by if growth is\n", "   *     necessary\n", "   * @throws IllegalArgumentException if {@code minLength} or {@code padding} is\n", "   *     negative\n", "   * @return an array containing the values of {@code array}, with guaranteed\n", "   *     minimum length {@code minLength}\n", "   */\n", "  public static double[] ensureCapacity(double[] array, int minLength, int padding) {\n", "    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n", "    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n", "    return (array.length < minLength)\n", "        ? copyOf(array, minLength + padding)\n", "        : array;\n", "  }\n", "\n", "  // Arrays.copyOf() requires Java 6\n", "  private static double[] copyOf(double[] original, int length) {\n", "    double[] copy = new double[length];\n", "    System.arraycopy(original, 0, copy, 0, Math.min(original.length, length));\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Returns a string containing the supplied {@code double} values, converted\n", "   * to strings as specified by {@link Double#toString(double)}, and separated\n", "   * by {@code separator}. For example, {@code join(\"-\", 1.0, 2.0, 3.0)} returns\n", "   * the string {@code \"1.0-2.0-3.0\"}.\n", "   *\n", "   * <p>Note that {@link Double#toString(double)} formats {@code double}\n", "   * differently in GWT sometimes.  In the previous example, it returns the\n", "   * string {@code \"1-2-3\"}.\n", "   *\n", "   * @param separator the text that should appear between consecutive values in\n", "   *     the resulting string (but not at the start or end)\n", "   * @param array an array of {@code double} values, possibly empty\n", "   */\n", "  public static String join(String separator, double... array) {\n", "    checkNotNull(separator);\n", "    if (array.length == 0) {\n", "      return \"\";\n", "    }\n", "\n", "    // For pre-sizing a builder, just get the right order of magnitude\n", "    StringBuilder builder = new StringBuilder(array.length * 12);\n", "    builder.append(array[0]);\n", "    for (int i = 1; i < array.length; i++) {\n", "      builder.append(separator).append(array[i]);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  /**\n", "   * Returns a comparator that compares two {@code double} arrays\n", "   * lexicographically. That is, it compares, using {@link\n", "   * #compare(double, double)}), the first pair of values that follow any\n", "   * common prefix, or when one array is a prefix of the other, treats the\n", "   * shorter array as the lesser. For example,\n", "   * {@code [] < [1.0] < [1.0, 2.0] < [2.0]}.\n", "   *\n", "   * <p>The returned comparator is inconsistent with {@link\n", "   * Object#equals(Object)} (since arrays support only identity equality), but\n", "   * it is consistent with {@link Arrays#equals(double[], double[])}.\n", "   *\n", "   * @see <a href=\"http://en.wikipedia.org/wiki/Lexicographical_order\">\n", "   *     Lexicographical order article at Wikipedia</a>\n", "   * @since 2.0\n", "   */\n", "  public static Comparator<double[]> lexicographicalComparator() {\n", "    return LexicographicalComparator.INSTANCE;\n", "  }\n", "\n", "  private enum LexicographicalComparator implements Comparator<double[]> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public int compare(double[] left, double[] right) {\n", "      int minLength = Math.min(left.length, right.length);\n", "      for (int i = 0; i < minLength; i++) {\n", "        int result = Double.compare(left[i], right[i]);\n", "        if (result != 0) {\n", "          return result;\n", "        }\n", "      }\n", "      return left.length - right.length;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing each value of {@code collection}, converted to\n", "   * a {@code double} value in the manner of {@link Number#doubleValue}.\n", "   *\n", "   * <p>Elements are copied from the argument collection as if by {@code\n", "   * collection.toArray()}.  Calling this method is as thread-safe as calling\n", "   * that method.\n", "   *\n", "   * @param collection a collection of {@code Number} instances\n", "   * @return an array containing the same values as {@code collection}, in the\n", "   *     same order, converted to primitives\n", "   * @throws NullPointerException if {@code collection} or any of its elements\n", "   *     is null\n", "   * @since 1.0 (parameter was {@code Collection<Double>} before 12.0)\n", "   */\n", "  public static double[] toArray(Collection<? extends Number> collection) {\n", "    if (collection instanceof DoubleArrayAsList) {\n", "      return ((DoubleArrayAsList) collection).toDoubleArray();\n", "    }\n", "\n", "    Object[] boxedArray = collection.toArray();\n", "    int len = boxedArray.length;\n", "    double[] array = new double[len];\n", "    for (int i = 0; i < len; i++) {\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[i] = ((Number) checkNotNull(boxedArray[i])).doubleValue();\n", "    }\n", "    return array;\n", "  }\n", "\n", "  /**\n", "   * Returns a fixed-size list backed by the specified array, similar to {@link\n", "   * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},\n", "   * but any attempt to set a value to {@code null} will result in a {@link\n", "   * NullPointerException}.\n", "   *\n", "   * <p>The returned list maintains the values, but not the identities, of\n", "   * {@code Double} objects written to or read from it.  For example, whether\n", "   * {@code list.get(0) == list.get(0)} is true for the returned list is\n", "   * unspecified.\n", "   *\n", "   * <p>The returned list may have unexpected behavior if it contains {@code\n", "   * NaN}, or if {@code NaN} is used as a parameter to any of its methods.\n", "   *\n", "   * @param backingArray the array to back the list\n", "   * @return a list view of the array\n", "   */\n", "  public static List<Double> asList(double... backingArray) {\n", "    if (backingArray.length == 0) {\n", "      return Collections.emptyList();\n", "    }\n", "    return new DoubleArrayAsList(backingArray);\n", "  }\n", "\n", "  @GwtCompatible\n", "  private static class DoubleArrayAsList extends AbstractList<Double>\n", "      implements RandomAccess, Serializable {\n", "    final double[] array;\n", "    final int start;\n", "    final int end;\n", "\n", "    DoubleArrayAsList(double[] array) {\n", "      this(array, 0, array.length);\n", "    }\n", "\n", "    DoubleArrayAsList(double[] array, int start, int end) {\n", "      this.array = array;\n", "      this.start = start;\n", "      this.end = end;\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return end - start;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public Double get(int index) {\n", "      checkElementIndex(index, size());\n", "      return array[start + index];\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      return (target instanceof Double)\n", "          && Doubles.indexOf(array, (Double) target, start, end) != -1;\n", "    }\n", "\n", "    @Override\n", "    public int indexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Double) {\n", "        int i = Doubles.indexOf(array, (Double) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Double) {\n", "        int i = Doubles.lastIndexOf(array, (Double) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public Double set(int index, Double element) {\n", "      checkElementIndex(index, size());\n", "      double oldValue = array[start + index];\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[start + index] = checkNotNull(element);\n", "      return oldValue;\n", "    }\n", "\n", "    @Override\n", "    public List<Double> subList(int fromIndex, int toIndex) {\n", "      int size = size();\n", "      checkPositionIndexes(fromIndex, toIndex, size);\n", "      if (fromIndex == toIndex) {\n", "        return Collections.emptyList();\n", "      }\n", "      return new DoubleArrayAsList(array, start + fromIndex, start + toIndex);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      if (object == this) {\n", "        return true;\n", "      }\n", "      if (object instanceof DoubleArrayAsList) {\n", "        DoubleArrayAsList that = (DoubleArrayAsList) object;\n", "        int size = size();\n", "        if (that.size() != size) {\n", "          return false;\n", "        }\n", "        for (int i = 0; i < size; i++) {\n", "          if (array[start + i] != that.array[that.start + i]) {\n", "            return false;\n", "          }\n", "        }\n", "        return true;\n", "      }\n", "      return super.equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      int result = 1;\n", "      for (int i = start; i < end; i++) {\n", "        result = 31 * result + Doubles.hashCode(array[i]);\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      StringBuilder builder = new StringBuilder(size() * 12);\n", "      builder.append('[').append(array[start]);\n", "      for (int i = start + 1; i < end; i++) {\n", "        builder.append(\", \").append(array[i]);\n", "      }\n", "      return builder.append(']').toString();\n", "    }\n", "\n", "    double[] toDoubleArray() {\n", "      // Arrays.copyOfRange() is not available under GWT\n", "      int size = size();\n", "      double[] result = new double[size];\n", "      System.arraycopy(array, start, result, 0, size);\n", "      return result;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588]}}, {"55": "guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/Floats.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkElementIndex;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkPositionIndexes;\n", "import static java.lang.Float.NEGATIVE_INFINITY;\n", "import static java.lang.Float.POSITIVE_INFINITY;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractList;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "import java.util.RandomAccess;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to {@code float} primitives, that are not\n", " * already found in either {@link Float} or {@link Arrays}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/PrimitivesExplained\">\n", " * primitive utilities</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 1.0\n", " */\n", "@CheckReturnValue\n", "@GwtCompatible(emulated = true)\n", "public final class Floats {\n", "  private Floats() {}\n", "\n", "  /**\n", "   * The number of bytes required to represent a primitive {@code float}\n", "   * value.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  public static final int BYTES = Float.SIZE / Byte.SIZE;\n", "\n", "  /**\n", "   * Returns a hash code for {@code value}; equal to the result of invoking\n", "   * {@code ((Float) value).hashCode()}.\n", "   *\n", "   * @param value a primitive {@code float} value\n", "   * @return a hash code for the value\n", "   */\n", "  public static int hashCode(float value) {\n", "    // TODO(kevinb): is there a better way, that's still gwt-safe?\n", "    return ((Float) value).hashCode();\n", "  }\n", "\n", "  /**\n", "   * Compares the two specified {@code float} values using {@link\n", "   * Float#compare(float, float)}. You may prefer to invoke that method\n", "   * directly; this method exists only for consistency with the other utilities\n", "   * in this package.\n", "   *\n", "   * <p><b>Note:</b> this method simply delegates to the JDK method {@link\n", "   * Float#compare}. It is provided for consistency with the other primitive\n", "   * types, whose compare methods were not added to the JDK until JDK 7.\n", "   *\n", "   * @param a the first {@code float} to compare\n", "   * @param b the second {@code float} to compare\n", "   * @return the result of invoking {@link Float#compare(float, float)}\n", "   */\n", "  public static int compare(float a, float b) {\n", "    return Float.compare(a, b);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code value} represents a real number. This is\n", "   * equivalent to, but not necessarily implemented as,\n", "   * {@code !(Float.isInfinite(value) || Float.isNaN(value))}.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  public static boolean isFinite(float value) {\n", "    return NEGATIVE_INFINITY < value & value < POSITIVE_INFINITY;\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code target} is present as an element anywhere in\n", "   * {@code array}. Note that this always returns {@code false} when {@code\n", "   * target} is {@code NaN}.\n", "   *\n", "   * @param array an array of {@code float} values, possibly empty\n", "   * @param target a primitive {@code float} value\n", "   * @return {@code true} if {@code array[i] == target} for some value of {@code\n", "   *     i}\n", "   */\n", "  public static boolean contains(float[] array, float target) {\n", "    for (float value : array) {\n", "      if (value == target) {\n", "        return true;\n", "      }\n", "    }\n", "    return false;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the first appearance of the value {@code target} in\n", "   * {@code array}. Note that this always returns {@code -1} when {@code target}\n", "   * is {@code NaN}.\n", "   *\n", "   * @param array an array of {@code float} values, possibly empty\n", "   * @param target a primitive {@code float} value\n", "   * @return the least index {@code i} for which {@code array[i] == target}, or\n", "   *     {@code -1} if no such index exists.\n", "   */\n", "  public static int indexOf(float[] array, float target) {\n", "    return indexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int indexOf(float[] array, float target, int start, int end) {\n", "    for (int i = start; i < end; i++) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the start position of the first occurrence of the specified {@code\n", "   * target} within {@code array}, or {@code -1} if there is no such occurrence.\n", "   *\n", "   * <p>More formally, returns the lowest index {@code i} such that {@code\n", "   * java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly\n", "   * the same elements as {@code target}.\n", "   *\n", "   * <p>Note that this always returns {@code -1} when {@code target} contains\n", "   * {@code NaN}.\n", "   *\n", "   * @param array the array to search for the sequence {@code target}\n", "   * @param target the array to search for as a sub-sequence of {@code array}\n", "   */\n", "  public static int indexOf(float[] array, float[] target) {\n", "    checkNotNull(array, \"array\");\n", "    checkNotNull(target, \"target\");\n", "    if (target.length == 0) {\n", "      return 0;\n", "    }\n", "\n", "    outer:\n", "    for (int i = 0; i < array.length - target.length + 1; i++) {\n", "      for (int j = 0; j < target.length; j++) {\n", "        if (array[i + j] != target[j]) {\n", "          continue outer;\n", "        }\n", "      }\n", "      return i;\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the last appearance of the value {@code target} in\n", "   * {@code array}. Note that this always returns {@code -1} when {@code target}\n", "   * is {@code NaN}.\n", "   *\n", "   * @param array an array of {@code float} values, possibly empty\n", "   * @param target a primitive {@code float} value\n", "   * @return the greatest index {@code i} for which {@code array[i] == target},\n", "   *     or {@code -1} if no such index exists.\n", "   */\n", "  public static int lastIndexOf(float[] array, float target) {\n", "    return lastIndexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int lastIndexOf(float[] array, float target, int start, int end) {\n", "    for (int i = end - 1; i >= start; i--) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the least value present in {@code array}, using the same rules of\n", "   * comparison as {@link Math#min(float, float)}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code float} values\n", "   * @return the value present in {@code array} that is less than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static float min(float... array) {\n", "    checkArgument(array.length > 0);\n", "    float min = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      min = Math.min(min, array[i]);\n", "    }\n", "    return min;\n", "  }\n", "\n", "  /**\n", "   * Returns the greatest value present in {@code array}, using the same rules\n", "   * of comparison as {@link Math#max(float, float)}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code float} values\n", "   * @return the value present in {@code array} that is greater than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static float max(float... array) {\n", "    checkArgument(array.length > 0);\n", "    float max = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      max = Math.max(max, array[i]);\n", "    }\n", "    return max;\n", "  }\n", "\n", "  /**\n", "   * Returns the values from each provided array combined into a single array.\n", "   * For example, {@code concat(new float[] {a, b}, new float[] {}, new\n", "   * float[] {c}} returns the array {@code {a, b, c}}.\n", "   *\n", "   * @param arrays zero or more {@code float} arrays\n", "   * @return a single array containing all the values from the source arrays, in\n", "   *     order\n", "   */\n", "  public static float[] concat(float[]... arrays) {\n", "    int length = 0;\n", "    for (float[] array : arrays) {\n", "      length += array.length;\n", "    }\n", "    float[] result = new float[length];\n", "    int pos = 0;\n", "    for (float[] array : arrays) {\n", "      System.arraycopy(array, 0, result, pos, array.length);\n", "      pos += array.length;\n", "    }\n", "    return result;\n", "  }\n", "\n", "  private static final class FloatConverter extends Converter<String, Float>\n", "      implements Serializable {\n", "    static final FloatConverter INSTANCE = new FloatConverter();\n", "\n", "    @Override\n", "    protected Float doForward(String value) {\n", "      return Float.valueOf(value);\n", "    }\n", "\n", "    @Override\n", "    protected String doBackward(Float value) {\n", "      return value.toString();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Floats.stringConverter()\";\n", "    }\n", "\n", "    private Object readResolve() {\n", "      return INSTANCE;\n", "    }\n", "\n", "    private static final long serialVersionUID = 1;\n", "  }\n", "\n", "  /**\n", "   * Returns a serializable converter object that converts between strings and\n", "   * floats using {@link Float#valueOf} and {@link Float#toString()}.\n", "   *\n", "   * @since 16.0\n", "   */\n", "  @Beta\n", "  public static Converter<String, Float> stringConverter() {\n", "    return FloatConverter.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing the same values as {@code array}, but\n", "   * guaranteed to be of a specified minimum length. If {@code array} already\n", "   * has a length of at least {@code minLength}, it is returned directly.\n", "   * Otherwise, a new array of size {@code minLength + padding} is returned,\n", "   * containing the values of {@code array}, and zeroes in the remaining places.\n", "   *\n", "   * @param array the source array\n", "   * @param minLength the minimum length the returned array must guarantee\n", "   * @param padding an extra amount to \"grow\" the array by if growth is\n", "   *     necessary\n", "   * @throws IllegalArgumentException if {@code minLength} or {@code padding} is\n", "   *     negative\n", "   * @return an array containing the values of {@code array}, with guaranteed\n", "   *     minimum length {@code minLength}\n", "   */\n", "  public static float[] ensureCapacity(float[] array, int minLength, int padding) {\n", "    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n", "    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n", "    return (array.length < minLength)\n", "        ? copyOf(array, minLength + padding)\n", "        : array;\n", "  }\n", "\n", "  // Arrays.copyOf() requires Java 6\n", "  private static float[] copyOf(float[] original, int length) {\n", "    float[] copy = new float[length];\n", "    System.arraycopy(original, 0, copy, 0, Math.min(original.length, length));\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Returns a string containing the supplied {@code float} values, converted\n", "   * to strings as specified by {@link Float#toString(float)}, and separated by\n", "   * {@code separator}. For example, {@code join(\"-\", 1.0f, 2.0f, 3.0f)}\n", "   * returns the string {@code \"1.0-2.0-3.0\"}.\n", "   *\n", "   * <p>Note that {@link Float#toString(float)} formats {@code float}\n", "   * differently in GWT.  In the previous example, it returns the string {@code\n", "   * \"1-2-3\"}.\n", "   *\n", "   * @param separator the text that should appear between consecutive values in\n", "   *     the resulting string (but not at the start or end)\n", "   * @param array an array of {@code float} values, possibly empty\n", "   */\n", "  public static String join(String separator, float... array) {\n", "    checkNotNull(separator);\n", "    if (array.length == 0) {\n", "      return \"\";\n", "    }\n", "\n", "    // For pre-sizing a builder, just get the right order of magnitude\n", "    StringBuilder builder = new StringBuilder(array.length * 12);\n", "    builder.append(array[0]);\n", "    for (int i = 1; i < array.length; i++) {\n", "      builder.append(separator).append(array[i]);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  /**\n", "   * Returns a comparator that compares two {@code float} arrays\n", "   * lexicographically. That is, it compares, using {@link\n", "   * #compare(float, float)}), the first pair of values that follow any\n", "   * common prefix, or when one array is a prefix of the other, treats the\n", "   * shorter array as the lesser. For example, {@code [] < [1.0f] < [1.0f, 2.0f]\n", "   * < [2.0f]}.\n", "   *\n", "   * <p>The returned comparator is inconsistent with {@link\n", "   * Object#equals(Object)} (since arrays support only identity equality), but\n", "   * it is consistent with {@link Arrays#equals(float[], float[])}.\n", "   *\n", "   * @see <a href=\"http://en.wikipedia.org/wiki/Lexicographical_order\">\n", "   *     Lexicographical order article at Wikipedia</a>\n", "   * @since 2.0\n", "   */\n", "  public static Comparator<float[]> lexicographicalComparator() {\n", "    return LexicographicalComparator.INSTANCE;\n", "  }\n", "\n", "  private enum LexicographicalComparator implements Comparator<float[]> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public int compare(float[] left, float[] right) {\n", "      int minLength = Math.min(left.length, right.length);\n", "      for (int i = 0; i < minLength; i++) {\n", "        int result = Float.compare(left[i], right[i]);\n", "        if (result != 0) {\n", "          return result;\n", "        }\n", "      }\n", "      return left.length - right.length;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing each value of {@code collection}, converted to\n", "   * a {@code float} value in the manner of {@link Number#floatValue}.\n", "   *\n", "   * <p>Elements are copied from the argument collection as if by {@code\n", "   * collection.toArray()}.  Calling this method is as thread-safe as calling\n", "   * that method.\n", "   *\n", "   * @param collection a collection of {@code Number} instances\n", "   * @return an array containing the same values as {@code collection}, in the\n", "   *     same order, converted to primitives\n", "   * @throws NullPointerException if {@code collection} or any of its elements\n", "   *     is null\n", "   * @since 1.0 (parameter was {@code Collection<Float>} before 12.0)\n", "   */\n", "  public static float[] toArray(Collection<? extends Number> collection) {\n", "    if (collection instanceof FloatArrayAsList) {\n", "      return ((FloatArrayAsList) collection).toFloatArray();\n", "    }\n", "\n", "    Object[] boxedArray = collection.toArray();\n", "    int len = boxedArray.length;\n", "    float[] array = new float[len];\n", "    for (int i = 0; i < len; i++) {\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[i] = ((Number) checkNotNull(boxedArray[i])).floatValue();\n", "    }\n", "    return array;\n", "  }\n", "\n", "  /**\n", "   * Returns a fixed-size list backed by the specified array, similar to {@link\n", "   * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},\n", "   * but any attempt to set a value to {@code null} will result in a {@link\n", "   * NullPointerException}.\n", "   *\n", "   * <p>The returned list maintains the values, but not the identities, of\n", "   * {@code Float} objects written to or read from it.  For example, whether\n", "   * {@code list.get(0) == list.get(0)} is true for the returned list is\n", "   * unspecified.\n", "   *\n", "   * <p>The returned list may have unexpected behavior if it contains {@code\n", "   * NaN}, or if {@code NaN} is used as a parameter to any of its methods.\n", "   *\n", "   * @param backingArray the array to back the list\n", "   * @return a list view of the array\n", "   */\n", "  public static List<Float> asList(float... backingArray) {\n", "    if (backingArray.length == 0) {\n", "      return Collections.emptyList();\n", "    }\n", "    return new FloatArrayAsList(backingArray);\n", "  }\n", "\n", "  @GwtCompatible\n", "  private static class FloatArrayAsList extends AbstractList<Float>\n", "      implements RandomAccess, Serializable {\n", "    final float[] array;\n", "    final int start;\n", "    final int end;\n", "\n", "    FloatArrayAsList(float[] array) {\n", "      this(array, 0, array.length);\n", "    }\n", "\n", "    FloatArrayAsList(float[] array, int start, int end) {\n", "      this.array = array;\n", "      this.start = start;\n", "      this.end = end;\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return end - start;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public Float get(int index) {\n", "      checkElementIndex(index, size());\n", "      return array[start + index];\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      return (target instanceof Float) && Floats.indexOf(array, (Float) target, start, end) != -1;\n", "    }\n", "\n", "    @Override\n", "    public int indexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Float) {\n", "        int i = Floats.indexOf(array, (Float) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Float) {\n", "        int i = Floats.lastIndexOf(array, (Float) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public Float set(int index, Float element) {\n", "      checkElementIndex(index, size());\n", "      float oldValue = array[start + index];\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[start + index] = checkNotNull(element);\n", "      return oldValue;\n", "    }\n", "\n", "    @Override\n", "    public List<Float> subList(int fromIndex, int toIndex) {\n", "      int size = size();\n", "      checkPositionIndexes(fromIndex, toIndex, size);\n", "      if (fromIndex == toIndex) {\n", "        return Collections.emptyList();\n", "      }\n", "      return new FloatArrayAsList(array, start + fromIndex, start + toIndex);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      if (object == this) {\n", "        return true;\n", "      }\n", "      if (object instanceof FloatArrayAsList) {\n", "        FloatArrayAsList that = (FloatArrayAsList) object;\n", "        int size = size();\n", "        if (that.size() != size) {\n", "          return false;\n", "        }\n", "        for (int i = 0; i < size; i++) {\n", "          if (array[start + i] != that.array[that.start + i]) {\n", "            return false;\n", "          }\n", "        }\n", "        return true;\n", "      }\n", "      return super.equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      int result = 1;\n", "      for (int i = start; i < end; i++) {\n", "        result = 31 * result + Floats.hashCode(array[i]);\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      StringBuilder builder = new StringBuilder(size() * 12);\n", "      builder.append('[').append(array[start]);\n", "      for (int i = start + 1; i < end; i++) {\n", "        builder.append(\", \").append(array[i]);\n", "      }\n", "      return builder.append(']').toString();\n", "    }\n", "\n", "    float[] toFloatArray() {\n", "      // Arrays.copyOfRange() is not available under GWT\n", "      int size = size();\n", "      float[] result = new float[size];\n", "      System.arraycopy(array, start, result, 0, size);\n", "      return result;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584]}}, {"56": "guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/Ints.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkElementIndex;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkPositionIndexes;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractList;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "import java.util.RandomAccess;\n", "\n", "import javax.annotation.CheckForNull;\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to {@code int} primitives, that are not\n", " * already found in either {@link Integer} or {@link Arrays}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/PrimitivesExplained\">\n", " * primitive utilities</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 1.0\n", " */\n", "@CheckReturnValue\n", "@GwtCompatible(emulated = true)\n", "public final class Ints {\n", "  private Ints() {}\n", "\n", "  /**\n", "   * The number of bytes required to represent a primitive {@code int}\n", "   * value.\n", "   */\n", "  public static final int BYTES = Integer.SIZE / Byte.SIZE;\n", "\n", "  /**\n", "   * The largest power of two that can be represented as an {@code int}.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  public static final int MAX_POWER_OF_TWO = 1 << (Integer.SIZE - 2);\n", "\n", "  /**\n", "   * Returns a hash code for {@code value}; equal to the result of invoking\n", "   * {@code ((Integer) value).hashCode()}.\n", "   *\n", "   * @param value a primitive {@code int} value\n", "   * @return a hash code for the value\n", "   */\n", "  public static int hashCode(int value) {\n", "    return value;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@code int} value that is equal to {@code value}, if possible.\n", "   *\n", "   * @param value any value in the range of the {@code int} type\n", "   * @return the {@code int} value that equals {@code value}\n", "   * @throws IllegalArgumentException if {@code value} is greater than {@link\n", "   *     Integer#MAX_VALUE} or less than {@link Integer#MIN_VALUE}\n", "   */\n", "  public static int checkedCast(long value) {\n", "    int result = (int) value;\n", "    if (result != value) {\n", "      // don't use checkArgument here, to avoid boxing\n", "      throw new IllegalArgumentException(\"Out of range: \" + value);\n", "    }\n", "    return result;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@code int} nearest in value to {@code value}.\n", "   *\n", "   * @param value any {@code long} value\n", "   * @return the same value cast to {@code int} if it is in the range of the\n", "   *     {@code int} type, {@link Integer#MAX_VALUE} if it is too large,\n", "   *     or {@link Integer#MIN_VALUE} if it is too small\n", "   */\n", "  public static int saturatedCast(long value) {\n", "    if (value > Integer.MAX_VALUE) {\n", "      return Integer.MAX_VALUE;\n", "    }\n", "    if (value < Integer.MIN_VALUE) {\n", "      return Integer.MIN_VALUE;\n", "    }\n", "    return (int) value;\n", "  }\n", "\n", "  /**\n", "   * Compares the two specified {@code int} values. The sign of the value\n", "   * returned is the same as that of {@code ((Integer) a).compareTo(b)}.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> this method should be treated as\n", "   * deprecated; use the equivalent {@link Integer#compare} method instead.\n", "   *\n", "   * @param a the first {@code int} to compare\n", "   * @param b the second {@code int} to compare\n", "   * @return a negative value if {@code a} is less than {@code b}; a positive\n", "   *     value if {@code a} is greater than {@code b}; or zero if they are equal\n", "   */\n", "  public static int compare(int a, int b) {\n", "    return (a < b) ? -1 : ((a > b) ? 1 : 0);\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code target} is present as an element anywhere in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code int} values, possibly empty\n", "   * @param target a primitive {@code int} value\n", "   * @return {@code true} if {@code array[i] == target} for some value of {@code\n", "   *     i}\n", "   */\n", "  public static boolean contains(int[] array, int target) {\n", "    for (int value : array) {\n", "      if (value == target) {\n", "        return true;\n", "      }\n", "    }\n", "    return false;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the first appearance of the value {@code target} in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code int} values, possibly empty\n", "   * @param target a primitive {@code int} value\n", "   * @return the least index {@code i} for which {@code array[i] == target}, or\n", "   *     {@code -1} if no such index exists.\n", "   */\n", "  public static int indexOf(int[] array, int target) {\n", "    return indexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int indexOf(int[] array, int target, int start, int end) {\n", "    for (int i = start; i < end; i++) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the start position of the first occurrence of the specified {@code\n", "   * target} within {@code array}, or {@code -1} if there is no such occurrence.\n", "   *\n", "   * <p>More formally, returns the lowest index {@code i} such that {@code\n", "   * java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly\n", "   * the same elements as {@code target}.\n", "   *\n", "   * @param array the array to search for the sequence {@code target}\n", "   * @param target the array to search for as a sub-sequence of {@code array}\n", "   */\n", "  public static int indexOf(int[] array, int[] target) {\n", "    checkNotNull(array, \"array\");\n", "    checkNotNull(target, \"target\");\n", "    if (target.length == 0) {\n", "      return 0;\n", "    }\n", "\n", "    outer:\n", "    for (int i = 0; i < array.length - target.length + 1; i++) {\n", "      for (int j = 0; j < target.length; j++) {\n", "        if (array[i + j] != target[j]) {\n", "          continue outer;\n", "        }\n", "      }\n", "      return i;\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the last appearance of the value {@code target} in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code int} values, possibly empty\n", "   * @param target a primitive {@code int} value\n", "   * @return the greatest index {@code i} for which {@code array[i] == target},\n", "   *     or {@code -1} if no such index exists.\n", "   */\n", "  public static int lastIndexOf(int[] array, int target) {\n", "    return lastIndexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int lastIndexOf(int[] array, int target, int start, int end) {\n", "    for (int i = end - 1; i >= start; i--) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the least value present in {@code array}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code int} values\n", "   * @return the value present in {@code array} that is less than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static int min(int... array) {\n", "    checkArgument(array.length > 0);\n", "    int min = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      if (array[i] < min) {\n", "        min = array[i];\n", "      }\n", "    }\n", "    return min;\n", "  }\n", "\n", "  /**\n", "   * Returns the greatest value present in {@code array}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code int} values\n", "   * @return the value present in {@code array} that is greater than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static int max(int... array) {\n", "    checkArgument(array.length > 0);\n", "    int max = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      if (array[i] > max) {\n", "        max = array[i];\n", "      }\n", "    }\n", "    return max;\n", "  }\n", "\n", "  /**\n", "   * Returns the values from each provided array combined into a single array.\n", "   * For example, {@code concat(new int[] {a, b}, new int[] {}, new\n", "   * int[] {c}} returns the array {@code {a, b, c}}.\n", "   *\n", "   * @param arrays zero or more {@code int} arrays\n", "   * @return a single array containing all the values from the source arrays, in\n", "   *     order\n", "   */\n", "  public static int[] concat(int[]... arrays) {\n", "    int length = 0;\n", "    for (int[] array : arrays) {\n", "      length += array.length;\n", "    }\n", "    int[] result = new int[length];\n", "    int pos = 0;\n", "    for (int[] array : arrays) {\n", "      System.arraycopy(array, 0, result, pos, array.length);\n", "      pos += array.length;\n", "    }\n", "    return result;\n", "  }\n", "\n", "  private static final class IntConverter extends Converter<String, Integer>\n", "      implements Serializable {\n", "    static final IntConverter INSTANCE = new IntConverter();\n", "\n", "    @Override\n", "    protected Integer doForward(String value) {\n", "      return Integer.decode(value);\n", "    }\n", "\n", "    @Override\n", "    protected String doBackward(Integer value) {\n", "      return value.toString();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Ints.stringConverter()\";\n", "    }\n", "\n", "    private Object readResolve() {\n", "      return INSTANCE;\n", "    }\n", "\n", "    private static final long serialVersionUID = 1;\n", "  }\n", "\n", "  /**\n", "   * Returns a serializable converter object that converts between strings and\n", "   * integers using {@link Integer#decode} and {@link Integer#toString()}.\n", "   *\n", "   * @since 16.0\n", "   */\n", "  @Beta\n", "  public static Converter<String, Integer> stringConverter() {\n", "    return IntConverter.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing the same values as {@code array}, but\n", "   * guaranteed to be of a specified minimum length. If {@code array} already\n", "   * has a length of at least {@code minLength}, it is returned directly.\n", "   * Otherwise, a new array of size {@code minLength + padding} is returned,\n", "   * containing the values of {@code array}, and zeroes in the remaining places.\n", "   *\n", "   * @param array the source array\n", "   * @param minLength the minimum length the returned array must guarantee\n", "   * @param padding an extra amount to \"grow\" the array by if growth is\n", "   *     necessary\n", "   * @throws IllegalArgumentException if {@code minLength} or {@code padding} is\n", "   *     negative\n", "   * @return an array containing the values of {@code array}, with guaranteed\n", "   *     minimum length {@code minLength}\n", "   */\n", "  public static int[] ensureCapacity(int[] array, int minLength, int padding) {\n", "    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n", "    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n", "    return (array.length < minLength)\n", "        ? copyOf(array, minLength + padding)\n", "        : array;\n", "  }\n", "\n", "  // Arrays.copyOf() requires Java 6\n", "  private static int[] copyOf(int[] original, int length) {\n", "    int[] copy = new int[length];\n", "    System.arraycopy(original, 0, copy, 0, Math.min(original.length, length));\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Returns a string containing the supplied {@code int} values separated\n", "   * by {@code separator}. For example, {@code join(\"-\", 1, 2, 3)} returns\n", "   * the string {@code \"1-2-3\"}.\n", "   *\n", "   * @param separator the text that should appear between consecutive values in\n", "   *     the resulting string (but not at the start or end)\n", "   * @param array an array of {@code int} values, possibly empty\n", "   */\n", "  public static String join(String separator, int... array) {\n", "    checkNotNull(separator);\n", "    if (array.length == 0) {\n", "      return \"\";\n", "    }\n", "\n", "    // For pre-sizing a builder, just get the right order of magnitude\n", "    StringBuilder builder = new StringBuilder(array.length * 5);\n", "    builder.append(array[0]);\n", "    for (int i = 1; i < array.length; i++) {\n", "      builder.append(separator).append(array[i]);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  /**\n", "   * Returns a comparator that compares two {@code int} arrays\n", "   * lexicographically. That is, it compares, using {@link\n", "   * #compare(int, int)}), the first pair of values that follow any\n", "   * common prefix, or when one array is a prefix of the other, treats the\n", "   * shorter array as the lesser. For example, {@code [] < [1] < [1, 2] < [2]}.\n", "   *\n", "   * <p>The returned comparator is inconsistent with {@link\n", "   * Object#equals(Object)} (since arrays support only identity equality), but\n", "   * it is consistent with {@link Arrays#equals(int[], int[])}.\n", "   *\n", "   * @see <a href=\"http://en.wikipedia.org/wiki/Lexicographical_order\">\n", "   *     Lexicographical order article at Wikipedia</a>\n", "   * @since 2.0\n", "   */\n", "  public static Comparator<int[]> lexicographicalComparator() {\n", "    return LexicographicalComparator.INSTANCE;\n", "  }\n", "\n", "  private enum LexicographicalComparator implements Comparator<int[]> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public int compare(int[] left, int[] right) {\n", "      int minLength = Math.min(left.length, right.length);\n", "      for (int i = 0; i < minLength; i++) {\n", "        int result = Ints.compare(left[i], right[i]);\n", "        if (result != 0) {\n", "          return result;\n", "        }\n", "      }\n", "      return left.length - right.length;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing each value of {@code collection}, converted to\n", "   * a {@code int} value in the manner of {@link Number#intValue}.\n", "   *\n", "   * <p>Elements are copied from the argument collection as if by {@code\n", "   * collection.toArray()}.  Calling this method is as thread-safe as calling\n", "   * that method.\n", "   *\n", "   * @param collection a collection of {@code Number} instances\n", "   * @return an array containing the same values as {@code collection}, in the\n", "   *     same order, converted to primitives\n", "   * @throws NullPointerException if {@code collection} or any of its elements\n", "   *     is null\n", "   * @since 1.0 (parameter was {@code Collection<Integer>} before 12.0)\n", "   */\n", "  public static int[] toArray(Collection<? extends Number> collection) {\n", "    if (collection instanceof IntArrayAsList) {\n", "      return ((IntArrayAsList) collection).toIntArray();\n", "    }\n", "\n", "    Object[] boxedArray = collection.toArray();\n", "    int len = boxedArray.length;\n", "    int[] array = new int[len];\n", "    for (int i = 0; i < len; i++) {\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[i] = ((Number) checkNotNull(boxedArray[i])).intValue();\n", "    }\n", "    return array;\n", "  }\n", "\n", "  /**\n", "   * Returns a fixed-size list backed by the specified array, similar to {@link\n", "   * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},\n", "   * but any attempt to set a value to {@code null} will result in a {@link\n", "   * NullPointerException}.\n", "   *\n", "   * <p>The returned list maintains the values, but not the identities, of\n", "   * {@code Integer} objects written to or read from it.  For example, whether\n", "   * {@code list.get(0) == list.get(0)} is true for the returned list is\n", "   * unspecified.\n", "   *\n", "   * @param backingArray the array to back the list\n", "   * @return a list view of the array\n", "   */\n", "  public static List<Integer> asList(int... backingArray) {\n", "    if (backingArray.length == 0) {\n", "      return Collections.emptyList();\n", "    }\n", "    return new IntArrayAsList(backingArray);\n", "  }\n", "\n", "  @GwtCompatible\n", "  private static class IntArrayAsList extends AbstractList<Integer>\n", "      implements RandomAccess, Serializable {\n", "    final int[] array;\n", "    final int start;\n", "    final int end;\n", "\n", "    IntArrayAsList(int[] array) {\n", "      this(array, 0, array.length);\n", "    }\n", "\n", "    IntArrayAsList(int[] array, int start, int end) {\n", "      this.array = array;\n", "      this.start = start;\n", "      this.end = end;\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return end - start;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public Integer get(int index) {\n", "      checkElementIndex(index, size());\n", "      return array[start + index];\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      return (target instanceof Integer) && Ints.indexOf(array, (Integer) target, start, end) != -1;\n", "    }\n", "\n", "    @Override\n", "    public int indexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Integer) {\n", "        int i = Ints.indexOf(array, (Integer) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Integer) {\n", "        int i = Ints.lastIndexOf(array, (Integer) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public Integer set(int index, Integer element) {\n", "      checkElementIndex(index, size());\n", "      int oldValue = array[start + index];\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[start + index] = checkNotNull(element);\n", "      return oldValue;\n", "    }\n", "\n", "    @Override\n", "    public List<Integer> subList(int fromIndex, int toIndex) {\n", "      int size = size();\n", "      checkPositionIndexes(fromIndex, toIndex, size);\n", "      if (fromIndex == toIndex) {\n", "        return Collections.emptyList();\n", "      }\n", "      return new IntArrayAsList(array, start + fromIndex, start + toIndex);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(@Nullable Object object) {\n", "      if (object == this) {\n", "        return true;\n", "      }\n", "      if (object instanceof IntArrayAsList) {\n", "        IntArrayAsList that = (IntArrayAsList) object;\n", "        int size = size();\n", "        if (that.size() != size) {\n", "          return false;\n", "        }\n", "        for (int i = 0; i < size; i++) {\n", "          if (array[start + i] != that.array[that.start + i]) {\n", "            return false;\n", "          }\n", "        }\n", "        return true;\n", "      }\n", "      return super.equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      int result = 1;\n", "      for (int i = start; i < end; i++) {\n", "        result = 31 * result + Ints.hashCode(array[i]);\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      StringBuilder builder = new StringBuilder(size() * 5);\n", "      builder.append('[').append(array[start]);\n", "      for (int i = start + 1; i < end; i++) {\n", "        builder.append(\", \").append(array[i]);\n", "      }\n", "      return builder.append(']').toString();\n", "    }\n", "\n", "    int[] toIntArray() {\n", "      // Arrays.copyOfRange() is not available under GWT\n", "      int size = size();\n", "      int[] result = new int[size];\n", "      System.arraycopy(array, start, result, 0, size);\n", "      return result;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Parses the specified string as a signed decimal integer value. The ASCII\n", "   * character {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the\n", "   * minus sign.\n", "   *\n", "   * <p>Unlike {@link Integer#parseInt(String)}, this method returns\n", "   * {@code null} instead of throwing an exception if parsing fails.\n", "   * Additionally, this method only accepts ASCII digits, and returns\n", "   * {@code null} if non-ASCII digits are present in the string.\n", "   *\n", "   * <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even\n", "   * under JDK 7, despite the change to {@link Integer#parseInt(String)} for\n", "   * that version.\n", "   *\n", "   * @param string the string representation of an integer value\n", "   * @return the integer value represented by {@code string}, or {@code null} if\n", "   *     {@code string} has a length of zero or cannot be parsed as an integer\n", "   *     value\n", "   * @since 11.0\n", "   */\n", "  @Beta\n", "  @Nullable\n", "  @CheckForNull\n", "  public static Integer tryParse(String string) {\n", "    return tryParse(string, 10);\n", "  }\n", "\n", "  /**\n", "   * Parses the specified string as a signed integer value using the specified\n", "   * radix. The ASCII character {@code '-'} (<code>'&#92;u002D'</code>) is\n", "   * recognized as the minus sign.\n", "   *\n", "   * <p>Unlike {@link Integer#parseInt(String, int)}, this method returns\n", "   * {@code null} instead of throwing an exception if parsing fails.\n", "   * Additionally, this method only accepts ASCII digits, and returns\n", "   * {@code null} if non-ASCII digits are present in the string.\n", "   *\n", "   * <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even\n", "   * under JDK 7, despite the change to {@link Integer#parseInt(String, int)}\n", "   * for that version.\n", "   *\n", "   * @param string the string representation of an integer value\n", "   * @param radix the radix to use when parsing\n", "   * @return the integer value represented by {@code string} using\n", "   *     {@code radix}, or {@code null} if {@code string} has a length of zero\n", "   *     or cannot be parsed as an integer value\n", "   * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or\n", "   *     {@code radix > Character.MAX_RADIX}\n", "   * @since 19.0\n", "   */\n", "  @Beta\n", "  @Nullable\n", "  @CheckForNull\n", "  public static Integer tryParse(\n", "      String string, int radix) {\n", "    Long result = Longs.tryParse(string, radix);\n", "    if (result == null || result.longValue() != result.intValue()) {\n", "      return null;\n", "    } else {\n", "      return result.intValue();\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659]}}, {"57": "guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/Shorts.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkElementIndex;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.base.Preconditions.checkPositionIndexes;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractList;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "import java.util.RandomAccess;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "\n", "/**\n", " * Static utility methods pertaining to {@code short} primitives, that are not\n", " * already found in either {@link Short} or {@link Arrays}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/PrimitivesExplained\">\n", " * primitive utilities</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @since 1.0\n", " */\n", "@CheckReturnValue\n", "@GwtCompatible(emulated = true)\n", "public final class Shorts {\n", "  private Shorts() {}\n", "\n", "  /**\n", "   * The number of bytes required to represent a primitive {@code short}\n", "   * value.\n", "   */\n", "  public static final int BYTES = Short.SIZE / Byte.SIZE;\n", "\n", "  /**\n", "   * The largest power of two that can be represented as a {@code short}.\n", "   *\n", "   * @since 10.0\n", "   */\n", "  public static final short MAX_POWER_OF_TWO = 1 << (Short.SIZE - 2);\n", "\n", "  /**\n", "   * Returns a hash code for {@code value}; equal to the result of invoking\n", "   * {@code ((Short) value).hashCode()}.\n", "   *\n", "   * @param value a primitive {@code short} value\n", "   * @return a hash code for the value\n", "   */\n", "  public static int hashCode(short value) {\n", "    return value;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@code short} value that is equal to {@code value}, if\n", "   * possible.\n", "   *\n", "   * @param value any value in the range of the {@code short} type\n", "   * @return the {@code short} value that equals {@code value}\n", "   * @throws IllegalArgumentException if {@code value} is greater than {@link\n", "   *     Short#MAX_VALUE} or less than {@link Short#MIN_VALUE}\n", "   */\n", "  public static short checkedCast(long value) {\n", "    short result = (short) value;\n", "    if (result != value) {\n", "      // don't use checkArgument here, to avoid boxing\n", "      throw new IllegalArgumentException(\"Out of range: \" + value);\n", "    }\n", "    return result;\n", "  }\n", "\n", "  /**\n", "   * Returns the {@code short} nearest in value to {@code value}.\n", "   *\n", "   * @param value any {@code long} value\n", "   * @return the same value cast to {@code short} if it is in the range of the\n", "   *     {@code short} type, {@link Short#MAX_VALUE} if it is too large,\n", "   *     or {@link Short#MIN_VALUE} if it is too small\n", "   */\n", "  public static short saturatedCast(long value) {\n", "    if (value > Short.MAX_VALUE) {\n", "      return Short.MAX_VALUE;\n", "    }\n", "    if (value < Short.MIN_VALUE) {\n", "      return Short.MIN_VALUE;\n", "    }\n", "    return (short) value;\n", "  }\n", "\n", "  /**\n", "   * Compares the two specified {@code short} values. The sign of the value\n", "   * returned is the same as that of {@code ((Short) a).compareTo(b)}.\n", "   *\n", "   * <p><b>Note for Java 7 and later:</b> this method should be treated as\n", "   * deprecated; use the equivalent {@link Short#compare} method instead.\n", "   *\n", "   * @param a the first {@code short} to compare\n", "   * @param b the second {@code short} to compare\n", "   * @return a negative value if {@code a} is less than {@code b}; a positive\n", "   *     value if {@code a} is greater than {@code b}; or zero if they are equal\n", "   */\n", "  public static int compare(short a, short b) {\n", "    return a - b; // safe due to restricted range\n", "  }\n", "\n", "  /**\n", "   * Returns {@code true} if {@code target} is present as an element anywhere in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code short} values, possibly empty\n", "   * @param target a primitive {@code short} value\n", "   * @return {@code true} if {@code array[i] == target} for some value of {@code\n", "   *     i}\n", "   */\n", "  public static boolean contains(short[] array, short target) {\n", "    for (short value : array) {\n", "      if (value == target) {\n", "        return true;\n", "      }\n", "    }\n", "    return false;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the first appearance of the value {@code target} in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code short} values, possibly empty\n", "   * @param target a primitive {@code short} value\n", "   * @return the least index {@code i} for which {@code array[i] == target}, or\n", "   *     {@code -1} if no such index exists.\n", "   */\n", "  public static int indexOf(short[] array, short target) {\n", "    return indexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int indexOf(short[] array, short target, int start, int end) {\n", "    for (int i = start; i < end; i++) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the start position of the first occurrence of the specified {@code\n", "   * target} within {@code array}, or {@code -1} if there is no such occurrence.\n", "   *\n", "   * <p>More formally, returns the lowest index {@code i} such that {@code\n", "   * java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly\n", "   * the same elements as {@code target}.\n", "   *\n", "   * @param array the array to search for the sequence {@code target}\n", "   * @param target the array to search for as a sub-sequence of {@code array}\n", "   */\n", "  public static int indexOf(short[] array, short[] target) {\n", "    checkNotNull(array, \"array\");\n", "    checkNotNull(target, \"target\");\n", "    if (target.length == 0) {\n", "      return 0;\n", "    }\n", "\n", "    outer:\n", "    for (int i = 0; i < array.length - target.length + 1; i++) {\n", "      for (int j = 0; j < target.length; j++) {\n", "        if (array[i + j] != target[j]) {\n", "          continue outer;\n", "        }\n", "      }\n", "      return i;\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the index of the last appearance of the value {@code target} in\n", "   * {@code array}.\n", "   *\n", "   * @param array an array of {@code short} values, possibly empty\n", "   * @param target a primitive {@code short} value\n", "   * @return the greatest index {@code i} for which {@code array[i] == target},\n", "   *     or {@code -1} if no such index exists.\n", "   */\n", "  public static int lastIndexOf(short[] array, short target) {\n", "    return lastIndexOf(array, target, 0, array.length);\n", "  }\n", "\n", "  // TODO(kevinb): consider making this public\n", "  private static int lastIndexOf(short[] array, short target, int start, int end) {\n", "    for (int i = end - 1; i >= start; i--) {\n", "      if (array[i] == target) {\n", "        return i;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "\n", "  /**\n", "   * Returns the least value present in {@code array}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code short} values\n", "   * @return the value present in {@code array} that is less than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static short min(short... array) {\n", "    checkArgument(array.length > 0);\n", "    short min = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      if (array[i] < min) {\n", "        min = array[i];\n", "      }\n", "    }\n", "    return min;\n", "  }\n", "\n", "  /**\n", "   * Returns the greatest value present in {@code array}.\n", "   *\n", "   * @param array a <i>nonempty</i> array of {@code short} values\n", "   * @return the value present in {@code array} that is greater than or equal to\n", "   *     every other value in the array\n", "   * @throws IllegalArgumentException if {@code array} is empty\n", "   */\n", "  public static short max(short... array) {\n", "    checkArgument(array.length > 0);\n", "    short max = array[0];\n", "    for (int i = 1; i < array.length; i++) {\n", "      if (array[i] > max) {\n", "        max = array[i];\n", "      }\n", "    }\n", "    return max;\n", "  }\n", "\n", "  /**\n", "   * Returns the values from each provided array combined into a single array.\n", "   * For example, {@code concat(new short[] {a, b}, new short[] {}, new\n", "   * short[] {c}} returns the array {@code {a, b, c}}.\n", "   *\n", "   * @param arrays zero or more {@code short} arrays\n", "   * @return a single array containing all the values from the source arrays, in\n", "   *     order\n", "   */\n", "  public static short[] concat(short[]... arrays) {\n", "    int length = 0;\n", "    for (short[] array : arrays) {\n", "      length += array.length;\n", "    }\n", "    short[] result = new short[length];\n", "    int pos = 0;\n", "    for (short[] array : arrays) {\n", "      System.arraycopy(array, 0, result, pos, array.length);\n", "      pos += array.length;\n", "    }\n", "    return result;\n", "  }\n", "\n", "  private static final class ShortConverter extends Converter<String, Short>\n", "      implements Serializable {\n", "    static final ShortConverter INSTANCE = new ShortConverter();\n", "\n", "    @Override\n", "    protected Short doForward(String value) {\n", "      return Short.decode(value);\n", "    }\n", "\n", "    @Override\n", "    protected String doBackward(Short value) {\n", "      return value.toString();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      return \"Shorts.stringConverter()\";\n", "    }\n", "\n", "    private Object readResolve() {\n", "      return INSTANCE;\n", "    }\n", "\n", "    private static final long serialVersionUID = 1;\n", "  }\n", "\n", "  /**\n", "   * Returns a serializable converter object that converts between strings and\n", "   * shorts using {@link Short#decode} and {@link Short#toString()}.\n", "   *\n", "   * @since 16.0\n", "   */\n", "  @Beta\n", "  public static Converter<String, Short> stringConverter() {\n", "    return ShortConverter.INSTANCE;\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing the same values as {@code array}, but\n", "   * guaranteed to be of a specified minimum length. If {@code array} already\n", "   * has a length of at least {@code minLength}, it is returned directly.\n", "   * Otherwise, a new array of size {@code minLength + padding} is returned,\n", "   * containing the values of {@code array}, and zeroes in the remaining places.\n", "   *\n", "   * @param array the source array\n", "   * @param minLength the minimum length the returned array must guarantee\n", "   * @param padding an extra amount to \"grow\" the array by if growth is\n", "   *     necessary\n", "   * @throws IllegalArgumentException if {@code minLength} or {@code padding} is\n", "   *     negative\n", "   * @return an array containing the values of {@code array}, with guaranteed\n", "   *     minimum length {@code minLength}\n", "   */\n", "  public static short[] ensureCapacity(short[] array, int minLength, int padding) {\n", "    checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n", "    checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n", "    return (array.length < minLength)\n", "        ? copyOf(array, minLength + padding)\n", "        : array;\n", "  }\n", "\n", "  // Arrays.copyOf() requires Java 6\n", "  private static short[] copyOf(short[] original, int length) {\n", "    short[] copy = new short[length];\n", "    System.arraycopy(original, 0, copy, 0, Math.min(original.length, length));\n", "    return copy;\n", "  }\n", "\n", "  /**\n", "   * Returns a string containing the supplied {@code short} values separated\n", "   * by {@code separator}. For example, {@code join(\"-\", (short) 1, (short) 2,\n", "   * (short) 3)} returns the string {@code \"1-2-3\"}.\n", "   *\n", "   * @param separator the text that should appear between consecutive values in\n", "   *     the resulting string (but not at the start or end)\n", "   * @param array an array of {@code short} values, possibly empty\n", "   */\n", "  public static String join(String separator, short... array) {\n", "    checkNotNull(separator);\n", "    if (array.length == 0) {\n", "      return \"\";\n", "    }\n", "\n", "    // For pre-sizing a builder, just get the right order of magnitude\n", "    StringBuilder builder = new StringBuilder(array.length * 6);\n", "    builder.append(array[0]);\n", "    for (int i = 1; i < array.length; i++) {\n", "      builder.append(separator).append(array[i]);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  /**\n", "   * Returns a comparator that compares two {@code short} arrays\n", "   * lexicographically. That is, it compares, using {@link\n", "   * #compare(short, short)}), the first pair of values that follow any\n", "   * common prefix, or when one array is a prefix of the other, treats the\n", "   * shorter array as the lesser. For example, {@code [] < [(short) 1] <\n", "   * [(short) 1, (short) 2] < [(short) 2]}.\n", "   *\n", "   * <p>The returned comparator is inconsistent with {@link\n", "   * Object#equals(Object)} (since arrays support only identity equality), but\n", "   * it is consistent with {@link Arrays#equals(short[], short[])}.\n", "   *\n", "   * @see <a href=\"http://en.wikipedia.org/wiki/Lexicographical_order\">\n", "   *     Lexicographical order article at Wikipedia</a>\n", "   * @since 2.0\n", "   */\n", "  public static Comparator<short[]> lexicographicalComparator() {\n", "    return LexicographicalComparator.INSTANCE;\n", "  }\n", "\n", "  private enum LexicographicalComparator implements Comparator<short[]> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public int compare(short[] left, short[] right) {\n", "      int minLength = Math.min(left.length, right.length);\n", "      for (int i = 0; i < minLength; i++) {\n", "        int result = Shorts.compare(left[i], right[i]);\n", "        if (result != 0) {\n", "          return result;\n", "        }\n", "      }\n", "      return left.length - right.length;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns an array containing each value of {@code collection}, converted to\n", "   * a {@code short} value in the manner of {@link Number#shortValue}.\n", "   *\n", "   * <p>Elements are copied from the argument collection as if by {@code\n", "   * collection.toArray()}.  Calling this method is as thread-safe as calling\n", "   * that method.\n", "   *\n", "   * @param collection a collection of {@code Number} instances\n", "   * @return an array containing the same values as {@code collection}, in the\n", "   *     same order, converted to primitives\n", "   * @throws NullPointerException if {@code collection} or any of its elements\n", "   *     is null\n", "   * @since 1.0 (parameter was {@code Collection<Short>} before 12.0)\n", "   */\n", "  public static short[] toArray(Collection<? extends Number> collection) {\n", "    if (collection instanceof ShortArrayAsList) {\n", "      return ((ShortArrayAsList) collection).toShortArray();\n", "    }\n", "\n", "    Object[] boxedArray = collection.toArray();\n", "    int len = boxedArray.length;\n", "    short[] array = new short[len];\n", "    for (int i = 0; i < len; i++) {\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[i] = ((Number) checkNotNull(boxedArray[i])).shortValue();\n", "    }\n", "    return array;\n", "  }\n", "\n", "  /**\n", "   * Returns a fixed-size list backed by the specified array, similar to {@link\n", "   * Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},\n", "   * but any attempt to set a value to {@code null} will result in a {@link\n", "   * NullPointerException}.\n", "   *\n", "   * <p>The returned list maintains the values, but not the identities, of\n", "   * {@code Short} objects written to or read from it.  For example, whether\n", "   * {@code list.get(0) == list.get(0)} is true for the returned list is\n", "   * unspecified.\n", "   *\n", "   * @param backingArray the array to back the list\n", "   * @return a list view of the array\n", "   */\n", "  public static List<Short> asList(short... backingArray) {\n", "    if (backingArray.length == 0) {\n", "      return Collections.emptyList();\n", "    }\n", "    return new ShortArrayAsList(backingArray);\n", "  }\n", "\n", "  @GwtCompatible\n", "  private static class ShortArrayAsList extends AbstractList<Short>\n", "      implements RandomAccess, Serializable {\n", "    final short[] array;\n", "    final int start;\n", "    final int end;\n", "\n", "    ShortArrayAsList(short[] array) {\n", "      this(array, 0, array.length);\n", "    }\n", "\n", "    ShortArrayAsList(short[] array, int start, int end) {\n", "      this.array = array;\n", "      this.start = start;\n", "      this.end = end;\n", "    }\n", "\n", "    @Override\n", "    public int size() {\n", "      return end - start;\n", "    }\n", "\n", "    @Override\n", "    public boolean isEmpty() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public Short get(int index) {\n", "      checkElementIndex(index, size());\n", "      return array[start + index];\n", "    }\n", "\n", "    @Override\n", "    public boolean contains(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      return (target instanceof Short) && Shorts.indexOf(array, (Short) target, start, end) != -1;\n", "    }\n", "\n", "    @Override\n", "    public int indexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Short) {\n", "        int i = Shorts.indexOf(array, (Short) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public int lastIndexOf(Object target) {\n", "      // Overridden to prevent a ton of boxing\n", "      if (target instanceof Short) {\n", "        int i = Shorts.lastIndexOf(array, (Short) target, start, end);\n", "        if (i >= 0) {\n", "          return i - start;\n", "        }\n", "      }\n", "      return -1;\n", "    }\n", "\n", "    @Override\n", "    public Short set(int index, Short element) {\n", "      checkElementIndex(index, size());\n", "      short oldValue = array[start + index];\n", "      // checkNotNull for GWT (do not optimize)\n", "      array[start + index] = checkNotNull(element);\n", "      return oldValue;\n", "    }\n", "\n", "    @Override\n", "    public List<Short> subList(int fromIndex, int toIndex) {\n", "      int size = size();\n", "      checkPositionIndexes(fromIndex, toIndex, size);\n", "      if (fromIndex == toIndex) {\n", "        return Collections.emptyList();\n", "      }\n", "      return new ShortArrayAsList(array, start + fromIndex, start + toIndex);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object object) {\n", "      if (object == this) {\n", "        return true;\n", "      }\n", "      if (object instanceof ShortArrayAsList) {\n", "        ShortArrayAsList that = (ShortArrayAsList) object;\n", "        int size = size();\n", "        if (that.size() != size) {\n", "          return false;\n", "        }\n", "        for (int i = 0; i < size; i++) {\n", "          if (array[start + i] != that.array[that.start + i]) {\n", "            return false;\n", "          }\n", "        }\n", "        return true;\n", "      }\n", "      return super.equals(object);\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      int result = 1;\n", "      for (int i = start; i < end; i++) {\n", "        result = 31 * result + Shorts.hashCode(array[i]);\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "      StringBuilder builder = new StringBuilder(size() * 6);\n", "      builder.append('[').append(array[start]);\n", "      for (int i = start + 1; i < end; i++) {\n", "        builder.append(\", \").append(array[i]);\n", "      }\n", "      return builder.append(']').toString();\n", "    }\n", "\n", "    short[] toShortArray() {\n", "      // Arrays.copyOfRange() is not available under GWT\n", "      int size = size();\n", "      short[] result = new short[size];\n", "      System.arraycopy(array, start, result, 0, size);\n", "      return result;\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596]}}, {"58": "guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/UnsignedInteger.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the\n", " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n", " * express or implied. See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.primitives.UnsignedInts.INT_MASK;\n", "import static com.google.common.primitives.UnsignedInts.compare;\n", "import static com.google.common.primitives.UnsignedInts.toLong;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.math.BigInteger;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * A wrapper class for unsigned {@code int} values, supporting arithmetic operations.\n", " *\n", " * <p>In some cases, when speed is more important than code readability, it may be faster simply to\n", " * treat primitive {@code int} values as unsigned, using the methods from {@link UnsignedInts}.\n", " *\n", " * <p>See the Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/PrimitivesExplained#unsigned-support\">\n", " * unsigned primitive utilities</a>.\n", " *\n", " * @author Louis Wasserman\n", " * @since 11.0\n", " */\n", "@CheckReturnValue\n", "@GwtCompatible(emulated = true)\n", "public final class UnsignedInteger extends Number implements Comparable<UnsignedInteger> {\n", "  public static final UnsignedInteger ZERO = fromIntBits(0);\n", "  public static final UnsignedInteger ONE = fromIntBits(1);\n", "  public static final UnsignedInteger MAX_VALUE = fromIntBits(-1);\n", "\n", "  private final int value;\n", "\n", "  private UnsignedInteger(int value) {\n", "    // GWT doesn't consistently overflow values to make them 32-bit, so we need to force it.\n", "    this.value = value & 0xffffffff;\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code UnsignedInteger} corresponding to a given bit representation.\n", "   * The argument is interpreted as an unsigned 32-bit value. Specifically, the sign bit\n", "   * of {@code bits} is interpreted as a normal bit, and all other bits are treated as usual.\n", "   *\n", "   * <p>If the argument is nonnegative, the returned result will be equal to {@code bits},\n", "   * otherwise, the result will be equal to {@code 2^32 + bits}.\n", "   *\n", "   * <p>To represent unsigned decimal constants, consider {@link #valueOf(long)} instead.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  public static UnsignedInteger fromIntBits(int bits) {\n", "    return new UnsignedInteger(bits);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code UnsignedInteger} that is equal to {@code value},\n", "   * if possible.  The inverse operation of {@link #longValue()}.\n", "   */\n", "  public static UnsignedInteger valueOf(long value) {\n", "    checkArgument(\n", "        (value & INT_MASK) == value,\n", "        \"value (%s) is outside the range for an unsigned integer value\",\n", "        value);\n", "    return fromIntBits((int) value);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code UnsignedInteger} representing the same value as the specified\n", "   * {@link BigInteger}. This is the inverse operation of {@link #bigIntegerValue()}.\n", "   *\n", "   * @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^32}\n", "   */\n", "  public static UnsignedInteger valueOf(BigInteger value) {\n", "    checkNotNull(value);\n", "    checkArgument(\n", "        value.signum() >= 0 && value.bitLength() <= Integer.SIZE,\n", "        \"value (%s) is outside the range for an unsigned integer value\",\n", "        value);\n", "    return fromIntBits(value.intValue());\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code UnsignedInteger} holding the value of the specified {@code String}, parsed\n", "   * as an unsigned {@code int} value.\n", "   *\n", "   * @throws NumberFormatException if the string does not contain a parsable unsigned {@code int}\n", "   *         value\n", "   */\n", "  public static UnsignedInteger valueOf(String string) {\n", "    return valueOf(string, 10);\n", "  }\n", "\n", "  /**\n", "   * Returns an {@code UnsignedInteger} holding the value of the specified {@code String}, parsed\n", "   * as an unsigned {@code int} value in the specified radix.\n", "   *\n", "   * @throws NumberFormatException if the string does not contain a parsable unsigned {@code int}\n", "   *         value\n", "   */\n", "  public static UnsignedInteger valueOf(String string, int radix) {\n", "    return fromIntBits(UnsignedInts.parseUnsignedInt(string, radix));\n", "  }\n", "\n", "  /**\n", "   * Returns the result of adding this and {@code val}. If the result would have more than 32 bits,\n", "   * returns the low 32 bits of the result.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  public UnsignedInteger plus(UnsignedInteger val) {\n", "    return fromIntBits(this.value + checkNotNull(val).value);\n", "  }\n", "\n", "  /**\n", "   * Returns the result of subtracting this and {@code val}. If the result would be negative,\n", "   * returns the low 32 bits of the result.\n", "   *\n", "   * @since 14.0\n", "   */\n", "  public UnsignedInteger minus(UnsignedInteger val) {\n", "    return fromIntBits(value - checkNotNull(val).value);\n", "  }\n", "\n", "  /**\n", "   * Returns the result of dividing this by {@code val}.\n", "   *\n", "   * @throws ArithmeticException if {@code val} is zero\n", "   * @since 14.0\n", "   */\n", "  public UnsignedInteger dividedBy(UnsignedInteger val) {\n", "    return fromIntBits(UnsignedInts.divide(value, checkNotNull(val).value));\n", "  }\n", "\n", "  /**\n", "   * Returns this mod {@code val}.\n", "   *\n", "   * @throws ArithmeticException if {@code val} is zero\n", "   * @since 14.0\n", "   */\n", "  public UnsignedInteger mod(UnsignedInteger val) {\n", "    return fromIntBits(UnsignedInts.remainder(value, checkNotNull(val).value));\n", "  }\n", "\n", "  /**\n", "   * Returns the value of this {@code UnsignedInteger} as an {@code int}. This is an inverse\n", "   * operation to {@link #fromIntBits}.\n", "   *\n", "   * <p>Note that if this {@code UnsignedInteger} holds a value {@code >= 2^31}, the returned value\n", "   * will be equal to {@code this - 2^32}.\n", "   */\n", "  @Override\n", "  public int intValue() {\n", "    return value;\n", "  }\n", "\n", "  /**\n", "   * Returns the value of this {@code UnsignedInteger} as a {@code long}.\n", "   */\n", "  @Override\n", "  public long longValue() {\n", "    return toLong(value);\n", "  }\n", "\n", "  /**\n", "   * Returns the value of this {@code UnsignedInteger} as a {@code float}, analogous to a widening\n", "   * primitive conversion from {@code int} to {@code float}, and correctly rounded.\n", "   */\n", "  @Override\n", "  public float floatValue() {\n", "    return longValue();\n", "  }\n", "\n", "  /**\n", "   * Returns the value of this {@code UnsignedInteger} as a {@code float}, analogous to a widening\n", "   * primitive conversion from {@code int} to {@code double}, and correctly rounded.\n", "   */\n", "  @Override\n", "  public double doubleValue() {\n", "    return longValue();\n", "  }\n", "\n", "  /**\n", "   * Returns the value of this {@code UnsignedInteger} as a {@link BigInteger}.\n", "   */\n", "  public BigInteger bigIntegerValue() {\n", "    return BigInteger.valueOf(longValue());\n", "  }\n", "\n", "  /**\n", "   * Compares this unsigned integer to another unsigned integer.\n", "   * Returns {@code 0} if they are equal, a negative number if {@code this < other},\n", "   * and a positive number if {@code this > other}.\n", "   */\n", "  @Override\n", "  public int compareTo(UnsignedInteger other) {\n", "    checkNotNull(other);\n", "    return compare(value, other.value);\n", "  }\n", "\n", "  @Override\n", "  public int hashCode() {\n", "    return value;\n", "  }\n", "\n", "  @Override\n", "  public boolean equals(@Nullable Object obj) {\n", "    if (obj instanceof UnsignedInteger) {\n", "      UnsignedInteger other = (UnsignedInteger) obj;\n", "      return value == other.value;\n", "    }\n", "    return false;\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of the {@code UnsignedInteger} value, in base 10.\n", "   */\n", "  @Override\n", "  public String toString() {\n", "    return toString(10);\n", "  }\n", "\n", "  /**\n", "   * Returns a string representation of the {@code UnsignedInteger} value, in base {@code radix}.\n", "   * If {@code radix < Character.MIN_RADIX} or {@code radix > Character.MAX_RADIX}, the radix\n", "   * {@code 10} is used.\n", "   */\n", "  public String toString(int radix) {\n", "    return UnsignedInts.toString(value, radix);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249]}}, {"59": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Callables.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.concurrent.Callable;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to the {@link Callable} interface.\n", " *\n", " * @author Isaac Shum\n", " * @since 1.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class Callables {\n", "  private Callables() {}\n", "\n", "  /**\n", "   * Creates a {@code Callable} which immediately returns a preset value each time it is called.\n", "   */\n", "  public static <T> Callable<T> returning(@Nullable final T value) {\n", "    return new Callable<T>() {\n", "      @Override\n", "      public T call() {\n", "        return value;\n", "      }\n", "    };\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44]}}, {"60": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/CollectionFuture.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Preconditions.checkState;\n", "import static com.google.common.collect.Lists.newArrayListWithCapacity;\n", "import static java.util.Collections.unmodifiableList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Optional;\n", "import com.google.common.collect.ImmutableCollection;\n", "import com.google.common.collect.ImmutableList;\n", "import com.google.common.collect.Lists;\n", "import com.google.j2objc.annotations.WeakOuter;\n", "\n", "import java.util.List;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Aggregate future that collects (stores) results of each future.\n", " */\n", "@GwtCompatible(emulated = true)\n", "abstract class CollectionFuture<V, C> extends AggregateFuture<V, C> {\n", "\n", "  @WeakOuter\n", "  abstract class CollectionFutureRunningState extends RunningState {\n", "    private List<Optional<V>> values;\n", "\n", "    CollectionFutureRunningState(\n", "        ImmutableCollection<? extends ListenableFuture<? extends V>> futures,\n", "        boolean allMustSucceed) {\n", "      super(futures, allMustSucceed, true);\n", "\n", "      this.values =\n", "          futures.isEmpty()\n", "              ? ImmutableList.<Optional<V>>of()\n", "              : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());\n", "\n", "      // Populate the results list with null initially.\n", "      for (int i = 0; i < futures.size(); ++i) {\n", "        values.add(null);\n", "      }\n", "    }\n", "\n", "    @Override\n", "    final void collectOneValue(boolean allMustSucceed, int index, @Nullable V returnValue) {\n", "      List<Optional<V>> localValues = values;\n", "\n", "      if (localValues != null) {\n", "        localValues.set(index, Optional.fromNullable(returnValue));\n", "      } else {\n", "        // Some other future failed or has been cancelled, causing this one to also be cancelled or\n", "        // have an exception set. This should only happen if allMustSucceed is true or if the output\n", "        // itself has been cancelled.\n", "        checkState(\n", "            allMustSucceed || isCancelled(), \"Future was done before all dependencies completed\");\n", "      }\n", "    }\n", "\n", "    @Override\n", "    final void handleAllCompleted() {\n", "      List<Optional<V>> localValues = values;\n", "      if (localValues != null) {\n", "        set(combine(localValues));\n", "      } else {\n", "        checkState(isDone());\n", "      }\n", "    }\n", "\n", "    @Override\n", "    void releaseResourcesAfterFailure() {\n", "      super.releaseResourcesAfterFailure();\n", "      this.values = null;\n", "    }\n", "\n", "    abstract C combine(List<Optional<V>> values);\n", "  }\n", "\n", "  /** Used for {@link Futures#allAsList} and {@link Futures#successfulAsList}. */\n", "  static final class ListFuture<V> extends CollectionFuture<V, List<V>> {\n", "    ListFuture(\n", "        ImmutableCollection<? extends ListenableFuture<? extends V>> futures,\n", "        boolean allMustSucceed) {\n", "      init(new ListFutureRunningState(futures, allMustSucceed));\n", "    }\n", "\n", "    private final class ListFutureRunningState extends CollectionFutureRunningState {\n", "      ListFutureRunningState(\n", "          ImmutableCollection<? extends ListenableFuture<? extends V>> futures,\n", "          boolean allMustSucceed) {\n", "        super(futures, allMustSucceed);\n", "      }\n", "\n", "      @Override\n", "      public List<V> combine(List<Optional<V>> values) {\n", "        List<V> result = newArrayListWithCapacity(values.size());\n", "        for (Optional<V> element : values) {\n", "          result.add(element != null ? element.orNull() : null);\n", "        }\n", "        return unmodifiableList(result);\n", "      }\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118]}}, {"61": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n", "import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;\n", "\n", "import com.google.common.annotations.Beta;\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Preconditions;\n", "import com.google.common.collect.ImmutableList;\n", "import com.google.common.util.concurrent.CollectionFuture.ListFuture;\n", "import com.google.common.util.concurrent.ImmediateFuture.ImmediateFailedFuture;\n", "import com.google.common.util.concurrent.ImmediateFuture.ImmediateSuccessfulFuture;\n", "\n", "import java.util.List;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.Executor;\n", "\n", "import javax.annotation.CheckReturnValue;\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Static utility methods pertaining to the {@link Future} interface.\n", " *\n", " * <p>Many of these methods use the {@link ListenableFuture} API; consult the\n", " * Guava User Guide article on <a href=\n", " * \"https://github.com/google/guava/wiki/ListenableFutureExplained\">\n", " * {@code ListenableFuture}</a>.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Nishant Thakkar\n", " * @author Sven Mawson\n", " * @since 1.0\n", " */\n", "@Beta\n", "@GwtCompatible(emulated = true)\n", "public final class Futures extends GwtFuturesCatchingSpecialization {\n", "\n", "  // A note on memory visibility.\n", "  // Many of the utilities in this class (transform, withFallback, withTimeout, asList, combine)\n", "  // have two requirements that significantly complicate their design.\n", "  // 1. Cancellation should propagate from the returned future to the input future(s).\n", "  // 2. The returned futures shouldn't unnecessarily 'pin' their inputs after completion.\n", "  //\n", "  // A consequence of these requirements is that the delegate futures cannot be stored in\n", "  // final fields.\n", "  //\n", "  // For simplicity the rest of this description will discuss Futures.catching since it is the\n", "  // simplest instance, though very similar descriptions apply to many other classes in this file.\n", "  //\n", "  // In the constructor of AbstractCatchingFuture, the delegate future is assigned to a field\n", "  // 'inputFuture'. That field is non-final and non-volatile.  There are 2 places where the\n", "  // 'inputFuture' field is read and where we will have to consider visibility of the write\n", "  // operation in the constructor.\n", "  //\n", "  // 1. In the listener that performs the callback.  In this case it is fine since inputFuture is\n", "  //    assigned prior to calling addListener, and addListener happens-before any invocation of the\n", "  //    listener. Notably, this means that 'volatile' is unnecessary to make 'inputFuture' visible\n", "  //    to the listener.\n", "  //\n", "  // 2. In done() where we may propagate cancellation to the input.  In this case it is _not_ fine.\n", "  //    There is currently nothing that enforces that the write to inputFuture in the constructor is\n", "  //    visible to done().  This is because there is no happens before edge between the write and a\n", "  //    (hypothetical) unsafe read by our caller. Note: adding 'volatile' does not fix this issue,\n", "  //    it would just add an edge such that if done() observed non-null, then it would also\n", "  //    definitely observe all earlier writes, but we still have no guarantee that done() would see\n", "  //    the inital write (just stronger guarantees if it does).\n", "  //\n", "  // See: http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/013800.html\n", "  // For a (long) discussion about this specific issue and the general futility of life.\n", "  //\n", "  // For the time being we are OK with the problem discussed above since it requires a caller to\n", "  // introduce a very specific kind of data-race.  And given the other operations performed by these\n", "  // methods that involve volatile read/write operations, in practice there is no issue.  Also, the\n", "  // way in such a visibility issue would surface is most likely as a failure of cancel() to\n", "  // propagate to the input.  Cancellation propagation is fundamentally racy so this is fine.\n", "  //\n", "  // Future versions of the JMM may revise safe construction semantics in such a way that we can\n", "  // safely publish these objects and we won't need this whole discussion.\n", "  // TODO(user,lukes): consider adding volatile to all these fields since in current known JVMs\n", "  // that should resolve the issue.  This comes at the cost of adding more write barriers to the\n", "  // implementations.\n", "\n", "  private Futures() {}\n", "\n", "  /**\n", "   * Creates a {@code ListenableFuture} which has its value set immediately upon construction. The\n", "   * getters just return the value. This {@code Future} can't be canceled or timed out and its\n", "   * {@code isDone()} method always returns {@code true}.\n", "   */\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<V> immediateFuture(@Nullable V value) {\n", "    if (value == null) {\n", "      // This cast is safe because null is assignable to V for all V (i.e. it is covariant)\n", "      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n", "      ListenableFuture<V> typedNull = (ListenableFuture) ImmediateSuccessfulFuture.NULL;\n", "      return typedNull;\n", "    }\n", "    return new ImmediateSuccessfulFuture<V>(value);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.\n", "   *\n", "   * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always\n", "   * returns {@code true}. Calling {@code get()} will immediately throw the provided {@code\n", "   * Throwable} wrapped in an {@code ExecutionException}.\n", "   */\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<V> immediateFailedFuture(Throwable throwable) {\n", "    checkNotNull(throwable);\n", "    return new ImmediateFailedFuture<V>(throwable);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n", "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n", "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n", "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n", "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   *\n", "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter in case an exception happens when\n", "   *   // processing the RPC to fetch counters.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(\n", "   *       fetchCounterFuture, new FutureFallback<Integer>() {\n", "   *         public ListenableFuture<Integer> create(Throwable t) {\n", "   *           // Returning \"0\" as the default for the counter when the\n", "   *           // exception happens.\n", "   *           return immediateFuture(0);\n", "   *         }\n", "   *       });}</pre>\n", "   *\n", "   * <p>The fallback can also choose to propagate the original exception when desired:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter only in case the exception was a\n", "   *   // TimeoutException.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(\n", "   *       fetchCounterFuture, new FutureFallback<Integer>() {\n", "   *         public ListenableFuture<Integer> create(Throwable t) {\n", "   *           if (t instanceof TimeoutException) {\n", "   *             return immediateFuture(0);\n", "   *           }\n", "   *           return immediateFailedFuture(t);\n", "   *         }\n", "   *       });}</pre>\n", "   *\n", "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code FutureFallback.create}, not to any work\n", "   * done to complete the returned {@code Future}.\n", "   *\n", "   * @param input the primary input {@code Future}\n", "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n", "   * @since 14.0\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction)\n", "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction)}, usually\n", "   *     replacing {@code Throwable.class} with the specific type you want to handle. This method\n", "   *     will be removed in Guava release 20.0.\n", "   */\n", "  @Deprecated\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<V> withFallback(\n", "      ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback) {\n", "    return withFallback(input, fallback, directExecutor());\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n", "   * primary input fails, from the {@code Future} provided by the {@code fallback}. {@link\n", "   * FutureFallback#create} is not invoked until the primary input has failed, so if the primary\n", "   * input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an\n", "   * exception is thrown, this exception is used as the result of the output {@code Future}.\n", "   *\n", "   * <p>Below is an example of a fallback that returns a default value if an exception occurs:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter in case an exception happens when\n", "   *   // processing the RPC to fetch counters.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(\n", "   *       fetchCounterFuture, new FutureFallback<Integer>() {\n", "   *         public ListenableFuture<Integer> create(Throwable t) {\n", "   *           // Returning \"0\" as the default for the counter when the\n", "   *           // exception happens.\n", "   *           return immediateFuture(0);\n", "   *         }\n", "   *       }, directExecutor());}</pre>\n", "   *\n", "   * <p>The fallback can also choose to propagate the original exception when desired:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n", "   *\n", "   *   // Falling back to a zero counter only in case the exception was a\n", "   *   // TimeoutException.\n", "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(\n", "   *       fetchCounterFuture, new FutureFallback<Integer>() {\n", "   *         public ListenableFuture<Integer> create(Throwable t) {\n", "   *           if (t instanceof TimeoutException) {\n", "   *             return immediateFuture(0);\n", "   *           }\n", "   *           return immediateFailedFuture(t);\n", "   *         }\n", "   *       }, directExecutor());}</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code FutureFallback.create}, not to any work done to complete the returned\n", "   * {@code Future}.\n", "   *\n", "   * @param input the primary input {@code Future}\n", "   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails\n", "   * @param executor the executor that runs {@code fallback} if {@code input} fails\n", "   * @since 14.0\n", "   * @deprecated Use {@link #catchingAsync(ListenableFuture, Class, AsyncFunction, Executor)\n", "   *     catchingAsync(input, Throwable.class, fallbackImplementedAsAnAsyncFunction, executor)},\n", "   *     usually replacing {@code Throwable.class} with the specific type you want to handle. This\n", "   *     method will be removed in Guava release 20.0.\n", "   */\n", "  @Deprecated\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<V> withFallback(\n", "      ListenableFuture<? extends V> input,\n", "      FutureFallback<? extends V> fallback,\n", "      Executor executor) {\n", "    return catchingAsync(input, Throwable.class, asAsyncFunction(fallback), executor);\n", "  }\n", "\n", "  @Deprecated\n", "  static <V> AsyncFunction<Throwable, V> asAsyncFunction(final FutureFallback<V> fallback) {\n", "    checkNotNull(fallback);\n", "    return new AsyncFunction<Throwable, V>() {\n", "      @Override\n", "      public ListenableFuture<V> apply(Throwable t) throws Exception {\n", "        return checkNotNull(\n", "            fallback.create(t),\n", "            \"FutureFallback.create returned null instead of a \"\n", "                + \"Future. Did you mean to return immediateFuture(null)?\");\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n", "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n", "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n", "   * original {@code Future}. Example:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n", "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n", "   *       new AsyncFunction<RowKey, QueryResult>() {\n", "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n", "   *           return dataService.read(rowKey);\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<QueryResult> queryFuture =\n", "   *       transform(rowKeyFuture, queryFunction);}</pre>\n", "   *\n", "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n", "   * to complete the returned {@code Future}.\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the function. That is, if the returned {@code\n", "   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two\n", "   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to\n", "   * cancel itself.\n", "   *\n", "   * @param input The future to transform\n", "   * @param function A function to transform the result of the input future to the result of the\n", "   *     output future\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   * @since 11.0\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n", "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n", "   *     This method will be removed in Guava release 20.0.\n", "   */\n", "  @Deprecated\n", "  public static <I, O> ListenableFuture<O> transform(\n", "      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {\n", "    return transformAsync(input, function);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n", "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n", "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n", "   * original {@code Future}. Example:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n", "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n", "   *       new AsyncFunction<RowKey, QueryResult>() {\n", "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n", "   *           return dataService.read(rowKey);\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<QueryResult> queryFuture =\n", "   *       transform(rowKeyFuture, queryFunction, executor);}</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n", "   * {@code Future}.\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the chain function. That is, if the returned\n", "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n", "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n", "   * attempt to cancel itself.\n", "   *\n", "   * @param input The future to transform\n", "   * @param function A function to transform the result of the input future to the result of the\n", "   *     output future\n", "   * @param executor Executor to run the function in.\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   * @since 11.0\n", "   * @deprecated These {@code AsyncFunction} overloads of {@code transform} are being renamed to\n", "   *     {@code transformAsync}. (The {@code Function} overloads are keeping the \"transform\" name.)\n", "   *     This method will be removed in Guava release 20.0.\n", "   */\n", "  @Deprecated\n", "  public static <I, O> ListenableFuture<O> transform(\n", "      ListenableFuture<I> input,\n", "      AsyncFunction<? super I, ? extends O> function,\n", "      Executor executor) {\n", "    return transformAsync(input, function, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n", "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n", "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n", "   * original {@code Future}. Example:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n", "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n", "   *       new AsyncFunction<RowKey, QueryResult>() {\n", "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n", "   *           return dataService.read(rowKey);\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<QueryResult> queryFuture =\n", "   *       transformAsync(rowKeyFuture, queryFunction);}</pre>\n", "   *\n", "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code AsyncFunction.apply}, not to any work done\n", "   * to complete the returned {@code Future}.\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the function. That is, if the returned {@code\n", "   * Future} is cancelled, it will attempt to cancel the other two, and if either of the other two\n", "   * is cancelled, the returned {@code Future} will receive a callback in which it will attempt to\n", "   * cancel itself.\n", "   *\n", "   * @param input The future to transform\n", "   * @param function A function to transform the result of the input future to the result of the\n", "   *     output future\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   * @since 19.0 (in 11.0 as {@code transform})\n", "   */\n", "  public static <I, O> ListenableFuture<O> transformAsync(\n", "      ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function) {\n", "    return AbstractTransformFuture.create(input, function);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code ListenableFuture} whose result is asynchronously derived from the result\n", "   * of the given {@code Future}. More precisely, the returned {@code Future} takes its result from\n", "   * a {@code Future} produced by applying the given {@code AsyncFunction} to the result of the\n", "   * original {@code Future}. Example:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);\n", "   *   AsyncFunction<RowKey, QueryResult> queryFunction =\n", "   *       new AsyncFunction<RowKey, QueryResult>() {\n", "   *         public ListenableFuture<QueryResult> apply(RowKey rowKey) {\n", "   *           return dataService.read(rowKey);\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<QueryResult> queryFuture =\n", "   *       transformAsync(rowKeyFuture, queryFunction, executor);}</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code AsyncFunction.apply}, not to any work done to complete the returned\n", "   * {@code Future}.\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future and that of the future returned by the chain function. That is, if the returned\n", "   * {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the\n", "   * other two is cancelled, the returned {@code Future} will receive a callback in which it will\n", "   * attempt to cancel itself.\n", "   *\n", "   * @param input The future to transform\n", "   * @param function A function to transform the result of the input future to the result of the\n", "   *     output future\n", "   * @param executor Executor to run the function in.\n", "   * @return A future that holds result of the function (if the input succeeded) or the original\n", "   *     input's failure (if not)\n", "   * @since 19.0 (in 11.0 as {@code transform})\n", "   */\n", "  public static <I, O> ListenableFuture<O> transformAsync(\n", "      ListenableFuture<I> input,\n", "      AsyncFunction<? super I, ? extends O> function,\n", "      Executor executor) {\n", "    return AbstractTransformFuture.create(input, function, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n", "   * Function} to the result of the given {@code Future}. Example:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<QueryResult> queryFuture = ...;\n", "   *   Function<QueryResult, List<Row>> rowsFunction =\n", "   *       new Function<QueryResult, List<Row>>() {\n", "   *         public List<Row> apply(QueryResult queryResult) {\n", "   *           return queryResult.getRows();\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<List<Row>> rowsFuture =\n", "   *       transform(queryFuture, rowsFunction);}</pre>\n", "   *\n", "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation. The documentation's warnings about \"lightweight\n", "   * listeners\" refer here to the work done during {@code Function.apply}.\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n", "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n", "   * in which it will attempt to cancel itself.\n", "   *\n", "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n", "   * a POJO.\n", "   *\n", "   * @param input The future to transform\n", "   * @param function A Function to transform the results of the provided future to the results of\n", "   *     the returned future.  This will be run in the thread that notifies input it is complete.\n", "   * @return A future that holds result of the transformation.\n", "   * @since 9.0 (in 1.0 as {@code compose})\n", "   */\n", "  public static <I, O> ListenableFuture<O> transform(\n", "      ListenableFuture<I> input, Function<? super I, ? extends O> function) {\n", "    return AbstractTransformFuture.create(input, function);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code ListenableFuture} whose result is the product of applying the given {@code\n", "   * Function} to the result of the given {@code Future}. Example:\n", "   *\n", "   * <pre>   {@code\n", "   *   ListenableFuture<QueryResult> queryFuture = ...;\n", "   *   Function<QueryResult, List<Row>> rowsFunction =\n", "   *       new Function<QueryResult, List<Row>>() {\n", "   *         public List<Row> apply(QueryResult queryResult) {\n", "   *           return queryResult.getRows();\n", "   *         }\n", "   *       };\n", "   *   ListenableFuture<List<Row>> rowsFuture =\n", "   *       transform(queryFuture, rowsFunction, executor);}</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation. The documentation's warnings about \"lightweight listeners\" refer here to the\n", "   * work done during {@code Function.apply}.\n", "   *\n", "   * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the\n", "   * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel\n", "   * the input, and if the input is cancelled, the returned {@code Future} will receive a callback\n", "   * in which it will attempt to cancel itself.\n", "   *\n", "   * <p>An example use of this method is to convert a serializable object returned from an RPC into\n", "   * a POJO.\n", "   *\n", "   * @param input The future to transform\n", "   * @param function A Function to transform the results of the provided future to the results of\n", "   *     the returned future.\n", "   * @param executor Executor to run the function in.\n", "   * @return A future that holds result of the transformation.\n", "   * @since 9.0 (in 2.0 as {@code compose})\n", "   */\n", "  public static <I, O> ListenableFuture<O> transform(\n", "      ListenableFuture<I> input, Function<? super I, ? extends O> function, Executor executor) {\n", "    return AbstractTransformFuture.create(input, function, executor);\n", "  }\n", "\n", "  /**\n", "   * Returns a new {@code ListenableFuture} whose result is the product of calling {@code get()} on\n", "   * the {@code Future} nested within the given {@code Future}, effectively chaining the futures one\n", "   * after the other.  Example:\n", "   *\n", "   * <pre>   {@code\n", "   *   SettableFuture<ListenableFuture<String>> nested = SettableFuture.create();\n", "   *   ListenableFuture<String> dereferenced = dereference(nested);}</pre>\n", "   *\n", "   * <p>This call has the same cancellation and execution semantics as {@link\n", "   * #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code Future} attempts to\n", "   * keep its cancellation state in sync with both the input {@code Future} and the nested {@code\n", "   * Future}.  The transformation is very lightweight and therefore takes place in the same thread\n", "   * (either the thread that called {@code dereference}, or the thread in which the dereferenced\n", "   * future completes).\n", "   *\n", "   * @param nested The nested future to transform.\n", "   * @return A future that holds result of the inner future.\n", "   * @since 13.0\n", "   */\n", "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<V> dereference(\n", "      ListenableFuture<? extends ListenableFuture<? extends V>> nested) {\n", "    return transformAsync((ListenableFuture) nested, (AsyncFunction) DEREFERENCER);\n", "  }\n", "\n", "  /**\n", "   * Helper {@code Function} for {@link #dereference}.\n", "   */\n", "  private static final AsyncFunction<ListenableFuture<Object>, Object> DEREFERENCER =\n", "      new AsyncFunction<ListenableFuture<Object>, Object>() {\n", "        @Override\n", "        public ListenableFuture<Object> apply(ListenableFuture<Object> input) {\n", "          return input;\n", "        }\n", "      };\n", "\n", "  /**\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n", "   *\n", "   * <p>The list of results is in the same order as the input list.\n", "   *\n", "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n", "   * provided futures fails or is canceled, this one is, too.\n", "   *\n", "   * @param futures futures to combine\n", "   * @return a future that provides a list of the results of the component futures\n", "   * @since 10.0\n", "   */\n", "  @Beta\n", "  @SafeVarargs\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<List<V>> allAsList(ListenableFuture<? extends V>... futures) {\n", "    return new ListFuture<V>(ImmutableList.copyOf(futures), true);\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n", "   *\n", "   * <p>The list of results is in the same order as the input list.\n", "   *\n", "   * <p>Canceling this future will attempt to cancel all the component futures, and if any of the\n", "   * provided futures fails or is canceled, this one is, too.\n", "   *\n", "   * @param futures futures to combine\n", "   * @return a future that provides a list of the results of the component futures\n", "   * @since 10.0\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<List<V>> allAsList(\n", "      Iterable<? extends ListenableFuture<? extends V>> futures) {\n", "    return new ListFuture<V>(ImmutableList.copyOf(futures), true);\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * successful input futures. The list of results is in the same order as the input list, and if\n", "   * any of the provided futures fails or is canceled, its corresponding position will contain\n", "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n", "   * null}).\n", "   *\n", "   * <p>Canceling this future will attempt to cancel all the component futures.\n", "   *\n", "   * @param futures futures to combine\n", "   * @return a future that provides a list of the results of the component futures\n", "   * @since 10.0\n", "   */\n", "  @Beta\n", "  @SafeVarargs\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<List<V>> successfulAsList(\n", "      ListenableFuture<? extends V>... futures) {\n", "    return new ListFuture<V>(ImmutableList.copyOf(futures), false);\n", "  }\n", "\n", "  /**\n", "   * Creates a new {@code ListenableFuture} whose value is a list containing the values of all its\n", "   * successful input futures. The list of results is in the same order as the input list, and if\n", "   * any of the provided futures fails or is canceled, its corresponding position will contain\n", "   * {@code null} (which is indistinguishable from the future having a successful value of {@code\n", "   * null}).\n", "   *\n", "   * <p>Canceling this future will attempt to cancel all the component futures.\n", "   *\n", "   * @param futures futures to combine\n", "   * @return a future that provides a list of the results of the component futures\n", "   * @since 10.0\n", "   */\n", "  @Beta\n", "  @CheckReturnValue\n", "  public static <V> ListenableFuture<List<V>> successfulAsList(\n", "      Iterable<? extends ListenableFuture<? extends V>> futures) {\n", "    return new ListFuture<V>(ImmutableList.copyOf(futures), false);\n", "  }\n", "\n", "  /**\n", "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n", "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n", "   * computation is already complete, immediately.\n", "   *\n", "   * <p>There is no guaranteed ordering of execution of callbacks, but any callback added through\n", "   * this method is guaranteed to be called once the computation is complete.\n", "   *\n", "   * Example: <pre> {@code\n", "   * ListenableFuture<QueryResult> future = ...;\n", "   * addCallback(future,\n", "   *     new FutureCallback<QueryResult> {\n", "   *       public void onSuccess(QueryResult result) {\n", "   *         storeInCache(result);\n", "   *       }\n", "   *       public void onFailure(Throwable t) {\n", "   *         reportError(t);\n", "   *       }\n", "   *     });}</pre>\n", "   *\n", "   * <p>This overload, which does not accept an executor, uses {@code directExecutor}, a dangerous\n", "   * choice in some cases. See the discussion in the {@link ListenableFuture#addListener\n", "   * ListenableFuture.addListener} documentation.\n", "   *\n", "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n", "   * ListenableFuture#addListener addListener}.\n", "   *\n", "   * @param future The future attach the callback to.\n", "   * @param callback The callback to invoke when {@code future} is completed.\n", "   * @since 10.0\n", "   */\n", "  public static <V> void addCallback(\n", "      ListenableFuture<V> future, FutureCallback<? super V> callback) {\n", "    addCallback(future, callback, directExecutor());\n", "  }\n", "\n", "  /**\n", "   * Registers separate success and failure callbacks to be run when the {@code Future}'s\n", "   * computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the\n", "   * computation is already complete, immediately.\n", "   *\n", "   * <p>The callback is run in {@code executor}. There is no guaranteed ordering of execution of\n", "   * callbacks, but any callback added through this method is guaranteed to be called once the\n", "   * computation is complete.\n", "   *\n", "   * Example: <pre> {@code\n", "   * ListenableFuture<QueryResult> future = ...;\n", "   * Executor e = ...\n", "   * addCallback(future,\n", "   *     new FutureCallback<QueryResult> {\n", "   *       public void onSuccess(QueryResult result) {\n", "   *         storeInCache(result);\n", "   *       }\n", "   *       public void onFailure(Throwable t) {\n", "   *         reportError(t);\n", "   *       }\n", "   *     }, e);}</pre>\n", "   *\n", "   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n", "   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n", "   * documentation.\n", "   *\n", "   * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link\n", "   * ListenableFuture#addListener addListener}.\n", "   *\n", "   * @param future The future attach the callback to.\n", "   * @param callback The callback to invoke when {@code future} is completed.\n", "   * @param executor The executor to run {@code callback} when the future completes.\n", "   * @since 10.0\n", "   */\n", "  public static <V> void addCallback(\n", "      final ListenableFuture<V> future,\n", "      final FutureCallback<? super V> callback,\n", "      Executor executor) {\n", "    Preconditions.checkNotNull(callback);\n", "    Runnable callbackListener =\n", "        new Runnable() {\n", "          @Override\n", "          public void run() {\n", "            final V value;\n", "            try {\n", "              // TODO(user): (Before Guava release), validate that this\n", "              // is the thing for IE.\n", "              value = getUninterruptibly(future);\n", "            } catch (ExecutionException e) {\n", "              callback.onFailure(e.getCause());\n", "              return;\n", "            } catch (RuntimeException e) {\n", "              callback.onFailure(e);\n", "              return;\n", "            } catch (Error e) {\n", "              callback.onFailure(e);\n", "              return;\n", "            }\n", "            callback.onSuccess(value);\n", "          }\n", "        };\n", "    future.addListener(callbackListener, executor);\n", "  }\n", "\n", "  /*\n", "   * Arguably we don't need a timed getUnchecked because any operation slow enough to require a\n", "   * timeout is heavyweight enough to throw a checked exception and therefore be inappropriate to\n", "   * use with getUnchecked. Further, it's not clear that converting the checked TimeoutException to\n", "   * a RuntimeException -- especially to an UncheckedExecutionException, since it wasn't thrown by\n", "   * the computation -- makes sense, and if we don't convert it, the user still has to write a\n", "   * try-catch block.\n", "   *\n", "   * If you think you would use this method, let us know. You might also also look into the\n", "   * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html\n", "   */\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756]}}, {"62": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/ImmediateFuture.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.TimeUnit;\n", "import java.util.logging.Level;\n", "import java.util.logging.Logger;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Implementations of {@code Futures.immediate*}.\n", " */\n", "@GwtCompatible(emulated = true)\n", "abstract class ImmediateFuture<V> implements ListenableFuture<V> {\n", "  /*\n", "   * TODO(lukes): Use AbstractFuture.TrustedFuture instead of special classes so that get() throws\n", "   * InterruptedException when appropriate, and, more importantly for failed/cancelled Futures, we\n", "   * can take advantage of the TrustedFuture optimizations.\n", "   */\n", "  private static final Logger log = Logger.getLogger(ImmediateFuture.class.getName());\n", "\n", "  @Override\n", "  public void addListener(Runnable listener, Executor executor) {\n", "    checkNotNull(listener, \"Runnable was null.\");\n", "    checkNotNull(executor, \"Executor was null.\");\n", "    try {\n", "      executor.execute(listener);\n", "    } catch (RuntimeException e) {\n", "      // ListenableFuture's contract is that it will not throw unchecked exceptions, so log the bad\n", "      // runnable and/or executor and swallow it.\n", "      log.log(\n", "          Level.SEVERE,\n", "          \"RuntimeException while executing runnable \" + listener + \" with executor \" + executor,\n", "          e);\n", "    }\n", "  }\n", "\n", "  @Override\n", "  public boolean cancel(boolean mayInterruptIfRunning) {\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public abstract V get() throws ExecutionException;\n", "\n", "  @Override\n", "  public V get(long timeout, TimeUnit unit) throws ExecutionException {\n", "    checkNotNull(unit);\n", "    return get();\n", "  }\n", "\n", "  @Override\n", "  public boolean isCancelled() {\n", "    return false;\n", "  }\n", "\n", "  @Override\n", "  public boolean isDone() {\n", "    return true;\n", "  }\n", "\n", "  static class ImmediateSuccessfulFuture<V> extends ImmediateFuture<V> {\n", "    static final ImmediateSuccessfulFuture<Object> NULL =\n", "        new ImmediateSuccessfulFuture<Object>(null);\n", "    @Nullable private final V value;\n", "\n", "    ImmediateSuccessfulFuture(@Nullable V value) {\n", "      this.value = value;\n", "    }\n", "\n", "    @Override\n", "    public V get() {\n", "      return value;\n", "    }\n", "  }\n", "\n", "  static class ImmediateFailedFuture<V> extends ImmediateFuture<V> {\n", "    private final Throwable thrown;\n", "\n", "    ImmediateFailedFuture(Throwable thrown) {\n", "      this.thrown = thrown;\n", "    }\n", "\n", "    @Override\n", "    public V get() throws ExecutionException {\n", "      throw new ExecutionException(thrown);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109]}}, {"63": "guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/MoreExecutors.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.RejectedExecutionException;\n", "\n", "/**\n", " * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link\n", " * ExecutorService}, and {@link ThreadFactory}.\n", " *\n", " * @author Eric Fellheimer\n", " * @author Kyle Littlefield\n", " * @author Justin Mahoney\n", " * @since 3.0\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class MoreExecutors {\n", "  private MoreExecutors() {}\n", "\n", "  // See sameThreadExecutor javadoc for behavioral notes.\n", "\n", "  /**\n", "   * Returns an {@link Executor} that runs each task in the thread that invokes\n", "   * {@link Executor#execute execute}, as in {@link CallerRunsPolicy}.\n", "   *\n", "   * <p>This instance is equivalent to: <pre>   {@code\n", "   *   final class DirectExecutor implements Executor {\n", "   *     public void execute(Runnable r) {\n", "   *       r.run();\n", "   *     }\n", "   *   }}</pre>\n", "   *\n", "   * <p>This should be preferred to {@link #newDirectExecutorService()} because the implementing the\n", "   * {@link ExecutorService} subinterface necessitates significant performance overhead.\n", "   *\n", "   * @since 18.0\n", "   */\n", "  public static Executor directExecutor() {\n", "    return DirectExecutor.INSTANCE;\n", "  }\n", "\n", "  /** See {@link #directExecutor} for behavioral notes. */\n", "  private enum DirectExecutor implements Executor {\n", "    INSTANCE;\n", "    @Override public void execute(Runnable command) {\n", "      command.run();\n", "    }\n", "\n", "    @Override public String toString() {\n", "      return \"MoreExecutors.directExecutor()\";\n", "    }\n", "  }\n", "\n", "  /*\n", "   * This following method is a modified version of one found in\n", "   * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n", "   * which contained the following notice:\n", "   *\n", "   * Written by Doug Lea with assistance from members of JCP JSR-166\n", "   * Expert Group and released to the public domain, as explained at\n", "   * http://creativecommons.org/publicdomain/zero/1.0/\n", "   * Other contributors include Andrew Wright, Jeffrey Hayes,\n", "   * Pat Fisher, Mike Judd.\n", "   */\n", "\n", "  // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n", "  // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n", "  // calculate names?\n", "\n", "  /**\n", "   * Returns an Executor that will propagate {@link RejectedExecutionException} from the delegate\n", "   * executor to the given {@code future}.\n", "   *\n", "   * <p>Note, the returned executor can only be used once.\n", "   */\n", "  static Executor rejectionPropagatingExecutor(\n", "      final Executor delegate, final AbstractFuture<?> future) {\n", "    checkNotNull(delegate);\n", "    checkNotNull(future);\n", "    if (delegate == directExecutor()) {\n", "      // directExecutor() cannot throw RejectedExecutionException\n", "      return delegate;\n", "    }\n", "    return new Executor() {\n", "      volatile boolean thrownFromDelegate = true;\n", "\n", "      @Override\n", "      public void execute(final Runnable command) {\n", "        try {\n", "          delegate.execute(\n", "              new Runnable() {\n", "                @Override\n", "                public void run() {\n", "                  thrownFromDelegate = false;\n", "                  command.run();\n", "                }\n", "              });\n", "        } catch (RejectedExecutionException e) {\n", "          if (thrownFromDelegate) {\n", "            // wrap exception?\n", "            future.setException(e);\n", "          }\n", "          // otherwise it must have been thrown from a transitive call and the delegate runnable\n", "          // should have handled it.\n", "        }\n", "      }\n", "    };\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128]}}, {"64": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/AbstractIteratorTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Iterator;\n", "import java.util.NoSuchElementException;\n", "\n", "/**\n", " * Unit test for {@code AbstractIterator}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "// TODO(cpovirk): why is this slow (>1m/test) under GWT when fully optimized?\n", "public class AbstractIteratorTest extends TestCase {\n", "\n", "  public void testDefaultBehaviorOfNextAndHasNext() {\n", "\n", "    // This sample AbstractIterator returns 0 on the first call, 1 on the\n", "    // second, then signals that it's reached the end of the data\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      private int rep;\n", "      @Override public Integer computeNext() {\n", "        switch (rep++) {\n", "          case 0:\n", "            return 0;\n", "          case 1:\n", "            return 1;\n", "          case 2:\n", "            return endOfData();\n", "          default:\n", "            fail(\"Should not have been invoked again\");\n", "            return null;\n", "        }\n", "      }\n", "    };\n", "\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(0, (int) iter.next());\n", "\n", "    // verify idempotence of hasNext()\n", "    assertTrue(iter.hasNext());\n", "    assertTrue(iter.hasNext());\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(1, (int) iter.next());\n", "\n", "    assertFalse(iter.hasNext());\n", "\n", "    // Make sure computeNext() doesn't get invoked again\n", "    assertFalse(iter.hasNext());\n", "\n", "    try {\n", "      iter.next();\n", "      fail(\"no exception thrown\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testSneakyThrow() throws Exception {\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      boolean haveBeenCalled;\n", "      @Override public Integer computeNext() {\n", "        if (haveBeenCalled) {\n", "          fail(\"Should not have been called again\");\n", "        } else {\n", "          haveBeenCalled = true;\n", "          sneakyThrow(new SomeCheckedException());\n", "        }\n", "        return null; // never reached\n", "      }\n", "    };\n", "\n", "    // The first time, the sneakily-thrown exception comes out\n", "    try {\n", "      iter.hasNext();\n", "      fail(\"No exception thrown\");\n", "    } catch (Exception e) {\n", "      if (!(e instanceof SomeCheckedException)) {\n", "        throw e;\n", "      }\n", "    }\n", "\n", "    // But the second time, AbstractIterator itself throws an ISE\n", "    try {\n", "      iter.hasNext();\n", "      fail(\"No exception thrown\");\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  public void testException() {\n", "    final SomeUncheckedException exception = new SomeUncheckedException();\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      @Override public Integer computeNext() {\n", "        throw exception;\n", "      }\n", "    };\n", "\n", "    // It should pass through untouched\n", "    try {\n", "      iter.hasNext();\n", "      fail(\"No exception thrown\");\n", "    } catch (SomeUncheckedException e) {\n", "      assertSame(exception, e);\n", "    }\n", "  }\n", "\n", "  public void testExceptionAfterEndOfData() {\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      @Override public Integer computeNext() {\n", "        endOfData();\n", "        throw new SomeUncheckedException();\n", "      }\n", "    };\n", "    try {\n", "      iter.hasNext();\n", "      fail(\"No exception thrown\");\n", "    } catch (SomeUncheckedException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCantRemove() {\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      boolean haveBeenCalled;\n", "      @Override public Integer computeNext() {\n", "        if (haveBeenCalled) {\n", "          endOfData();\n", "        }\n", "        haveBeenCalled = true;\n", "        return 0;\n", "      }\n", "    };\n", "\n", "    assertEquals(0, (int) iter.next());\n", "\n", "    try {\n", "      iter.remove();\n", "      fail(\"No exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testReentrantHasNext() {\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      @Override protected Integer computeNext() {\n", "        hasNext();\n", "        return null;\n", "      }\n", "    };\n", "    try {\n", "      iter.hasNext();\n", "      fail();\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  // Technically we should test other reentrant scenarios (4 combinations of\n", "  // hasNext/next), but we'll cop out for now, knowing that \n", "  // next() both start by invoking hasNext() anyway.\n", "\n", "  /**\n", "   * Throws a undeclared checked exception.\n", "   */\n", "  private static void sneakyThrow(Throwable t) {\n", "    class SneakyThrower<T extends Throwable> {\n", "      @SuppressWarnings(\"unchecked\") // intentionally unsafe for test\n", "      void throwIt(Throwable t) throws T {\n", "        throw (T) t;\n", "      }\n", "    }\n", "    new SneakyThrower<Error>().throwIt(t);\n", "  }\n", "\n", "  private static class SomeCheckedException extends Exception {\n", "  }\n", "\n", "  private static class SomeUncheckedException extends RuntimeException {\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198]}}, {"65": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/CaseFormatTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.CaseFormat.LOWER_CAMEL;\n", "import static com.google.common.base.CaseFormat.LOWER_HYPHEN;\n", "import static com.google.common.base.CaseFormat.LOWER_UNDERSCORE;\n", "import static com.google.common.base.CaseFormat.UPPER_CAMEL;\n", "import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.testing.SerializableTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Unit test for {@link CaseFormat}.\n", " *\n", " * @author Mike Bostock\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CaseFormatTest extends TestCase {\n", "\n", "  public void testIdentity() {\n", "    for (CaseFormat from : CaseFormat.values()) {\n", "      assertSame(from + \" to \" + from, \"foo\", from.to(from, \"foo\"));\n", "      for (CaseFormat to : CaseFormat.values()) {\n", "        assertEquals(from + \" to \" + to, \"\", from.to(to, \"\"));\n", "        assertEquals(from + \" to \" + to, \" \", from.to(to, \" \"));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testLowerHyphenToLowerHyphen() {\n", "    assertEquals(\"foo\", LOWER_HYPHEN.to(LOWER_HYPHEN, \"foo\"));\n", "    assertEquals(\"foo-bar\", LOWER_HYPHEN.to(LOWER_HYPHEN, \"foo-bar\"));\n", "  }\n", "\n", "  public void testLowerHyphenToLowerUnderscore() {\n", "    assertEquals(\"foo\", LOWER_HYPHEN.to(LOWER_UNDERSCORE, \"foo\"));\n", "    assertEquals(\"foo_bar\", LOWER_HYPHEN.to(LOWER_UNDERSCORE, \"foo-bar\"));\n", "  }\n", "\n", "  public void testLowerHyphenToLowerCamel() {\n", "    assertEquals(\"foo\", LOWER_HYPHEN.to(LOWER_CAMEL, \"foo\"));\n", "    assertEquals(\"fooBar\", LOWER_HYPHEN.to(LOWER_CAMEL, \"foo-bar\"));\n", "  }\n", "\n", "  public void testLowerHyphenToUpperCamel() {\n", "    assertEquals(\"Foo\", LOWER_HYPHEN.to(UPPER_CAMEL, \"foo\"));\n", "    assertEquals(\"FooBar\", LOWER_HYPHEN.to(UPPER_CAMEL, \"foo-bar\"));\n", "  }\n", "\n", "  public void testLowerHyphenToUpperUnderscore() {\n", "    assertEquals(\"FOO\", LOWER_HYPHEN.to(UPPER_UNDERSCORE, \"foo\"));\n", "    assertEquals(\"FOO_BAR\", LOWER_HYPHEN.to(UPPER_UNDERSCORE, \"foo-bar\"));\n", "  }\n", "\n", "  public void testLowerUnderscoreToLowerHyphen() {\n", "    assertEquals(\"foo\", LOWER_UNDERSCORE.to(LOWER_HYPHEN, \"foo\"));\n", "    assertEquals(\"foo-bar\", LOWER_UNDERSCORE.to(LOWER_HYPHEN, \"foo_bar\"));\n", "  }\n", "\n", "  public void testLowerUnderscoreToLowerUnderscore() {\n", "    assertEquals(\"foo\", LOWER_UNDERSCORE.to(LOWER_UNDERSCORE, \"foo\"));\n", "    assertEquals(\"foo_bar\", LOWER_UNDERSCORE.to(LOWER_UNDERSCORE, \"foo_bar\"));\n", "  }\n", "\n", "  public void testLowerUnderscoreToLowerCamel() {\n", "    assertEquals(\"foo\", LOWER_UNDERSCORE.to(LOWER_CAMEL, \"foo\"));\n", "    assertEquals(\"fooBar\", LOWER_UNDERSCORE.to(LOWER_CAMEL, \"foo_bar\"));\n", "  }\n", "\n", "  public void testLowerUnderscoreToUpperCamel() {\n", "    assertEquals(\"Foo\", LOWER_UNDERSCORE.to(UPPER_CAMEL, \"foo\"));\n", "    assertEquals(\"FooBar\", LOWER_UNDERSCORE.to(UPPER_CAMEL, \"foo_bar\"));\n", "  }\n", "\n", "  public void testLowerUnderscoreToUpperUnderscore() {\n", "    assertEquals(\"FOO\", LOWER_UNDERSCORE.to(UPPER_UNDERSCORE, \"foo\"));\n", "    assertEquals(\"FOO_BAR\", LOWER_UNDERSCORE.to(UPPER_UNDERSCORE, \"foo_bar\"));\n", "  }\n", "\n", "  public void testLowerCamelToLowerHyphen() {\n", "    assertEquals(\"foo\", LOWER_CAMEL.to(LOWER_HYPHEN, \"foo\"));\n", "    assertEquals(\"foo-bar\", LOWER_CAMEL.to(LOWER_HYPHEN, \"fooBar\"));\n", "    assertEquals(\"h-t-t-p\", LOWER_CAMEL.to(LOWER_HYPHEN, \"HTTP\"));\n", "  }\n", "\n", "  public void testLowerCamelToLowerUnderscore() {\n", "    assertEquals(\"foo\", LOWER_CAMEL.to(LOWER_UNDERSCORE, \"foo\"));\n", "    assertEquals(\"foo_bar\", LOWER_CAMEL.to(LOWER_UNDERSCORE, \"fooBar\"));\n", "    assertEquals(\"h_t_t_p\", LOWER_CAMEL.to(LOWER_UNDERSCORE, \"hTTP\"));\n", "  }\n", "\n", "  public void testLowerCamelToLowerCamel() {\n", "    assertEquals(\"foo\", LOWER_CAMEL.to(LOWER_CAMEL, \"foo\"));\n", "    assertEquals(\"fooBar\", LOWER_CAMEL.to(LOWER_CAMEL, \"fooBar\"));\n", "  }\n", "\n", "  public void testLowerCamelToUpperCamel() {\n", "    assertEquals(\"Foo\", LOWER_CAMEL.to(UPPER_CAMEL, \"foo\"));\n", "    assertEquals(\"FooBar\", LOWER_CAMEL.to(UPPER_CAMEL, \"fooBar\"));\n", "    assertEquals(\"HTTP\", LOWER_CAMEL.to(UPPER_CAMEL, \"hTTP\"));\n", "  }\n", "\n", "  public void testLowerCamelToUpperUnderscore() {\n", "    assertEquals(\"FOO\", LOWER_CAMEL.to(UPPER_UNDERSCORE, \"foo\"));\n", "    assertEquals(\"FOO_BAR\", LOWER_CAMEL.to(UPPER_UNDERSCORE, \"fooBar\"));\n", "  }\n", "\n", "  public void testUpperCamelToLowerHyphen() {\n", "    assertEquals(\"foo\", UPPER_CAMEL.to(LOWER_HYPHEN, \"Foo\"));\n", "    assertEquals(\"foo-bar\", UPPER_CAMEL.to(LOWER_HYPHEN, \"FooBar\"));\n", "  }\n", "\n", "  public void testUpperCamelToLowerUnderscore() {\n", "    assertEquals(\"foo\", UPPER_CAMEL.to(LOWER_UNDERSCORE, \"Foo\"));\n", "    assertEquals(\"foo_bar\", UPPER_CAMEL.to(LOWER_UNDERSCORE, \"FooBar\"));\n", "  }\n", "\n", "  public void testUpperCamelToLowerCamel() {\n", "    assertEquals(\"foo\", UPPER_CAMEL.to(LOWER_CAMEL, \"Foo\"));\n", "    assertEquals(\"fooBar\", UPPER_CAMEL.to(LOWER_CAMEL, \"FooBar\"));\n", "    assertEquals(\"hTTP\", UPPER_CAMEL.to(LOWER_CAMEL, \"HTTP\"));\n", "  }\n", "\n", "  public void testUpperCamelToUpperCamel() {\n", "    assertEquals(\"Foo\", UPPER_CAMEL.to(UPPER_CAMEL, \"Foo\"));\n", "    assertEquals(\"FooBar\", UPPER_CAMEL.to(UPPER_CAMEL, \"FooBar\"));\n", "  }\n", "\n", "  public void testUpperCamelToUpperUnderscore() {\n", "    assertEquals(\"FOO\", UPPER_CAMEL.to(UPPER_UNDERSCORE, \"Foo\"));\n", "    assertEquals(\"FOO_BAR\", UPPER_CAMEL.to(UPPER_UNDERSCORE, \"FooBar\"));\n", "    assertEquals(\"H_T_T_P\", UPPER_CAMEL.to(UPPER_UNDERSCORE, \"HTTP\"));\n", "    assertEquals(\"H__T__T__P\", UPPER_CAMEL.to(UPPER_UNDERSCORE, \"H_T_T_P\"));\n", "  }\n", "\n", "  public void testUpperUnderscoreToLowerHyphen() {\n", "    assertEquals(\"foo\", UPPER_UNDERSCORE.to(LOWER_HYPHEN, \"FOO\"));\n", "    assertEquals(\"foo-bar\", UPPER_UNDERSCORE.to(LOWER_HYPHEN, \"FOO_BAR\"));\n", "  }\n", "\n", "  public void testUpperUnderscoreToLowerUnderscore() {\n", "    assertEquals(\"foo\", UPPER_UNDERSCORE.to(LOWER_UNDERSCORE, \"FOO\"));\n", "    assertEquals(\"foo_bar\", UPPER_UNDERSCORE.to(LOWER_UNDERSCORE, \"FOO_BAR\"));\n", "  }\n", "\n", "  public void testUpperUnderscoreToLowerCamel() {\n", "    assertEquals(\"foo\", UPPER_UNDERSCORE.to(LOWER_CAMEL, \"FOO\"));\n", "    assertEquals(\"fooBar\", UPPER_UNDERSCORE.to(LOWER_CAMEL, \"FOO_BAR\"));\n", "  }\n", "\n", "  public void testUpperUnderscoreToUpperCamel() {\n", "    assertEquals(\"Foo\", UPPER_UNDERSCORE.to(UPPER_CAMEL, \"FOO\"));\n", "    assertEquals(\"FooBar\", UPPER_UNDERSCORE.to(UPPER_CAMEL, \"FOO_BAR\"));\n", "    assertEquals(\"HTTP\", UPPER_UNDERSCORE.to(UPPER_CAMEL, \"H_T_T_P\"));\n", "  }\n", "\n", "  public void testUpperUnderscoreToUpperUnderscore() {\n", "    assertEquals(\"FOO\", UPPER_UNDERSCORE.to(UPPER_UNDERSCORE, \"FOO\"));\n", "    assertEquals(\"FOO_BAR\", UPPER_UNDERSCORE.to(UPPER_UNDERSCORE, \"FOO_BAR\"));\n", "  }\n", "\n", "  public void testConverterToForward() {\n", "    assertEquals(\"FooBar\", UPPER_UNDERSCORE.converterTo(UPPER_CAMEL).convert(\"FOO_BAR\"));\n", "    assertEquals(\"fooBar\", UPPER_UNDERSCORE.converterTo(LOWER_CAMEL).convert(\"FOO_BAR\"));\n", "    assertEquals(\"FOO_BAR\", UPPER_CAMEL.converterTo(UPPER_UNDERSCORE).convert(\"FooBar\"));\n", "    assertEquals(\"FOO_BAR\", LOWER_CAMEL.converterTo(UPPER_UNDERSCORE).convert(\"fooBar\"));\n", "  }\n", "\n", "  public void testConverterToBackward() {\n", "    assertEquals(\"FOO_BAR\", UPPER_UNDERSCORE.converterTo(UPPER_CAMEL).reverse().convert(\"FooBar\"));\n", "    assertEquals(\"FOO_BAR\", UPPER_UNDERSCORE.converterTo(LOWER_CAMEL).reverse().convert(\"fooBar\"));\n", "    assertEquals(\"FooBar\", UPPER_CAMEL.converterTo(UPPER_UNDERSCORE).reverse().convert(\"FOO_BAR\"));\n", "    assertEquals(\"fooBar\", LOWER_CAMEL.converterTo(UPPER_UNDERSCORE).reverse().convert(\"FOO_BAR\"));\n", "  }\n", "\n", "  public void testConverter_nullConversions() {\n", "    for (CaseFormat outer : CaseFormat.values()) {\n", "      for (CaseFormat inner : CaseFormat.values()) {\n", "        assertNull(outer.converterTo(inner).convert(null));\n", "        assertNull(outer.converterTo(inner).reverse().convert(null));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testConverter_toString() {\n", "    assertEquals(\n", "        \"LOWER_HYPHEN.converterTo(UPPER_CAMEL)\",\n", "        LOWER_HYPHEN.converterTo(UPPER_CAMEL).toString());\n", "  }\n", "\n", "  public void testConverter_serialization() {\n", "    for (CaseFormat outer : CaseFormat.values()) {\n", "      for (CaseFormat inner : CaseFormat.values()) {\n", "        SerializableTester.reserializeAndAssert(outer.converterTo(inner));\n", "      }\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217]}}, {"66": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/CharMatcherTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.CharMatcher.anyOf;\n", "import static com.google.common.base.CharMatcher.breakingWhitespace;\n", "import static com.google.common.base.CharMatcher.forPredicate;\n", "import static com.google.common.base.CharMatcher.inRange;\n", "import static com.google.common.base.CharMatcher.is;\n", "import static com.google.common.base.CharMatcher.isNot;\n", "import static com.google.common.base.CharMatcher.noneOf;\n", "import static com.google.common.base.CharMatcher.whitespace;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Sets;\n", "\n", "import junit.framework.AssertionFailedError;\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.HashSet;\n", "import java.util.Random;\n", "import java.util.Set;\n", "\n", "/**\n", " * Unit test for {@link CharMatcher}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CharMatcherTest extends TestCase {\n", "\n", "  private static final CharMatcher WHATEVER = new CharMatcher() {\n", "    @Override public boolean matches(char c) {\n", "      throw new AssertionFailedError(\n", "          \"You weren't supposed to actually invoke me!\");\n", "    }\n", "  };\n", "\n", "  public void testAnyAndNone_logicalOps() throws Exception {\n", "    // These are testing behavior that's never promised by the API, but since\n", "    // we're lucky enough that these do pass, it saves us from having to write\n", "    // more excruciating tests! Hooray!\n", "\n", "    assertSame(CharMatcher.any(), CharMatcher.none().negate());\n", "    assertSame(CharMatcher.none(), CharMatcher.any().negate());\n", "\n", "    assertSame(WHATEVER, CharMatcher.any().and(WHATEVER));\n", "    assertSame(CharMatcher.any(), CharMatcher.any().or(WHATEVER));\n", "\n", "    assertSame(CharMatcher.none(), CharMatcher.none().and(WHATEVER));\n", "    assertSame(WHATEVER, CharMatcher.none().or(WHATEVER));\n", "  }\n", "\n", "  // The rest of the behavior of ANY and DEFAULT will be covered in the tests for\n", "  // the text processing methods below.\n", "\n", "  public void testWhitespaceBreakingWhitespaceSubset() throws Exception {\n", "    for (int c = 0; c <= Character.MAX_VALUE; c++) {\n", "      if (breakingWhitespace().matches((char) c)) {\n", "        assertTrue(Integer.toHexString(c), whitespace().matches((char) c));\n", "      }\n", "    }\n", "  }\n", "\n", "  // The next tests require ICU4J and have, at least for now, been sliced out\n", "  // of the open-source view of the tests.\n", "\n", "  // Omitting tests for the rest of the JAVA_* constants as these are defined\n", "  // as extremely straightforward pass-throughs to the JDK methods.\n", "\n", "  // We're testing the is(), isNot(), anyOf(), noneOf() and inRange() methods\n", "  // below by testing their text-processing methods.\n", "\n", "  // The organization of this test class is unusual, as it's not done by\n", "  // method, but by overall \"scenario\". Also, the variety of actual tests we\n", "  // do borders on absurd overkill. Better safe than sorry, though?\n", "\n", "  public void testEmpty() throws Exception {\n", "    doTestEmpty(CharMatcher.any());\n", "    doTestEmpty(CharMatcher.none());\n", "    doTestEmpty(is('a'));\n", "    doTestEmpty(isNot('a'));\n", "    doTestEmpty(anyOf(\"\"));\n", "    doTestEmpty(anyOf(\"x\"));\n", "    doTestEmpty(anyOf(\"xy\"));\n", "    doTestEmpty(anyOf(\"CharMatcher\"));\n", "    doTestEmpty(noneOf(\"CharMatcher\"));\n", "    doTestEmpty(inRange('n', 'q'));\n", "    doTestEmpty(forPredicate(Predicates.equalTo('c')));\n", "  }\n", "\n", "  private void doTestEmpty(CharMatcher matcher) throws Exception {\n", "    reallyTestEmpty(matcher);\n", "    reallyTestEmpty(matcher.negate());\n", "    reallyTestEmpty(matcher.precomputed());\n", "  }\n", "\n", "  private void reallyTestEmpty(CharMatcher matcher) throws Exception {\n", "    assertEquals(-1, matcher.indexIn(\"\"));\n", "    assertEquals(-1, matcher.indexIn(\"\", 0));\n", "    try {\n", "      matcher.indexIn(\"\", 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "    try {\n", "      matcher.indexIn(\"\", -1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "    assertEquals(-1, matcher.lastIndexIn(\"\"));\n", "    assertFalse(matcher.matchesAnyOf(\"\"));\n", "    assertTrue(matcher.matchesAllOf(\"\"));\n", "    assertTrue(matcher.matchesNoneOf(\"\"));\n", "    assertEquals(\"\", matcher.removeFrom(\"\"));\n", "    assertEquals(\"\", matcher.replaceFrom(\"\", 'z'));\n", "    assertEquals(\"\", matcher.replaceFrom(\"\", \"ZZ\"));\n", "    assertEquals(\"\", matcher.trimFrom(\"\"));\n", "    assertEquals(0, matcher.countIn(\"\"));\n", "  }\n", "\n", "  public void testNoMatches() {\n", "    doTestNoMatches(CharMatcher.none(), \"blah\");\n", "    doTestNoMatches(is('a'), \"bcde\");\n", "    doTestNoMatches(isNot('a'), \"aaaa\");\n", "    doTestNoMatches(anyOf(\"\"), \"abcd\");\n", "    doTestNoMatches(anyOf(\"x\"), \"abcd\");\n", "    doTestNoMatches(anyOf(\"xy\"), \"abcd\");\n", "    doTestNoMatches(anyOf(\"CharMatcher\"), \"zxqy\");\n", "    doTestNoMatches(noneOf(\"CharMatcher\"), \"ChMa\");\n", "    doTestNoMatches(inRange('p', 'x'), \"mom\");\n", "    doTestNoMatches(forPredicate(Predicates.equalTo('c')), \"abe\");\n", "    doTestNoMatches(inRange('A', 'Z').and(inRange('F', 'K').negate()), \"F1a\");\n", "    doTestNoMatches(CharMatcher.digit(), \"\\tAz()\");\n", "    doTestNoMatches(CharMatcher.javaDigit(), \"\\tAz()\");\n", "    doTestNoMatches(CharMatcher.digit().and(CharMatcher.ascii()), \"\\tAz()\");\n", "    doTestNoMatches(CharMatcher.singleWidth(), \"\\u05bf\\u3000\");\n", "  }\n", "\n", "  private void doTestNoMatches(CharMatcher matcher, String s) {\n", "    reallyTestNoMatches(matcher, s);\n", "    reallyTestAllMatches(matcher.negate(), s);\n", "    reallyTestNoMatches(matcher.precomputed(), s);\n", "    reallyTestAllMatches(matcher.negate().precomputed(), s);\n", "    reallyTestAllMatches(matcher.precomputed().negate(), s);\n", "    reallyTestNoMatches(forPredicate(matcher), s);\n", "\n", "    reallyTestNoMatches(matcher, new StringBuilder(s));\n", "  }\n", "\n", "  public void testAllMatches() {\n", "    doTestAllMatches(CharMatcher.any(), \"blah\");\n", "    doTestAllMatches(isNot('a'), \"bcde\");\n", "    doTestAllMatches(is('a'), \"aaaa\");\n", "    doTestAllMatches(noneOf(\"CharMatcher\"), \"zxqy\");\n", "    doTestAllMatches(anyOf(\"x\"), \"xxxx\");\n", "    doTestAllMatches(anyOf(\"xy\"), \"xyyx\");\n", "    doTestAllMatches(anyOf(\"CharMatcher\"), \"ChMa\");\n", "    doTestAllMatches(inRange('m', 'p'), \"mom\");\n", "    doTestAllMatches(forPredicate(Predicates.equalTo('c')), \"ccc\");\n", "    doTestAllMatches(CharMatcher.digit(), \"0123456789\\u0ED0\\u1B59\");\n", "    doTestAllMatches(CharMatcher.javaDigit(), \"0123456789\");\n", "    doTestAllMatches(CharMatcher.digit().and(CharMatcher.ascii()), \"0123456789\");\n", "    doTestAllMatches(CharMatcher.singleWidth(), \"\\t0123ABCdef~\\u00A0\\u2111\");\n", "  }\n", "\n", "  private void doTestAllMatches(CharMatcher matcher, String s) {\n", "    reallyTestAllMatches(matcher, s);\n", "    reallyTestNoMatches(matcher.negate(), s);\n", "    reallyTestAllMatches(matcher.precomputed(), s);\n", "    reallyTestNoMatches(matcher.negate().precomputed(), s);\n", "    reallyTestNoMatches(matcher.precomputed().negate(), s);\n", "    reallyTestAllMatches(forPredicate(matcher), s);\n", "\n", "    reallyTestAllMatches(matcher, new StringBuilder(s));\n", "  }\n", "\n", "  private void reallyTestNoMatches(CharMatcher matcher, CharSequence s) {\n", "    assertFalse(matcher.matches(s.charAt(0)));\n", "    assertEquals(-1, matcher.indexIn(s));\n", "    assertEquals(-1, matcher.indexIn(s, 0));\n", "    assertEquals(-1, matcher.indexIn(s, 1));\n", "    assertEquals(-1, matcher.indexIn(s, s.length()));\n", "    try {\n", "      matcher.indexIn(s, s.length() + 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "    try {\n", "      matcher.indexIn(s, -1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "    assertEquals(-1, matcher.lastIndexIn(s));\n", "    assertFalse(matcher.matchesAnyOf(s));\n", "    assertFalse(matcher.matchesAllOf(s));\n", "    assertTrue(matcher.matchesNoneOf(s));\n", "\n", "    assertEquals(s.toString(), matcher.removeFrom(s));\n", "    assertEquals(s.toString(), matcher.replaceFrom(s, 'z'));\n", "    assertEquals(s.toString(), matcher.replaceFrom(s, \"ZZ\"));\n", "    assertEquals(s.toString(), matcher.trimFrom(s));\n", "    assertEquals(0, matcher.countIn(s));\n", "  }\n", "\n", "  private void reallyTestAllMatches(CharMatcher matcher, CharSequence s) {\n", "    assertTrue(matcher.matches(s.charAt(0)));\n", "    assertEquals(0, matcher.indexIn(s));\n", "    assertEquals(0, matcher.indexIn(s, 0));\n", "    assertEquals(1, matcher.indexIn(s, 1));\n", "    assertEquals(-1, matcher.indexIn(s, s.length()));\n", "    assertEquals(s.length() - 1, matcher.lastIndexIn(s));\n", "    assertTrue(matcher.matchesAnyOf(s));\n", "    assertTrue(matcher.matchesAllOf(s));\n", "    assertFalse(matcher.matchesNoneOf(s));\n", "    assertEquals(\"\", matcher.removeFrom(s));\n", "    assertEquals(Strings.repeat(\"z\", s.length()),\n", "        matcher.replaceFrom(s, 'z'));\n", "    assertEquals(Strings.repeat(\"ZZ\", s.length()),\n", "        matcher.replaceFrom(s, \"ZZ\"));\n", "    assertEquals(\"\", matcher.trimFrom(s));\n", "    assertEquals(s.length(), matcher.countIn(s));\n", "  }\n", "\n", "  public void testGeneral() {\n", "    doTestGeneral(is('a'), 'a', 'b');\n", "    doTestGeneral(isNot('a'), 'b', 'a');\n", "    doTestGeneral(anyOf(\"x\"), 'x', 'z');\n", "    doTestGeneral(anyOf(\"xy\"), 'y', 'z');\n", "    doTestGeneral(anyOf(\"CharMatcher\"), 'C', 'z');\n", "    doTestGeneral(noneOf(\"CharMatcher\"), 'z', 'C');\n", "    doTestGeneral(inRange('p', 'x'), 'q', 'z');\n", "  }\n", "\n", "  private void doTestGeneral(CharMatcher matcher, char match, char noMatch) {\n", "    doTestOneCharMatch(matcher, \"\" + match);\n", "    doTestOneCharNoMatch(matcher, \"\" + noMatch);\n", "    doTestMatchThenNoMatch(matcher, \"\" + match + noMatch);\n", "    doTestNoMatchThenMatch(matcher, \"\" + noMatch + match);\n", "  }\n", "\n", "  private void doTestOneCharMatch(CharMatcher matcher, String s) {\n", "    reallyTestOneCharMatch(matcher, s);\n", "    reallyTestOneCharNoMatch(matcher.negate(), s);\n", "    reallyTestOneCharMatch(matcher.precomputed(), s);\n", "    reallyTestOneCharNoMatch(matcher.negate().precomputed(), s);\n", "    reallyTestOneCharNoMatch(matcher.precomputed().negate(), s);\n", "  }\n", "\n", "  private void doTestOneCharNoMatch(CharMatcher matcher, String s) {\n", "    reallyTestOneCharNoMatch(matcher, s);\n", "    reallyTestOneCharMatch(matcher.negate(), s);\n", "    reallyTestOneCharNoMatch(matcher.precomputed(), s);\n", "    reallyTestOneCharMatch(matcher.negate().precomputed(), s);\n", "    reallyTestOneCharMatch(matcher.precomputed().negate(), s);\n", "  }\n", "\n", "  private void doTestMatchThenNoMatch(CharMatcher matcher, String s) {\n", "    reallyTestMatchThenNoMatch(matcher, s);\n", "    reallyTestNoMatchThenMatch(matcher.negate(), s);\n", "    reallyTestMatchThenNoMatch(matcher.precomputed(), s);\n", "    reallyTestNoMatchThenMatch(matcher.negate().precomputed(), s);\n", "    reallyTestNoMatchThenMatch(matcher.precomputed().negate(), s);\n", "  }\n", "\n", "  private void doTestNoMatchThenMatch(CharMatcher matcher, String s) {\n", "    reallyTestNoMatchThenMatch(matcher, s);\n", "    reallyTestMatchThenNoMatch(matcher.negate(), s);\n", "    reallyTestNoMatchThenMatch(matcher.precomputed(), s);\n", "    reallyTestMatchThenNoMatch(matcher.negate().precomputed(), s);\n", "    reallyTestMatchThenNoMatch(matcher.precomputed().negate(), s);\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\") // intentionally testing apply() method\n", "  private void reallyTestOneCharMatch(CharMatcher matcher, String s) {\n", "    assertTrue(matcher.matches(s.charAt(0)));\n", "    assertTrue(matcher.apply(s.charAt(0)));\n", "    assertEquals(0, matcher.indexIn(s));\n", "    assertEquals(0, matcher.indexIn(s, 0));\n", "    assertEquals(-1, matcher.indexIn(s, 1));\n", "    assertEquals(0, matcher.lastIndexIn(s));\n", "    assertTrue(matcher.matchesAnyOf(s));\n", "    assertTrue(matcher.matchesAllOf(s));\n", "    assertFalse(matcher.matchesNoneOf(s));\n", "    assertEquals(\"\", matcher.removeFrom(s));\n", "    assertEquals(\"z\", matcher.replaceFrom(s, 'z'));\n", "    assertEquals(\"ZZ\", matcher.replaceFrom(s, \"ZZ\"));\n", "    assertEquals(\"\", matcher.trimFrom(s));\n", "    assertEquals(1, matcher.countIn(s));\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\") // intentionally testing apply() method\n", "  private void reallyTestOneCharNoMatch(CharMatcher matcher, String s) {\n", "    assertFalse(matcher.matches(s.charAt(0)));\n", "    assertFalse(matcher.apply(s.charAt(0)));\n", "    assertEquals(-1, matcher.indexIn(s));\n", "    assertEquals(-1, matcher.indexIn(s, 0));\n", "    assertEquals(-1, matcher.indexIn(s, 1));\n", "    assertEquals(-1, matcher.lastIndexIn(s));\n", "    assertFalse(matcher.matchesAnyOf(s));\n", "    assertFalse(matcher.matchesAllOf(s));\n", "    assertTrue(matcher.matchesNoneOf(s));\n", "\n", "    assertSame(s, matcher.removeFrom(s));\n", "    assertSame(s, matcher.replaceFrom(s, 'z'));\n", "    assertSame(s, matcher.replaceFrom(s, \"ZZ\"));\n", "    assertSame(s, matcher.trimFrom(s));\n", "    assertSame(0, matcher.countIn(s));\n", "  }\n", "\n", "  private void reallyTestMatchThenNoMatch(CharMatcher matcher, String s) {\n", "    assertEquals(0, matcher.indexIn(s));\n", "    assertEquals(0, matcher.indexIn(s, 0));\n", "    assertEquals(-1, matcher.indexIn(s, 1));\n", "    assertEquals(-1, matcher.indexIn(s, 2));\n", "    assertEquals(0, matcher.lastIndexIn(s));\n", "    assertTrue(matcher.matchesAnyOf(s));\n", "    assertFalse(matcher.matchesAllOf(s));\n", "    assertFalse(matcher.matchesNoneOf(s));\n", "    assertEquals(s.substring(1), matcher.removeFrom(s));\n", "    assertEquals(\"z\" + s.substring(1), matcher.replaceFrom(s, 'z'));\n", "    assertEquals(\"ZZ\" + s.substring(1), matcher.replaceFrom(s, \"ZZ\"));\n", "    assertEquals(s.substring(1), matcher.trimFrom(s));\n", "    assertEquals(1, matcher.countIn(s));\n", "  }\n", "\n", "  private void reallyTestNoMatchThenMatch(CharMatcher matcher, String s) {\n", "    assertEquals(1, matcher.indexIn(s));\n", "    assertEquals(1, matcher.indexIn(s, 0));\n", "    assertEquals(1, matcher.indexIn(s, 1));\n", "    assertEquals(-1, matcher.indexIn(s, 2));\n", "    assertEquals(1, matcher.lastIndexIn(s));\n", "    assertTrue(matcher.matchesAnyOf(s));\n", "    assertFalse(matcher.matchesAllOf(s));\n", "    assertFalse(matcher.matchesNoneOf(s));\n", "    assertEquals(s.substring(0, 1), matcher.removeFrom(s));\n", "    assertEquals(s.substring(0, 1) + \"z\", matcher.replaceFrom(s, 'z'));\n", "    assertEquals(s.substring(0, 1) + \"ZZ\", matcher.replaceFrom(s, \"ZZ\"));\n", "    assertEquals(s.substring(0, 1), matcher.trimFrom(s));\n", "    assertEquals(1, matcher.countIn(s));\n", "  }\n", "\n", "  /**\n", "   * Checks that expected is equals to out, and further, if in is\n", "   * equals to expected, then out is successfully optimized to be\n", "   * identical to in, i.e. that \"in\" is simply returned.\n", "   */\n", "  private void assertEqualsSame(String expected, String in, String out) {\n", "    if (expected.equals(in)) {\n", "      assertSame(in, out);\n", "    } else {\n", "      assertEquals(expected, out);\n", "    }\n", "  }\n", "\n", "  // Test collapse() a little differently than the rest, as we really want to\n", "  // cover lots of different configurations of input text\n", "  public void testCollapse() {\n", "    // collapsing groups of '-' into '_' or '-'\n", "    doTestCollapse(\"-\", \"_\");\n", "    doTestCollapse(\"x-\", \"x_\");\n", "    doTestCollapse(\"-x\", \"_x\");\n", "    doTestCollapse(\"--\", \"_\");\n", "    doTestCollapse(\"x--\", \"x_\");\n", "    doTestCollapse(\"--x\", \"_x\");\n", "    doTestCollapse(\"-x-\", \"_x_\");\n", "    doTestCollapse(\"x-x\", \"x_x\");\n", "    doTestCollapse(\"---\", \"_\");\n", "    doTestCollapse(\"--x-\", \"_x_\");\n", "    doTestCollapse(\"--xx\", \"_xx\");\n", "    doTestCollapse(\"-x--\", \"_x_\");\n", "    doTestCollapse(\"-x-x\", \"_x_x\");\n", "    doTestCollapse(\"-xx-\", \"_xx_\");\n", "    doTestCollapse(\"x--x\", \"x_x\");\n", "    doTestCollapse(\"x-x-\", \"x_x_\");\n", "    doTestCollapse(\"x-xx\", \"x_xx\");\n", "    doTestCollapse(\"x-x--xx---x----x\", \"x_x_xx_x_x\");\n", "\n", "    doTestCollapseWithNoChange(\"\");\n", "    doTestCollapseWithNoChange(\"x\");\n", "    doTestCollapseWithNoChange(\"xx\");\n", "  }\n", "\n", "  private void doTestCollapse(String in, String out) {\n", "    // Try a few different matchers which all match '-' and not 'x'\n", "    // Try replacement chars that both do and do not change the value.\n", "    for (char replacement : new char[] { '_', '-' }) {\n", "      String expected = out.replace('_', replacement);\n", "      assertEqualsSame(expected, in, is('-').collapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, is('-').collapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, is('-').or(is('#')).collapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, isNot('x').collapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, is('x').negate().collapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, anyOf(\"-\").collapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, anyOf(\"-#\").collapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, anyOf(\"-#123\").collapseFrom(in, replacement));\n", "    }\n", "  }\n", "\n", "  private void doTestCollapseWithNoChange(String inout) {\n", "    assertSame(inout, is('-').collapseFrom(inout, '_'));\n", "    assertSame(inout, is('-').or(is('#')).collapseFrom(inout, '_'));\n", "    assertSame(inout, isNot('x').collapseFrom(inout, '_'));\n", "    assertSame(inout, is('x').negate().collapseFrom(inout, '_'));\n", "    assertSame(inout, anyOf(\"-\").collapseFrom(inout, '_'));\n", "    assertSame(inout, anyOf(\"-#\").collapseFrom(inout, '_'));\n", "    assertSame(inout, anyOf(\"-#123\").collapseFrom(inout, '_'));\n", "    assertSame(inout, CharMatcher.none().collapseFrom(inout, '_'));\n", "  }\n", "\n", "  public void testCollapse_any() {\n", "    assertEquals(\"\", CharMatcher.any().collapseFrom(\"\", '_'));\n", "    assertEquals(\"_\", CharMatcher.any().collapseFrom(\"a\", '_'));\n", "    assertEquals(\"_\", CharMatcher.any().collapseFrom(\"ab\", '_'));\n", "    assertEquals(\"_\", CharMatcher.any().collapseFrom(\"abcd\", '_'));\n", "  }\n", "\n", "  public void testTrimFrom() {\n", "    // trimming -\n", "    doTestTrimFrom(\"-\", \"\");\n", "    doTestTrimFrom(\"x-\", \"x\");\n", "    doTestTrimFrom(\"-x\", \"x\");\n", "    doTestTrimFrom(\"--\", \"\");\n", "    doTestTrimFrom(\"x--\", \"x\");\n", "    doTestTrimFrom(\"--x\", \"x\");\n", "    doTestTrimFrom(\"-x-\", \"x\");\n", "    doTestTrimFrom(\"x-x\", \"x-x\");\n", "    doTestTrimFrom(\"---\", \"\");\n", "    doTestTrimFrom(\"--x-\", \"x\");\n", "    doTestTrimFrom(\"--xx\", \"xx\");\n", "    doTestTrimFrom(\"-x--\", \"x\");\n", "    doTestTrimFrom(\"-x-x\", \"x-x\");\n", "    doTestTrimFrom(\"-xx-\", \"xx\");\n", "    doTestTrimFrom(\"x--x\", \"x--x\");\n", "    doTestTrimFrom(\"x-x-\", \"x-x\");\n", "    doTestTrimFrom(\"x-xx\", \"x-xx\");\n", "    doTestTrimFrom(\"x-x--xx---x----x\", \"x-x--xx---x----x\");\n", "    // additional testing using the doc example\n", "    assertEquals(\"cat\", anyOf(\"ab\").trimFrom(\"abacatbab\"));\n", "  }\n", "\n", "  private void doTestTrimFrom(String in, String out) {\n", "    // Try a few different matchers which all match '-' and not 'x'\n", "    assertEquals(out, is('-').trimFrom(in));\n", "    assertEquals(out, is('-').or(is('#')).trimFrom(in));\n", "    assertEquals(out, isNot('x').trimFrom(in));\n", "    assertEquals(out, is('x').negate().trimFrom(in));\n", "    assertEquals(out, anyOf(\"-\").trimFrom(in));\n", "    assertEquals(out, anyOf(\"-#\").trimFrom(in));\n", "    assertEquals(out, anyOf(\"-#123\").trimFrom(in));\n", "  }\n", "\n", "  public void testTrimLeadingFrom() {\n", "    // trimming -\n", "    doTestTrimLeadingFrom(\"-\", \"\");\n", "    doTestTrimLeadingFrom(\"x-\", \"x-\");\n", "    doTestTrimLeadingFrom(\"-x\", \"x\");\n", "    doTestTrimLeadingFrom(\"--\", \"\");\n", "    doTestTrimLeadingFrom(\"x--\", \"x--\");\n", "    doTestTrimLeadingFrom(\"--x\", \"x\");\n", "    doTestTrimLeadingFrom(\"-x-\", \"x-\");\n", "    doTestTrimLeadingFrom(\"x-x\", \"x-x\");\n", "    doTestTrimLeadingFrom(\"---\", \"\");\n", "    doTestTrimLeadingFrom(\"--x-\", \"x-\");\n", "    doTestTrimLeadingFrom(\"--xx\", \"xx\");\n", "    doTestTrimLeadingFrom(\"-x--\", \"x--\");\n", "    doTestTrimLeadingFrom(\"-x-x\", \"x-x\");\n", "    doTestTrimLeadingFrom(\"-xx-\", \"xx-\");\n", "    doTestTrimLeadingFrom(\"x--x\", \"x--x\");\n", "    doTestTrimLeadingFrom(\"x-x-\", \"x-x-\");\n", "    doTestTrimLeadingFrom(\"x-xx\", \"x-xx\");\n", "    doTestTrimLeadingFrom(\"x-x--xx---x----x\", \"x-x--xx---x----x\");\n", "    // additional testing using the doc example\n", "    assertEquals(\"catbab\", anyOf(\"ab\").trimLeadingFrom(\"abacatbab\"));\n", "  }\n", "\n", "  private void doTestTrimLeadingFrom(String in, String out) {\n", "    // Try a few different matchers which all match '-' and not 'x'\n", "    assertEquals(out, is('-').trimLeadingFrom(in));\n", "    assertEquals(out, is('-').or(is('#')).trimLeadingFrom(in));\n", "    assertEquals(out, isNot('x').trimLeadingFrom(in));\n", "    assertEquals(out, is('x').negate().trimLeadingFrom(in));\n", "    assertEquals(out, anyOf(\"-#\").trimLeadingFrom(in));\n", "    assertEquals(out, anyOf(\"-#123\").trimLeadingFrom(in));\n", "  }\n", "\n", "  public void testTrimTrailingFrom() {\n", "    // trimming -\n", "    doTestTrimTrailingFrom(\"-\", \"\");\n", "    doTestTrimTrailingFrom(\"x-\", \"x\");\n", "    doTestTrimTrailingFrom(\"-x\", \"-x\");\n", "    doTestTrimTrailingFrom(\"--\", \"\");\n", "    doTestTrimTrailingFrom(\"x--\", \"x\");\n", "    doTestTrimTrailingFrom(\"--x\", \"--x\");\n", "    doTestTrimTrailingFrom(\"-x-\", \"-x\");\n", "    doTestTrimTrailingFrom(\"x-x\", \"x-x\");\n", "    doTestTrimTrailingFrom(\"---\", \"\");\n", "    doTestTrimTrailingFrom(\"--x-\", \"--x\");\n", "    doTestTrimTrailingFrom(\"--xx\", \"--xx\");\n", "    doTestTrimTrailingFrom(\"-x--\", \"-x\");\n", "    doTestTrimTrailingFrom(\"-x-x\", \"-x-x\");\n", "    doTestTrimTrailingFrom(\"-xx-\", \"-xx\");\n", "    doTestTrimTrailingFrom(\"x--x\", \"x--x\");\n", "    doTestTrimTrailingFrom(\"x-x-\", \"x-x\");\n", "    doTestTrimTrailingFrom(\"x-xx\", \"x-xx\");\n", "    doTestTrimTrailingFrom(\"x-x--xx---x----x\", \"x-x--xx---x----x\");\n", "    // additional testing using the doc example\n", "    assertEquals(\"abacat\", anyOf(\"ab\").trimTrailingFrom(\"abacatbab\"));\n", "  }\n", "\n", "  private void doTestTrimTrailingFrom(String in, String out) {\n", "    // Try a few different matchers which all match '-' and not 'x'\n", "    assertEquals(out, is('-').trimTrailingFrom(in));\n", "    assertEquals(out, is('-').or(is('#')).trimTrailingFrom(in));\n", "    assertEquals(out, isNot('x').trimTrailingFrom(in));\n", "    assertEquals(out, is('x').negate().trimTrailingFrom(in));\n", "    assertEquals(out, anyOf(\"-#\").trimTrailingFrom(in));\n", "    assertEquals(out, anyOf(\"-#123\").trimTrailingFrom(in));\n", "  }\n", "\n", "  public void testTrimAndCollapse() {\n", "    // collapsing groups of '-' into '_' or '-'\n", "    doTestTrimAndCollapse(\"\", \"\");\n", "    doTestTrimAndCollapse(\"x\", \"x\");\n", "    doTestTrimAndCollapse(\"-\", \"\");\n", "    doTestTrimAndCollapse(\"x-\", \"x\");\n", "    doTestTrimAndCollapse(\"-x\", \"x\");\n", "    doTestTrimAndCollapse(\"--\", \"\");\n", "    doTestTrimAndCollapse(\"x--\", \"x\");\n", "    doTestTrimAndCollapse(\"--x\", \"x\");\n", "    doTestTrimAndCollapse(\"-x-\", \"x\");\n", "    doTestTrimAndCollapse(\"x-x\", \"x_x\");\n", "    doTestTrimAndCollapse(\"---\", \"\");\n", "    doTestTrimAndCollapse(\"--x-\", \"x\");\n", "    doTestTrimAndCollapse(\"--xx\", \"xx\");\n", "    doTestTrimAndCollapse(\"-x--\", \"x\");\n", "    doTestTrimAndCollapse(\"-x-x\", \"x_x\");\n", "    doTestTrimAndCollapse(\"-xx-\", \"xx\");\n", "    doTestTrimAndCollapse(\"x--x\", \"x_x\");\n", "    doTestTrimAndCollapse(\"x-x-\", \"x_x\");\n", "    doTestTrimAndCollapse(\"x-xx\", \"x_xx\");\n", "    doTestTrimAndCollapse(\"x-x--xx---x----x\", \"x_x_xx_x_x\");\n", "  }\n", "\n", "  private void doTestTrimAndCollapse(String in, String out) {\n", "    // Try a few different matchers which all match '-' and not 'x'\n", "    for (char replacement : new char[] { '_', '-' }) {\n", "      String expected = out.replace('_', replacement);\n", "      assertEqualsSame(expected, in, is('-').trimAndCollapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, is('-').or(is('#')).trimAndCollapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, isNot('x').trimAndCollapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, is('x').negate().trimAndCollapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, anyOf(\"-\").trimAndCollapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, anyOf(\"-#\").trimAndCollapseFrom(in, replacement));\n", "      assertEqualsSame(expected, in, anyOf(\"-#123\").trimAndCollapseFrom(in, replacement));\n", "    }\n", "  }\n", "\n", "  public void testReplaceFrom() {\n", "    assertEquals(\"yoho\", is('a').replaceFrom(\"yaha\", 'o'));\n", "    assertEquals(\"yh\", is('a').replaceFrom(\"yaha\", \"\"));\n", "    assertEquals(\"yoho\", is('a').replaceFrom(\"yaha\", \"o\"));\n", "    assertEquals(\"yoohoo\", is('a').replaceFrom(\"yaha\", \"oo\"));\n", "    assertEquals(\"12 &gt; 5\", is('>').replaceFrom(\"12 > 5\", \"&gt;\"));\n", "  }\n", "\n", "  public void testPrecomputedOptimizations() {\n", "    // These are testing behavior that's never promised by the API.\n", "    // Some matchers are so efficient that it is a waste of effort to\n", "    // build a precomputed version.\n", "    CharMatcher m1 = is('x');\n", "    assertSame(m1, m1.precomputed());\n", "    assertEquals(m1.toString(), m1.precomputed().toString());\n", "\n", "    CharMatcher m2 = anyOf(\"Az\");\n", "    assertSame(m2, m2.precomputed());\n", "    assertEquals(m2.toString(), m2.precomputed().toString());\n", "\n", "    CharMatcher m3 = inRange('A', 'Z');\n", "    assertSame(m3, m3.precomputed());\n", "    assertEquals(m3.toString(), m3.precomputed().toString());\n", "\n", "    assertSame(CharMatcher.none(), CharMatcher.none().precomputed());\n", "    assertSame(CharMatcher.any(), CharMatcher.any().precomputed());\n", "  }\n", "\n", "  static void checkExactMatches(CharMatcher m, char[] chars) {\n", "    Set<Character> positive = Sets.newHashSetWithExpectedSize(chars.length);\n", "    for (char c : chars) {\n", "      positive.add(c);\n", "    }\n", "    for (int c = 0; c <= Character.MAX_VALUE; c++) {\n", "      assertFalse(positive.contains(new Character((char) c)) ^ m.matches((char) c));\n", "    }\n", "  }\n", "\n", "  static char[] randomChars(Random rand, int size) {\n", "    Set<Character> chars = new HashSet<Character>(size);\n", "    for (int i = 0; i < size; i++) {\n", "      char c;\n", "      while (true) {\n", "        c = (char) rand.nextInt(Character.MAX_VALUE - Character.MIN_VALUE + 1);\n", "        if (!chars.contains(c)) {\n", "          break;\n", "        }\n", "      }\n", "      chars.add(c);\n", "    }\n", "    char[] retValue = new char[chars.size()];\n", "    int i = 0;\n", "    for (char c : chars) {\n", "      retValue[i++] = c;\n", "    }\n", "    Arrays.sort(retValue);\n", "    return retValue;\n", "  }\n", "\n", "  public void testToString() {\n", "    assertToStringWorks(\"CharMatcher.none()\", CharMatcher.anyOf(\"\"));\n", "    assertToStringWorks(\"CharMatcher.is('\\\\u0031')\", CharMatcher.anyOf(\"1\"));\n", "    assertToStringWorks(\"CharMatcher.isNot('\\\\u0031')\", CharMatcher.isNot('1'));\n", "    assertToStringWorks(\"CharMatcher.anyOf(\\\"\\\\u0031\\\\u0032\\\")\", CharMatcher.anyOf(\"12\"));\n", "    assertToStringWorks(\"CharMatcher.anyOf(\\\"\\\\u0031\\\\u0032\\\\u0033\\\")\",\n", "        CharMatcher.anyOf(\"321\"));\n", "    assertToStringWorks(\"CharMatcher.inRange('\\\\u0031', '\\\\u0033')\",\n", "        CharMatcher.inRange('1', '3'));\n", "  }\n", "\n", "  private static void assertToStringWorks(String expected, CharMatcher matcher) {\n", "    assertEquals(expected, matcher.toString());\n", "    assertEquals(expected, matcher.precomputed().toString());\n", "    assertEquals(expected, matcher.negate().negate().toString());\n", "    assertEquals(expected, matcher.negate().precomputed().negate().toString());\n", "    assertEquals(expected, matcher.negate().precomputed().negate().precomputed().toString());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652]}}, {"67": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/CharsetsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.nio.charset.Charset;\n", "\n", "/**\n", " * Unit test for {@link Charsets}.\n", " *\n", " * @author Mike Bostock\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CharsetsTest extends TestCase {\n", "\n", "  public void testUtf8() {\n", "    assertEquals(Charset.forName(\"UTF-8\"), Charsets.UTF_8);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37]}}, {"68": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/EnumsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.testing.SerializableTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.lang.annotation.Retention;\n", "import java.lang.annotation.RetentionPolicy;\n", "\n", "/**\n", " * Tests for {@link Enums}.\n", " *\n", " * @author Steve McKay\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class EnumsTest extends TestCase {\n", "\n", "  private enum TestEnum {\n", "    CHEETO,\n", "    HONDA,\n", "    POODLE,\n", "  }\n", "\n", "  private enum OtherEnum {}\n", "\n", "  public void testGetIfPresent() {\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"CHEETO\")).hasValue(TestEnum.CHEETO);\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"HONDA\")).hasValue(TestEnum.HONDA);\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"POODLE\")).hasValue(TestEnum.POODLE);\n", "\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"CHEETO\")).isPresent();\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"HONDA\")).isPresent();\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"POODLE\")).isPresent();\n", "\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"CHEETO\")).hasValue(TestEnum.CHEETO);\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"HONDA\")).hasValue(TestEnum.HONDA);\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"POODLE\")).hasValue(TestEnum.POODLE);\n", "  }\n", "\n", "  public void testGetIfPresent_caseSensitive() {\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"cHEETO\")).isAbsent();\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"Honda\")).isAbsent();\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"poodlE\")).isAbsent();\n", "  }\n", "\n", "  public void testGetIfPresent_whenNoMatchingConstant() {\n", "    assertThat(Enums.getIfPresent(TestEnum.class, \"WOMBAT\")).isAbsent();\n", "  }\n", "\n", "  // Create a second ClassLoader and use it to get a second version of the TestEnum class.\n", "  // Run Enums.getIfPresent on that other TestEnum and then return a WeakReference containing the\n", "  // new ClassLoader. If Enums.getIfPresent does caching that prevents the shadow TestEnum\n", "  // (and therefore its ClassLoader) from being unloaded, then this WeakReference will never be\n", "  // cleared.\n", "\n", "  public void testStringConverter_convert() {\n", "    Converter<String, TestEnum> converter = Enums.stringConverter(TestEnum.class);\n", "    assertEquals(TestEnum.CHEETO, converter.convert(\"CHEETO\"));\n", "    assertEquals(TestEnum.HONDA, converter.convert(\"HONDA\"));\n", "    assertEquals(TestEnum.POODLE, converter.convert(\"POODLE\"));\n", "    assertNull(converter.convert(null));\n", "    assertNull(converter.reverse().convert(null));\n", "  }\n", "\n", "  public void testStringConverter_convertError() {\n", "    Converter<String, TestEnum> converter = Enums.stringConverter(TestEnum.class);\n", "    try {\n", "      converter.convert(\"xxx\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testStringConverter_reverse() {\n", "    Converter<String, TestEnum> converter = Enums.stringConverter(TestEnum.class);\n", "    assertEquals(\"CHEETO\", converter.reverse().convert(TestEnum.CHEETO));\n", "    assertEquals(\"HONDA\", converter.reverse().convert(TestEnum.HONDA));\n", "    assertEquals(\"POODLE\", converter.reverse().convert(TestEnum.POODLE));\n", "  }\n", "\n", "  public void testStringConverter_nullConversions() {\n", "    Converter<String, TestEnum> converter = Enums.stringConverter(TestEnum.class);\n", "    assertNull(converter.convert(null));\n", "    assertNull(converter.reverse().convert(null));\n", "  }\n", "\n", "  public void testStringConverter_serialization() {\n", "    SerializableTester.reserializeAndAssert(Enums.stringConverter(TestEnum.class));\n", "  }\n", "\n", "  @Retention(RetentionPolicy.RUNTIME)\n", "  private @interface ExampleAnnotation {}\n", "\n", "  private enum AnEnum {\n", "    @ExampleAnnotation FOO,\n", "    BAR\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118]}}, {"69": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/EquivalenceTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2010 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * diOBJECTibuted under the License is diOBJECTibuted on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Equivalence.Wrapper;\n", "import com.google.common.collect.ImmutableList;\n", "import com.google.common.testing.EqualsTester;\n", "import com.google.common.testing.EquivalenceTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Unit test for {@link Equivalence}.\n", " *\n", " * @author Jige Yu\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class EquivalenceTest extends TestCase {\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testPairwiseEquivalent() {\n", "    EquivalenceTester.of(Equivalence.equals().<String>pairwise())\n", "        .addEquivalenceGroup(ImmutableList.<String>of())\n", "        .addEquivalenceGroup(ImmutableList.of(\"a\"))\n", "        .addEquivalenceGroup(ImmutableList.of(\"b\"))\n", "        .addEquivalenceGroup(ImmutableList.of(\"a\", \"b\"), ImmutableList.of(\"a\", \"b\"))\n", "        .test();\n", "  }\n", "\n", "  public void testPairwiseEquivalent_equals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Equivalence.equals().pairwise(), Equivalence.equals().pairwise())\n", "        .addEqualityGroup(Equivalence.identity().pairwise())\n", "        .testEquals();\n", "  }\n", "\n", "  private enum LengthFunction implements Function<String, Integer> {\n", "    INSTANCE;\n", "\n", "    @Override public Integer apply(String input) {\n", "      return input.length();\n", "    }\n", "  }\n", "\n", "  private static final Equivalence<String> LENGTH_EQUIVALENCE = Equivalence.equals()\n", "      .onResultOf(LengthFunction.INSTANCE);\n", "\n", "  public void testWrap() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            LENGTH_EQUIVALENCE.wrap(\"hello\"),\n", "            LENGTH_EQUIVALENCE.wrap(\"hello\"),\n", "            LENGTH_EQUIVALENCE.wrap(\"world\"))\n", "        .addEqualityGroup(\n", "            LENGTH_EQUIVALENCE.wrap(\"hi\"),\n", "            LENGTH_EQUIVALENCE.wrap(\"yo\"))\n", "        .addEqualityGroup(\n", "            LENGTH_EQUIVALENCE.wrap(null),\n", "            LENGTH_EQUIVALENCE.wrap(null))\n", "        .addEqualityGroup(Equivalence.equals().wrap(\"hello\"))\n", "        .addEqualityGroup(Equivalence.equals().wrap(null))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testWrap_get() {\n", "    String test = \"test\";\n", "    Wrapper<String> wrapper = LENGTH_EQUIVALENCE.wrap(test);\n", "    assertSame(test, wrapper.get());\n", "  }\n", "\n", "  private static class IntValue {\n", "    private final int value;\n", "    \n", "    IntValue(int value) {\n", "      this.value = value;\n", "    }\n", "\n", "    @Override public String toString() {\n", "      return \"value = \" + value;\n", "    }\n", "  }\n", "  \n", "  public void testOnResultOf() {\n", "    EquivalenceTester.of(Equivalence.equals().onResultOf(Functions.toStringFunction()))\n", "        .addEquivalenceGroup(new IntValue(1), new IntValue(1))\n", "        .addEquivalenceGroup(new IntValue(2))\n", "        .test();\n", "  }\n", "  \n", "  public void testOnResultOf_equals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Equivalence.identity().onResultOf(Functions.toStringFunction()),\n", "            Equivalence.identity().onResultOf(Functions.toStringFunction()))\n", "        .addEqualityGroup(Equivalence.equals().onResultOf(Functions.toStringFunction()))\n", "        .addEqualityGroup(Equivalence.identity().onResultOf(Functions.identity()))\n", "        .testEquals();\n", "  }\n", "  \n", "  public void testEquivalentTo() {\n", "    Predicate<Object> equalTo1 = Equivalence.equals().equivalentTo(\"1\");\n", "    assertTrue(equalTo1.apply(\"1\"));\n", "    assertFalse(equalTo1.apply(\"2\"));\n", "    assertFalse(equalTo1.apply(null));\n", "    Predicate<Object> isNull = Equivalence.equals().equivalentTo(null);\n", "    assertFalse(isNull.apply(\"1\"));\n", "    assertFalse(isNull.apply(\"2\"));\n", "    assertTrue(isNull.apply(null));\n", "    \n", "    new EqualsTester()\n", "        .addEqualityGroup(equalTo1, Equivalence.equals().equivalentTo(\"1\"))\n", "        .addEqualityGroup(isNull)\n", "        .addEqualityGroup(Equivalence.identity().equivalentTo(\"1\"))\n", "        .testEquals();\n", "  }\n", "  public void testEqualsEquivalent() {\n", "    EquivalenceTester.of(Equivalence.equals())\n", "        .addEquivalenceGroup(new Integer(42), 42)\n", "        .addEquivalenceGroup(\"a\")\n", "        .test();\n", "  }\n", "\n", "  public void testIdentityEquivalent() {\n", "    EquivalenceTester.of(Equivalence.identity())\n", "        .addEquivalenceGroup(new Integer(42))\n", "        .addEquivalenceGroup(new Integer(42))\n", "        .addEquivalenceGroup(\"a\")\n", "        .test();\n", "  }\n", "  \n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Equivalence.equals(), Equivalence.equals())\n", "        .addEqualityGroup(Equivalence.identity(), Equivalence.identity())\n", "        .testEquals();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152]}}, {"70": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/FunctionsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2005 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableMap;\n", "import com.google.common.collect.Maps;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.Map;\n", "\n", "/**\n", " * Tests for {@link Functions}.\n", " *\n", " * @author Mike Bostock\n", " * @author Vlad Patryshev\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class FunctionsTest extends TestCase {\n", "\n", "  public void testIdentity_same() {\n", "    Function<String, String> identity = Functions.identity();\n", "    assertNull(identity.apply(null));\n", "    assertSame(\"foo\", identity.apply(\"foo\"));\n", "  }\n", "\n", "  public void testIdentity_notSame() {\n", "    Function<Long, Long> identity = Functions.identity();\n", "    assertNotSame(new Long(135135L), identity.apply(new Long(135135L)));\n", "  }\n", "\n", "  public void testToStringFunction_apply() {\n", "    assertEquals(\"3\", Functions.toStringFunction().apply(3));\n", "    assertEquals(\"hiya\", Functions.toStringFunction().apply(\"hiya\"));\n", "    assertEquals(\"I'm a string\",\n", "        Functions.toStringFunction().apply(\n", "            new Object() {\n", "              @Override public String toString() {\n", "                return \"I'm a string\";\n", "              }\n", "            }));\n", "    try {\n", "      Functions.toStringFunction().apply(null);\n", "      fail(\"expected NullPointerException\");\n", "    } catch (NullPointerException e) {\n", "      // expected\n", "    }\n", "  }\n", "\n", "  public void testForMapWithoutDefault() {\n", "    Map<String, Integer> map = Maps.newHashMap();\n", "    map.put(\"One\", 1);\n", "    map.put(\"Three\", 3);\n", "    map.put(\"Null\", null);\n", "    Function<String, Integer> function = Functions.forMap(map);\n", "\n", "    assertEquals(1, function.apply(\"One\").intValue());\n", "    assertEquals(3, function.apply(\"Three\").intValue());\n", "    assertNull(function.apply(\"Null\"));\n", "\n", "    try {\n", "      function.apply(\"Two\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(function, Functions.forMap(map))\n", "        .addEqualityGroup(Functions.forMap(map, 42))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testForMapWithDefault() {\n", "    Map<String, Integer> map = Maps.newHashMap();\n", "    map.put(\"One\", 1);\n", "    map.put(\"Three\", 3);\n", "    map.put(\"Null\", null);\n", "    Function<String, Integer> function = Functions.forMap(map, 42);\n", "\n", "    assertEquals(1, function.apply(\"One\").intValue());\n", "    assertEquals(42, function.apply(\"Two\").intValue());\n", "    assertEquals(3, function.apply(\"Three\").intValue());\n", "    assertNull(function.apply(\"Null\"));\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(function, Functions.forMap(map, 42))\n", "        .addEqualityGroup(Functions.forMap(map))\n", "        .addEqualityGroup(Functions.forMap(map, null))\n", "        .addEqualityGroup(Functions.forMap(map, 43))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testForMapWithDefault_null() {\n", "    ImmutableMap<String, Integer> map = ImmutableMap.of(\"One\", 1);\n", "    Function<String, Integer> function = Functions.forMap(map, null);\n", "\n", "    assertEquals((Integer) 1, function.apply(\"One\"));\n", "    assertNull(function.apply(\"Two\"));\n", "\n", "    // check basic sanity of equals and hashCode\n", "    new EqualsTester()\n", "        .addEqualityGroup(function)\n", "        .addEqualityGroup(Functions.forMap(map, 1))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testForMapWildCardWithDefault() {\n", "    Map<String, Integer> map = Maps.newHashMap();\n", "    map.put(\"One\", 1);\n", "    map.put(\"Three\", 3);\n", "    Number number = Double.valueOf(42);\n", "    Function<String, Number> function = Functions.forMap(map, number);\n", "\n", "    assertEquals(1, function.apply(\"One\").intValue());\n", "    assertEquals(number, function.apply(\"Two\"));\n", "    assertEquals(3L, function.apply(\"Three\").longValue());\n", "  }\n", "\n", "  public void testComposition() {\n", "    Map<String, Integer> mJapaneseToInteger = Maps.newHashMap();\n", "    mJapaneseToInteger.put(\"Ichi\", 1);\n", "    mJapaneseToInteger.put(\"Ni\", 2);\n", "    mJapaneseToInteger.put(\"San\", 3);\n", "    Function<String, Integer> japaneseToInteger =\n", "        Functions.forMap(mJapaneseToInteger);\n", "\n", "    Map<Integer, String> mIntegerToSpanish = Maps.newHashMap();\n", "    mIntegerToSpanish.put(1, \"Uno\");\n", "    mIntegerToSpanish.put(3, \"Tres\");\n", "    mIntegerToSpanish.put(4, \"Cuatro\");\n", "    Function<Integer, String> integerToSpanish =\n", "        Functions.forMap(mIntegerToSpanish);\n", "\n", "    Function<String, String> japaneseToSpanish =\n", "        Functions.compose(integerToSpanish, japaneseToInteger);\n", "\n", "    assertEquals(\"Uno\", japaneseToSpanish.apply(\"Ichi\"));\n", "    try {\n", "      japaneseToSpanish.apply(\"Ni\");\n", "      fail();\n", "    } catch (IllegalArgumentException e) {\n", "    }\n", "    assertEquals(\"Tres\", japaneseToSpanish.apply(\"San\"));\n", "    try {\n", "      japaneseToSpanish.apply(\"Shi\");\n", "      fail();\n", "    } catch (IllegalArgumentException e) {\n", "    }\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            japaneseToSpanish,\n", "            Functions.compose(integerToSpanish, japaneseToInteger))\n", "        .addEqualityGroup(japaneseToInteger)\n", "        .addEqualityGroup(integerToSpanish)\n", "        .addEqualityGroup(\n", "            Functions.compose(japaneseToInteger, integerToSpanish))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testCompositionWildcard() {\n", "    Map<String, Integer> mapJapaneseToInteger = Maps.newHashMap();\n", "    Function<String, Integer> japaneseToInteger =\n", "        Functions.forMap(mapJapaneseToInteger);\n", "\n", "    Function<Object, String> numberToSpanish = Functions.constant(\"Yo no se\");\n", "\n", "    Function<String, String> japaneseToSpanish =\n", "        Functions.compose(numberToSpanish, japaneseToInteger);\n", "  }\n", "\n", "  private static class HashCodeFunction implements Function<Object, Integer> {\n", "    @Override\n", "    public Integer apply(Object o) {\n", "      return (o == null) ? 0 : o.hashCode();\n", "    }\n", "  }\n", "\n", "  public void testComposeOfFunctionsIsAssociative() {\n", "    Map<Float, String> m = ImmutableMap.of(\n", "        4.0f, \"A\", 3.0f, \"B\", 2.0f, \"C\", 1.0f, \"D\");\n", "    Function<? super Integer, Boolean> h = Functions.constant(Boolean.TRUE);\n", "    Function<? super String, Integer> g = new HashCodeFunction();\n", "    Function<Float, String> f = Functions.forMap(m, \"F\");\n", "\n", "    Function<Float, Boolean> c1 = Functions.compose(Functions.compose(h, g), f);\n", "    Function<Float, Boolean> c2 = Functions.compose(h, Functions.compose(g, f));\n", "\n", "    // Might be nice (eventually) to have:\n", "    //     assertEquals(c1, c2);\n", "\n", "    // But for now, settle for this:\n", "    assertEquals(c1.hashCode(), c2.hashCode());\n", "\n", "    assertEquals(c1.apply(1.0f), c2.apply(1.0f));\n", "    assertEquals(c1.apply(5.0f), c2.apply(5.0f));\n", "  }\n", "\n", "  public void testComposeOfPredicateAndFunctionIsAssociative() {\n", "    Map<Float, String> m = ImmutableMap.of(\n", "        4.0f, \"A\", 3.0f, \"B\", 2.0f, \"C\", 1.0f, \"D\");\n", "    Predicate<? super Integer> h = Predicates.equalTo(42);\n", "    Function<? super String, Integer> g = new HashCodeFunction();\n", "    Function<Float, String> f = Functions.forMap(m, \"F\");\n", "\n", "    Predicate<Float> p1 = Predicates.compose(Predicates.compose(h, g), f);\n", "    Predicate<Float> p2 = Predicates.compose(h, Functions.compose(g, f));\n", "\n", "    // Might be nice (eventually) to have:\n", "    //     assertEquals(p1, p2);\n", "\n", "    // But for now, settle for this:\n", "    assertEquals(p1.hashCode(), p2.hashCode());\n", "\n", "    assertEquals(p1.apply(1.0f), p2.apply(1.0f));\n", "    assertEquals(p1.apply(5.0f), p2.apply(5.0f));\n", "  }\n", "\n", "  public void testForPredicate() {\n", "    Function<Object, Boolean> alwaysTrue =\n", "        Functions.forPredicate(Predicates.alwaysTrue());\n", "    Function<Object, Boolean> alwaysFalse =\n", "        Functions.forPredicate(Predicates.alwaysFalse());\n", "\n", "    assertTrue(alwaysTrue.apply(0));\n", "    assertFalse(alwaysFalse.apply(0));\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            alwaysTrue, Functions.forPredicate(Predicates.alwaysTrue()))\n", "        .addEqualityGroup(alwaysFalse)\n", "        .addEqualityGroup(Functions.identity())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testConstant() {\n", "    Function<Object, Object> f = Functions.<Object>constant(\"correct\");\n", "    assertEquals(\"correct\", f.apply(new Object()));\n", "    assertEquals(\"correct\", f.apply(null));\n", "\n", "    Function<Object, String> g = Functions.constant(null);\n", "    assertEquals(null, g.apply(2));\n", "    assertEquals(null, g.apply(null));\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(f, Functions.constant(\"correct\"))\n", "        .addEqualityGroup(Functions.constant(\"incorrect\"))\n", "        .addEqualityGroup(Functions.toStringFunction())\n", "        .addEqualityGroup(g)\n", "        .testEquals();\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(g, Functions.constant(null))\n", "        .addEqualityGroup(Functions.constant(\"incorrect\"))\n", "        .addEqualityGroup(Functions.toStringFunction())\n", "        .addEqualityGroup(f)\n", "        .testEquals();\n", "  }\n", "\n", "  private static class CountingSupplier\n", "      implements Supplier<Integer>, Serializable {\n", "\n", "    private static final long serialVersionUID = 0;\n", "\n", "    private int value;\n", "\n", "    @Override\n", "    public Integer get() {\n", "      return ++value;\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "      if (obj instanceof CountingSupplier) {\n", "        return this.value == ((CountingSupplier) obj).value;\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return value;\n", "    }\n", "  }\n", "\n", "  public void testForSupplier() {\n", "    Supplier<Integer> supplier = new CountingSupplier();\n", "    Function<Object, Integer> function = Functions.forSupplier(supplier);\n", "\n", "    assertEquals(1, (int) function.apply(null));\n", "    assertEquals(2, (int) function.apply(\"foo\"));\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(function, Functions.forSupplier(supplier))\n", "        .addEqualityGroup(Functions.forSupplier(new CountingSupplier()))\n", "        .addEqualityGroup(Functions.forSupplier(Suppliers.ofInstance(12)))\n", "        .addEqualityGroup(Functions.toStringFunction())\n", "        .testEquals();\n", "  }\n", "\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319]}}, {"71": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/JoinerTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Joiner.MapJoiner;\n", "import com.google.common.collect.ImmutableMap;\n", "import com.google.common.collect.ImmutableMultimap;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Lists;\n", "import com.google.common.collect.Maps;\n", "\n", "import junit.framework.AssertionFailedError;\n", "import junit.framework.TestCase;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "/**\n", " * Unit test for {@link Joiner}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class JoinerTest extends TestCase {\n", "  private static final Joiner J = Joiner.on(\"-\");\n", "\n", "  // <Integer> needed to prevent warning :(\n", "  private static final Iterable<Integer> ITERABLE_ = Arrays.<Integer>asList();\n", "  private static final Iterable<Integer> ITERABLE_1 = Arrays.asList(1);\n", "  private static final Iterable<Integer> ITERABLE_12 = Arrays.asList(1, 2);\n", "  private static final Iterable<Integer> ITERABLE_123 = Arrays.asList(1, 2, 3);\n", "  private static final Iterable<Integer> ITERABLE_NULL = Arrays.asList((Integer) null);\n", "  private static final Iterable<Integer> ITERABLE_NULL_NULL\n", "      = Arrays.asList((Integer) null, null);\n", "  private static final Iterable<Integer> ITERABLE_NULL_1 = Arrays.asList(null, 1);\n", "  private static final Iterable<Integer> ITERABLE_1_NULL = Arrays.asList(1, null);\n", "  private static final Iterable<Integer> ITERABLE_1_NULL_2 = Arrays.asList(1, null, 2);\n", "  private static final Iterable<Integer> ITERABLE_FOUR_NULLS\n", "      = Arrays.asList((Integer) null, null, null, null);\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testNoSpecialNullBehavior() {\n", "    checkNoOutput(J, ITERABLE_);\n", "    checkResult(J, ITERABLE_1, \"1\");\n", "    checkResult(J, ITERABLE_12, \"1-2\");\n", "    checkResult(J, ITERABLE_123, \"1-2-3\");\n", "\n", "    try {\n", "      J.join(ITERABLE_NULL);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    try {\n", "      J.join(ITERABLE_1_NULL_2);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    try {\n", "      J.join(ITERABLE_NULL.iterator());\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    try {\n", "      J.join(ITERABLE_1_NULL_2.iterator());\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testOnCharOverride() {\n", "    Joiner onChar = Joiner.on('-');\n", "    checkNoOutput(onChar, ITERABLE_);\n", "    checkResult(onChar, ITERABLE_1, \"1\");\n", "    checkResult(onChar, ITERABLE_12, \"1-2\");\n", "    checkResult(onChar, ITERABLE_123, \"1-2-3\");\n", "  }\n", "\n", "  public void testSkipNulls() {\n", "    Joiner skipNulls = J.skipNulls();\n", "    checkNoOutput(skipNulls, ITERABLE_);\n", "    checkNoOutput(skipNulls, ITERABLE_NULL);\n", "    checkNoOutput(skipNulls, ITERABLE_NULL_NULL);\n", "    checkNoOutput(skipNulls, ITERABLE_FOUR_NULLS);\n", "    checkResult(skipNulls, ITERABLE_1, \"1\");\n", "    checkResult(skipNulls, ITERABLE_12, \"1-2\");\n", "    checkResult(skipNulls, ITERABLE_123, \"1-2-3\");\n", "    checkResult(skipNulls, ITERABLE_NULL_1, \"1\");\n", "    checkResult(skipNulls, ITERABLE_1_NULL, \"1\");\n", "    checkResult(skipNulls, ITERABLE_1_NULL_2, \"1-2\");\n", "  }\n", "\n", "  public void testUseForNull() {\n", "    Joiner zeroForNull = J.useForNull(\"0\");\n", "    checkNoOutput(zeroForNull, ITERABLE_);\n", "    checkResult(zeroForNull, ITERABLE_1, \"1\");\n", "    checkResult(zeroForNull, ITERABLE_12, \"1-2\");\n", "    checkResult(zeroForNull, ITERABLE_123, \"1-2-3\");\n", "    checkResult(zeroForNull, ITERABLE_NULL, \"0\");\n", "    checkResult(zeroForNull, ITERABLE_NULL_NULL, \"0-0\");\n", "    checkResult(zeroForNull, ITERABLE_NULL_1, \"0-1\");\n", "    checkResult(zeroForNull, ITERABLE_1_NULL, \"1-0\");\n", "    checkResult(zeroForNull, ITERABLE_1_NULL_2, \"1-0-2\");\n", "    checkResult(zeroForNull, ITERABLE_FOUR_NULLS, \"0-0-0-0\");\n", "  }\n", "\n", "  private static void checkNoOutput(Joiner joiner, Iterable<Integer> set) {\n", "    assertEquals(\"\", joiner.join(set));\n", "    assertEquals(\"\", joiner.join(set.iterator()));\n", "\n", "    Object[] array = Lists.newArrayList(set).toArray(new Integer[0]);\n", "    assertEquals(\"\", joiner.join(array));\n", "\n", "    StringBuilder sb1FromIterable = new StringBuilder();\n", "    assertSame(sb1FromIterable, joiner.appendTo(sb1FromIterable, set));\n", "    assertEquals(0, sb1FromIterable.length());\n", "\n", "    StringBuilder sb1FromIterator = new StringBuilder();\n", "    assertSame(sb1FromIterator, joiner.appendTo(sb1FromIterator, set));\n", "    assertEquals(0, sb1FromIterator.length());\n", "\n", "    StringBuilder sb2 = new StringBuilder();\n", "    assertSame(sb2, joiner.appendTo(sb2, array));\n", "    assertEquals(0, sb2.length());\n", "\n", "    try {\n", "      joiner.appendTo(NASTY_APPENDABLE, set);\n", "    } catch (IOException e) {\n", "      throw new AssertionError(e);\n", "    }\n", "\n", "    try {\n", "      joiner.appendTo(NASTY_APPENDABLE, set.iterator());\n", "    } catch (IOException e) {\n", "      throw new AssertionError(e);\n", "    }\n", "\n", "    try {\n", "      joiner.appendTo(NASTY_APPENDABLE, array);\n", "    } catch (IOException e) {\n", "      throw new AssertionError(e);\n", "    }\n", "  }\n", "\n", "  private static final Appendable NASTY_APPENDABLE = new Appendable() {\n", "    @Override\n", "    public Appendable append(CharSequence csq) throws IOException {\n", "      throw new IOException();\n", "    }\n", "    @Override\n", "    public Appendable append(CharSequence csq, int start, int end) throws IOException {\n", "      throw new IOException();\n", "    }\n", "    @Override\n", "    public Appendable append(char c) throws IOException {\n", "      throw new IOException();\n", "    }\n", "  };\n", "\n", "  private static void checkResult(Joiner joiner, Iterable<Integer> parts, String expected) {\n", "    assertEquals(expected, joiner.join(parts));\n", "    assertEquals(expected, joiner.join(parts.iterator()));\n", "\n", "    StringBuilder sb1FromIterable = new StringBuilder().append('x');\n", "    joiner.appendTo(sb1FromIterable, parts);\n", "    assertEquals(\"x\" + expected, sb1FromIterable.toString());\n", "\n", "    StringBuilder sb1FromIterator = new StringBuilder().append('x');\n", "    joiner.appendTo(sb1FromIterator, parts.iterator());\n", "    assertEquals(\"x\" + expected, sb1FromIterator.toString());\n", "\n", "    Integer[] partsArray = Lists.newArrayList(parts).toArray(new Integer[0]);\n", "    assertEquals(expected, joiner.join(partsArray));\n", "\n", "    StringBuilder sb2 = new StringBuilder().append('x');\n", "    joiner.appendTo(sb2, partsArray);\n", "    assertEquals(\"x\" + expected, sb2.toString());\n", "\n", "    int num = partsArray.length - 2;\n", "    if (num >= 0) {\n", "      Object[] rest = new Integer[num];\n", "      for (int i = 0; i < num; i++) {\n", "        rest[i] = partsArray[i + 2];\n", "      }\n", "\n", "      assertEquals(expected, joiner.join(partsArray[0], partsArray[1], rest));\n", "\n", "      StringBuilder sb3 = new StringBuilder().append('x');\n", "      joiner.appendTo(sb3, partsArray[0], partsArray[1], rest);\n", "      assertEquals(\"x\" + expected, sb3.toString());\n", "    }\n", "  }\n", "\n", "  public void test_useForNull_skipNulls() {\n", "    Joiner j = Joiner.on(\"x\").useForNull(\"y\");\n", "    try {\n", "      j = j.skipNulls();\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void test_skipNulls_useForNull() {\n", "    Joiner j = Joiner.on(\"x\").skipNulls();\n", "    try {\n", "      j = j.useForNull(\"y\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void test_useForNull_twice() {\n", "    Joiner j = Joiner.on(\"x\").useForNull(\"y\");\n", "    try {\n", "      j = j.useForNull(\"y\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMap() {\n", "    MapJoiner j = Joiner.on(\";\").withKeyValueSeparator(\":\");\n", "    assertEquals(\"\", j.join(ImmutableMap.of()));\n", "    assertEquals(\":\", j.join(ImmutableMap.of(\"\", \"\")));\n", "\n", "    Map<String, String> mapWithNulls = Maps.newLinkedHashMap();\n", "    mapWithNulls.put(\"a\", null);\n", "    mapWithNulls.put(null, \"b\");\n", "\n", "    try {\n", "      j.join(mapWithNulls);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    assertEquals(\"a:00;00:b\", j.useForNull(\"00\").join(mapWithNulls));\n", "\n", "    StringBuilder sb = new StringBuilder();\n", "    j.appendTo(sb, ImmutableMap.of(1, 2, 3, 4, 5, 6));\n", "    assertEquals(\"1:2;3:4;5:6\", sb.toString());\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEntries() {\n", "    MapJoiner j = Joiner.on(\";\").withKeyValueSeparator(\":\");\n", "    assertEquals(\"\", j.join(ImmutableMultimap.of().entries()));\n", "    assertEquals(\"\", j.join(ImmutableMultimap.of().entries().iterator()));\n", "    assertEquals(\":\", j.join(ImmutableMultimap.of(\"\", \"\").entries()));\n", "    assertEquals(\":\", j.join(ImmutableMultimap.of(\"\", \"\").entries().iterator()));\n", "    assertEquals(\"1:a;1:b\", j.join(ImmutableMultimap.of(\"1\", \"a\", \"1\", \"b\").entries()));\n", "    assertEquals(\"1:a;1:b\", j.join(ImmutableMultimap.of(\"1\", \"a\", \"1\", \"b\").entries().iterator()));\n", "\n", "    Map<String, String> mapWithNulls = Maps.newLinkedHashMap();\n", "    mapWithNulls.put(\"a\", null);\n", "    mapWithNulls.put(null, \"b\");\n", "    Set<Map.Entry<String, String>> entriesWithNulls = mapWithNulls.entrySet();\n", "\n", "    try {\n", "      j.join(entriesWithNulls);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    try {\n", "      j.join(entriesWithNulls.iterator());\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    assertEquals(\"a:00;00:b\", j.useForNull(\"00\").join(entriesWithNulls));\n", "    assertEquals(\"a:00;00:b\", j.useForNull(\"00\").join(entriesWithNulls.iterator()));\n", "\n", "    StringBuilder sb1 = new StringBuilder();\n", "    j.appendTo(sb1, ImmutableMultimap.of(1, 2, 3, 4, 5, 6, 1, 3, 5, 10).entries());\n", "    assertEquals(\"1:2;1:3;3:4;5:6;5:10\", sb1.toString());\n", "\n", "    StringBuilder sb2 = new StringBuilder();\n", "    j.appendTo(sb2, ImmutableMultimap.of(1, 2, 3, 4, 5, 6, 1, 3, 5, 10).entries().iterator());\n", "    assertEquals(\"1:2;1:3;3:4;5:6;5:10\", sb2.toString());\n", "  }\n", "\n", "  @SuppressWarnings(\"ReturnValueIgnored\") // testing for exception\n", "  public void test_skipNulls_onMap() {\n", "    Joiner j = Joiner.on(\",\").skipNulls();\n", "    try {\n", "      j.withKeyValueSeparator(\"/\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  private static class DontStringMeBro implements CharSequence {\n", "    @Override\n", "    public int length() {\n", "      return 3;\n", "    }\n", "    @Override\n", "    public char charAt(int index) {\n", "      return \"foo\".charAt(index);\n", "    }\n", "    @Override\n", "    public CharSequence subSequence(int start, int end) {\n", "      return \"foo\".subSequence(start, end);\n", "    }\n", "    @Override public String toString() {\n", "      throw new AssertionFailedError(\"shouldn't be invoked\");\n", "    }\n", "  }\n", "\n", "  // Don't do this.\n", "  private static class IterableIterator implements Iterable<Integer>, Iterator<Integer> {\n", "    private static final ImmutableSet<Integer> INTEGERS = ImmutableSet.of(1, 2, 3, 4);\n", "    private final Iterator<Integer> iterator;\n", "    public IterableIterator() {\n", "      this.iterator = iterator();\n", "    }\n", "    @Override public Iterator<Integer> iterator() {\n", "      return INTEGERS.iterator();\n", "    }\n", "    @Override public boolean hasNext() {\n", "      return iterator.hasNext();\n", "    }\n", "    @Override public Integer next() {\n", "      return iterator.next();\n", "    }\n", "    @Override public void remove() {\n", "      iterator.remove();\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350]}}, {"72": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/ObjectsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Tests for {@link Objects}.\n", " *\n", " * @author Laurence Gonsalves\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ObjectsTest extends TestCase {\n", "\n", "  public void testEqual() throws Exception {\n", "    assertTrue(Objects.equal(1, 1));\n", "    assertTrue(Objects.equal(null, null));\n", "\n", "    // test distinct string objects\n", "    String s1 = \"foobar\";\n", "    String s2 = new String(s1);\n", "    assertTrue(Objects.equal(s1, s2));\n", "\n", "    assertFalse(Objects.equal(s1, null));\n", "    assertFalse(Objects.equal(null, s1));\n", "    assertFalse(Objects.equal(\"foo\", \"bar\"));\n", "    assertFalse(Objects.equal(\"1\", 1));\n", "  }\n", "\n", "  public void testHashCode() throws Exception {\n", "    int h1 = Objects.hashCode(1, \"two\", 3.0);\n", "    int h2 = Objects.hashCode(\n", "        new Integer(1), new String(\"two\"), new Double(3.0));\n", "    // repeatable\n", "    assertEquals(h1, h2);\n", "\n", "    // These don't strictly need to be true, but they're nice properties.\n", "    assertTrue(Objects.hashCode(1, 2, null) != Objects.hashCode(1, 2));\n", "    assertTrue(Objects.hashCode(1, 2, null) != Objects.hashCode(1, null, 2));\n", "    assertTrue(Objects.hashCode(1, null, 2) != Objects.hashCode(1, 2));\n", "    assertTrue(Objects.hashCode(1, 2, 3) != Objects.hashCode(3, 2, 1));\n", "    assertTrue(Objects.hashCode(1, 2, 3) != Objects.hashCode(2, 3, 1));\n", "  }\n", "\n", "  public void testFirstNonNull_withNonNull() throws Exception {\n", "    String s1 = \"foo\";\n", "    String s2 = Objects.firstNonNull(s1, \"bar\");\n", "    assertSame(s1, s2);\n", "\n", "    Long n1 = new Long(42);\n", "    Long n2 = Objects.firstNonNull(null, n1);\n", "    assertSame(n1, n2);\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testFirstNonNull_throwsNullPointerException() throws Exception {\n", "    try {\n", "      Objects.firstNonNull(null, null);\n", "      fail(\"expected NullPointerException\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80]}}, {"73": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/OptionalTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.FluentIterable;\n", "import com.google.common.collect.ImmutableList;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collections;\n", "import java.util.List;\n", "import java.util.Set;\n", "\n", "/**\n", " * Unit test for {@link Optional}.\n", " *\n", " * @author Kurt Alfred Kluever\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class OptionalTest extends TestCase {\n", "  public void testAbsent() {\n", "    Optional<String> optionalName = Optional.absent();\n", "    assertFalse(optionalName.isPresent());\n", "  }\n", "\n", "  public void testOf() {\n", "    assertEquals(\"training\", Optional.of(\"training\").get());\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testOf_null() {\n", "    try {\n", "      Optional.of(null);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testFromNullable() {\n", "    Optional<String> optionalName = Optional.fromNullable(\"bob\");\n", "    assertEquals(\"bob\", optionalName.get());\n", "  }\n", "\n", "  public void testFromNullable_null() {\n", "    // not promised by spec, but easier to test\n", "    assertSame(Optional.absent(), Optional.fromNullable(null));\n", "  }\n", "\n", "  public void testIsPresent_no() {\n", "    assertFalse(Optional.absent().isPresent());\n", "  }\n", "\n", "  public void testIsPresent_yes() {\n", "    assertTrue(Optional.of(\"training\").isPresent());\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testGet_absent() {\n", "    Optional<String> optional = Optional.absent();\n", "    try {\n", "      optional.get();\n", "      fail();\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  public void testGet_present() {\n", "    assertEquals(\"training\", Optional.of(\"training\").get());\n", "  }\n", "\n", "  public void testOr_T_present() {\n", "    assertEquals(\"a\", Optional.of(\"a\").or(\"default\"));\n", "  }\n", "\n", "  public void testOr_T_absent() {\n", "    assertEquals(\"default\", Optional.absent().or(\"default\"));\n", "  }\n", "\n", "  public void testOr_supplier_present() {\n", "    assertEquals(\"a\", Optional.of(\"a\").or(Suppliers.ofInstance(\"fallback\")));\n", "  }\n", "\n", "  public void testOr_supplier_absent() {\n", "    assertEquals(\"fallback\", Optional.absent().or(Suppliers.ofInstance(\"fallback\")));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testOr_nullSupplier_absent() {\n", "    Supplier<Object> nullSupplier = Suppliers.ofInstance(null);\n", "    Optional<Object> absentOptional = Optional.absent();\n", "    try {\n", "      absentOptional.or(nullSupplier);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testOr_nullSupplier_present() {\n", "    Supplier<String> nullSupplier = Suppliers.ofInstance(null);\n", "    assertEquals(\"a\", Optional.of(\"a\").or(nullSupplier));\n", "  }\n", "\n", "  public void testOr_Optional_present() {\n", "    assertEquals(Optional.of(\"a\"), Optional.of(\"a\").or(Optional.of(\"fallback\")));\n", "  }\n", "\n", "  public void testOr_Optional_absent() {\n", "    assertEquals(Optional.of(\"fallback\"), Optional.absent().or(Optional.of(\"fallback\")));\n", "  }\n", "\n", "  public void testOrNull_present() {\n", "    assertEquals(\"a\", Optional.of(\"a\").orNull());\n", "  }\n", "\n", "  public void testOrNull_absent() {\n", "    assertNull(Optional.absent().orNull());\n", "  }\n", "\n", "  public void testAsSet_present() {\n", "    Set<String> expected = Collections.singleton(\"a\");\n", "    assertEquals(expected, Optional.of(\"a\").asSet());\n", "  }\n", "\n", "  public void testAsSet_absent() {\n", "    assertTrue(\"Returned set should be empty\", Optional.absent().asSet().isEmpty());\n", "  }\n", "\n", "  public void testAsSet_presentIsImmutable() {\n", "    Set<String> presentAsSet = Optional.of(\"a\").asSet();\n", "    try {\n", "      presentAsSet.add(\"b\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsSet_absentIsImmutable() {\n", "    Set<Object> absentAsSet = Optional.absent().asSet();\n", "    try {\n", "      absentAsSet.add(\"foo\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testTransform_absent() {\n", "    assertEquals(Optional.absent(), Optional.absent().transform(Functions.identity()));\n", "    assertEquals(Optional.absent(), Optional.absent().transform(Functions.toStringFunction()));\n", "  }\n", "\n", "  public void testTransform_presentIdentity() {\n", "    assertEquals(Optional.of(\"a\"), Optional.of(\"a\").transform(Functions.identity()));\n", "  }\n", "\n", "  public void testTransform_presentToString() {\n", "    assertEquals(Optional.of(\"42\"), Optional.of(42).transform(Functions.toStringFunction()));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testTransform_present_functionReturnsNull() {\n", "    try {\n", "      Optional.of(\"a\").transform(\n", "          new Function<String, String>() {\n", "            @Override public String apply(String input) {\n", "              return null;\n", "            }\n", "          });\n", "      fail(\"Should throw if Function returns null.\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testTransform_abssent_functionReturnsNull() {\n", "    assertEquals(Optional.absent(),\n", "        Optional.absent().transform(\n", "          new Function<Object, Object>() {\n", "            @Override public Object apply(Object input) {\n", "              return null;\n", "            }\n", "          }));\n", "  }\n", "\n", "  // TODO(kevinb): use EqualsTester\n", "\n", "  public void testEqualsAndHashCode_absent() {\n", "    assertEquals(Optional.<String>absent(), Optional.<Integer>absent());\n", "    assertEquals(Optional.absent().hashCode(), Optional.absent().hashCode());\n", "    assertThat(Optional.absent().hashCode())\n", "        .isNotEqualTo(Optional.of(0).hashCode());\n", "  }\n", "\n", "  public void testEqualsAndHashCode_present() {\n", "    assertEquals(Optional.of(\"training\"), Optional.of(\"training\"));\n", "    assertFalse(Optional.of(\"a\").equals(Optional.of(\"b\")));\n", "    assertFalse(Optional.of(\"a\").equals(Optional.absent()));\n", "    assertEquals(Optional.of(\"training\").hashCode(), Optional.of(\"training\").hashCode());\n", "  }\n", "\n", "  public void testToString_absent() {\n", "    assertEquals(\"Optional.absent()\", Optional.absent().toString());\n", "  }\n", "\n", "  public void testToString_present() {\n", "    assertEquals(\"Optional.of(training)\", Optional.of(\"training\").toString());\n", "  }\n", "\n", "  public void testPresentInstances_allPresent() {\n", "    List<Optional<String>> optionals =\n", "        ImmutableList.of(Optional.of(\"a\"), Optional.of(\"b\"), Optional.of(\"c\"));\n", "    assertThat(Optional.presentInstances(optionals)).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testPresentInstances_allAbsent() {\n", "    List<Optional<Object>> optionals =\n", "        ImmutableList.of(Optional.absent(), Optional.absent());\n", "    assertThat(Optional.presentInstances(optionals)).isEmpty();\n", "  }\n", "\n", "  public void testPresentInstances_somePresent() {\n", "    List<Optional<String>> optionals =\n", "        ImmutableList.of(Optional.of(\"a\"), Optional.<String>absent(), Optional.of(\"c\"));\n", "    assertThat(Optional.presentInstances(optionals)).containsExactly(\"a\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testPresentInstances_callingIteratorTwice() {\n", "    List<Optional<String>> optionals =\n", "        ImmutableList.of(Optional.of(\"a\"), Optional.<String>absent(), Optional.of(\"c\"));\n", "    Iterable<String> onlyPresent = Optional.presentInstances(optionals);\n", "    assertThat(onlyPresent).containsExactly(\"a\", \"c\").inOrder();\n", "    assertThat(onlyPresent).containsExactly(\"a\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testPresentInstances_wildcards() {\n", "    List<Optional<? extends Number>> optionals =\n", "        ImmutableList.<Optional<? extends Number>>of(Optional.<Double>absent(), Optional.of(2));\n", "    Iterable<Number> onlyPresent = Optional.presentInstances(optionals);\n", "    assertThat(onlyPresent).containsExactly(2).inOrder();\n", "  }\n", "\n", "  private static Optional<Integer> getSomeOptionalInt() {\n", "    return Optional.of(1);\n", "  }\n", "\n", "  private static FluentIterable<? extends Number> getSomeNumbers() {\n", "    return FluentIterable.from(ImmutableList.<Number>of());\n", "  }\n", "\n", "  /*\n", "   * The following tests demonstrate the shortcomings of or() and test that the casting workaround\n", "   * mentioned in the method Javadoc does in fact compile.\n", "   */\n", "\n", "  @SuppressWarnings(\"unused\") // compilation test\n", "  public void testSampleCodeError1() {\n", "    Optional<Integer> optionalInt = getSomeOptionalInt();\n", "    // Number value = optionalInt.or(0.5); // error\n", "  }\n", "\n", "  @SuppressWarnings(\"unused\") // compilation test\n", "  public void testSampleCodeError2() {\n", "    FluentIterable<? extends Number> numbers = getSomeNumbers();\n", "    Optional<? extends Number> first = numbers.first();\n", "    // Number value = first.or(0.5); // error\n", "  }\n", "\n", "  @SuppressWarnings(\"unused\") // compilation test\n", "  public void testSampleCodeFine1() {\n", "    Optional<Number> optionalInt = Optional.of((Number) 1);\n", "    Number value = optionalInt.or(0.5); // fine\n", "  }\n", "\n", "  @SuppressWarnings(\"unused\") // compilation test\n", "  public void testSampleCodeFine2() {\n", "    FluentIterable<? extends Number> numbers = getSomeNumbers();\n", "\n", "    // Sadly, the following is what users will have to do in some circumstances.\n", "\n", "    @SuppressWarnings(\"unchecked\") // safe covariant cast\n", "    Optional<Number> first = (Optional) numbers.first();\n", "    Number value = first.or(0.5); // fine\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300]}}, {"74": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/PreconditionsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2006 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.AssertionFailedError;\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Unit test for {@link Preconditions}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class PreconditionsTest extends TestCase {\n", "  public void testCheckArgument_simple_success() {\n", "    Preconditions.checkArgument(true);\n", "  }\n", "\n", "  public void testCheckArgument_simple_failure() {\n", "    try {\n", "      Preconditions.checkArgument(false);\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCheckArgument_simpleMessage_success() {\n", "    Preconditions.checkArgument(true, IGNORE_ME);\n", "  }\n", "\n", "  public void testCheckArgument_simpleMessage_failure() {\n", "    try {\n", "      Preconditions.checkArgument(false, new Message());\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalArgumentException expected) {\n", "      verifySimpleMessage(expected);\n", "    }\n", "  }\n", "\n", "  public void testCheckArgument_nullMessage_failure() {\n", "    try {\n", "      Preconditions.checkArgument(false, null);\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected).hasMessage(\"null\");\n", "    }\n", "  }\n", "\n", "  public void testCheckArgument_complexMessage_success() {\n", "    Preconditions.checkArgument(true, \"%s\", IGNORE_ME);\n", "  }\n", "\n", "  public void testCheckArgument_complexMessage_failure() {\n", "    try {\n", "      Preconditions.checkArgument(false, FORMAT, 5);\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalArgumentException expected) {\n", "      verifyComplexMessage(expected);\n", "    }\n", "  }\n", "\n", "  public void testCheckState_simple_success() {\n", "    Preconditions.checkState(true);\n", "  }\n", "\n", "  public void testCheckState_simple_failure() {\n", "    try {\n", "      Preconditions.checkState(false);\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCheckState_simpleMessage_success() {\n", "    Preconditions.checkState(true, IGNORE_ME);\n", "  }\n", "\n", "  public void testCheckState_simpleMessage_failure() {\n", "    try {\n", "      Preconditions.checkState(false, new Message());\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalStateException expected) {\n", "      verifySimpleMessage(expected);\n", "    }\n", "  }\n", "\n", "  public void testCheckState_nullMessage_failure() {\n", "    try {\n", "      Preconditions.checkState(false, null);\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalStateException expected) {\n", "      assertThat(expected).hasMessage(\"null\");\n", "    }\n", "  }\n", "\n", "  public void testCheckState_complexMessage_success() {\n", "    Preconditions.checkState(true, \"%s\", IGNORE_ME);\n", "  }\n", "\n", "  public void testCheckState_complexMessage_failure() {\n", "    try {\n", "      Preconditions.checkState(false, FORMAT, 5);\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalStateException expected) {\n", "      verifyComplexMessage(expected);\n", "    }\n", "  }\n", "\n", "  private static final String NON_NULL_STRING = \"foo\";\n", "\n", "  public void testCheckNotNull_simple_success() {\n", "    String result = Preconditions.checkNotNull(NON_NULL_STRING);\n", "    assertSame(NON_NULL_STRING, result);\n", "  }\n", "\n", "  public void testCheckNotNull_simple_failure() {\n", "    try {\n", "      Preconditions.checkNotNull(null);\n", "      fail(\"no exception thrown\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCheckNotNull_simpleMessage_success() {\n", "    String result = Preconditions.checkNotNull(NON_NULL_STRING, IGNORE_ME);\n", "    assertSame(NON_NULL_STRING, result);\n", "  }\n", "\n", "  public void testCheckNotNull_simpleMessage_failure() {\n", "    try {\n", "      Preconditions.checkNotNull(null, new Message());\n", "      fail(\"no exception thrown\");\n", "    } catch (NullPointerException expected) {\n", "      verifySimpleMessage(expected);\n", "    }\n", "  }\n", "\n", "  public void testCheckNotNull_complexMessage_success() {\n", "    String result = Preconditions.checkNotNull(\n", "        NON_NULL_STRING, \"%s\", IGNORE_ME);\n", "    assertSame(NON_NULL_STRING, result);\n", "  }\n", "\n", "  public void testCheckNotNull_complexMessage_failure() {\n", "    try {\n", "      Preconditions.checkNotNull(null, FORMAT, 5);\n", "      fail(\"no exception thrown\");\n", "    } catch (NullPointerException expected) {\n", "      verifyComplexMessage(expected);\n", "    }\n", "  }\n", "\n", "  public void testCheckElementIndex_ok() {\n", "    assertEquals(0, Preconditions.checkElementIndex(0, 1));\n", "    assertEquals(0, Preconditions.checkElementIndex(0, 2));\n", "    assertEquals(1, Preconditions.checkElementIndex(1, 2));\n", "  }\n", "\n", "  public void testCheckElementIndex_badSize() {\n", "    try {\n", "      Preconditions.checkElementIndex(1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      // don't care what the message text is, as this is an invalid usage of\n", "      // the Preconditions class, unlike all the other exceptions it throws\n", "    }\n", "  }\n", "\n", "  public void testCheckElementIndex_negative() {\n", "    try {\n", "      Preconditions.checkElementIndex(-1, 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"index (-1) must not be negative\");\n", "    }\n", "  }\n", "\n", "  public void testCheckElementIndex_tooHigh() {\n", "    try {\n", "      Preconditions.checkElementIndex(1, 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"index (1) must be less than size (1)\");\n", "    }\n", "  }\n", "\n", "  public void testCheckElementIndex_withDesc_negative() {\n", "    try {\n", "      Preconditions.checkElementIndex(-1, 1, \"foo\");\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"foo (-1) must not be negative\");\n", "    }\n", "  }\n", "\n", "  public void testCheckElementIndex_withDesc_tooHigh() {\n", "    try {\n", "      Preconditions.checkElementIndex(1, 1, \"foo\");\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"foo (1) must be less than size (1)\");\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndex_ok() {\n", "    assertEquals(0, Preconditions.checkPositionIndex(0, 0));\n", "    assertEquals(0, Preconditions.checkPositionIndex(0, 1));\n", "    assertEquals(1, Preconditions.checkPositionIndex(1, 1));\n", "  }\n", "\n", "  public void testCheckPositionIndex_badSize() {\n", "    try {\n", "      Preconditions.checkPositionIndex(1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      // don't care what the message text is, as this is an invalid usage of\n", "      // the Preconditions class, unlike all the other exceptions it throws\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndex_negative() {\n", "    try {\n", "      Preconditions.checkPositionIndex(-1, 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"index (-1) must not be negative\");\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndex_tooHigh() {\n", "    try {\n", "      Preconditions.checkPositionIndex(2, 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"index (2) must not be greater than size (1)\");\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndex_withDesc_negative() {\n", "    try {\n", "      Preconditions.checkPositionIndex(-1, 1, \"foo\");\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"foo (-1) must not be negative\");\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndex_withDesc_tooHigh() {\n", "    try {\n", "      Preconditions.checkPositionIndex(2, 1, \"foo\");\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"foo (2) must not be greater than size (1)\");\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndexes_ok() {\n", "    Preconditions.checkPositionIndexes(0, 0, 0);\n", "    Preconditions.checkPositionIndexes(0, 0, 1);\n", "    Preconditions.checkPositionIndexes(0, 1, 1);\n", "    Preconditions.checkPositionIndexes(1, 1, 1);\n", "  }\n", "\n", "  public void testCheckPositionIndexes_badSize() {\n", "    try {\n", "      Preconditions.checkPositionIndexes(1, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndex_startNegative() {\n", "    try {\n", "      Preconditions.checkPositionIndexes(-1, 1, 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"start index (-1) must not be negative\");\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndexes_endTooHigh() {\n", "    try {\n", "      Preconditions.checkPositionIndexes(0, 2, 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"end index (2) must not be greater than size (1)\");\n", "    }\n", "  }\n", "\n", "  public void testCheckPositionIndexes_reversed() {\n", "    try {\n", "      Preconditions.checkPositionIndexes(1, 0, 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      assertThat(expected).hasMessage(\"end index (0) must not be less than start index (1)\");\n", "    }\n", "  }\n", "\n", "  public void testFormat() {\n", "    assertEquals(\"%s\", Preconditions.format(\"%s\"));\n", "    assertEquals(\"5\", Preconditions.format(\"%s\", 5));\n", "    assertEquals(\"foo [5]\", Preconditions.format(\"foo\", 5));\n", "    assertEquals(\"foo [5, 6, 7]\", Preconditions.format(\"foo\", 5, 6, 7));\n", "    assertEquals(\"%s 1 2\", Preconditions.format(\"%s %s %s\", \"%s\", 1, 2));\n", "    assertEquals(\" [5, 6]\", Preconditions.format(\"\", 5, 6));\n", "    assertEquals(\"123\", Preconditions.format(\"%s%s%s\", 1, 2, 3));\n", "    assertEquals(\"1%s%s\", Preconditions.format(\"%s%s%s\", 1));\n", "    assertEquals(\"5 + 6 = 11\", Preconditions.format(\"%s + 6 = 11\", 5));\n", "    assertEquals(\"5 + 6 = 11\", Preconditions.format(\"5 + %s = 11\", 6));\n", "    assertEquals(\"5 + 6 = 11\", Preconditions.format(\"5 + 6 = %s\", 11));\n", "    assertEquals(\"5 + 6 = 11\", Preconditions.format(\"%s + %s = %s\", 5, 6, 11));\n", "    assertEquals(\"null [null, null]\",\n", "        Preconditions.format(\"%s\", null, null, null));\n", "    assertEquals(\"null [5, 6]\", Preconditions.format(null, 5, 6));\n", "  }\n", "\n", "  private static final Object IGNORE_ME = new Object() {\n", "    @Override public String toString() {\n", "      throw new AssertionFailedError();\n", "    }\n", "  };\n", "\n", "  private static class Message {\n", "    boolean invoked;\n", "    @Override public String toString() {\n", "      assertFalse(invoked);\n", "      invoked = true;\n", "      return \"A message\";\n", "    }\n", "  }\n", "\n", "  private static final String FORMAT = \"I ate %s pies.\";\n", "\n", "  private static void verifySimpleMessage(Exception e) {\n", "    assertThat(e).hasMessage(\"A message\");\n", "  }\n", "\n", "  private static void verifyComplexMessage(Exception e) {\n", "    assertThat(e).hasMessage(\"I ate 5 pies.\");\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360]}}, {"75": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/PredicatesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2005 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.base.CharMatcher.WHITESPACE;\n", "import static com.google.common.collect.Lists.newArrayList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.AssertionFailedError;\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link Predicates}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class PredicatesTest extends TestCase {\n", "  private static final Predicate<Integer> TRUE = Predicates.alwaysTrue();\n", "  private static final Predicate<Integer> FALSE = Predicates.alwaysFalse();\n", "  private static final Predicate<Integer> NEVER_REACHED =\n", "      new Predicate<Integer>() {\n", "    @Override\n", "    public boolean apply(Integer i) {\n", "      throw new AssertionFailedError(\n", "          \"This predicate should never have been evaluated\");\n", "    }\n", "  };\n", "\n", "  /** Instantiable predicate with reasonable hashCode() and equals() methods. */\n", "  static class IsOdd implements Predicate<Integer>, Serializable {\n", "    private static final long serialVersionUID = 0x150ddL;\n", "    @Override\n", "    public boolean apply(Integer i) {\n", "      return (i.intValue() & 1) == 1;\n", "    }\n", "    @Override public int hashCode() {\n", "      return 0x150dd;\n", "    }\n", "    @Override public boolean equals(Object obj) {\n", "      return obj instanceof IsOdd;\n", "    }\n", "    @Override public String toString() {\n", "      return \"IsOdd\";\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Generates a new Predicate per call.\n", "   *\n", "   * <p>Creating a new Predicate each time helps catch cases where code is\n", "   * using {@code x == y} instead of {@code x.equals(y)}.\n", "   */\n", "  private static IsOdd isOdd() {\n", "    return new IsOdd();\n", "  }\n", "\n", "  /*\n", "   * Tests for Predicates.alwaysTrue().\n", "   */\n", "\n", "  public void testAlwaysTrue_apply() {\n", "    assertEvalsToTrue(Predicates.alwaysTrue());\n", "  }\n", "\n", "  public void testAlwaysTrue_equality() throws Exception {\n", "    new EqualsTester()\n", "        .addEqualityGroup(TRUE, Predicates.alwaysTrue())\n", "        .addEqualityGroup(isOdd())\n", "        .addEqualityGroup(Predicates.alwaysFalse())\n", "        .testEquals();\n", "  }\n", "\n", "  /*\n", "   * Tests for Predicates.alwaysFalse().\n", "   */\n", "\n", "  public void testAlwaysFalse_apply() throws Exception {\n", "    assertEvalsToFalse(Predicates.alwaysFalse());\n", "  }\n", "\n", "  public void testAlwaysFalse_equality() throws Exception {\n", "    new EqualsTester()\n", "        .addEqualityGroup(FALSE, Predicates.alwaysFalse())\n", "        .addEqualityGroup(isOdd())\n", "        .addEqualityGroup(Predicates.alwaysTrue())\n", "        .testEquals();\n", "  }\n", "\n", "  /*\n", "   * Tests for Predicates.not(predicate).\n", "   */\n", "\n", "  public void testNot_apply() {\n", "    assertEvalsToTrue(Predicates.not(FALSE));\n", "    assertEvalsToFalse(Predicates.not(TRUE));\n", "    assertEvalsLikeOdd(Predicates.not(Predicates.not(isOdd())));\n", "  }\n", "\n", "  public void testNot_equality() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.not(isOdd()), Predicates.not(isOdd()))\n", "        .addEqualityGroup(Predicates.not(TRUE))\n", "        .addEqualityGroup(isOdd())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testNot_equalityForNotOfKnownValues() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(TRUE, Predicates.alwaysTrue())\n", "        .addEqualityGroup(FALSE)\n", "        .addEqualityGroup(Predicates.not(TRUE))\n", "        .testEquals();\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(FALSE, Predicates.alwaysFalse())\n", "        .addEqualityGroup(TRUE)\n", "        .addEqualityGroup(Predicates.not(FALSE))\n", "        .testEquals();\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.isNull(), Predicates.isNull())\n", "        .addEqualityGroup(Predicates.notNull())\n", "        .addEqualityGroup(Predicates.not(Predicates.isNull()))\n", "        .testEquals();\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.notNull(), Predicates.notNull())\n", "        .addEqualityGroup(Predicates.isNull())\n", "        .addEqualityGroup(Predicates.not(Predicates.notNull()))\n", "        .testEquals();\n", "  }\n", "\n", "  /*\n", "   * Tests for all the different flavors of Predicates.and().\n", "   */\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_applyNoArgs() {\n", "    assertEvalsToTrue(Predicates.and());\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_equalityNoArgs() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.and(), Predicates.and())\n", "        .addEqualityGroup(Predicates.and(FALSE))\n", "        .addEqualityGroup(Predicates.or())\n", "        .testEquals();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_applyOneArg() {\n", "    assertEvalsLikeOdd(Predicates.and(isOdd()));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_equalityOneArg() {\n", "    Object[] notEqualObjects = {Predicates.and(NEVER_REACHED, FALSE)};\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Predicates.and(NEVER_REACHED), Predicates.and(NEVER_REACHED))\n", "        .addEqualityGroup(notEqualObjects)\n", "        .addEqualityGroup(Predicates.and(isOdd()))\n", "        .addEqualityGroup(Predicates.and())\n", "        .addEqualityGroup(Predicates.or(NEVER_REACHED))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testAnd_applyBinary() {\n", "    assertEvalsLikeOdd(Predicates.and(isOdd(), TRUE));\n", "    assertEvalsLikeOdd(Predicates.and(TRUE, isOdd()));\n", "    assertEvalsToFalse(Predicates.and(FALSE, NEVER_REACHED));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_equalityBinary() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Predicates.and(TRUE, NEVER_REACHED),\n", "            Predicates.and(TRUE, NEVER_REACHED))\n", "        .addEqualityGroup(Predicates.and(NEVER_REACHED, TRUE))\n", "        .addEqualityGroup(Predicates.and(TRUE))\n", "        .addEqualityGroup(Predicates.or(TRUE, NEVER_REACHED))\n", "        .testEquals();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_applyTernary() {\n", "    assertEvalsLikeOdd(Predicates.and(isOdd(), TRUE, TRUE));\n", "    assertEvalsLikeOdd(Predicates.and(TRUE, isOdd(), TRUE));\n", "    assertEvalsLikeOdd(Predicates.and(TRUE, TRUE, isOdd()));\n", "    assertEvalsToFalse(Predicates.and(TRUE, FALSE, NEVER_REACHED));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_equalityTernary() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Predicates.and(TRUE, isOdd(), NEVER_REACHED),\n", "            Predicates.and(TRUE, isOdd(), NEVER_REACHED))\n", "        .addEqualityGroup(Predicates.and(isOdd(), NEVER_REACHED, TRUE))\n", "        .addEqualityGroup(Predicates.and(TRUE))\n", "        .addEqualityGroup(Predicates.or(TRUE, isOdd(), NEVER_REACHED))\n", "        .testEquals();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_applyIterable() {\n", "    Collection<Predicate<Integer>> empty = Arrays.asList();\n", "    assertEvalsToTrue(Predicates.and(empty));\n", "    assertEvalsLikeOdd(Predicates.and(Arrays.asList(isOdd())));\n", "    assertEvalsLikeOdd(Predicates.and(Arrays.asList(TRUE, isOdd())));\n", "    assertEvalsToFalse(Predicates.and(Arrays.asList(FALSE, NEVER_REACHED)));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_equalityIterable() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Predicates.and(Arrays.asList(TRUE, NEVER_REACHED)),\n", "            Predicates.and(Arrays.asList(TRUE, NEVER_REACHED)),\n", "            Predicates.and(TRUE, NEVER_REACHED))\n", "        .addEqualityGroup(Predicates.and(FALSE, NEVER_REACHED))\n", "        .addEqualityGroup(Predicates.or(TRUE, NEVER_REACHED))\n", "        .testEquals();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testAnd_arrayDefensivelyCopied() {\n", "    Predicate[] array = {Predicates.alwaysFalse()};\n", "    Predicate<Object> predicate = Predicates.and(array);\n", "    assertFalse(predicate.apply(1));\n", "    array[0] = Predicates.alwaysTrue();\n", "    assertFalse(predicate.apply(1));\n", "  }\n", "\n", "  public void testAnd_listDefensivelyCopied() {\n", "    List<Predicate<Object>> list = newArrayList();\n", "    Predicate<Object> predicate = Predicates.and(list);\n", "    assertTrue(predicate.apply(1));\n", "    list.add(Predicates.alwaysFalse());\n", "    assertTrue(predicate.apply(1));\n", "  }\n", "\n", "  public void testAnd_iterableDefensivelyCopied() {\n", "    final List<Predicate<Object>> list = newArrayList();\n", "    Iterable<Predicate<Object>> iterable = new Iterable<Predicate<Object>>() {\n", "      @Override\n", "      public Iterator<Predicate<Object>> iterator() {\n", "        return list.iterator();\n", "      }\n", "    };\n", "    Predicate<Object> predicate = Predicates.and(iterable);\n", "    assertTrue(predicate.apply(1));\n", "    list.add(Predicates.alwaysFalse());\n", "    assertTrue(predicate.apply(1));\n", "  }\n", "\n", "  /*\n", "   * Tests for all the different flavors of Predicates.or().\n", "   */\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_applyNoArgs() {\n", "    assertEvalsToFalse(Predicates.or());\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_equalityNoArgs() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.or(), Predicates.or())\n", "        .addEqualityGroup(Predicates.or(TRUE))\n", "        .addEqualityGroup(Predicates.and())\n", "        .testEquals();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_applyOneArg() {\n", "    assertEvalsToTrue(Predicates.or(TRUE));\n", "    assertEvalsToFalse(Predicates.or(FALSE));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_equalityOneArg() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Predicates.or(NEVER_REACHED), Predicates.or(NEVER_REACHED))\n", "        .addEqualityGroup(Predicates.or(NEVER_REACHED, TRUE))\n", "        .addEqualityGroup(Predicates.or(TRUE))\n", "        .addEqualityGroup(Predicates.or())\n", "        .addEqualityGroup(Predicates.and(NEVER_REACHED))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testOr_applyBinary() {\n", "    Predicate<Integer> falseOrFalse = Predicates.or(FALSE, FALSE);\n", "    Predicate<Integer> falseOrTrue = Predicates.or(FALSE, TRUE);\n", "    Predicate<Integer> trueOrAnything = Predicates.or(TRUE, NEVER_REACHED);\n", "\n", "    assertEvalsToFalse(falseOrFalse);\n", "    assertEvalsToTrue(falseOrTrue);\n", "    assertEvalsToTrue(trueOrAnything);\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_equalityBinary() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Predicates.or(FALSE, NEVER_REACHED),\n", "            Predicates.or(FALSE, NEVER_REACHED))\n", "        .addEqualityGroup(Predicates.or(NEVER_REACHED, FALSE))\n", "        .addEqualityGroup(Predicates.or(TRUE))\n", "        .addEqualityGroup(Predicates.and(FALSE, NEVER_REACHED))\n", "        .testEquals();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_applyTernary() {\n", "    assertEvalsLikeOdd(Predicates.or(isOdd(), FALSE, FALSE));\n", "    assertEvalsLikeOdd(Predicates.or(FALSE, isOdd(), FALSE));\n", "    assertEvalsLikeOdd(Predicates.or(FALSE, FALSE, isOdd()));\n", "    assertEvalsToTrue(Predicates.or(FALSE, TRUE, NEVER_REACHED));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_equalityTernary() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Predicates.or(FALSE, NEVER_REACHED, TRUE),\n", "            Predicates.or(FALSE, NEVER_REACHED, TRUE))\n", "        .addEqualityGroup(Predicates.or(TRUE, NEVER_REACHED, FALSE))\n", "        .addEqualityGroup(Predicates.or(TRUE))\n", "        .addEqualityGroup(Predicates.and(FALSE, NEVER_REACHED, TRUE))\n", "        .testEquals();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_applyIterable() {\n", "    Predicate<Integer> vacuouslyFalse =\n", "        Predicates.or(Collections.<Predicate<Integer>>emptyList());\n", "    Predicate<Integer> troo = Predicates.or(Collections.singletonList(TRUE));\n", "    /*\n", "     * newLinkedList() takes varargs. TRUE and FALSE are both instances of\n", "     * Predicate<Integer>, so the call is safe.\n", "     */\n", "    Predicate<Integer> trueAndFalse = Predicates.or(Arrays.asList(TRUE, FALSE));\n", "\n", "    assertEvalsToFalse(vacuouslyFalse);\n", "    assertEvalsToTrue(troo);\n", "    assertEvalsToTrue(trueAndFalse);\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_equalityIterable() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Predicates.or(Arrays.asList(FALSE, NEVER_REACHED)),\n", "            Predicates.or(Arrays.asList(FALSE, NEVER_REACHED)),\n", "            Predicates.or(FALSE, NEVER_REACHED))\n", "        .addEqualityGroup(Predicates.or(TRUE, NEVER_REACHED))\n", "        .addEqualityGroup(Predicates.and(FALSE, NEVER_REACHED))\n", "        .testEquals();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testOr_arrayDefensivelyCopied() {\n", "    Predicate[] array = {Predicates.alwaysFalse()};\n", "    Predicate<Object> predicate = Predicates.or(array);\n", "    assertFalse(predicate.apply(1));\n", "    array[0] = Predicates.alwaysTrue();\n", "    assertFalse(predicate.apply(1));\n", "  }\n", "\n", "  public void testOr_listDefensivelyCopied() {\n", "    List<Predicate<Object>> list = newArrayList();\n", "    Predicate<Object> predicate = Predicates.or(list);\n", "    assertFalse(predicate.apply(1));\n", "    list.add(Predicates.alwaysTrue());\n", "    assertFalse(predicate.apply(1));\n", "  }\n", "\n", "  public void testOr_iterableDefensivelyCopied() {\n", "    final List<Predicate<Object>> list = newArrayList();\n", "    Iterable<Predicate<Object>> iterable = new Iterable<Predicate<Object>>() {\n", "      @Override\n", "      public Iterator<Predicate<Object>> iterator() {\n", "        return list.iterator();\n", "      }\n", "    };\n", "    Predicate<Object> predicate = Predicates.or(iterable);\n", "    assertFalse(predicate.apply(1));\n", "    list.add(Predicates.alwaysTrue());\n", "    assertFalse(predicate.apply(1));\n", "  }\n", "\n", "  /*\n", "   * Tests for Predicates.equalTo(x).\n", "   */\n", "\n", "  public void testIsEqualTo_apply() {\n", "    Predicate<Integer> isOne = Predicates.equalTo(1);\n", "\n", "    assertTrue(isOne.apply(1));\n", "    assertFalse(isOne.apply(2));\n", "    assertFalse(isOne.apply(null));\n", "  }\n", "\n", "  public void testIsEqualTo_equality() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.equalTo(1), Predicates.equalTo(1))\n", "        .addEqualityGroup(Predicates.equalTo(2))\n", "        .addEqualityGroup(Predicates.equalTo(null))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testIsEqualToNull_apply() {\n", "    Predicate<Integer> isNull = Predicates.equalTo(null);\n", "    assertTrue(isNull.apply(null));\n", "    assertFalse(isNull.apply(1));\n", "  }\n", "\n", "  public void testIsEqualToNull_equality() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.equalTo(null), Predicates.equalTo(null))\n", "        .addEqualityGroup(Predicates.equalTo(1))\n", "        .addEqualityGroup(Predicates.equalTo(\"null\"))\n", "        .testEquals();\n", "  }\n", "\n", "  /*\n", "   * Tests for Predicates.isNull()\n", "   */\n", "\n", "  public void testIsNull_apply() {\n", "    Predicate<Integer> isNull = Predicates.isNull();\n", "    assertTrue(isNull.apply(null));\n", "    assertFalse(isNull.apply(1));\n", "  }\n", "\n", "  public void testIsNull_equality() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.isNull(), Predicates.isNull())\n", "        .addEqualityGroup(Predicates.notNull())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testNotNull_apply() {\n", "    Predicate<Integer> notNull = Predicates.notNull();\n", "    assertFalse(notNull.apply(null));\n", "    assertTrue(notNull.apply(1));\n", "  }\n", "\n", "  public void testNotNull_equality() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.notNull(), Predicates.notNull())\n", "        .addEqualityGroup(Predicates.isNull())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testIn_apply() {\n", "    Collection<Integer> nums = Arrays.asList(1, 5);\n", "    Predicate<Integer> isOneOrFive = Predicates.in(nums);\n", "\n", "    assertTrue(isOneOrFive.apply(1));\n", "    assertTrue(isOneOrFive.apply(5));\n", "    assertFalse(isOneOrFive.apply(3));\n", "    assertFalse(isOneOrFive.apply(null));\n", "  }\n", "\n", "  public void testIn_equality() {\n", "    Collection<Integer> nums = ImmutableSet.of(1, 5);\n", "    Collection<Integer> sameOrder = ImmutableSet.of(1, 5);\n", "    Collection<Integer> differentOrder = ImmutableSet.of(5, 1);\n", "    Collection<Integer> differentNums = ImmutableSet.of(1, 3, 5);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(Predicates.in(nums), Predicates.in(nums),\n", "            Predicates.in(sameOrder), Predicates.in(differentOrder))\n", "        .addEqualityGroup(Predicates.in(differentNums))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testIn_handlesNullPointerException() {\n", "    class CollectionThatThrowsNPE<T> extends ArrayList<T> {\n", "      private static final long serialVersionUID = 1L;\n", "\n", "      @Override public boolean contains(Object element) {\n", "        Preconditions.checkNotNull(element);\n", "        return super.contains(element);\n", "      }\n", "    }\n", "    Collection<Integer> nums = new CollectionThatThrowsNPE<Integer>();\n", "    Predicate<Integer> isFalse = Predicates.in(nums);\n", "    assertFalse(isFalse.apply(null));\n", "  }\n", "\n", "  public void testIn_handlesClassCastException() {\n", "    class CollectionThatThrowsCCE<T> extends ArrayList<T> {\n", "      private static final long serialVersionUID = 1L;\n", "\n", "      @Override public boolean contains(Object element) {\n", "        throw new ClassCastException(\"\");\n", "      }\n", "    }\n", "    Collection<Integer> nums = new CollectionThatThrowsCCE<Integer>();\n", "    nums.add(3);\n", "    Predicate<Integer> isThree = Predicates.in(nums);\n", "    assertFalse(isThree.apply(3));\n", "  }\n", "\n", "  /*\n", "   * Tests that compilation will work when applying explicit types.\n", "   */\n", "  @SuppressWarnings(\"unused\") // compilation test\n", "  public void testIn_compilesWithExplicitSupertype() {\n", "    Collection<Number> nums = ImmutableSet.of();\n", "    Predicate<Number> p1 = Predicates.in(nums);\n", "    Predicate<Object> p2 = Predicates.<Object>in(nums);\n", "    // The next two lines are not expected to compile.\n", "    // Predicate<Integer> p3 = Predicates.in(nums);\n", "    // Predicate<Integer> p4 = Predicates.<Integer>in(nums);\n", "  }\n", "\n", "  // enum singleton pattern\n", "  private enum TrimStringFunction implements Function<String, String> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public String apply(String string) {\n", "      return WHITESPACE.trimFrom(string);\n", "    }\n", "  }\n", "\n", "  public void testCompose() {\n", "    Function<String, String> trim = TrimStringFunction.INSTANCE;\n", "    Predicate<String> equalsFoo = Predicates.equalTo(\"Foo\");\n", "    Predicate<String> equalsBar = Predicates.equalTo(\"Bar\");\n", "    Predicate<String> trimEqualsFoo = Predicates.compose(equalsFoo, trim);\n", "    Function<String, String> identity = Functions.identity();\n", "\n", "    assertTrue(trimEqualsFoo.apply(\"Foo\"));\n", "    assertTrue(trimEqualsFoo.apply(\"   Foo   \"));\n", "    assertFalse(trimEqualsFoo.apply(\"Foo-b-que\"));\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(trimEqualsFoo, Predicates.compose(equalsFoo, trim))\n", "        .addEqualityGroup(equalsFoo)\n", "        .addEqualityGroup(trim)\n", "        .addEqualityGroup(Predicates.compose(equalsFoo, identity))\n", "        .addEqualityGroup(Predicates.compose(equalsBar, trim))\n", "        .testEquals();\n", "  }\n", "\n", "  public void assertEqualHashCode(\n", "      Predicate<? super Integer> expected, Predicate<? super Integer> actual) {\n", "    assertEquals(actual + \" should hash like \" + expected, expected.hashCode(), actual.hashCode());\n", "  }\n", "\n", "  public void testHashCodeForBooleanOperations() {\n", "    Predicate<Integer> p1 = Predicates.isNull();\n", "    Predicate<Integer> p2 = isOdd();\n", "\n", "    // Make sure that hash codes are not computed per-instance.\n", "    assertEqualHashCode(\n", "        Predicates.not(p1),\n", "        Predicates.not(p1));\n", "\n", "    assertEqualHashCode(\n", "        Predicates.and(p1, p2),\n", "        Predicates.and(p1, p2));\n", "\n", "    assertEqualHashCode(\n", "        Predicates.or(p1, p2),\n", "        Predicates.or(p1, p2));\n", "\n", "    // While not a contractual requirement, we'd like the hash codes for ands\n", "    // & ors of the same predicates to not collide.\n", "    assertTrue(Predicates.and(p1, p2).hashCode() != Predicates.or(p1, p2).hashCode());\n", "  }\n", "\n", "  private static void assertEvalsToTrue(Predicate<? super Integer> predicate) {\n", "    assertTrue(predicate.apply(0));\n", "    assertTrue(predicate.apply(1));\n", "    assertTrue(predicate.apply(null));\n", "  }\n", "\n", "  private static void assertEvalsToFalse(Predicate<? super Integer> predicate) {\n", "    assertFalse(predicate.apply(0));\n", "    assertFalse(predicate.apply(1));\n", "    assertFalse(predicate.apply(null));\n", "  }\n", "\n", "  private static void assertEvalsLikeOdd(Predicate<? super Integer> predicate) {\n", "    assertEvalsLike(isOdd(), predicate);\n", "  }\n", "\n", "  private static void assertEvalsLike(\n", "      Predicate<? super Integer> expected,\n", "      Predicate<? super Integer> actual) {\n", "    assertEvalsLike(expected, actual, 0);\n", "    assertEvalsLike(expected, actual, 1);\n", "    assertEvalsLike(expected, actual, null);\n", "  }\n", "\n", "  private static <T> void assertEvalsLike(\n", "      Predicate<? super T> expected,\n", "      Predicate<? super T> actual,\n", "      T input) {\n", "    Boolean expectedResult = null;\n", "    RuntimeException expectedRuntimeException = null;\n", "    try {\n", "      expectedResult = expected.apply(input);\n", "    } catch (RuntimeException e) {\n", "      expectedRuntimeException = e;\n", "    }\n", "\n", "    Boolean actualResult = null;\n", "    RuntimeException actualRuntimeException = null;\n", "    try {\n", "      actualResult = actual.apply(input);\n", "    } catch (RuntimeException e) {\n", "      actualRuntimeException = e;\n", "    }\n", "\n", "    assertEquals(expectedResult, actualResult);\n", "    if (expectedRuntimeException != null) {\n", "      assertNotNull(actualRuntimeException);\n", "      assertEquals(\n", "          expectedRuntimeException.getClass(),\n", "          actualRuntimeException.getClass());\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660]}}, {"76": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/SplitterTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableMap;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Map;\n", "\n", "/**\n", " * @author Julien Silland\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SplitterTest extends TestCase {\n", "\n", "  private static final Splitter COMMA_SPLITTER = Splitter.on(',');\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testSplitNullString() {\n", "    try {\n", "      COMMA_SPLITTER.split(null);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCharacterSimpleSplit() {\n", "    String simple = \"a,b,c\";\n", "    Iterable<String> letters = COMMA_SPLITTER.split(simple);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  /**\n", "   * All of the infrastructure of split and splitToString is identical, so we\n", "   * do one test of splitToString. All other cases should be covered by testing\n", "   * of split.\n", "   *\n", "   * <p>TODO(user): It would be good to make all the relevant tests run on\n", "   * both split and splitToString automatically.\n", "   */\n", "  public void testCharacterSimpleSplitToList() {\n", "    String simple = \"a,b,c\";\n", "    List<String> letters = COMMA_SPLITTER.splitToList(simple);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testToString() {\n", "    assertEquals(\"[]\", Splitter.on(',').split(\"\").toString());\n", "    assertEquals(\"[a, b, c]\", Splitter.on(',').split(\"a,b,c\").toString());\n", "    assertEquals(\"[yam, bam, jam, ham]\", Splitter.on(\", \").split(\"yam, bam, jam, ham\").toString());\n", "  }\n", "\n", "  public void testCharacterSimpleSplitWithNoDelimiter() {\n", "    String simple = \"a,b,c\";\n", "    Iterable<String> letters = Splitter.on('.').split(simple);\n", "    assertThat(letters).containsExactly(\"a,b,c\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitWithDoubleDelimiter() {\n", "    String doubled = \"a,,b,c\";\n", "    Iterable<String> letters = COMMA_SPLITTER.split(doubled);\n", "    assertThat(letters).containsExactly(\"a\", \"\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitWithDoubleDelimiterAndSpace() {\n", "    String doubled = \"a,, b,c\";\n", "    Iterable<String> letters = COMMA_SPLITTER.split(doubled);\n", "    assertThat(letters).containsExactly(\"a\", \"\", \" b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitWithTrailingDelimiter() {\n", "    String trailing = \"a,b,c,\";\n", "    Iterable<String> letters = COMMA_SPLITTER.split(trailing);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitWithLeadingDelimiter() {\n", "    String leading = \",a,b,c\";\n", "    Iterable<String> letters = COMMA_SPLITTER.split(leading);\n", "    assertThat(letters).containsExactly(\"\", \"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitWithMulitpleLetters() {\n", "    Iterable<String> testCharacteringMotto = Splitter.on('-').split(\n", "        \"Testing-rocks-Debugging-sucks\");\n", "    assertThat(testCharacteringMotto)\n", "        .containsExactly(\"Testing\", \"rocks\", \"Debugging\", \"sucks\")\n", "        .inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitWithMatcherDelimiter() {\n", "    Iterable<String> testCharacteringMotto = Splitter\n", "        .on(CharMatcher.WHITESPACE)\n", "        .split(\"Testing\\nrocks\\tDebugging sucks\");\n", "    assertThat(testCharacteringMotto)\n", "        .containsExactly(\"Testing\", \"rocks\", \"Debugging\", \"sucks\")\n", "        .inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitWithDoubleDelimiterOmitEmptyStrings() {\n", "    String doubled = \"a..b.c\";\n", "    Iterable<String> letters = Splitter.on('.')\n", "        .omitEmptyStrings().split(doubled);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitEmptyToken() {\n", "    String emptyToken = \"a. .c\";\n", "    Iterable<String> letters = Splitter.on('.').trimResults()\n", "        .split(emptyToken);\n", "    assertThat(letters).containsExactly(\"a\", \"\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitEmptyTokenOmitEmptyStrings() {\n", "    String emptyToken = \"a. .c\";\n", "    Iterable<String> letters = Splitter.on('.')\n", "        .omitEmptyStrings().trimResults().split(emptyToken);\n", "    assertThat(letters).containsExactly(\"a\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitOnEmptyString() {\n", "    Iterable<String> nothing = Splitter.on('.').split(\"\");\n", "    assertThat(nothing).containsExactly(\"\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitOnEmptyStringOmitEmptyStrings() {\n", "    assertThat(Splitter.on('.').omitEmptyStrings().split(\"\")).isEmpty();\n", "  }\n", "\n", "  public void testCharacterSplitOnOnlyDelimiter() {\n", "    Iterable<String> blankblank = Splitter.on('.').split(\".\");\n", "    assertThat(blankblank).containsExactly(\"\", \"\").inOrder();\n", "  }\n", "\n", "  public void testCharacterSplitOnOnlyDelimitersOmitEmptyStrings() {\n", "    Iterable<String> empty = Splitter.on('.').omitEmptyStrings().split(\"...\");\n", "    assertThat(empty).isEmpty();\n", "  }\n", "\n", "  public void testCharacterSplitWithTrim() {\n", "    String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \"\n", "        + \"ofar(Jemaine), aff(Tito)\";\n", "    Iterable<String> family = COMMA_SPLITTER\n", "        .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE))\n", "        .split(jacksons);\n", "    assertThat(family)\n", "        .containsExactly(\"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\")\n", "        .inOrder();\n", "  }\n", "\n", "  public void testStringSimpleSplit() {\n", "    String simple = \"a,b,c\";\n", "    Iterable<String> letters = Splitter.on(',').split(simple);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSimpleSplitWithNoDelimiter() {\n", "    String simple = \"a,b,c\";\n", "    Iterable<String> letters = Splitter.on('.').split(simple);\n", "    assertThat(letters).containsExactly(\"a,b,c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithDoubleDelimiter() {\n", "    String doubled = \"a,,b,c\";\n", "    Iterable<String> letters = Splitter.on(',').split(doubled);\n", "    assertThat(letters).containsExactly(\"a\", \"\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithDoubleDelimiterAndSpace() {\n", "    String doubled = \"a,, b,c\";\n", "    Iterable<String> letters = Splitter.on(',').split(doubled);\n", "    assertThat(letters).containsExactly(\"a\", \"\", \" b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithTrailingDelimiter() {\n", "    String trailing = \"a,b,c,\";\n", "    Iterable<String> letters = Splitter.on(',').split(trailing);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithLeadingDelimiter() {\n", "    String leading = \",a,b,c\";\n", "    Iterable<String> letters = Splitter.on(',').split(leading);\n", "    assertThat(letters).containsExactly(\"\", \"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithMultipleLetters() {\n", "    Iterable<String> testStringingMotto = Splitter.on('-').split(\n", "        \"Testing-rocks-Debugging-sucks\");\n", "    assertThat(testStringingMotto)\n", "        .containsExactly(\"Testing\", \"rocks\", \"Debugging\", \"sucks\")\n", "        .inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithDoubleDelimiterOmitEmptyStrings() {\n", "    String doubled = \"a..b.c\";\n", "    Iterable<String> letters = Splitter.on('.')\n", "        .omitEmptyStrings().split(doubled);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitEmptyToken() {\n", "    String emptyToken = \"a. .c\";\n", "    Iterable<String> letters = Splitter.on('.').trimResults()\n", "        .split(emptyToken);\n", "    assertThat(letters).containsExactly(\"a\", \"\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitEmptyTokenOmitEmptyStrings() {\n", "    String emptyToken = \"a. .c\";\n", "    Iterable<String> letters = Splitter.on('.')\n", "        .omitEmptyStrings().trimResults().split(emptyToken);\n", "    assertThat(letters).containsExactly(\"a\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithLongDelimiter() {\n", "    String longDelimiter = \"a, b, c\";\n", "    Iterable<String> letters = Splitter.on(\", \").split(longDelimiter);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithLongLeadingDelimiter() {\n", "    String longDelimiter = \", a, b, c\";\n", "    Iterable<String> letters = Splitter.on(\", \").split(longDelimiter);\n", "    assertThat(letters).containsExactly(\"\", \"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithLongTrailingDelimiter() {\n", "    String longDelimiter = \"a, b, c, \";\n", "    Iterable<String> letters = Splitter.on(\", \").split(longDelimiter);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitWithDelimiterSubstringInValue() {\n", "    String fourCommasAndFourSpaces = \",,,,    \";\n", "    Iterable<String> threeCommasThenThreeSpaces = Splitter.on(\", \").split(\n", "        fourCommasAndFourSpaces);\n", "    assertThat(threeCommasThenThreeSpaces).containsExactly(\",,,\", \"   \").inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testStringSplitWithEmptyString() {\n", "    try {\n", "      Splitter.on(\"\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testStringSplitOnEmptyString() {\n", "    Iterable<String> notMuch = Splitter.on('.').split(\"\");\n", "    assertThat(notMuch).containsExactly(\"\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitOnEmptyStringOmitEmptyString() {\n", "    assertThat(Splitter.on('.').omitEmptyStrings().split(\"\")).isEmpty();\n", "  }\n", "\n", "  public void testStringSplitOnOnlyDelimiter() {\n", "    Iterable<String> blankblank = Splitter.on('.').split(\".\");\n", "    assertThat(blankblank).containsExactly(\"\", \"\").inOrder();\n", "  }\n", "\n", "  public void testStringSplitOnOnlyDelimitersOmitEmptyStrings() {\n", "    Iterable<String> empty = Splitter.on('.').omitEmptyStrings().split(\"...\");\n", "    assertThat(empty).isEmpty();\n", "  }\n", "\n", "  public void testStringSplitWithTrim() {\n", "    String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \"\n", "        + \"ofar(Jemaine), aff(Tito)\";\n", "    Iterable<String> family = Splitter.on(',')\n", "        .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE))\n", "        .split(jacksons);\n", "    assertThat(family)\n", "        .containsExactly(\"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\")\n", "        .inOrder();\n", "  }\n", "\n", "  // TODO(kevinb): the name of this method suggests it might not actually be testing what it\n", "  // intends to be testing?\n", "\n", "  public void testSplitterIterableIsUnmodifiable_char() {\n", "    assertIteratorIsUnmodifiable(COMMA_SPLITTER.split(\"a,b\").iterator());\n", "  }\n", "\n", "  public void testSplitterIterableIsUnmodifiable_string() {\n", "    assertIteratorIsUnmodifiable(Splitter.on(',').split(\"a,b\").iterator());\n", "  }\n", "\n", "  private void assertIteratorIsUnmodifiable(Iterator<?> iterator) {\n", "    iterator.next();\n", "    try {\n", "      iterator.remove();\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testSplitterIterableIsLazy_char() {\n", "    assertSplitterIterableIsLazy(COMMA_SPLITTER);\n", "  }\n", "\n", "  public void testSplitterIterableIsLazy_string() {\n", "    assertSplitterIterableIsLazy(Splitter.on(','));\n", "  }\n", "\n", "  /**\n", "   * This test really pushes the boundaries of what we support. In general the\n", "   * splitter's behaviour is not well defined if the char sequence it's\n", "   * splitting is mutated during iteration.\n", "   */\n", "  private void assertSplitterIterableIsLazy(Splitter splitter) {\n", "    StringBuilder builder = new StringBuilder();\n", "    Iterator<String> iterator = splitter.split(builder).iterator();\n", "\n", "    builder.append(\"A,\");\n", "    assertEquals(\"A\", iterator.next());\n", "    builder.append(\"B,\");\n", "    assertEquals(\"B\", iterator.next());\n", "    builder.append(\"C\");\n", "    assertEquals(\"C\", iterator.next());\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testFixedLengthSimpleSplit() {\n", "    String simple = \"abcde\";\n", "    Iterable<String> letters = Splitter.fixedLength(2).split(simple);\n", "    assertThat(letters).containsExactly(\"ab\", \"cd\", \"e\").inOrder();\n", "  }\n", "\n", "  public void testFixedLengthSplitEqualChunkLength() {\n", "    String simple = \"abcdef\";\n", "    Iterable<String> letters = Splitter.fixedLength(2).split(simple);\n", "    assertThat(letters).containsExactly(\"ab\", \"cd\", \"ef\").inOrder();\n", "  }\n", "\n", "  public void testFixedLengthSplitOnlyOneChunk() {\n", "    String simple = \"abc\";\n", "    Iterable<String> letters = Splitter.fixedLength(3).split(simple);\n", "    assertThat(letters).containsExactly(\"abc\").inOrder();\n", "  }\n", "\n", "  public void testFixedLengthSplitSmallerString() {\n", "    String simple = \"ab\";\n", "    Iterable<String> letters = Splitter.fixedLength(3).split(simple);\n", "    assertThat(letters).containsExactly(\"ab\").inOrder();\n", "  }\n", "\n", "  public void testFixedLengthSplitEmptyString() {\n", "    String simple = \"\";\n", "    Iterable<String> letters = Splitter.fixedLength(3).split(simple);\n", "    assertThat(letters).containsExactly(\"\").inOrder();\n", "  }\n", "\n", "  public void testFixedLengthSplitEmptyStringWithOmitEmptyStrings() {\n", "    assertThat(Splitter.fixedLength(3).omitEmptyStrings().split(\"\")).isEmpty();\n", "  }\n", "\n", "  public void testFixedLengthSplitIntoChars() {\n", "    String simple = \"abcd\";\n", "    Iterable<String> letters = Splitter.fixedLength(1).split(simple);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"d\").inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testFixedLengthSplitZeroChunkLen() {\n", "    try {\n", "      Splitter.fixedLength(0);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testFixedLengthSplitNegativeChunkLen() {\n", "    try {\n", "      Splitter.fixedLength(-1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testLimitLarge() {\n", "    String simple = \"abcd\";\n", "    Iterable<String> letters = Splitter.fixedLength(1).limit(100).split(simple);\n", "    assertThat(letters).containsExactly(\"a\", \"b\", \"c\", \"d\").inOrder();\n", "  }\n", "\n", "  public void testLimitOne() {\n", "    String simple = \"abcd\";\n", "    Iterable<String> letters = Splitter.fixedLength(1).limit(1).split(simple);\n", "    assertThat(letters).containsExactly(\"abcd\").inOrder();\n", "  }\n", "\n", "  public void testLimitFixedLength() {\n", "    String simple = \"abcd\";\n", "    Iterable<String> letters = Splitter.fixedLength(1).limit(2).split(simple);\n", "    assertThat(letters).containsExactly(\"a\", \"bcd\").inOrder();\n", "  }\n", "\n", "  public void testLimitSeparator() {\n", "    String simple = \"a,b,c,d\";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(2).split(simple);\n", "    assertThat(items).containsExactly(\"a\", \"b,c,d\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparators() {\n", "    String text = \"a,,,b,,c,d\";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(2).split(text);\n", "    assertThat(items).containsExactly(\"a\", \",,b,,c,d\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparatorsOmitEmpty() {\n", "    String text = \"a,,,b,,c,d\";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(2).omitEmptyStrings().split(text);\n", "    assertThat(items).containsExactly(\"a\", \"b,,c,d\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparatorsOmitEmpty3() {\n", "    String text = \"a,,,b,,c,d\";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(3).omitEmptyStrings().split(text);\n", "    assertThat(items).containsExactly(\"a\", \"b\", \"c,d\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparatorsTrim() {\n", "    String text = \",,a,,  , b ,, c,d \";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(2).omitEmptyStrings().trimResults().split(text);\n", "    assertThat(items).containsExactly(\"a\", \"b ,, c,d\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparatorsTrim3() {\n", "    String text = \",,a,,  , b ,, c,d \";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(3).omitEmptyStrings().trimResults().split(text);\n", "    assertThat(items).containsExactly(\"a\", \"b\", \"c,d\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparatorsTrim1() {\n", "    String text = \",,a,,  , b ,, c,d \";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(1).omitEmptyStrings().trimResults().split(text);\n", "    assertThat(items).containsExactly(\"a,,  , b ,, c,d\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparatorsTrim1NoOmit() {\n", "    String text = \",,a,,  , b ,, c,d \";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(1).trimResults().split(text);\n", "    assertThat(items).containsExactly(\",,a,,  , b ,, c,d\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparatorsTrim1Empty() {\n", "    String text = \"\";\n", "    Iterable<String> items = COMMA_SPLITTER.limit(1).split(text);\n", "    assertThat(items).containsExactly(\"\").inOrder();\n", "  }\n", "\n", "  public void testLimitExtraSeparatorsTrim1EmptyOmit() {\n", "    String text = \"\";\n", "    Iterable<String> items = COMMA_SPLITTER.omitEmptyStrings().limit(1).split(text);\n", "    assertThat(items).isEmpty();\n", "  }\n", "\n", "  @SuppressWarnings(\"ReturnValueIgnored\") // testing for exception\n", "  public void testInvalidZeroLimit() {\n", "    try {\n", "      COMMA_SPLITTER.limit(0);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMapSplitter_trimmedBoth() {\n", "    Map<String, String> m = COMMA_SPLITTER\n", "        .trimResults()\n", "        .withKeyValueSeparator(Splitter.on(':').trimResults())\n", "        .split(\"boy  : tom , girl: tina , cat  : kitty , dog: tommy \");\n", "    ImmutableMap<String, String> expected =\n", "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");\n", "    assertThat(m).isEqualTo(expected);\n", "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n", "  }\n", "\n", "  public void testMapSplitter_trimmedEntries() {\n", "    Map<String, String> m = COMMA_SPLITTER\n", "        .trimResults()\n", "        .withKeyValueSeparator(\":\")\n", "        .split(\"boy  : tom , girl: tina , cat  : kitty , dog: tommy \");\n", "    ImmutableMap<String, String> expected =\n", "        ImmutableMap.of(\"boy  \", \" tom\", \"girl\", \" tina\", \"cat  \", \" kitty\", \"dog\", \" tommy\");\n", "\n", "    assertThat(m).isEqualTo(expected);\n", "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n", "  }\n", "\n", "  public void testMapSplitter_trimmedKeyValue() {\n", "    Map<String, String> m =\n", "        COMMA_SPLITTER.withKeyValueSeparator(Splitter.on(':').trimResults()).split(\n", "            \"boy  : tom , girl: tina , cat  : kitty , dog: tommy \");\n", "    ImmutableMap<String, String> expected =\n", "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");\n", "    assertThat(m).isEqualTo(expected);\n", "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n", "  }\n", "\n", "  public void testMapSplitter_notTrimmed() {\n", "    Map<String, String> m = COMMA_SPLITTER.withKeyValueSeparator(\":\").split(\n", "        \" boy:tom , girl: tina , cat :kitty , dog:  tommy \");\n", "    ImmutableMap<String, String> expected =\n", "        ImmutableMap.of(\" boy\", \"tom \", \" girl\", \" tina \", \" cat \", \"kitty \", \" dog\", \"  tommy \");\n", "    assertThat(m).isEqualTo(expected);\n", "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n", "  }\n", "\n", "  public void testMapSplitter_CharacterSeparator() {\n", "    // try different delimiters.\n", "    Map<String, String> m = Splitter\n", "        .on(\",\")\n", "        .withKeyValueSeparator(':')\n", "        .split(\"boy:tom,girl:tina,cat:kitty,dog:tommy\");\n", "    ImmutableMap<String, String> expected =\n", "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");\n", "\n", "    assertThat(m).isEqualTo(expected);\n", "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n", "  }\n", "\n", "  public void testMapSplitter_multiCharacterSeparator() {\n", "    // try different delimiters.\n", "    Map<String, String> m = Splitter\n", "        .on(\",\")\n", "        .withKeyValueSeparator(\":^&\")\n", "        .split(\"boy:^&tom,girl:^&tina,cat:^&kitty,dog:^&tommy\");\n", "    ImmutableMap<String, String> expected =\n", "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");\n", "\n", "    assertThat(m).isEqualTo(expected);\n", "    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMapSplitter_emptySeparator() {\n", "    try {\n", "      COMMA_SPLITTER.withKeyValueSeparator(\"\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMapSplitter_malformedEntry() {\n", "    try {\n", "      COMMA_SPLITTER.withKeyValueSeparator(\"=\").split(\"a=1,b,c=2\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMapSplitter_orderedResults() {\n", "    Map<String, String> m = Splitter.on(',')\n", "        .withKeyValueSeparator(\":\")\n", "        .split(\"boy:tom,girl:tina,cat:kitty,dog:tommy\");\n", "\n", "    assertThat(m.keySet()).containsExactly(\"boy\", \"girl\", \"cat\", \"dog\").inOrder();\n", "    assertThat(m).isEqualTo(\n", "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"));\n", "\n", "    // try in a different order\n", "    m = Splitter.on(',')\n", "        .withKeyValueSeparator(\":\")\n", "        .split(\"girl:tina,boy:tom,dog:tommy,cat:kitty\");\n", "\n", "    assertThat(m.keySet()).containsExactly(\"girl\", \"boy\", \"dog\", \"cat\").inOrder();\n", "    assertThat(m).isEqualTo(\n", "        ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMapSplitter_duplicateKeys() {\n", "    try {\n", "      Splitter.on(',').withKeyValueSeparator(\":\").split(\"a:1,b:2,a:3\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604]}}, {"77": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/StopwatchTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static java.util.concurrent.TimeUnit.MICROSECONDS;\n", "import static java.util.concurrent.TimeUnit.MILLISECONDS;\n", "import static java.util.concurrent.TimeUnit.NANOSECONDS;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.testing.FakeTicker;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Unit test for {@link Stopwatch}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class StopwatchTest extends TestCase {\n", "\n", "  private final FakeTicker ticker = new FakeTicker();\n", "  private final Stopwatch stopwatch = new Stopwatch(ticker);\n", "\n", "  public void testCreateStarted() {\n", "    Stopwatch startedStopwatch = Stopwatch.createStarted();\n", "    assertTrue(startedStopwatch.isRunning());\n", "  }\n", "\n", "  public void testCreateUnstarted() {\n", "    Stopwatch unstartedStopwatch = Stopwatch.createUnstarted();\n", "    assertFalse(unstartedStopwatch.isRunning());\n", "    assertEquals(0, unstartedStopwatch.elapsed(NANOSECONDS));\n", "  }\n", "\n", "  public void testInitialState() {\n", "    assertFalse(stopwatch.isRunning());\n", "    assertEquals(0, stopwatch.elapsed(NANOSECONDS));\n", "  }\n", "\n", "  public void testStart() {\n", "    assertSame(stopwatch, stopwatch.start());\n", "    assertTrue(stopwatch.isRunning());\n", "  }\n", "\n", "  public void testStart_whileRunning() {\n", "    stopwatch.start();\n", "    try {\n", "      stopwatch.start();\n", "      fail();\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "    assertTrue(stopwatch.isRunning());\n", "  }\n", "\n", "  public void testStop() {\n", "    stopwatch.start();\n", "    assertSame(stopwatch, stopwatch.stop());\n", "    assertFalse(stopwatch.isRunning());\n", "  }\n", "\n", "  public void testStop_new() {\n", "    try {\n", "      stopwatch.stop();\n", "      fail();\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "    assertFalse(stopwatch.isRunning());\n", "  }\n", "\n", "  public void testStop_alreadyStopped() {\n", "    stopwatch.start();\n", "    stopwatch.stop();\n", "    try {\n", "      stopwatch.stop();\n", "      fail();\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "    assertFalse(stopwatch.isRunning());\n", "  }\n", "\n", "  public void testReset_new() {\n", "    ticker.advance(1);\n", "    stopwatch.reset();\n", "    assertFalse(stopwatch.isRunning());\n", "    ticker.advance(2);\n", "    assertEquals(0, stopwatch.elapsed(NANOSECONDS));\n", "    stopwatch.start();\n", "    ticker.advance(3);\n", "    assertEquals(3, stopwatch.elapsed(NANOSECONDS));\n", "  }\n", "\n", "  public void testReset_whileRunning() {\n", "    ticker.advance(1);\n", "    stopwatch.start();\n", "    assertEquals(0, stopwatch.elapsed(NANOSECONDS));\n", "    ticker.advance(2);\n", "    assertEquals(2, stopwatch.elapsed(NANOSECONDS));\n", "    stopwatch.reset();\n", "    assertFalse(stopwatch.isRunning());\n", "    ticker.advance(3);\n", "    assertEquals(0, stopwatch.elapsed(NANOSECONDS));\n", "  }\n", "\n", "  public void testElapsed_whileRunning() {\n", "    ticker.advance(78);\n", "    stopwatch.start();\n", "    assertEquals(0, stopwatch.elapsed(NANOSECONDS));\n", "\n", "    ticker.advance(345);\n", "    assertEquals(345, stopwatch.elapsed(NANOSECONDS));\n", "  }\n", "\n", "  public void testElapsed_notRunning() {\n", "    ticker.advance(1);\n", "    stopwatch.start();\n", "    ticker.advance(4);\n", "    stopwatch.stop();\n", "    ticker.advance(9);\n", "    assertEquals(4, stopwatch.elapsed(NANOSECONDS));\n", "  }\n", "\n", "  public void testElapsed_multipleSegments() {\n", "    stopwatch.start();\n", "    ticker.advance(9);\n", "    stopwatch.stop();\n", "\n", "    ticker.advance(16);\n", "\n", "    stopwatch.start();\n", "    assertEquals(9, stopwatch.elapsed(NANOSECONDS));\n", "    ticker.advance(25);\n", "    assertEquals(34, stopwatch.elapsed(NANOSECONDS));\n", "\n", "    stopwatch.stop();\n", "    ticker.advance(36);\n", "    assertEquals(34, stopwatch.elapsed(NANOSECONDS));\n", "  }\n", "\n", "  public void testElapsed_micros() {\n", "    stopwatch.start();\n", "    ticker.advance(999);\n", "    assertEquals(0, stopwatch.elapsed(MICROSECONDS));\n", "    ticker.advance(1);\n", "    assertEquals(1, stopwatch.elapsed(MICROSECONDS));\n", "  }\n", "\n", "  public void testElapsed_millis() {\n", "    stopwatch.start();\n", "    ticker.advance(999999);\n", "    assertEquals(0, stopwatch.elapsed(MILLISECONDS));\n", "    ticker.advance(1);\n", "    assertEquals(1, stopwatch.elapsed(MILLISECONDS));\n", "  }\n", "\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171]}}, {"78": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/StringsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2010 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Unit test for {@link Strings}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class StringsTest extends TestCase {\n", "  public void testNullToEmpty() {\n", "    assertEquals(\"\", Strings.nullToEmpty(null));\n", "    assertEquals(\"\", Strings.nullToEmpty(\"\"));\n", "    assertEquals(\"a\", Strings.nullToEmpty(\"a\"));\n", "  }\n", "\n", "  public void testEmptyToNull() {\n", "    assertNull(Strings.emptyToNull(null));\n", "    assertNull(Strings.emptyToNull(\"\"));\n", "    assertEquals(\"a\", Strings.emptyToNull(\"a\"));\n", "  }\n", "\n", "  public void testIsNullOrEmpty() {\n", "    assertTrue(Strings.isNullOrEmpty(null));\n", "    assertTrue(Strings.isNullOrEmpty(\"\"));\n", "    assertFalse(Strings.isNullOrEmpty(\"a\"));\n", "  }\n", "\n", "  public void testPadStart_noPadding() {\n", "    assertSame(\"\", Strings.padStart(\"\", 0, '-'));\n", "    assertSame(\"x\", Strings.padStart(\"x\", 0, '-'));\n", "    assertSame(\"x\", Strings.padStart(\"x\", 1, '-'));\n", "    assertSame(\"xx\", Strings.padStart(\"xx\", 0, '-'));\n", "    assertSame(\"xx\", Strings.padStart(\"xx\", 2, '-'));\n", "  }\n", "\n", "  public void testPadStart_somePadding() {\n", "    assertEquals(\"-\", Strings.padStart(\"\", 1, '-'));\n", "    assertEquals(\"--\", Strings.padStart(\"\", 2, '-'));\n", "    assertEquals(\"-x\", Strings.padStart(\"x\", 2, '-'));\n", "    assertEquals(\"--x\", Strings.padStart(\"x\", 3, '-'));\n", "    assertEquals(\"-xx\", Strings.padStart(\"xx\", 3, '-'));\n", "  }\n", "\n", "  public void testPadStart_negativeMinLength() {\n", "    assertSame(\"x\", Strings.padStart(\"x\", -1, '-'));\n", "  }\n", "\n", "  // TODO: could remove if we got NPT working in GWT somehow\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testPadStart_null() {\n", "    try {\n", "      Strings.padStart(null, 5, '0');\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testPadEnd_noPadding() {\n", "    assertSame(\"\", Strings.padEnd(\"\", 0, '-'));\n", "    assertSame(\"x\", Strings.padEnd(\"x\", 0, '-'));\n", "    assertSame(\"x\", Strings.padEnd(\"x\", 1, '-'));\n", "    assertSame(\"xx\", Strings.padEnd(\"xx\", 0, '-'));\n", "    assertSame(\"xx\", Strings.padEnd(\"xx\", 2, '-'));\n", "  }\n", "\n", "  public void testPadEnd_somePadding() {\n", "    assertEquals(\"-\", Strings.padEnd(\"\", 1, '-'));\n", "    assertEquals(\"--\", Strings.padEnd(\"\", 2, '-'));\n", "    assertEquals(\"x-\", Strings.padEnd(\"x\", 2, '-'));\n", "    assertEquals(\"x--\", Strings.padEnd(\"x\", 3, '-'));\n", "    assertEquals(\"xx-\", Strings.padEnd(\"xx\", 3, '-'));\n", "  }\n", "\n", "  public void testPadEnd_negativeMinLength() {\n", "    assertSame(\"x\", Strings.padEnd(\"x\", -1, '-'));\n", "  }\n", "\n", "  // TODO: could remove if we got NPT working in GWT somehow\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testPadEnd_null() {\n", "    try {\n", "      Strings.padEnd(null, 5, '0');\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testRepeat() {\n", "    String input = \"20\";\n", "    assertEquals(\"\", Strings.repeat(input, 0));\n", "    assertEquals(\"20\", Strings.repeat(input, 1));\n", "    assertEquals(\"2020\", Strings.repeat(input, 2));\n", "    assertEquals(\"202020\", Strings.repeat(input, 3));\n", "\n", "    assertEquals(\"\", Strings.repeat(\"\", 4));\n", "\n", "    for (int i = 0; i < 100; ++i) {\n", "      assertEquals(2 * i, Strings.repeat(input, i).length());\n", "    }\n", "\n", "    try {\n", "      Strings.repeat(\"x\", -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // Massive string\n", "      Strings.repeat(\"12345678\", (1 << 30) + 3);\n", "      fail();\n", "    } catch (ArrayIndexOutOfBoundsException expected) {\n", "    }\n", "  }\n", "\n", "  // TODO: could remove if we got NPT working in GWT somehow\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testRepeat_null() {\n", "    try {\n", "      Strings.repeat(null, 5);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCommonPrefix() {\n", "    assertEquals(\"\", Strings.commonPrefix(\"\", \"\"));\n", "    assertEquals(\"\", Strings.commonPrefix(\"abc\", \"\"));\n", "    assertEquals(\"\", Strings.commonPrefix(\"\", \"abc\"));\n", "    assertEquals(\"\", Strings.commonPrefix(\"abcde\", \"xyz\"));\n", "    assertEquals(\"\", Strings.commonPrefix(\"xyz\", \"abcde\"));\n", "    assertEquals(\"\", Strings.commonPrefix(\"xyz\", \"abcxyz\"));\n", "    assertEquals(\"a\", Strings.commonPrefix(\"abc\", \"aaaaa\"));\n", "    assertEquals(\"aa\", Strings.commonPrefix(\"aa\", \"aaaaa\"));\n", "    assertEquals(\"abc\",\n", "        Strings.commonPrefix(new StringBuffer(\"abcdef\"), \"abcxyz\"));\n", "\n", "    // Identical valid surrogate pairs.\n", "    assertEquals(\"abc\\uD8AB\\uDCAB\",\n", "        Strings.commonPrefix(\"abc\\uD8AB\\uDCABdef\", \"abc\\uD8AB\\uDCABxyz\"));\n", "    // Differing valid surrogate pairs.\n", "    assertEquals(\"abc\",\n", "        Strings.commonPrefix(\"abc\\uD8AB\\uDCABdef\", \"abc\\uD8AB\\uDCACxyz\"));\n", "    // One invalid pair.\n", "    assertEquals(\"abc\",\n", "        Strings.commonPrefix(\"abc\\uD8AB\\uDCABdef\", \"abc\\uD8AB\\uD8ABxyz\"));\n", "    // Two identical invalid pairs.\n", "    assertEquals(\"abc\\uD8AB\\uD8AC\",\n", "        Strings.commonPrefix(\"abc\\uD8AB\\uD8ACdef\", \"abc\\uD8AB\\uD8ACxyz\"));\n", "    // Two differing invalid pairs.\n", "    assertEquals(\"abc\\uD8AB\",\n", "        Strings.commonPrefix(\"abc\\uD8AB\\uD8ABdef\", \"abc\\uD8AB\\uD8ACxyz\"));\n", "    // One orphan high surrogate.\n", "    assertEquals(\"\", Strings.commonPrefix(\"\\uD8AB\\uDCAB\", \"\\uD8AB\"));\n", "    // Two orphan high surrogates.\n", "    assertEquals(\"\\uD8AB\", Strings.commonPrefix(\"\\uD8AB\", \"\\uD8AB\"));\n", "  }\n", "\n", "  public void testCommonSuffix() {\n", "    assertEquals(\"\", Strings.commonSuffix(\"\", \"\"));\n", "    assertEquals(\"\", Strings.commonSuffix(\"abc\", \"\"));\n", "    assertEquals(\"\", Strings.commonSuffix(\"\", \"abc\"));\n", "    assertEquals(\"\", Strings.commonSuffix(\"abcde\", \"xyz\"));\n", "    assertEquals(\"\", Strings.commonSuffix(\"xyz\", \"abcde\"));\n", "    assertEquals(\"\", Strings.commonSuffix(\"xyz\", \"xyzabc\"));\n", "    assertEquals(\"c\", Strings.commonSuffix(\"abc\", \"ccccc\"));\n", "    assertEquals(\"aa\", Strings.commonSuffix(\"aa\", \"aaaaa\"));\n", "    assertEquals(\"abc\",\n", "        Strings.commonSuffix(new StringBuffer(\"xyzabc\"), \"xxxabc\"));\n", "\n", "    // Identical valid surrogate pairs.\n", "    assertEquals(\"\\uD8AB\\uDCABdef\",\n", "        Strings.commonSuffix(\"abc\\uD8AB\\uDCABdef\", \"xyz\\uD8AB\\uDCABdef\"));\n", "    // Differing valid surrogate pairs.\n", "    assertEquals(\"def\",\n", "        Strings.commonSuffix(\"abc\\uD8AB\\uDCABdef\", \"abc\\uD8AC\\uDCABdef\"));\n", "    // One invalid pair.\n", "    assertEquals(\"def\",\n", "        Strings.commonSuffix(\"abc\\uD8AB\\uDCABdef\", \"xyz\\uDCAB\\uDCABdef\"));\n", "    // Two identical invalid pairs.\n", "    assertEquals(\"\\uD8AB\\uD8ABdef\",\n", "        Strings.commonSuffix(\"abc\\uD8AB\\uD8ABdef\", \"xyz\\uD8AB\\uD8ABdef\"));\n", "    // Two differing invalid pairs.\n", "    assertEquals(\"\\uDCABdef\",\n", "        Strings.commonSuffix(\"abc\\uDCAB\\uDCABdef\", \"abc\\uDCAC\\uDCABdef\"));\n", "    // One orphan low surrogate.\n", "    assertEquals(\"\", Strings.commonSuffix(\"x\\uD8AB\\uDCAB\", \"\\uDCAB\"));\n", "    // Two orphan low surrogates.\n", "    assertEquals(\"\\uDCAB\", Strings.commonSuffix(\"\\uDCAB\", \"\\uDCAB\"));\n", "  }\n", "\n", "  public void testValidSurrogatePairAt() {\n", "    assertTrue(Strings.validSurrogatePairAt(\"\\uD8AB\\uDCAB\", 0));\n", "    assertTrue(Strings.validSurrogatePairAt(\"abc\\uD8AB\\uDCAB\", 3));\n", "    assertTrue(Strings.validSurrogatePairAt(\"abc\\uD8AB\\uDCABxyz\", 3));\n", "    assertFalse(Strings.validSurrogatePairAt(\"\\uD8AB\\uD8AB\", 0));\n", "    assertFalse(Strings.validSurrogatePairAt(\"\\uDCAB\\uDCAB\", 0));\n", "    assertFalse(Strings.validSurrogatePairAt(\"\\uD8AB\\uDCAB\", -1));\n", "    assertFalse(Strings.validSurrogatePairAt(\"\\uD8AB\\uDCAB\", 1));\n", "    assertFalse(Strings.validSurrogatePairAt(\"\\uD8AB\\uDCAB\", -2));\n", "    assertFalse(Strings.validSurrogatePairAt(\"\\uD8AB\\uDCAB\", 2));\n", "    assertFalse(Strings.validSurrogatePairAt(\"x\\uDCAB\", 0));\n", "    assertFalse(Strings.validSurrogatePairAt(\"\\uD8ABx\", 0));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225]}}, {"79": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/SuppliersTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Lists;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.ArrayList;\n", "import java.util.List;\n", "\n", "/**\n", " * Tests com.google.common.base.Suppliers.\n", " *\n", " * @author Laurence Gonsalves\n", " * @author Harry Heymann\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SuppliersTest extends TestCase {\n", "  public void testCompose() {\n", "    Supplier<Integer> fiveSupplier = new Supplier<Integer>() {\n", "      @Override\n", "      public Integer get() {\n", "        return 5;\n", "      }\n", "    };\n", "\n", "    Function<Number, Integer> intValueFunction =\n", "        new Function<Number, Integer>() {\n", "          @Override\n", "          public Integer apply(Number x) {\n", "            return x.intValue();\n", "          }\n", "        };\n", "\n", "    Supplier<Integer> squareSupplier = Suppliers.compose(intValueFunction,\n", "        fiveSupplier);\n", "\n", "    assertEquals(Integer.valueOf(5), squareSupplier.get());\n", "  }\n", "\n", "  public void testComposeWithLists() {\n", "    Supplier<ArrayList<Integer>> listSupplier\n", "        = new Supplier<ArrayList<Integer>>() {\n", "      @Override\n", "      public ArrayList<Integer> get() {\n", "        return Lists.newArrayList(0);\n", "      }\n", "    };\n", "\n", "    Function<List<Integer>, List<Integer>> addElementFunction =\n", "        new Function<List<Integer>, List<Integer>>() {\n", "          @Override\n", "          public List<Integer> apply(List<Integer> list) {\n", "            ArrayList<Integer> result = Lists.newArrayList(list);\n", "            result.add(1);\n", "            return result;\n", "          }\n", "        };\n", "\n", "    Supplier<List<Integer>> addSupplier = Suppliers.compose(addElementFunction,\n", "        listSupplier);\n", "\n", "    List<Integer> result = addSupplier.get();\n", "    assertEquals(Integer.valueOf(0), result.get(0));\n", "    assertEquals(Integer.valueOf(1), result.get(1));\n", "  }\n", "\n", "  static class CountingSupplier implements Supplier<Integer>, Serializable {\n", "    private static final long serialVersionUID = 0L;\n", "    transient int calls = 0;\n", "    @Override\n", "    public Integer get() {\n", "      calls++;\n", "      return calls * 10;\n", "    }\n", "  }\n", "\n", "  public void testMemoize() {\n", "    CountingSupplier countingSupplier = new CountingSupplier();\n", "    Supplier<Integer> memoizedSupplier = Suppliers.memoize(countingSupplier);\n", "    checkMemoize(countingSupplier, memoizedSupplier);\n", "  }\n", "\n", "  public void testMemoize_redudantly() {\n", "    CountingSupplier countingSupplier = new CountingSupplier();\n", "    Supplier<Integer> memoizedSupplier = Suppliers.memoize(countingSupplier);\n", "    assertSame(memoizedSupplier, Suppliers.memoize(memoizedSupplier));\n", "  }\n", "\n", "  private void checkMemoize(\n", "      CountingSupplier countingSupplier, Supplier<Integer> memoizedSupplier) {\n", "    // the underlying supplier hasn't executed yet\n", "    assertEquals(0, countingSupplier.calls);\n", "\n", "    assertEquals(10, (int) memoizedSupplier.get());\n", "\n", "    // now it has\n", "    assertEquals(1, countingSupplier.calls);\n", "\n", "    assertEquals(10, (int) memoizedSupplier.get());\n", "\n", "    // it still should only have executed once due to memoization\n", "    assertEquals(1, countingSupplier.calls);\n", "  }\n", "\n", "  public void testMemoizeExceptionThrown() {\n", "    Supplier<Integer> exceptingSupplier = new Supplier<Integer>() {\n", "      @Override\n", "      public Integer get() {\n", "        throw new NullPointerException();\n", "      }\n", "    };\n", "\n", "    Supplier<Integer> memoizedSupplier = Suppliers.memoize(exceptingSupplier);\n", "\n", "    // call get() twice to make sure that memoization doesn't interfere\n", "    // with throwing the exception\n", "    for (int i = 0; i < 2; i++) {\n", "      try {\n", "        memoizedSupplier.get();\n", "        fail(\"failed to throw NullPointerException\");\n", "      } catch (NullPointerException e) {\n", "        // this is what should happen\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testOfInstanceSuppliesSameInstance() {\n", "    Object toBeSupplied = new Object();\n", "    Supplier<Object> objectSupplier = Suppliers.ofInstance(toBeSupplied);\n", "    assertSame(toBeSupplied,objectSupplier.get());\n", "    assertSame(toBeSupplied,objectSupplier.get()); // idempotent\n", "  }\n", "\n", "  public void testOfInstanceSuppliesNull() {\n", "    Supplier<Integer> nullSupplier = Suppliers.ofInstance(null);\n", "    assertNull(nullSupplier.get());\n", "  }\n", "\n", "  public void testSupplierFunction() {\n", "    Supplier<Integer> supplier = Suppliers.ofInstance(14);\n", "    Function<Supplier<Integer>, Integer> supplierFunction =\n", "        Suppliers.supplierFunction();\n", "\n", "    assertEquals(14, (int) supplierFunction.apply(supplier));\n", "  }\n", "\n", "  public void testOfInstance_equals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Suppliers.ofInstance(\"foo\"), Suppliers.ofInstance(\"foo\"))\n", "        .addEqualityGroup(Suppliers.ofInstance(\"bar\"))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testCompose_equals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            Suppliers.compose(Functions.constant(1), Suppliers.ofInstance(\"foo\")),\n", "            Suppliers.compose(Functions.constant(1), Suppliers.ofInstance(\"foo\")))\n", "        .addEqualityGroup(\n", "            Suppliers.compose(Functions.constant(2), Suppliers.ofInstance(\"foo\")))\n", "        .addEqualityGroup(\n", "            Suppliers.compose(Functions.constant(1), Suppliers.ofInstance(\"bar\")))\n", "        .testEquals();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186]}}, {"80": "guava-gwt/test-super/com/google/common/base/super/com/google/common/base/Utf8Test.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.base;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.lang.Character.MAX_CODE_POINT;\n", "import static java.lang.Character.MAX_HIGH_SURROGATE;\n", "import static java.lang.Character.MAX_LOW_SURROGATE;\n", "import static java.lang.Character.MIN_HIGH_SURROGATE;\n", "import static java.lang.Character.MIN_LOW_SURROGATE;\n", "import static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableList;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.HashMap;\n", "import java.util.Random;\n", "\n", "/**\n", " * Unit tests for {@link Utf8}.\n", " *\n", " * @author Jon Perlow\n", " * @author Martin Buchholz\n", " * @author Cl\u00e9ment Roux\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class Utf8Test extends TestCase {\n", "\n", "  private static final ImmutableList<String> ILL_FORMED_STRINGS;\n", "  static {\n", "    ImmutableList.Builder<String> builder = ImmutableList.builder();\n", "    char[] surrogates = {\n", "      MAX_LOW_SURROGATE,\n", "      MAX_HIGH_SURROGATE,\n", "      MIN_LOW_SURROGATE,\n", "      MIN_HIGH_SURROGATE,\n", "    };\n", "    for (char surrogate : surrogates) {\n", "      builder.add(newString(surrogate));\n", "      builder.add(newString(surrogate, 'n'));\n", "      builder.add(newString('n', surrogate));\n", "      builder.add(newString(surrogate, surrogate));\n", "    }\n", "    builder.add(newString(MIN_LOW_SURROGATE, MAX_HIGH_SURROGATE));\n", "    ILL_FORMED_STRINGS = builder.build();\n", "  }\n", "\n", "  public void testEncodedLength_validStrings() {\n", "    assertEquals(0, Utf8.encodedLength(\"\"));\n", "    assertEquals(11, Utf8.encodedLength(\"Hello world\"));\n", "    assertEquals(8, Utf8.encodedLength(\"R\u00e9sum\u00e9\"));\n", "    assertEquals(461, Utf8.encodedLength(\"\u5a01\u5ec9\u00b7\u838e\u58eb\u6bd4\u4e9e\uff08William Shakespeare\uff0c\"\n", "        + \"1564\u5e744\u670826\u865f\u20141616\u5e744\u670823\u865f[1]\uff09\u4fc2\u96bb\u82f1\u570b\u55f0\u6f14\u54e1\u3001\u5287\u4f5c\u5bb6\u540c\u8a69\u4eba\uff0c\"\n", "        + \"\u6709\u6642\u9593\u4f62\u7c21\u7a31\u838e\u7fc1\uff1b\u4e2d\u570b\u6e05\u672b\u6c11\u521d\u54c8\u62d5\u7ffb\u8b6f\u505a\u820c\u514b\u65af\u6bd5\u3001\u6c99\u65af\u76ae\u8033\u3001\u7b5b\u65af\u6bd4\u8033\u3001\"\n", "        + \"\u838e\u57fa\u65af\u5e87\u5c14\u3001\u7d22\u58eb\u6bd4\u5c14\u3001\u590f\u514b\u601d\u8298\u5c14\u3001\u5e0c\u54c0\u82e6\u76ae\u963f\u3001\u53f6\u65af\u58c1\u3001\u6c99\u514b\u76ae\u5c14\u3001\"\n", "        + \"\u72f9\u65af\u4e15\u723e\u3002[2]\u838e\u58eb\u6bd4\u4e9e\u7de8\u5beb\u904e\u597d\u591a\u4f5c\u54c1\uff0c\u4f62\u55f0\u5287\u4f5c\u97ff\u897f\u6d0b\u6587\u5b78\u597d\u6709\u5f71\u97ff\uff0c\"\n", "        + \"\u54c8\u90fd\u62d5\u4eba\u7ffb\u8b6f\u505a\u597d\u591a\u8a71\u3002\"));\n", "    // A surrogate pair\n", "    assertEquals(4, Utf8.encodedLength(newString(MIN_HIGH_SURROGATE, MIN_LOW_SURROGATE)));\n", "  }\n", "\n", "  public void testEncodedLength_validStrings2() {\n", "    HashMap<Integer, Integer> utf8Lengths = new HashMap<Integer, Integer>();\n", "    utf8Lengths.put(0x00, 1);\n", "    utf8Lengths.put(0x7f, 1);\n", "    utf8Lengths.put(0x80, 2);\n", "    utf8Lengths.put(0x7ff, 2);\n", "    utf8Lengths.put(0x800, 3);\n", "    utf8Lengths.put(MIN_SUPPLEMENTARY_CODE_POINT - 1, 3);\n", "    utf8Lengths.put(MIN_SUPPLEMENTARY_CODE_POINT, 4);\n", "    utf8Lengths.put(MAX_CODE_POINT, 4);\n", "\n", "    Integer[] codePoints = utf8Lengths.keySet().toArray(new Integer[]{});\n", "    StringBuilder sb = new StringBuilder();\n", "    Random rnd = new Random();\n", "    for (int trial = 0; trial < 100; trial++) {\n", "      sb.setLength(0);\n", "      int utf8Length = 0;\n", "      for (int i = 0; i < 6; i++) {\n", "        Integer randomCodePoint = codePoints[rnd.nextInt(codePoints.length)];\n", "        sb.appendCodePoint(randomCodePoint);\n", "        utf8Length += utf8Lengths.get(randomCodePoint);\n", "        if (utf8Length != Utf8.encodedLength(sb)) {\n", "          StringBuilder repro = new StringBuilder();\n", "          for (int j = 0; j < sb.length(); j++) {\n", "            repro.append(\" \" + (int) sb.charAt(j));  // GWT compatible\n", "          }\n", "          assertEquals(repro.toString(), utf8Length, Utf8.encodedLength(sb));\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testEncodedLength_invalidStrings() {\n", "    testEncodedLengthFails(newString(MIN_HIGH_SURROGATE), 0);\n", "    testEncodedLengthFails(\"foobar\" + newString(MIN_HIGH_SURROGATE), 6);\n", "    testEncodedLengthFails(newString(MIN_LOW_SURROGATE), 0);\n", "    testEncodedLengthFails(\"foobar\" + newString(MIN_LOW_SURROGATE), 6);\n", "    testEncodedLengthFails(newString(MIN_HIGH_SURROGATE, MIN_HIGH_SURROGATE), 0);\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  private static void testEncodedLengthFails(String invalidString,\n", "      int invalidCodePointIndex) {\n", "    try {\n", "      Utf8.encodedLength(invalidString);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected).hasMessage(\"Unpaired surrogate at index \" + invalidCodePointIndex);\n", "    }\n", "  }\n", "\n", "  // 128 - [chars 0x0000 to 0x007f]\n", "  private static final long ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n", "      0x007f - 0x0000 + 1;\n", "\n", "  // 128\n", "  private static final long EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT =\n", "      ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n", "\n", "  // 1920 [chars 0x0080 to 0x07FF]\n", "  private static final long TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n", "      0x07FF - 0x0080 + 1;\n", "\n", "  // 18,304\n", "  private static final long EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT =\n", "      // Both bytes are one byte characters\n", "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 2) +\n", "      // The possible number of two byte characters\n", "      TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n", "\n", "  // 2048\n", "  private static final long THREE_BYTE_SURROGATES = 2 * 1024;\n", "\n", "  // 61,440 [chars 0x0800 to 0xFFFF, minus surrogates]\n", "  private static final long THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n", "      0xFFFF - 0x0800 + 1 - THREE_BYTE_SURROGATES;\n", "\n", "  // 2,650,112\n", "  private static final long EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT =\n", "      // All one byte characters\n", "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 3) +\n", "      // One two byte character and a one byte character\n", "      2 * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n", "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n", "       // Three byte characters\n", "      THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n", "\n", "  // 1,048,576 [chars 0x10000L to 0x10FFFF]\n", "  private static final long FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS =\n", "      0x10FFFF - 0x10000L + 1;\n", "\n", "  // 289,571,839\n", "  private static final long EXPECTED_FOUR_BYTE_ROUNDTRIPPABLE_COUNT =\n", "      // All one byte characters\n", "      (long) Math.pow(EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT, 4) +\n", "      // One and three byte characters\n", "      2 * THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n", "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n", "      // Two two byte characters\n", "      TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n", "      // Permutations of one and two byte characters\n", "      3 * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n", "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS *\n", "          ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS +\n", "      // Four byte characters\n", "      FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS;\n", "\n", "  /**\n", "   * Tests that round tripping of a sample of four byte permutations work.\n", "   * All permutations are prohibitively expensive to test for automated runs.\n", "   * This method tests specific four-byte cases.\n", "   */\n", "  public void testIsWellFormed_4BytesSamples() {\n", "    // Valid 4 byte.\n", "    assertWellFormed(0xF0, 0xA4, 0xAD, 0xA2);\n", "    // Bad trailing bytes\n", "    assertNotWellFormed(0xF0, 0xA4, 0xAD, 0x7F);\n", "    assertNotWellFormed(0xF0, 0xA4, 0xAD, 0xC0);\n", "    // Special cases for byte2\n", "    assertNotWellFormed(0xF0, 0x8F, 0xAD, 0xA2);\n", "    assertNotWellFormed(0xF4, 0x90, 0xAD, 0xA2);\n", "  }\n", "\n", "  /** Tests some hard-coded test cases. */\n", "  public void testSomeSequences() {\n", "    // Empty\n", "    assertWellFormed();\n", "    // One-byte characters, including control characters\n", "    assertWellFormed(0x00, 0x61, 0x62, 0x63, 0x7F); // \"\\u0000abc\\u007f\"\n", "    // Two-byte characters\n", "    assertWellFormed(0xC2, 0xA2, 0xC2, 0xA2); // \"\\u00a2\\u00a2\"\n", "    // Three-byte characters\n", "    assertWellFormed(0xc8, 0x8a, 0x63, 0xc8, 0x8a, 0x63); // \"\\u020ac\\u020ac\"\n", "    // Four-byte characters\n", "    // \"\\u024B62\\u024B62\"\n", "    assertWellFormed(0xc9, 0x8b, 0x36, 0x32, 0xc9, 0x8b, 0x36, 0x32);\n", "    // Mixed string\n", "    // \"a\\u020ac\\u00a2b\\\\u024B62u020acc\\u00a2de\\u024B62\"\n", "    assertWellFormed(0x61, 0xc8, 0x8a, 0x63, 0xc2, 0xa2, 0x62, 0x5c, 0x75, 0x30,\n", "        0x32, 0x34, 0x42, 0x36, 0x32, 0x75, 0x30, 0x32, 0x30, 0x61, 0x63, 0x63,\n", "        0xc2, 0xa2, 0x64, 0x65, 0xc9, 0x8b, 0x36, 0x32);\n", "    // Not a valid string\n", "    assertNotWellFormed(-1, 0, -1, 0);\n", "  }\n", "\n", "  public void testShardsHaveExpectedRoundTrippables() {\n", "    // A sanity check.\n", "    long actual = 0;\n", "    for (long expected : generateFourByteShardsExpectedRunnables()) {\n", "      actual += expected;\n", "    }\n", "    assertEquals(EXPECTED_FOUR_BYTE_ROUNDTRIPPABLE_COUNT, actual);\n", "  }\n", "\n", "  private static String newString(char... chars) {\n", "    return new String(chars);\n", "  }\n", "\n", "  private static byte[] toByteArray(int... bytes) {\n", "    byte[] realBytes = new byte[bytes.length];\n", "    for (int i = 0; i < bytes.length; i++) {\n", "      realBytes[i] = (byte) bytes[i];\n", "    }\n", "    return realBytes;\n", "  }\n", "\n", "  private static void assertWellFormed(int... bytes) {\n", "    assertTrue(Utf8.isWellFormed(toByteArray(bytes)));\n", "  }\n", "\n", "  private static void assertNotWellFormed(int... bytes) {\n", "    assertFalse(Utf8.isWellFormed(toByteArray(bytes)));\n", "  }\n", "\n", "  private static long[] generateFourByteShardsExpectedRunnables() {\n", "    long[] expected = new long[128];\n", "    // 0-63 are all 5300224\n", "    for (int i = 0; i <= 63; i++) {\n", "      expected[i] = 5300224;\n", "    }\n", "    // 97-111 are all 2342912\n", "    for (int i = 97; i <= 111; i++) {\n", "     expected[i] = 2342912;\n", "    }\n", "    // 113-117 are all 1048576\n", "    for (int i = 113; i <= 117; i++) {\n", "      expected[i] = 1048576;\n", "    }\n", "    // One offs\n", "    expected[112] = 786432;\n", "    expected[118] = 786432;\n", "    expected[119] = 1048576;\n", "    expected[120] = 458752;\n", "    expected[121] = 524288;\n", "    expected[122] = 65536;\n", "    // Anything not assigned was the default 0.\n", "    return expected;\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276]}}, {"81": "guava-gwt/test-super/com/google/common/cache/super/com/google/common/cache/CacheBuilderTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.cache;\n", "\n", "import static com.google.common.cache.TestingCacheLoaders.constantLoader;\n", "import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n", "import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n", "import static com.google.common.cache.TestingRemovalListeners.nullRemovalListener;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.concurrent.TimeUnit.NANOSECONDS;\n", "import static java.util.concurrent.TimeUnit.SECONDS;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Ticker;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * Unit tests for CacheBuilder.\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CacheBuilderTest extends TestCase {\n", "\n", "  public void testNewBuilder() {\n", "    CacheLoader<Object, Integer> loader = constantLoader(1);\n", "\n", "    LoadingCache<String, Integer> cache = CacheBuilder.newBuilder()\n", "        .removalListener(countingRemovalListener())\n", "        .build(loader);\n", "\n", "    assertEquals(Integer.valueOf(1), cache.getUnchecked(\"one\"));\n", "    assertEquals(1, cache.size());\n", "  }\n", "\n", "  public void testInitialCapacity_negative() {\n", "    CacheBuilder<Object, Object> builder = new CacheBuilder<Object, Object>();\n", "    try {\n", "      builder.initialCapacity(-1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testInitialCapacity_setTwice() {\n", "    CacheBuilder<Object, Object> builder = new CacheBuilder<Object, Object>().initialCapacity(16);\n", "    try {\n", "      // even to the same value is not allowed\n", "      builder.initialCapacity(16);\n", "      fail();\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testInitialCapacity_large() {\n", "    CacheBuilder.newBuilder().initialCapacity(Integer.MAX_VALUE);\n", "    // that the builder didn't blow up is enough;\n", "    // don't actually create this monster!\n", "  }\n", "\n", "  public void testConcurrencyLevel_zero() {\n", "    CacheBuilder<Object, Object> builder = new CacheBuilder<Object, Object>();\n", "    try {\n", "      builder.concurrencyLevel(0);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testConcurrencyLevel_setTwice() {\n", "    CacheBuilder<Object, Object> builder = new CacheBuilder<Object, Object>().concurrencyLevel(16);\n", "    try {\n", "      // even to the same value is not allowed\n", "      builder.concurrencyLevel(16);\n", "      fail();\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testConcurrencyLevel_large() {\n", "    CacheBuilder.newBuilder().concurrencyLevel(Integer.MAX_VALUE);\n", "    // don't actually build this beast\n", "  }\n", "\n", "  public void testMaximumSize_negative() {\n", "    CacheBuilder<Object, Object> builder = new CacheBuilder<Object, Object>();\n", "    try {\n", "      builder.maximumSize(-1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testMaximumSize_setTwice() {\n", "    CacheBuilder<Object, Object> builder = new CacheBuilder<Object, Object>().maximumSize(16);\n", "    try {\n", "      // even to the same value is not allowed\n", "      builder.maximumSize(16);\n", "      fail();\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testTimeToLive_negative() {\n", "    CacheBuilder<Object, Object> builder = new CacheBuilder<Object, Object>();\n", "    try {\n", "      builder.expireAfterWrite(-1, SECONDS);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testTimeToLive_small() {\n", "    CacheBuilder.newBuilder()\n", "        .expireAfterWrite(1, NANOSECONDS)\n", "        .build(identityLoader());\n", "    // well, it didn't blow up.\n", "  }\n", "\n", "  public void testTimeToLive_setTwice() {\n", "    CacheBuilder<Object, Object> builder =\n", "        new CacheBuilder<Object, Object>().expireAfterWrite(3600, SECONDS);\n", "    try {\n", "      // even to the same value is not allowed\n", "      builder.expireAfterWrite(3600, SECONDS);\n", "      fail();\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testTimeToIdle_negative() {\n", "    CacheBuilder<Object, Object> builder = new CacheBuilder<Object, Object>();\n", "    try {\n", "      builder.expireAfterAccess(-1, SECONDS);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testTimeToIdle_small() {\n", "    CacheBuilder.newBuilder()\n", "        .expireAfterAccess(1, NANOSECONDS)\n", "        .build(identityLoader());\n", "    // well, it didn't blow up.\n", "  }\n", "\n", "  public void testTimeToIdle_setTwice() {\n", "    CacheBuilder<Object, Object> builder =\n", "        new CacheBuilder<Object, Object>().expireAfterAccess(3600, SECONDS);\n", "    try {\n", "      // even to the same value is not allowed\n", "      builder.expireAfterAccess(3600, SECONDS);\n", "      fail();\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testTimeToIdleAndToLive() {\n", "    CacheBuilder.newBuilder()\n", "        .expireAfterWrite(1, NANOSECONDS)\n", "        .expireAfterAccess(1, NANOSECONDS)\n", "        .build(identityLoader());\n", "    // well, it didn't blow up.\n", "  }\n", "\n", "  public void testTicker_setTwice() {\n", "    Ticker testTicker = Ticker.systemTicker();\n", "    CacheBuilder<Object, Object> builder =\n", "        new CacheBuilder<Object, Object>().ticker(testTicker);\n", "    try {\n", "      // even to the same instance is not allowed\n", "      builder.ticker(testTicker);\n", "      fail();\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testRemovalListener_setTwice() {\n", "    RemovalListener<Object, Object> testListener = nullRemovalListener();\n", "    CacheBuilder<Object, Object> builder =\n", "        new CacheBuilder<Object, Object>().removalListener(testListener);\n", "    try {\n", "      // even to the same instance is not allowed\n", "      builder = builder.removalListener(testListener);\n", "      fail();\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testValuesIsNotASet() {\n", "    assertThat(new CacheBuilder<Object, Object>().build().asMap().values())\n", "        .isNotInstanceOf(Set.class);\n", "  }\n", "\n", "  // \"Basher tests\", where we throw a bunch of stuff at a LoadingCache and check basic invariants.\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200]}}, {"82": "guava-gwt/test-super/com/google/common/cache/super/com/google/common/cache/TestingCacheLoaders.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.cache;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Maps;\n", "\n", "import java.util.Map;\n", "import java.util.concurrent.atomic.AtomicInteger;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Utility {@link CacheLoader} implementations intended for use in testing.\n", " *\n", " * @author mike nonemacher\n", " */\n", "@GwtCompatible(emulated = true)\n", "class TestingCacheLoaders {\n", "\n", "  /**\n", "   * Returns a {@link CacheLoader} that implements a naive {@link CacheLoader#loadAll}, delegating\n", "   * {@link CacheLoader#load} calls to {@code loader}.\n", "   */\n", "  static <K, V> CacheLoader<K, V> bulkLoader(final CacheLoader<K, V> loader) {\n", "    checkNotNull(loader);\n", "    return new CacheLoader<K, V>() {\n", "      @Override\n", "      public V load(K key) throws Exception {\n", "        return loader.load(key);\n", "      }\n", "\n", "      @Override\n", "      public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {\n", "        Map<K, V> result = Maps.newHashMap(); // allow nulls\n", "        for (K key : keys) {\n", "          result.put(key, load(key));\n", "        }\n", "        return result;\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link CacheLoader} that returns the given {@code constant} for every request.\n", "   */\n", "  static <K, V> ConstantLoader<K, V> constantLoader(@Nullable V constant) {\n", "    return new ConstantLoader<K, V>(constant);\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link CacheLoader} that returns the given {@code constant} for every request.\n", "   */\n", "  static IncrementingLoader incrementingLoader() {\n", "    return new IncrementingLoader();\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link CacheLoader} that throws the given error for every request.\n", "   */\n", "  static <K, V> CacheLoader<K, V> errorLoader(final Error e) {\n", "    checkNotNull(e);\n", "    return new CacheLoader<K, V>() {\n", "      @Override\n", "      public V load(K key) {\n", "        throw e;\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link CacheLoader} that throws the given exception for every request.\n", "   */\n", "  static <K, V> CacheLoader<K, V> exceptionLoader(final Exception e) {\n", "    checkNotNull(e);\n", "    return new CacheLoader<K, V>() {\n", "      @Override\n", "      public V load(K key) throws Exception {\n", "        throw e;\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a {@link CacheLoader} that returns the key for every request.\n", "   */\n", "  static <T> IdentityLoader<T> identityLoader() {\n", "    return new IdentityLoader<T>();\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code new Object()} for every request, and increments a counter for every request.\n", "   * The count is accessible via {@link #getCount}.\n", "   */\n", "  static class CountingLoader extends CacheLoader<Object, Object> {\n", "    private final AtomicInteger count = new AtomicInteger();\n", "\n", "    @Override\n", "    public Object load(Object from) {\n", "      count.incrementAndGet();\n", "      return new Object();\n", "    }\n", "\n", "    public int getCount() {\n", "      return count.get();\n", "    }\n", "  }\n", "\n", "  static final class ConstantLoader<K, V> extends CacheLoader<K, V> {\n", "    private final V constant;\n", "\n", "    ConstantLoader(V constant) {\n", "      this.constant = constant;\n", "    }\n", "\n", "    @Override\n", "    public V load(K key) {\n", "      return constant;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a {@code new Object()} for every request, and increments a counter for every request.\n", "   * An {@code Integer} loader that returns the key for {@code load} requests, and increments the\n", "   * old value on {@code reload} requests. The load counts are accessible via {@link #getLoadCount}\n", "   * and {@link #getReloadCount}.\n", "   */\n", "  static class IncrementingLoader extends CacheLoader<Integer, Integer> {\n", "    private final AtomicInteger countLoad = new AtomicInteger();\n", "    private final AtomicInteger countReload = new AtomicInteger();\n", "\n", "    @Override\n", "    public Integer load(Integer key) {\n", "      countLoad.incrementAndGet();\n", "      return key;\n", "    }\n", "\n", "    public int getLoadCount() {\n", "      return countLoad.get();\n", "    }\n", "\n", "    public int getReloadCount() {\n", "      return countReload.get();\n", "    }\n", "  }\n", "\n", "  static final class IdentityLoader<T> extends CacheLoader<T, T> {\n", "    @Override\n", "    public T load(T key) {\n", "      return key;\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168]}}, {"83": "guava-gwt/test-super/com/google/common/cache/super/com/google/common/cache/TestingRemovalListeners.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.cache;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.concurrent.atomic.AtomicInteger;\n", "\n", "/**\n", " * Utility {@link RemovalListener} implementations intended for use in testing.\n", " *\n", " * @author mike nonemacher\n", " */\n", "@GwtCompatible(emulated = true)\n", "class TestingRemovalListeners {\n", "\n", "  /**\n", "   * Returns a new no-op {@code RemovalListener}.\n", "   */\n", "  static <K, V> NullRemovalListener<K, V> nullRemovalListener() {\n", "    return new NullRemovalListener<K, V>();\n", "  }\n", "\n", "  /**\n", "   * Type-inferring factory method for creating a {@link CountingRemovalListener}.\n", "   */\n", "  static <K, V> CountingRemovalListener<K, V> countingRemovalListener() {\n", "    return new CountingRemovalListener<K,V>();\n", "  }\n", "\n", "  /**\n", "   * {@link RemovalListener} that counts each {@link RemovalNotification} it receives, and provides\n", "   * access to the most-recently received one.\n", "   */\n", "  static class CountingRemovalListener<K, V> implements RemovalListener<K, V> {\n", "    private final AtomicInteger count = new AtomicInteger();\n", "    private volatile RemovalNotification<K, V> lastNotification;\n", "\n", "    @Override\n", "    public void onRemoval(RemovalNotification<K, V> notification) {\n", "      count.incrementAndGet();\n", "      lastNotification = notification;\n", "    }\n", "\n", "    public int getCount() {\n", "      return count.get();\n", "    }\n", "\n", "    public K getLastEvictedKey() {\n", "      return lastNotification.getKey();\n", "    }\n", "\n", "    public V getLastEvictedValue() {\n", "      return lastNotification.getValue();\n", "    }\n", "\n", "    public RemovalNotification<K, V> getLastNotification() {\n", "      return lastNotification;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * No-op {@link RemovalListener}.\n", "   */\n", "  static class NullRemovalListener<K, V> implements RemovalListener<K, V> {\n", "    @Override\n", "    public void onRemoval(RemovalNotification<K, V> notification) {}\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82]}}, {"84": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/AbstractImmutableSetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.MinimalCollection;\n", "import com.google.common.collect.testing.MinimalIterable;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Set;\n", "\n", "/**\n", " * Base class for {@link ImmutableSet} and  {@link ImmutableSortedSet} tests.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public abstract class AbstractImmutableSetTest extends TestCase {\n", "\n", "  protected abstract Set<String> of();\n", "  protected abstract Set<String> of(String e);\n", "  protected abstract Set<String> of(String e1, String e2);\n", "  protected abstract Set<String> of(String e1, String e2, String e3);\n", "  protected abstract Set<String> of(String e1, String e2, String e3, String e4);\n", "  protected abstract Set<String> of(String e1, String e2, String e3, String e4,\n", "      String e5);\n", "  protected abstract Set<String> of(String e1, String e2, String e3, String e4,\n", "      String e5, String e6, String... rest);\n", "  protected abstract Set<String> copyOf(String[] elements);\n", "  protected abstract Set<String> copyOf(Collection<String> elements);\n", "  protected abstract Set<String> copyOf(Iterable<String> elements);\n", "  protected abstract Set<String> copyOf(Iterator<String> elements);\n", "\n", "  public void testCreation_noArgs() {\n", "    Set<String> set = of();\n", "    assertEquals(Collections.<String>emptySet(), set);\n", "    assertSame(of(), set);\n", "  }\n", "\n", "  public void testCreation_oneElement() {\n", "    Set<String> set = of(\"a\");\n", "    assertEquals(Collections.singleton(\"a\"), set);\n", "  }\n", "\n", "  public void testCreation_twoElements() {\n", "    Set<String> set = of(\"a\", \"b\");\n", "    assertEquals(Sets.newHashSet(\"a\", \"b\"), set);\n", "  }\n", "\n", "  public void testCreation_threeElements() {\n", "    Set<String> set = of(\"a\", \"b\", \"c\");\n", "    assertEquals(Sets.newHashSet(\"a\", \"b\", \"c\"), set);\n", "  }\n", "\n", "  public void testCreation_fourElements() {\n", "    Set<String> set = of(\"a\", \"b\", \"c\", \"d\");\n", "    assertEquals(Sets.newHashSet(\"a\", \"b\", \"c\", \"d\"), set);\n", "  }\n", "\n", "  public void testCreation_fiveElements() {\n", "    Set<String> set = of(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertEquals(Sets.newHashSet(\"a\", \"b\", \"c\", \"d\", \"e\"), set);\n", "  }\n", "\n", "  public void testCreation_sixElements() {\n", "    Set<String> set = of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n", "    assertEquals(Sets.newHashSet(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"), set);\n", "  }\n", "\n", "  public void testCreation_sevenElements() {\n", "    Set<String> set = of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\");\n", "    assertEquals(Sets.newHashSet(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"), set);\n", "  }\n", "\n", "  public void testCreation_eightElements() {\n", "    Set<String> set = of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\");\n", "    assertEquals(Sets.newHashSet(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"), set);\n", "  }\n", "\n", "  public void testCopyOf_emptyArray() {\n", "    String[] array = new String[0];\n", "    Set<String> set = copyOf(array);\n", "    assertEquals(Collections.<String>emptySet(), set);\n", "    assertSame(of(), set);\n", "  }\n", "\n", "  public void testCopyOf_arrayOfOneElement() {\n", "    String[] array = new String[] { \"a\" };\n", "    Set<String> set = copyOf(array);\n", "    assertEquals(Collections.singleton(\"a\"), set);\n", "  }\n", "\n", "  public void testCopyOf_nullArray() {\n", "    try {\n", "      copyOf((String[]) null);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCopyOf_arrayContainingOnlyNull() {\n", "    String[] array = new String[] { null };\n", "    try {\n", "      copyOf(array);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCopyOf_collection_empty() {\n", "    // \"<String>\" is required to work around a javac 1.5 bug.\n", "    Collection<String> c = MinimalCollection.<String>of();\n", "    Set<String> set = copyOf(c);\n", "    assertEquals(Collections.<String>emptySet(), set);\n", "    assertSame(of(), set);\n", "  }\n", "\n", "  public void testCopyOf_collection_oneElement() {\n", "    Collection<String> c = MinimalCollection.of(\"a\");\n", "    Set<String> set = copyOf(c);\n", "    assertEquals(Collections.singleton(\"a\"), set);\n", "  }\n", "\n", "  public void testCopyOf_collection_oneElementRepeated() {\n", "    Collection<String> c = MinimalCollection.of(\"a\", \"a\", \"a\");\n", "    Set<String> set = copyOf(c);\n", "    assertEquals(Collections.singleton(\"a\"), set);\n", "  }\n", "\n", "  public void testCopyOf_collection_general() {\n", "    Collection<String> c = MinimalCollection.of(\"a\", \"b\", \"a\");\n", "    Set<String> set = copyOf(c);\n", "    assertEquals(2, set.size());\n", "    assertTrue(set.contains(\"a\"));\n", "    assertTrue(set.contains(\"b\"));\n", "  }\n", "\n", "  public void testCopyOf_collectionContainingNull() {\n", "    Collection<String> c = MinimalCollection.of(\"a\", null, \"b\");\n", "    try {\n", "      copyOf(c);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCopyOf_iterator_empty() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    Set<String> set = copyOf(iterator);\n", "    assertEquals(Collections.<String>emptySet(), set);\n", "    assertSame(of(), set);\n", "  }\n", "\n", "  public void testCopyOf_iterator_oneElement() {\n", "    Iterator<String> iterator = Iterators.singletonIterator(\"a\");\n", "    Set<String> set = copyOf(iterator);\n", "    assertEquals(Collections.singleton(\"a\"), set);\n", "  }\n", "\n", "  public void testCopyOf_iterator_oneElementRepeated() {\n", "    Iterator<String> iterator = Iterators.forArray(\"a\", \"a\", \"a\");\n", "    Set<String> set = copyOf(iterator);\n", "    assertEquals(Collections.singleton(\"a\"), set);\n", "  }\n", "\n", "  public void testCopyOf_iterator_general() {\n", "    Iterator<String> iterator = Iterators.forArray(\"a\", \"b\", \"a\");\n", "    Set<String> set = copyOf(iterator);\n", "    assertEquals(2, set.size());\n", "    assertTrue(set.contains(\"a\"));\n", "    assertTrue(set.contains(\"b\"));\n", "  }\n", "\n", "  public void testCopyOf_iteratorContainingNull() {\n", "    Iterator<String> c = Iterators.forArray(\"a\", null, \"b\");\n", "    try {\n", "      copyOf(c);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  private static class CountingIterable implements Iterable<String> {\n", "    int count = 0;\n", "    @Override\n", "    public Iterator<String> iterator() {\n", "      count++;\n", "      return Iterators.forArray(\"a\", \"b\", \"a\");\n", "    }\n", "  }\n", "\n", "  public void testCopyOf_plainIterable() {\n", "    CountingIterable iterable = new CountingIterable();\n", "    Set<String> set = copyOf(iterable);\n", "    assertEquals(2, set.size());\n", "    assertTrue(set.contains(\"a\"));\n", "    assertTrue(set.contains(\"b\"));\n", "  }\n", "\n", "  public void testCopyOf_plainIterable_iteratesOnce() {\n", "    CountingIterable iterable = new CountingIterable();\n", "    copyOf(iterable);\n", "    assertEquals(1, iterable.count);\n", "  }\n", "\n", "  public void testCopyOf_shortcut_empty() {\n", "    Collection<String> c = of();\n", "    assertEquals(Collections.<String>emptySet(), copyOf(c));\n", "    assertSame(c, copyOf(c));\n", "  }\n", "\n", "  public void testCopyOf_shortcut_singleton() {\n", "    Collection<String> c = of(\"a\");\n", "    assertEquals(Collections.singleton(\"a\"), copyOf(c));\n", "    assertSame(c, copyOf(c));\n", "  }\n", "\n", "  public void testCopyOf_shortcut_sameType() {\n", "    Collection<String> c = of(\"a\", \"b\", \"c\");\n", "    assertSame(c, copyOf(c));\n", "  }\n", "\n", "  public void testToString() {\n", "    Set<String> set = of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\");\n", "    assertEquals(\"[a, b, c, d, e, f, g]\", set.toString());\n", "  }\n", "\n", "  public void testContainsAll_sameType() {\n", "    Collection<String> c = of(\"a\", \"b\", \"c\");\n", "    assertFalse(c.containsAll(of(\"a\", \"b\", \"c\", \"d\")));\n", "    assertFalse(c.containsAll(of(\"a\", \"d\")));\n", "    assertTrue(c.containsAll(of(\"a\", \"c\")));\n", "    assertTrue(c.containsAll(of(\"a\", \"b\", \"c\")));\n", "  }\n", "\n", "  public void testEquals_sameType() {\n", "    Collection<String> c = of(\"a\", \"b\", \"c\");\n", "    assertTrue(c.equals(of(\"a\", \"b\", \"c\")));\n", "    assertFalse(c.equals(of(\"a\", \"b\", \"d\")));\n", "  }\n", "\n", "  abstract <E extends Comparable<E>> ImmutableSet.Builder<E> builder();\n", "\n", "  public void testBuilderWithNonDuplicateElements() {\n", "    ImmutableSet<String> set = this.<String>builder()\n", "        .add(\"a\")\n", "        .add(\"b\", \"c\")\n", "        .add(\"d\", \"e\", \"f\")\n", "        .add(\"g\", \"h\", \"i\", \"j\")\n", "        .build();\n", "    assertThat(set).containsExactly(\n", "        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\").inOrder();\n", "  }\n", "\n", "  public void testReuseBuilderWithNonDuplicateElements() {\n", "    ImmutableSet.Builder<String> builder = this.<String>builder()\n", "        .add(\"a\")\n", "        .add(\"b\");\n", "    assertThat(builder.build()).containsExactly(\"a\", \"b\").inOrder();\n", "    builder.add(\"c\", \"d\");\n", "    assertThat(builder.build()).containsExactly(\"a\", \"b\", \"c\", \"d\").inOrder();\n", "  }\n", "\n", "  public void testBuilderWithDuplicateElements() {\n", "    ImmutableSet<String> set = this.<String>builder()\n", "        .add(\"a\")\n", "        .add(\"a\", \"a\")\n", "        .add(\"a\", \"a\", \"a\")\n", "        .add(\"a\", \"a\", \"a\", \"a\")\n", "        .build();\n", "    assertTrue(set.contains(\"a\"));\n", "    assertFalse(set.contains(\"b\"));\n", "    assertEquals(1, set.size());\n", "  }\n", "\n", "  public void testReuseBuilderWithDuplicateElements() {\n", "    ImmutableSet.Builder<String> builder = this.<String>builder()\n", "        .add(\"a\")\n", "        .add(\"a\", \"a\")\n", "        .add(\"b\");\n", "    assertThat(builder.build()).containsExactly(\"a\", \"b\").inOrder();\n", "    builder.add(\"a\", \"b\", \"c\", \"c\");\n", "    assertThat(builder.build()).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testBuilderAddAll() {\n", "    List<String> a = asList(\"a\", \"b\", \"c\");\n", "    List<String> b = asList(\"c\", \"d\", \"e\");\n", "    ImmutableSet<String> set = this.<String>builder()\n", "        .addAll(a)\n", "        .addAll(b)\n", "        .build();\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\").inOrder();\n", "  }\n", "\n", "  static final int LAST_COLOR_ADDED = 0x00BFFF;\n", "\n", "  public void testComplexBuilder() {\n", "    List<Integer> colorElem = asList(0x00, 0x33, 0x66, 0x99, 0xCC, 0xFF);\n", "    // javac won't compile this without \"this.<Integer>\"\n", "    ImmutableSet.Builder<Integer> webSafeColorsBuilder\n", "        = this.<Integer>builder();\n", "    for (Integer red : colorElem) {\n", "      for (Integer green : colorElem) {\n", "        for (Integer blue : colorElem) {\n", "          webSafeColorsBuilder.add((red << 16) + (green << 8) + blue);\n", "        }\n", "      }\n", "    }\n", "    ImmutableSet<Integer> webSafeColors = webSafeColorsBuilder.build();\n", "    assertEquals(216, webSafeColors.size());\n", "    Integer[] webSafeColorArray =\n", "        webSafeColors.toArray(new Integer[webSafeColors.size()]);\n", "    assertEquals(0x000000, (int) webSafeColorArray[0]);\n", "    assertEquals(0x000033, (int) webSafeColorArray[1]);\n", "    assertEquals(0x000066, (int) webSafeColorArray[2]);\n", "    assertEquals(0x003300, (int) webSafeColorArray[6]);\n", "    assertEquals(0x330000, (int) webSafeColorArray[36]);\n", "    ImmutableSet<Integer> addedColor\n", "        = webSafeColorsBuilder.add(LAST_COLOR_ADDED).build();\n", "    assertEquals(\n", "        \"Modifying the builder should not have changed any already built sets\",\n", "        216, webSafeColors.size());\n", "    assertEquals(\"the new array should be one bigger than webSafeColors\",\n", "        217, addedColor.size());\n", "    Integer[] appendColorArray =\n", "        addedColor.toArray(new Integer[addedColor.size()]);\n", "    assertEquals(\n", "        getComplexBuilderSetLastElement(), (int) appendColorArray[216]);\n", "  }\n", "\n", "  abstract int getComplexBuilderSetLastElement();\n", "\n", "  public void testBuilderAddHandlesNullsCorrectly() {\n", "    ImmutableSet.Builder<String> builder = this.<String>builder();\n", "    try {\n", "      builder.add((String) null);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    builder = this.<String>builder();\n", "    try {\n", "      builder.add((String[]) null);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    builder = this.<String>builder();\n", "    try {\n", "      builder.add(\"a\", (String) null);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    builder = this.<String>builder();\n", "    try {\n", "      builder.add(\"a\", \"b\", (String) null);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    builder = this.<String>builder();\n", "    try {\n", "      builder.add(\"a\", \"b\", \"c\", null);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    builder = this.<String>builder();\n", "    try {\n", "      builder.add(\"a\", \"b\", null, \"c\");\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testBuilderAddAllHandlesNullsCorrectly() {\n", "    ImmutableSet.Builder<String> builder = this.<String>builder();\n", "    try {\n", "      builder.addAll((Iterable<String>) null);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    try {\n", "      builder.addAll((Iterator<String>) null);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    builder = this.<String>builder();\n", "    List<String> listWithNulls = asList(\"a\", null, \"b\");\n", "    try {\n", "      builder.addAll(listWithNulls);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "\n", "    Iterable<String> iterableWithNulls = MinimalIterable.of(\"a\", null, \"b\");\n", "    try {\n", "      builder.addAll(iterableWithNulls);\n", "      fail(\"expected NullPointerException\");  // COV_NF_LINE\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431]}}, {"85": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/AbstractIteratorTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Iterator;\n", "import java.util.NoSuchElementException;\n", "\n", "/**\n", " * Unit test for {@code AbstractIterator}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@SuppressWarnings(\"serial\") // No serialization is used in this test\n", "@GwtCompatible(emulated = true)\n", "// TODO(cpovirk): why is this slow (>1m/test) under GWT when fully optimized?\n", "public class AbstractIteratorTest extends TestCase {\n", "\n", "  public void testDefaultBehaviorOfNextAndHasNext() {\n", "\n", "    // This sample AbstractIterator returns 0 on the first call, 1 on the\n", "    // second, then signals that it's reached the end of the data\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      private int rep;\n", "      @Override public Integer computeNext() {\n", "        switch (rep++) {\n", "          case 0:\n", "            return 0;\n", "          case 1:\n", "            return 1;\n", "          case 2:\n", "            return endOfData();\n", "          default:\n", "            fail(\"Should not have been invoked again\");\n", "            return null;\n", "        }\n", "      }\n", "    };\n", "\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(0, (int) iter.next());\n", "\n", "    // verify idempotence of hasNext()\n", "    assertTrue(iter.hasNext());\n", "    assertTrue(iter.hasNext());\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(1, (int) iter.next());\n", "\n", "    assertFalse(iter.hasNext());\n", "\n", "    // Make sure computeNext() doesn't get invoked again\n", "    assertFalse(iter.hasNext());\n", "\n", "    try {\n", "      iter.next();\n", "      fail(\"no exception thrown\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testDefaultBehaviorOfPeek() {\n", "    /*\n", "     * This sample AbstractIterator returns 0 on the first call, 1 on the\n", "     * second, then signals that it's reached the end of the data\n", "     */\n", "    AbstractIterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      private int rep;\n", "      @Override public Integer computeNext() {\n", "        switch (rep++) {\n", "          case 0:\n", "            return 0;\n", "          case 1:\n", "            return 1;\n", "          case 2:\n", "            return endOfData();\n", "          default:\n", "            fail(\"Should not have been invoked again\");\n", "            return null;\n", "        }\n", "      }\n", "    };\n", "\n", "    assertEquals(0, (int) iter.peek());\n", "    assertEquals(0, (int) iter.peek());\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(0, (int) iter.peek());\n", "    assertEquals(0, (int) iter.next());\n", "\n", "    assertEquals(1, (int) iter.peek());\n", "    assertEquals(1, (int) iter.next());\n", "\n", "    try {\n", "      iter.peek();\n", "      fail(\"peek() should throw NoSuchElementException at end\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "\n", "    try {\n", "      iter.peek();\n", "      fail(\"peek() should continue to throw NoSuchElementException at end\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "\n", "    try {\n", "      iter.next();\n", "      fail(\"next() should throw NoSuchElementException as usual\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "\n", "    try {\n", "      iter.peek();\n", "      fail(\"peek() should still throw NoSuchElementException after next()\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testDefaultBehaviorOfPeekForEmptyIteration() {\n", "\n", "    AbstractIterator<Integer> empty = new AbstractIterator<Integer>() {\n", "      private boolean alreadyCalledEndOfData;\n", "      @Override public Integer computeNext() {\n", "        if (alreadyCalledEndOfData) {\n", "          fail(\"Should not have been invoked again\");\n", "        }\n", "        alreadyCalledEndOfData = true;\n", "        return endOfData();\n", "      }\n", "    };\n", "\n", "    try {\n", "      empty.peek();\n", "      fail(\"peek() should throw NoSuchElementException at end\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "\n", "    try {\n", "      empty.peek();\n", "      fail(\"peek() should continue to throw NoSuchElementException at end\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testSneakyThrow() throws Exception {\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      boolean haveBeenCalled;\n", "      @Override public Integer computeNext() {\n", "        if (haveBeenCalled) {\n", "          fail(\"Should not have been called again\");\n", "        } else {\n", "          haveBeenCalled = true;\n", "          sneakyThrow(new SomeCheckedException());\n", "        }\n", "        return null; // never reached\n", "      }\n", "    };\n", "\n", "    // The first time, the sneakily-thrown exception comes out\n", "    try {\n", "      iter.hasNext();\n", "      fail(\"No exception thrown\");\n", "    } catch (Exception e) {\n", "      if (!(e instanceof SomeCheckedException)) {\n", "        throw e;\n", "      }\n", "    }\n", "\n", "    // But the second time, AbstractIterator itself throws an ISE\n", "    try {\n", "      iter.hasNext();\n", "      fail(\"No exception thrown\");\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  public void testException() {\n", "    final SomeUncheckedException exception = new SomeUncheckedException();\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      @Override public Integer computeNext() {\n", "        throw exception;\n", "      }\n", "    };\n", "\n", "    // It should pass through untouched\n", "    try {\n", "      iter.hasNext();\n", "      fail(\"No exception thrown\");\n", "    } catch (SomeUncheckedException e) {\n", "      assertSame(exception, e);\n", "    }\n", "  }\n", "\n", "  public void testExceptionAfterEndOfData() {\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      @Override public Integer computeNext() {\n", "        endOfData();\n", "        throw new SomeUncheckedException();\n", "      }\n", "    };\n", "    try {\n", "      iter.hasNext();\n", "      fail(\"No exception thrown\");\n", "    } catch (SomeUncheckedException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCantRemove() {\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      boolean haveBeenCalled;\n", "      @Override public Integer computeNext() {\n", "        if (haveBeenCalled) {\n", "          endOfData();\n", "        }\n", "        haveBeenCalled = true;\n", "        return 0;\n", "      }\n", "    };\n", "\n", "    assertEquals(0, (int) iter.next());\n", "\n", "    try {\n", "      iter.remove();\n", "      fail(\"No exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testReentrantHasNext() {\n", "    Iterator<Integer> iter = new AbstractIterator<Integer>() {\n", "      @Override protected Integer computeNext() {\n", "        hasNext();\n", "        return null;\n", "      }\n", "    };\n", "    try {\n", "      iter.hasNext();\n", "      fail();\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  // Technically we should test other reentrant scenarios (9 combinations of\n", "  // hasNext/next/peek), but we'll cop out for now, knowing that peek() and\n", "  // next() both start by invoking hasNext() anyway.\n", "\n", "  /**\n", "   * Throws a undeclared checked exception.\n", "   */\n", "  private static void sneakyThrow(Throwable t) {\n", "    class SneakyThrower<T extends Throwable> {\n", "      @SuppressWarnings(\"unchecked\") // not really safe, but that's the point\n", "      void throwIt(Throwable t) throws T {\n", "        throw (T) t;\n", "      }\n", "    }\n", "    new SneakyThrower<Error>().throwIt(t);\n", "  }\n", "\n", "  private static class SomeCheckedException extends Exception {\n", "  }\n", "\n", "  private static class SomeUncheckedException extends RuntimeException {\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281]}}, {"86": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/AbstractSequentialIteratorTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2010 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.AssertionFailedError;\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Iterator;\n", "import java.util.NoSuchElementException;\n", "\n", "/** Tests for {@link AbstractSequentialIterator}. */\n", "@GwtCompatible(emulated = true)\n", "public class AbstractSequentialIteratorTest extends TestCase {\n", "\n", "  public void testDoubler() {\n", "    Iterable<Integer> doubled = new Iterable<Integer>() {\n", "      @Override\n", "      public Iterator<Integer> iterator() {\n", "        return newDoubler(2, 32);\n", "      }\n", "    };\n", "    assertThat(doubled).containsExactly(2, 4, 8, 16, 32).inOrder();\n", "  }\n", "\n", "  public void testSampleCode() {\n", "    Iterable<Integer> actual = new Iterable<Integer>() {\n", "      @Override\n", "      public Iterator<Integer> iterator() {\n", "        Iterator<Integer> powersOfTwo = new AbstractSequentialIterator<Integer>(1) {\n", "          protected Integer computeNext(Integer previous) {\n", "            return (previous == 1 << 30) ? null : previous * 2;\n", "          }\n", "        };\n", "        return powersOfTwo;\n", "      }\n", "    };\n", "    assertThat(actual)\n", "        .containsExactly(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384,\n", "            32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216,\n", "            33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)\n", "        .inOrder();\n", "  }\n", "\n", "  public void testEmpty() {\n", "    Iterator<Object> empty = newEmpty();\n", "    assertFalse(empty.hasNext());\n", "    try {\n", "      empty.next();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "    try {\n", "      empty.remove();\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testBroken() {\n", "    Iterator<Object> broken = newBroken();\n", "    assertTrue(broken.hasNext());\n", "    // We can't retrieve even the known first element:\n", "    try {\n", "      broken.next();\n", "      fail();\n", "    } catch (MyException expected) {\n", "    }\n", "    try {\n", "      broken.next();\n", "      fail();\n", "    } catch (MyException expected) {\n", "    }\n", "  }\n", "\n", "  private static Iterator<Integer> newDoubler(int first, final int last) {\n", "    return new AbstractSequentialIterator<Integer>(first) {\n", "      @Override\n", "      protected Integer computeNext(Integer previous) {\n", "        return (previous == last) ? null : previous * 2;\n", "      }\n", "    };\n", "  }\n", "\n", "  private static <T> Iterator<T> newEmpty() {\n", "    return new AbstractSequentialIterator<T>(null) {\n", "      @Override\n", "      protected T computeNext(T previous) {\n", "        throw new AssertionFailedError();\n", "      }\n", "    };\n", "  }\n", "\n", "  private static Iterator<Object> newBroken() {\n", "    return new AbstractSequentialIterator<Object>(\"UNUSED\") {\n", "      @Override\n", "      protected Object computeNext(Object previous) {\n", "        throw new MyException();\n", "      }\n", "    };\n", "  }\n", "\n", "  private static class MyException extends RuntimeException {}\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]}}, {"87": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/AbstractTableReadTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Objects;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Test cases for {@link Table} read operations.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public abstract class AbstractTableReadTest extends TestCase {\n", "  protected Table<String, Integer, Character> table;\n", "\n", "  /**\n", "   * Creates a table with the specified data.\n", "   *\n", "   * @param data the table data, repeating the sequence row key, column key,\n", "   *     value once per mapping\n", "   * @throws IllegalArgumentException if the size of {@code data} isn't a\n", "   *     multiple of 3\n", "   * @throws ClassCastException if a data element has the wrong type\n", "   */\n", "  protected abstract Table<String, Integer, Character>\n", "      create(Object... data);\n", "\n", "  protected void assertSize(int expectedSize) {\n", "    assertEquals(expectedSize, table.size());\n", "  }\n", "\n", "  @Override public void setUp() throws Exception {\n", "    super.setUp();\n", "    table = create();\n", "  }\n", "\n", "  public void testContains() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertTrue(table.contains(\"foo\", 1));\n", "    assertTrue(table.contains(\"bar\", 1));\n", "    assertTrue(table.contains(\"foo\", 3));\n", "    assertFalse(table.contains(\"foo\", 2));\n", "    assertFalse(table.contains(\"bar\", 3));\n", "    assertFalse(table.contains(\"cat\", 1));\n", "    assertFalse(table.contains(\"foo\", null));\n", "    assertFalse(table.contains(null, 1));\n", "    assertFalse(table.contains(null, null));\n", "  }\n", "\n", "  public void testContainsRow() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertTrue(table.containsRow(\"foo\"));\n", "    assertTrue(table.containsRow(\"bar\"));\n", "    assertFalse(table.containsRow(\"cat\"));\n", "    assertFalse(table.containsRow(null));\n", "  }\n", "\n", "  public void testContainsColumn() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertTrue(table.containsColumn(1));\n", "    assertTrue(table.containsColumn(3));\n", "    assertFalse(table.containsColumn(2));\n", "    assertFalse(table.containsColumn(null));\n", "  }\n", "\n", "  public void testContainsValue() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertTrue(table.containsValue('a'));\n", "    assertTrue(table.containsValue('b'));\n", "    assertTrue(table.containsValue('c'));\n", "    assertFalse(table.containsValue('x'));\n", "    assertFalse(table.containsValue(null));\n", "  }\n", "\n", "  public void testGet() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals((Character) 'a', table.get(\"foo\", 1));\n", "    assertEquals((Character) 'b', table.get(\"bar\", 1));\n", "    assertEquals((Character) 'c', table.get(\"foo\", 3));\n", "    assertNull(table.get(\"foo\", 2));\n", "    assertNull(table.get(\"bar\", 3));\n", "    assertNull(table.get(\"cat\", 1));\n", "    assertNull(table.get(\"foo\", null));\n", "    assertNull(table.get(null, 1));\n", "    assertNull(table.get(null, null));\n", "  }\n", "\n", "  public void testIsEmpty() {\n", "    assertTrue(table.isEmpty());\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertFalse(table.isEmpty());\n", "  }\n", "\n", "  public void testSize() {\n", "    assertSize(0);\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertSize(3);\n", "  }\n", "\n", "  public void testEquals() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Table<String, Integer, Character> hashCopy = HashBasedTable.create(table);\n", "    Table<String, Integer, Character> reordered\n", "        = create(\"foo\", 3, 'c', \"foo\", 1, 'a', \"bar\", 1, 'b');\n", "    Table<String, Integer, Character> smaller\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b');\n", "    Table<String, Integer, Character> swapOuter\n", "        = create(\"bar\", 1, 'a', \"foo\", 1, 'b', \"bar\", 3, 'c');\n", "    Table<String, Integer, Character> swapValues\n", "        = create(\"foo\", 1, 'c', \"bar\", 1, 'b', \"foo\", 3, 'a');\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(table, hashCopy, reordered)\n", "        .addEqualityGroup(smaller)\n", "        .addEqualityGroup(swapOuter)\n", "        .addEqualityGroup(swapValues)\n", "        .testEquals();\n", "  }\n", "\n", "  public void testHashCode() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    int expected = Objects.hashCode(\"foo\", 1, 'a')\n", "        + Objects.hashCode(\"bar\", 1, 'b')\n", "        + Objects.hashCode(\"foo\", 3, 'c');\n", "    assertEquals(expected, table.hashCode());\n", "  }\n", "\n", "  public void testToStringSize1() {\n", "    table = create(\"foo\", 1, 'a');\n", "    assertEquals(\"{foo={1=a}}\", table.toString());\n", "  }\n", "\n", "  public void testRow() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(ImmutableMap.of(1, 'a', 3, 'c'), table.row(\"foo\"));\n", "  }\n", "\n", "  // This test assumes that the implementation does not support null keys.\n", "  public void testRowNull() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    try {\n", "      table.row(null);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testColumn() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(ImmutableMap.of(\"foo\", 'a', \"bar\", 'b'), table.column(1));\n", "  }\n", "\n", "  // This test assumes that the implementation does not support null keys.\n", "  public void testColumnNull() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    try {\n", "      table.column(null);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testColumnSetPartialOverlap() {\n", "    table = create(\n", "        \"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 2, 'c', \"bar\", 3, 'd');\n", "    assertThat(table.columnKeySet()).containsExactly(1, 2, 3);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187]}}, {"88": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ArrayListMultimapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.ConcurrentModificationException;\n", "import java.util.List;\n", "import java.util.RandomAccess;\n", "\n", "/**\n", " * Unit tests for {@code ArrayListMultimap}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ArrayListMultimapTest extends TestCase {\n", "\n", "  protected ListMultimap<String, Integer> create() {\n", "    return ArrayListMultimap.create();\n", "  }\n", "\n", "  /**\n", "   * Confirm that get() returns a List implementing RandomAccess.\n", "   */\n", "  public void testGetRandomAccess() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 3);\n", "    assertTrue(multimap.get(\"foo\") instanceof RandomAccess);\n", "    assertTrue(multimap.get(\"bar\") instanceof RandomAccess);\n", "  }\n", "\n", "  /**\n", "   * Confirm that removeAll() returns a List implementing RandomAccess.\n", "   */\n", "  public void testRemoveAllRandomAccess() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 3);\n", "    assertTrue(multimap.removeAll(\"foo\") instanceof RandomAccess);\n", "    assertTrue(multimap.removeAll(\"bar\") instanceof RandomAccess);\n", "  }\n", "\n", "  /**\n", "   * Confirm that replaceValues() returns a List implementing RandomAccess.\n", "   */\n", "  public void testReplaceValuesRandomAccess() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 3);\n", "    assertTrue(multimap.replaceValues(\"foo\", asList(2, 4))\n", "        instanceof RandomAccess);\n", "    assertTrue(multimap.replaceValues(\"bar\", asList(2, 4))\n", "        instanceof RandomAccess);\n", "  }\n", "\n", "  /**\n", "   * Test throwing ConcurrentModificationException when a sublist's ancestor's\n", "   * delegate changes.\n", "   */\n", "  public void testSublistConcurrentModificationException() {\n", "    ListMultimap<String, Integer> multimap = create();\n", "    multimap.putAll(\"foo\", asList(1, 2, 3, 4, 5));\n", "    List<Integer> list = multimap.get(\"foo\");\n", "    assertThat(multimap.get(\"foo\")).containsExactly(1, 2, 3, 4, 5).inOrder();\n", "    List<Integer> sublist = list.subList(0, 5);\n", "    assertThat(sublist).containsExactly(1, 2, 3, 4, 5).inOrder();\n", "\n", "    sublist.clear();\n", "    assertTrue(sublist.isEmpty());\n", "    multimap.put(\"foo\", 6);\n", "\n", "    try {\n", "      sublist.isEmpty();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {}\n", "  }\n", "\n", "  public void testCreateFromMultimap() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 3);\n", "    multimap.put(\"bar\", 2);\n", "    ArrayListMultimap<String, Integer> copy\n", "        = ArrayListMultimap.create(multimap);\n", "    assertEquals(multimap, copy);\n", "  }\n", "\n", "  public void testCreate() {\n", "    ArrayListMultimap<String, Integer> multimap\n", "        = ArrayListMultimap.create();\n", "    assertEquals(3, multimap.expectedValuesPerKey);\n", "  }\n", "\n", "  public void testCreateFromSizes() {\n", "    ArrayListMultimap<String, Integer> multimap\n", "        = ArrayListMultimap.create(15, 20);\n", "    assertEquals(20, multimap.expectedValuesPerKey);\n", "  }\n", "\n", "  public void testCreateFromIllegalSizes() {\n", "    try {\n", "      ArrayListMultimap.create(15, -2);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "\n", "    try {\n", "      ArrayListMultimap.create(-15, 2);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreateFromHashMultimap() {\n", "    Multimap<String, Integer> original = HashMultimap.create();\n", "    ArrayListMultimap<String, Integer> multimap\n", "        = ArrayListMultimap.create(original);\n", "    assertEquals(3, multimap.expectedValuesPerKey);\n", "  }\n", "\n", "  public void testCreateFromArrayListMultimap() {\n", "    ArrayListMultimap<String, Integer> original\n", "        = ArrayListMultimap.create(15, 20);\n", "    ArrayListMultimap<String, Integer> multimap\n", "        = ArrayListMultimap.create(original);\n", "    assertEquals(20, multimap.expectedValuesPerKey);\n", "  }\n", "\n", "  public void testTrimToSize() {\n", "    ArrayListMultimap<String, Integer> multimap\n", "        = ArrayListMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 2);\n", "    multimap.put(\"bar\", 3);\n", "    multimap.trimToSize();\n", "    assertEquals(3, multimap.size());\n", "    assertThat(multimap.get(\"foo\")).containsExactly(1, 2).inOrder();\n", "    assertThat(multimap.get(\"bar\")).contains(3);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160]}}, {"89": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ArrayTableTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Objects;\n", "import com.google.common.collect.Table.Cell;\n", "import com.google.common.testing.EqualsTester;\n", "import com.google.common.testing.SerializableTester;\n", "\n", "import java.util.Arrays;\n", "import java.util.Map;\n", "\n", "/**\n", " * Test cases for {@link ArrayTable}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ArrayTableTest extends AbstractTableTest {\n", "\n", "  @Override protected ArrayTable<String, Integer, Character> create(\n", "      Object... data) {\n", "    // TODO: Specify different numbers of rows and columns, to detect problems\n", "    // that arise when the wrong size is used.\n", "    ArrayTable<String, Integer, Character> table =\n", "        ArrayTable.create(asList(\"foo\", \"bar\", \"cat\"), asList(1, 2, 3));\n", "    populate(table, data);\n", "    return table;\n", "  }\n", "\n", "  @Override protected void assertSize(int expectedSize) {\n", "    assertEquals(9, table.size());\n", "  }\n", "\n", "  @Override protected boolean supportsRemove() {\n", "    return false;\n", "  }\n", "\n", "  @Override protected boolean supportsNullValues() {\n", "    return true;\n", "  }\n", "\n", "  // Overriding tests of behavior that differs for ArrayTable.\n", "\n", "  @Override public void testContains() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertTrue(table.contains(\"foo\", 1));\n", "    assertTrue(table.contains(\"bar\", 1));\n", "    assertTrue(table.contains(\"foo\", 3));\n", "    assertTrue(table.contains(\"foo\", 2));\n", "    assertTrue(table.contains(\"bar\", 3));\n", "    assertTrue(table.contains(\"cat\", 1));\n", "    assertFalse(table.contains(\"foo\", -1));\n", "    assertFalse(table.contains(\"bad\", 1));\n", "    assertFalse(table.contains(\"bad\", -1));\n", "    assertFalse(table.contains(\"foo\", null));\n", "    assertFalse(table.contains(null, 1));\n", "    assertFalse(table.contains(null, null));\n", "  }\n", "\n", "  @Override public void testContainsRow() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertTrue(table.containsRow(\"foo\"));\n", "    assertTrue(table.containsRow(\"bar\"));\n", "    assertTrue(table.containsRow(\"cat\"));\n", "    assertFalse(table.containsRow(\"bad\"));\n", "    assertFalse(table.containsRow(null));\n", "  }\n", "\n", "  @Override public void testContainsColumn() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertTrue(table.containsColumn(1));\n", "    assertTrue(table.containsColumn(3));\n", "    assertTrue(table.containsColumn(2));\n", "    assertFalse(table.containsColumn(-1));\n", "    assertFalse(table.containsColumn(null));\n", "  }\n", "\n", "  @Override public void testContainsValue() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertTrue(table.containsValue('a'));\n", "    assertTrue(table.containsValue('b'));\n", "    assertTrue(table.containsValue('c'));\n", "    assertFalse(table.containsValue('x'));\n", "    assertTrue(table.containsValue(null));\n", "  }\n", "\n", "  @Override public void testIsEmpty() {\n", "    assertFalse(table.isEmpty());\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertFalse(table.isEmpty());\n", "  }\n", "\n", "  @Override public void testEquals() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Table<String, Integer, Character> hashCopy = HashBasedTable.create();\n", "    hashCopy.put(\"foo\", 1, 'a');\n", "    hashCopy.put(\"bar\", 1, 'b');\n", "    hashCopy.put(\"foo\", 3, 'c');\n", "    Table<String, Integer, Character> reordered\n", "        = create(\"foo\", 3, 'c', \"foo\", 1, 'a', \"bar\", 1, 'b');\n", "    Table<String, Integer, Character> smaller\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b');\n", "    Table<String, Integer, Character> swapOuter\n", "        = create(\"bar\", 1, 'a', \"foo\", 1, 'b', \"bar\", 3, 'c');\n", "    Table<String, Integer, Character> swapValues\n", "        = create(\"foo\", 1, 'c', \"bar\", 1, 'b', \"foo\", 3, 'a');\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(table, reordered)\n", "        .addEqualityGroup(hashCopy)\n", "        .addEqualityGroup(smaller)\n", "        .addEqualityGroup(swapOuter)\n", "        .addEqualityGroup(swapValues)\n", "        .testEquals();\n", "  }\n", "\n", "  @Override public void testHashCode() {\n", "    table = ArrayTable.create(asList(\"foo\", \"bar\"), asList(1, 3));\n", "    table.put(\"foo\", 1, 'a');\n", "    table.put(\"bar\", 1, 'b');\n", "    table.put(\"foo\", 3, 'c');\n", "    int expected = Objects.hashCode(\"foo\", 1, 'a')\n", "        + Objects.hashCode(\"bar\", 1, 'b')\n", "        + Objects.hashCode(\"foo\", 3, 'c')\n", "        + Objects.hashCode(\"bar\", 3, 0);\n", "    assertEquals(expected, table.hashCode());\n", "  }\n", "\n", "  @Override public void testRow() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Map<Integer, Character> expected = Maps.newHashMap();\n", "    expected.put(1, 'a');\n", "    expected.put(3, 'c');\n", "    expected.put(2, null);\n", "    assertEquals(expected, table.row(\"foo\"));\n", "  }\n", "\n", "  @Override public void testColumn() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Map<String, Character> expected = Maps.newHashMap();\n", "    expected.put(\"foo\", 'a');\n", "    expected.put(\"bar\", 'b');\n", "    expected.put(\"cat\", null);\n", "    assertEquals(expected, table.column(1));\n", "  }\n", "\n", "  @Override public void testToStringSize1() {\n", "    table = ArrayTable.create(ImmutableList.of(\"foo\"), ImmutableList.of(1));\n", "    table.put(\"foo\", 1, 'a');\n", "    assertEquals(\"{foo={1=a}}\", table.toString());\n", "  }\n", "\n", "  public void testCreateDuplicateRows() {\n", "    try {\n", "      ArrayTable.create(asList(\"foo\", \"bar\", \"foo\"), asList(1, 2, 3));\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreateDuplicateColumns() {\n", "    try {\n", "      ArrayTable.create(asList(\"foo\", \"bar\"), asList(1, 2, 3, 2));\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreateEmptyRows() {\n", "    try {\n", "      ArrayTable.create(Arrays.<String>asList(), asList(1, 2, 3));\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreateEmptyColumns() {\n", "    try {\n", "      ArrayTable.create(asList(\"foo\", \"bar\"), Arrays.<Integer>asList());\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreateCopyArrayTable() {\n", "    Table<String, Integer, Character> original\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Table<String, Integer, Character> copy = ArrayTable.create(original);\n", "    assertEquals(original, copy);\n", "    original.put(\"foo\", 1, 'd');\n", "    assertEquals((Character) 'd', original.get(\"foo\", 1));\n", "    assertEquals((Character) 'a', copy.get(\"foo\", 1));\n", "    assertEquals(copy.rowKeySet(), original.rowKeySet());\n", "    assertEquals(copy.columnKeySet(), original.columnKeySet());\n", "  }\n", "\n", "  public void testCreateCopyHashBasedTable() {\n", "    Table<String, Integer, Character> original = HashBasedTable.create();\n", "    original.put(\"foo\", 1, 'a');\n", "    original.put(\"bar\", 1, 'b');\n", "    original.put(\"foo\", 3, 'c');\n", "    Table<String, Integer, Character> copy = ArrayTable.create(original);\n", "    assertEquals(4, copy.size());\n", "    assertEquals((Character) 'a', copy.get(\"foo\", 1));\n", "    assertEquals((Character) 'b', copy.get(\"bar\", 1));\n", "    assertEquals((Character) 'c', copy.get(\"foo\", 3));\n", "    assertNull(copy.get(\"bar\", 3));\n", "    original.put(\"foo\", 1, 'd');\n", "    assertEquals((Character) 'd', original.get(\"foo\", 1));\n", "    assertEquals((Character) 'a', copy.get(\"foo\", 1));\n", "    assertEquals(copy.rowKeySet(), ImmutableSet.of(\"foo\", \"bar\"));\n", "    assertEquals(copy.columnKeySet(), ImmutableSet.of(1, 3));\n", "  }\n", "\n", "  public void testCreateCopyEmptyTable() {\n", "    Table<String, Integer, Character> original = HashBasedTable.create();\n", "    try {\n", "      ArrayTable.create(original);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testSerialization() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    SerializableTester.reserializeAndAssert(table);\n", "  }\n", "\n", "  public void testToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"{foo={1=a, 2=null, 3=c}, \" +\n", "        \"bar={1=b, 2=null, 3=null}, \" +\n", "        \"cat={1=null, 2=null, 3=null}}\",\n", "        table.toString());\n", "    assertEquals(\"{foo={1=a, 2=null, 3=c}, \" +\n", "        \"bar={1=b, 2=null, 3=null}, \" +\n", "        \"cat={1=null, 2=null, 3=null}}\",\n", "        table.rowMap().toString());\n", "  }\n", "\n", "  public void testCellSetToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"[(foo,1)=a, (foo,2)=null, (foo,3)=c, \" +\n", "        \"(bar,1)=b, (bar,2)=null, (bar,3)=null, \" +\n", "        \"(cat,1)=null, (cat,2)=null, (cat,3)=null]\",\n", "        table.cellSet().toString());\n", "  }\n", "\n", "  public void testRowKeySetToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"[foo, bar, cat]\", table.rowKeySet().toString());\n", "  }\n", "\n", "  public void testColumnKeySetToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"[1, 2, 3]\", table.columnKeySet().toString());\n", "  }\n", "\n", "  public void testValuesToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"[a, null, c, b, null, null, null, null, null]\",\n", "        table.values().toString());\n", "  }\n", "\n", "  public void testRowKeyList() {\n", "    ArrayTable<String, Integer, Character> table\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertThat(table.rowKeyList()).containsExactly(\"foo\", \"bar\", \"cat\").inOrder();\n", "  }\n", "\n", "  public void testColumnKeyList() {\n", "    ArrayTable<String, Integer, Character> table\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertThat(table.columnKeyList()).containsExactly(1, 2, 3).inOrder();\n", "  }\n", "\n", "  public void testGetMissingKeys() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertNull(table.get(\"dog\", 1));\n", "    assertNull(table.get(\"foo\", 4));\n", "  }\n", "\n", "  public void testAt() {\n", "    ArrayTable<String, Integer, Character> table\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals((Character) 'b', table.at(1, 0));\n", "    assertEquals((Character) 'c', table.at(0, 2));\n", "    assertNull(table.at(1, 2));\n", "    try {\n", "      table.at(1, 3);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    try {\n", "      table.at(1, -1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    try {\n", "      table.at(3, 2);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    try {\n", "      table.at(-1, 2);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "  }\n", "\n", "  public void testSet() {\n", "    ArrayTable<String, Integer, Character> table\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals((Character) 'b', table.set(1, 0, 'd'));\n", "    assertEquals((Character) 'd', table.get(\"bar\", 1));\n", "    assertNull(table.set(2, 0, 'e'));\n", "    assertEquals((Character) 'e', table.get(\"cat\", 1));\n", "    assertEquals((Character) 'a', table.set(0, 0, null));\n", "    assertNull(table.get(\"foo\", 1));\n", "    try {\n", "      table.set(1, 3, 'z');\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    try {\n", "      table.set(1, -1, 'z');\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    try {\n", "      table.set(3, 2, 'z');\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    try {\n", "      table.set(-1, 2, 'z');\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    assertFalse(table.containsValue('z'));\n", "  }\n", "\n", "  public void testEraseAll() {\n", "    ArrayTable<String, Integer, Character> table\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    table.eraseAll();\n", "    assertEquals(9, table.size());\n", "    assertNull(table.get(\"bar\", 1));\n", "    assertTrue(table.containsRow(\"foo\"));\n", "    assertFalse(table.containsValue('a'));\n", "  }\n", "\n", "  public void testPutIllegal() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    try {\n", "      table.put(\"dog\", 1, 'd');\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected).hasMessage(\"Row dog not in [foo, bar, cat]\");\n", "    }\n", "    try {\n", "      table.put(\"foo\", 4, 'd');\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected).hasMessage(\"Column 4 not in [1, 2, 3]\");\n", "    }\n", "    assertFalse(table.containsValue('d'));\n", "  }\n", "\n", "  public void testErase() {\n", "    ArrayTable<String, Integer, Character> table\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals((Character) 'b', table.erase(\"bar\", 1));\n", "    assertNull(table.get(\"bar\", 1));\n", "    assertEquals(9, table.size());\n", "    assertNull(table.erase(\"bar\", 1));\n", "    assertNull(table.erase(\"foo\", 2));\n", "    assertNull(table.erase(\"dog\", 1));\n", "    assertNull(table.erase(\"bar\", 5));\n", "    assertNull(table.erase(null, 1));\n", "    assertNull(table.erase(\"bar\", null));\n", "  }\n", "\n", "  public void testCellReflectsChanges() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Cell<String, Integer, Character> cell = table.cellSet().iterator().next();\n", "    assertEquals(Tables.immutableCell(\"foo\", 1, 'a'), cell);\n", "    assertEquals((Character) 'a', table.put(\"foo\", 1, 'd'));\n", "    assertEquals(Tables.immutableCell(\"foo\", 1, 'd'), cell);\n", "  }\n", "\n", "  public void testRowMissing() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Map<Integer, Character> row = table.row(\"dog\");\n", "    assertTrue(row.isEmpty());\n", "    try {\n", "      row.put(1, 'd');\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {}\n", "  }\n", "\n", "  public void testColumnMissing() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Map<String, Character> column = table.column(4);\n", "    assertTrue(column.isEmpty());\n", "    try {\n", "      column.put(\"foo\", 'd');\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {}\n", "  }\n", "\n", "  public void testRowPutIllegal() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Map<Integer, Character> map = table.row(\"foo\");\n", "    try {\n", "      map.put(4, 'd');\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected).hasMessage(\"Column 4 not in [1, 2, 3]\");\n", "    }\n", "  }\n", "\n", "  public void testColumnPutIllegal() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Map<String, Character> map = table.column(3);\n", "    try {\n", "      map.put(\"dog\", 'd');\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected).hasMessage(\"Row dog not in [foo, bar, cat]\");\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440]}}, {"90": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/Collections2Test.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.Iterables.concat;\n", "import static com.google.common.collect.Lists.newArrayList;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "import static java.util.Collections.nCopies;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Predicate;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.NoSuchElementException;\n", "\n", "/**\n", " * Tests for {@link Collections2}.\n", " *\n", " * @author Chris Povirk\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class Collections2Test extends TestCase {\n", "\n", "  static final Predicate<String> NOT_YYY_ZZZ = new Predicate<String>() {\n", "      @Override\n", "      public boolean apply(String input) {\n", "        return !\"yyy\".equals(input) && !\"zzz\".equals(input);\n", "      }\n", "  };\n", "\n", "  static final Predicate<String> LENGTH_1 = new Predicate<String>() {\n", "    @Override\n", "    public boolean apply(String input) {\n", "      return input.length() == 1;\n", "    }\n", "  };\n", "\n", "  static final Predicate<String> STARTS_WITH_VOWEL = new Predicate<String>() {\n", "    @Override\n", "    public boolean apply(String input) {\n", "      return asList('a', 'e', 'i', 'o', 'u').contains(input.charAt(0));\n", "    }\n", "  };\n", "\n", "  private static final Function<String, String> REMOVE_FIRST_CHAR\n", "      = new Function<String, String>() {\n", "        @Override\n", "        public String apply(String from) {\n", "          return ((from == null) || \"\".equals(from))\n", "              ? null : from.substring(1);\n", "        }\n", "      };\n", "\n", "  public void testOrderedPermutationSetEmpty() {\n", "    List<Integer> list = newArrayList();\n", "    Collection<List<Integer>> permutationSet =\n", "        Collections2.orderedPermutations(list);\n", "\n", "    assertEquals(1, permutationSet.size());\n", "    assertThat(permutationSet).contains(list);\n", "\n", "    Iterator<List<Integer>> permutations = permutationSet.iterator();\n", "\n", "    assertNextPermutation(Lists.<Integer>newArrayList(), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testOrderedPermutationSetOneElement() {\n", "    List<Integer> list = newArrayList(1);\n", "    Iterator<List<Integer>> permutations =\n", "        Collections2.orderedPermutations(list).iterator();\n", "\n", "    assertNextPermutation(newArrayList(1), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testOrderedPermutationSetThreeElements() {\n", "    List<String> list = newArrayList(\"b\", \"a\", \"c\");\n", "    Iterator<List<String>> permutations =\n", "        Collections2.orderedPermutations(list).iterator();\n", "\n", "    assertNextPermutation(newArrayList(\"a\", \"b\", \"c\"), permutations);\n", "    assertNextPermutation(newArrayList(\"a\", \"c\", \"b\"), permutations);\n", "    assertNextPermutation(newArrayList(\"b\", \"a\", \"c\"), permutations);\n", "    assertNextPermutation(newArrayList(\"b\", \"c\", \"a\"), permutations);\n", "    assertNextPermutation(newArrayList(\"c\", \"a\", \"b\"), permutations);\n", "    assertNextPermutation(newArrayList(\"c\", \"b\", \"a\"), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testOrderedPermutationSetRepeatedElements() {\n", "    List<Integer> list = newArrayList(1, 1, 2, 2);\n", "    Iterator<List<Integer>> permutations =\n", "        Collections2.orderedPermutations(list, Ordering.natural()).iterator();\n", "\n", "    assertNextPermutation(newArrayList(1, 1, 2, 2), permutations);\n", "    assertNextPermutation(newArrayList(1, 2, 1, 2), permutations);\n", "    assertNextPermutation(newArrayList(1, 2, 2, 1), permutations);\n", "    assertNextPermutation(newArrayList(2, 1, 1, 2), permutations);\n", "    assertNextPermutation(newArrayList(2, 1, 2, 1), permutations);\n", "    assertNextPermutation(newArrayList(2, 2, 1, 1), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testOrderedPermutationSetRepeatedElementsSize() {\n", "    List<Integer> list = newArrayList(1, 1, 1, 1, 2, 2, 3);\n", "    Collection<List<Integer>> permutations =\n", "        Collections2.orderedPermutations(list, Ordering.natural());\n", "\n", "    assertPermutationsCount(105, permutations);\n", "  }\n", "\n", "  public void testOrderedPermutationSetSizeOverflow() {\n", "    // 12 elements won't overflow\n", "    assertEquals(479001600 /*12!*/, Collections2.orderedPermutations(\n", "        newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)).size());\n", "    // 13 elements overflow an int\n", "    assertEquals(Integer.MAX_VALUE, Collections2.orderedPermutations(\n", "        newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)).size());\n", "    // 21 elements overflow a long\n", "    assertEquals(Integer.MAX_VALUE, Collections2.orderedPermutations(\n", "        newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n", "            16, 17, 18, 19, 20, 21)).size());\n", "\n", "    // Almost force an overflow in the binomial coefficient calculation\n", "    assertEquals(1391975640 /*C(34,14)*/, Collections2.orderedPermutations(\n", "        concat(nCopies(20, 1), nCopies(14, 2))).size());\n", "    // Do force an overflow in the binomial coefficient calculation\n", "    assertEquals(Integer.MAX_VALUE, Collections2.orderedPermutations(\n", "        concat(nCopies(21, 1), nCopies(14, 2))).size());\n", "  }\n", "\n", "  public void testOrderedPermutationSetContains() {\n", "    List<Integer> list = newArrayList(3, 2, 1);\n", "    Collection<List<Integer>> permutationSet =\n", "        Collections2.orderedPermutations(list);\n", "\n", "    assertTrue(permutationSet.contains(newArrayList(1, 2, 3)));\n", "    assertTrue(permutationSet.contains(newArrayList(2, 3, 1)));\n", "    assertFalse(permutationSet.contains(newArrayList(1, 2)));\n", "    assertFalse(permutationSet.contains(newArrayList(1, 1, 2, 3)));\n", "    assertFalse(permutationSet.contains(newArrayList(1, 2, 3, 4)));\n", "    assertFalse(permutationSet.contains(null));\n", "  }\n", "\n", "  public void testPermutationSetEmpty() {\n", "    Collection<List<Integer>> permutationSet =\n", "        Collections2.permutations(Collections.<Integer>emptyList());\n", "\n", "    assertEquals(1, permutationSet.size());\n", "    assertTrue(permutationSet.contains(Collections.<Integer> emptyList()));\n", "\n", "    Iterator<List<Integer>> permutations = permutationSet.iterator();\n", "    assertNextPermutation(Collections.<Integer> emptyList(), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testPermutationSetOneElement() {\n", "    Iterator<List<Integer>> permutations =\n", "        Collections2.permutations(Collections.<Integer> singletonList(1))\n", "        .iterator();\n", "    assertNextPermutation(newArrayList(1), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testPermutationSetTwoElements() {\n", "    Iterator<List<Integer>> permutations = Collections2.permutations(\n", "        newArrayList(1, 2)).iterator();\n", "    assertNextPermutation(newArrayList(1, 2), permutations);\n", "    assertNextPermutation(newArrayList(2, 1), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testPermutationSetThreeElements() {\n", "    Iterator<List<Integer>> permutations = Collections2.permutations(\n", "        newArrayList(1, 2, 3)).iterator();\n", "    assertNextPermutation(newArrayList(1, 2, 3), permutations);\n", "    assertNextPermutation(newArrayList(1, 3, 2), permutations);\n", "    assertNextPermutation(newArrayList(3, 1, 2), permutations);\n", "\n", "    assertNextPermutation(newArrayList(3, 2, 1), permutations);\n", "    assertNextPermutation(newArrayList(2, 3, 1), permutations);\n", "    assertNextPermutation(newArrayList(2, 1, 3), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testPermutationSetThreeElementsOutOfOrder() {\n", "    Iterator<List<Integer>> permutations = Collections2.permutations(\n", "        newArrayList(3, 2, 1)).iterator();\n", "    assertNextPermutation(newArrayList(3, 2, 1), permutations);\n", "    assertNextPermutation(newArrayList(3, 1, 2), permutations);\n", "    assertNextPermutation(newArrayList(1, 3, 2), permutations);\n", "\n", "    assertNextPermutation(newArrayList(1, 2, 3), permutations);\n", "    assertNextPermutation(newArrayList(2, 1, 3), permutations);\n", "    assertNextPermutation(newArrayList(2, 3, 1), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testPermutationSetThreeRepeatedElements() {\n", "    Iterator<List<Integer>> permutations = Collections2.permutations(\n", "        newArrayList(1, 1, 2)).iterator();\n", "    assertNextPermutation(newArrayList(1, 1, 2), permutations);\n", "    assertNextPermutation(newArrayList(1, 2, 1), permutations);\n", "    assertNextPermutation(newArrayList(2, 1, 1), permutations);\n", "    assertNextPermutation(newArrayList(2, 1, 1), permutations);\n", "    assertNextPermutation(newArrayList(1, 2, 1), permutations);\n", "    assertNextPermutation(newArrayList(1, 1, 2), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testPermutationSetFourElements() {\n", "    Iterator<List<Integer>> permutations = Collections2.permutations(\n", "        newArrayList(1, 2, 3, 4)).iterator();\n", "    assertNextPermutation(newArrayList(1, 2, 3, 4), permutations);\n", "    assertNextPermutation(newArrayList(1, 2, 4, 3), permutations);\n", "    assertNextPermutation(newArrayList(1, 4, 2, 3), permutations);\n", "    assertNextPermutation(newArrayList(4, 1, 2, 3), permutations);\n", "\n", "    assertNextPermutation(newArrayList(4, 1, 3, 2), permutations);\n", "    assertNextPermutation(newArrayList(1, 4, 3, 2), permutations);\n", "    assertNextPermutation(newArrayList(1, 3, 4, 2), permutations);\n", "    assertNextPermutation(newArrayList(1, 3, 2, 4), permutations);\n", "\n", "    assertNextPermutation(newArrayList(3, 1, 2, 4), permutations);\n", "    assertNextPermutation(newArrayList(3, 1, 4, 2), permutations);\n", "    assertNextPermutation(newArrayList(3, 4, 1, 2), permutations);\n", "    assertNextPermutation(newArrayList(4, 3, 1, 2), permutations);\n", "\n", "    assertNextPermutation(newArrayList(4, 3, 2, 1), permutations);\n", "    assertNextPermutation(newArrayList(3, 4, 2, 1), permutations);\n", "    assertNextPermutation(newArrayList(3, 2, 4, 1), permutations);\n", "    assertNextPermutation(newArrayList(3, 2, 1, 4), permutations);\n", "\n", "    assertNextPermutation(newArrayList(2, 3, 1, 4), permutations);\n", "    assertNextPermutation(newArrayList(2, 3, 4, 1), permutations);\n", "    assertNextPermutation(newArrayList(2, 4, 3, 1), permutations);\n", "    assertNextPermutation(newArrayList(4, 2, 3, 1), permutations);\n", "\n", "    assertNextPermutation(newArrayList(4, 2, 1, 3), permutations);\n", "    assertNextPermutation(newArrayList(2, 4, 1, 3), permutations);\n", "    assertNextPermutation(newArrayList(2, 1, 4, 3), permutations);\n", "    assertNextPermutation(newArrayList(2, 1, 3, 4), permutations);\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testPermutationSetSize() {\n", "    assertPermutationsCount(1,\n", "        Collections2.permutations(Collections.<Integer>emptyList()));\n", "    assertPermutationsCount(1, Collections2.permutations(newArrayList(1)));\n", "    assertPermutationsCount(2, Collections2.permutations(newArrayList(1, 2)));\n", "    assertPermutationsCount(6,\n", "        Collections2.permutations(newArrayList(1, 2, 3)));\n", "    assertPermutationsCount(5040,\n", "        Collections2.permutations(newArrayList(1, 2, 3, 4, 5, 6, 7)));\n", "    assertPermutationsCount(40320,\n", "        Collections2.permutations(newArrayList(1, 2, 3, 4, 5, 6, 7, 8)));\n", "  }\n", "\n", "  public void testPermutationSetSizeOverflow() {\n", "    // 13 elements overflow an int\n", "    assertEquals(Integer.MAX_VALUE, Collections2.permutations(newArrayList(\n", "        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)).size());\n", "    // 21 elements overflow a long\n", "    assertEquals(Integer.MAX_VALUE, Collections2.orderedPermutations(\n", "        newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n", "            16, 17, 18, 19, 20)).size());\n", "    assertEquals(Integer.MAX_VALUE, Collections2.orderedPermutations(\n", "        newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n", "            16, 17, 18, 19, 20, 21)).size());\n", "  }\n", "\n", "  public void testPermutationSetContains() {\n", "    List<Integer> list = newArrayList(3, 2, 1);\n", "    Collection<List<Integer>> permutationSet =\n", "        Collections2.permutations(list);\n", "\n", "    assertTrue(permutationSet.contains(newArrayList(1, 2, 3)));\n", "    assertTrue(permutationSet.contains(newArrayList(2, 3, 1)));\n", "    assertFalse(permutationSet.contains(newArrayList(1, 2)));\n", "    assertFalse(permutationSet.contains(newArrayList(1, 1, 2, 3)));\n", "    assertFalse(permutationSet.contains(newArrayList(1, 2, 3, 4)));\n", "    assertFalse(permutationSet.contains(null));\n", "  }\n", "\n", "  private <T> void assertNextPermutation(List<T> expectedPermutation,\n", "      Iterator<List<T>> permutations) {\n", "    assertTrue(\"Expected another permutation, but there was none.\",\n", "        permutations.hasNext());\n", "    assertEquals(expectedPermutation, permutations.next());\n", "  }\n", "\n", "  private <T> void assertNoMorePermutations(\n", "      Iterator<List<T>> permutations) {\n", "    assertFalse(\"Expected no more permutations, but there was one.\",\n", "        permutations.hasNext());\n", "    try {\n", "      permutations.next();\n", "      fail(\"Expected NoSuchElementException.\");\n", "    } catch (NoSuchElementException expected) {}\n", "  }\n", "\n", "  private <T> void assertPermutationsCount(int expected,\n", "      Collection<List<T>> permutationSet) {\n", "    assertEquals(expected, permutationSet.size());\n", "    Iterator<List<T>> permutations = permutationSet.iterator();\n", "    for (int i = 0; i < expected; i++) {\n", "      assertTrue(permutations.hasNext());\n", "      permutations.next();\n", "    }\n", "    assertNoMorePermutations(permutations);\n", "  }\n", "\n", "  public void testToStringImplWithNullEntries() throws Exception {\n", "    List<String> list = Lists.newArrayList();\n", "    list.add(\"foo\");\n", "    list.add(null);\n", "\n", "    assertEquals(list.toString(), Collections2.toStringImpl(list));\n", "  }\n", "\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345]}}, {"91": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ConstrainedBiMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.MapConstraintsTest.TestKeyException;\n", "import com.google.common.collect.MapConstraintsTest.TestValueException;\n", "import com.google.common.collect.testing.google.TestStringBiMapGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * Tests for {@link MapConstraints#constrainedBiMap}.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ConstrainedBiMapTest extends TestCase {\n", "\n", "  private static final String TEST_KEY = \"42\";\n", "  private static final String TEST_VALUE = \"test\";\n", "  private static final MapConstraint<String, String> TEST_CONSTRAINT = new TestConstraint();\n", "\n", "  public void testPutWithForbiddenKeyForbiddenValue() {\n", "    BiMap<String, String> map = MapConstraints.constrainedBiMap(\n", "        HashBiMap.<String, String> create(),\n", "        TEST_CONSTRAINT);\n", "    try {\n", "      map.put(TEST_KEY, TEST_VALUE);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  public void testPutWithForbiddenKeyAllowedValue() {\n", "    BiMap<String, String> map = MapConstraints.constrainedBiMap(\n", "        HashBiMap.<String, String> create(),\n", "        TEST_CONSTRAINT);\n", "    try {\n", "      map.put(TEST_KEY, \"allowed\");\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  public void testPutWithAllowedKeyForbiddenValue() {\n", "    BiMap<String, String> map = MapConstraints.constrainedBiMap(\n", "        HashBiMap.<String, String> create(),\n", "        TEST_CONSTRAINT);\n", "    try {\n", "      map.put(\"allowed\", TEST_VALUE);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  public static final class ConstrainedBiMapGenerator extends TestStringBiMapGenerator {\n", "    @Override\n", "    protected BiMap<String, String> create(Entry<String, String>[] entries) {\n", "      BiMap<String, String> bimap = MapConstraints.constrainedBiMap(\n", "          HashBiMap.<String, String> create(),\n", "          TEST_CONSTRAINT);\n", "      for (Entry<String, String> entry : entries) {\n", "        checkArgument(!bimap.containsKey(entry.getKey()));\n", "        bimap.put(entry.getKey(), entry.getValue());\n", "      }\n", "      return bimap;\n", "    }\n", "  }\n", "\n", "  private static final class TestConstraint implements MapConstraint<String, String> {\n", "    @Override\n", "    public void checkKeyValue(String key, String value) {\n", "      if (TEST_KEY.equals(key)) {\n", "        throw new TestKeyException();\n", "      }\n", "      if (TEST_VALUE.equals(value)) {\n", "        throw new TestValueException();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107]}}, {"92": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ConstrainedMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.MapConstraintsTest.TestKeyException;\n", "import com.google.common.collect.MapConstraintsTest.TestValueException;\n", "import com.google.common.collect.testing.TestStringMapGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.HashMap;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * Tests for {@link MapConstraints#constrainedMap}.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ConstrainedMapTest extends TestCase {\n", "\n", "  private static final String TEST_KEY = \"42\";\n", "  private static final String TEST_VALUE = \"test\";\n", "  private static final MapConstraint<String, String> TEST_CONSTRAINT = new TestConstraint();\n", "\n", "  public void testPutWithForbiddenKeyForbiddenValue() {\n", "    Map<String, String> map = MapConstraints.constrainedMap(\n", "        new HashMap<String, String>(),\n", "        TEST_CONSTRAINT);\n", "    try {\n", "      map.put(TEST_KEY, TEST_VALUE);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  public void testPutWithForbiddenKeyAllowedValue() {\n", "    Map<String, String> map = MapConstraints.constrainedMap(\n", "        new HashMap<String, String>(),\n", "        TEST_CONSTRAINT);\n", "    try {\n", "      map.put(TEST_KEY, \"allowed\");\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  public void testPutWithAllowedKeyForbiddenValue() {\n", "    Map<String, String> map = MapConstraints.constrainedMap(\n", "        new HashMap<String, String>(),\n", "        TEST_CONSTRAINT);\n", "    try {\n", "      map.put(\"allowed\", TEST_VALUE);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  public static final class ConstrainedMapGenerator extends TestStringMapGenerator {\n", "    @Override\n", "    protected Map<String, String> create(Entry<String, String>[] entries) {\n", "      Map<String, String> map = MapConstraints.constrainedMap(\n", "          new HashMap<String, String>(),\n", "          TEST_CONSTRAINT);\n", "      for (Entry<String, String> entry : entries) {\n", "        map.put(entry.getKey(), entry.getValue());\n", "      }\n", "      return map;\n", "    }\n", "  }\n", "\n", "  private static final class TestConstraint implements MapConstraint<String, String> {\n", "    @Override\n", "    public void checkKeyValue(String key, String value) {\n", "      if (TEST_KEY.equals(key)) {\n", "        throw new TestKeyException();\n", "      }\n", "      if (TEST_VALUE.equals(value)) {\n", "        throw new TestValueException();\n", "      }\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106]}}, {"93": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ContiguousSetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.BoundType.CLOSED;\n", "import static com.google.common.collect.BoundType.OPEN;\n", "import static com.google.common.collect.DiscreteDomain.integers;\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Set;\n", "\n", "/**\n", " * @author Gregory Kick\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ContiguousSetTest extends TestCase {\n", "  private static DiscreteDomain<Integer> NOT_EQUAL_TO_INTEGERS = new DiscreteDomain<Integer>() {\n", "    @Override public Integer next(Integer value) {\n", "      return integers().next(value);\n", "    }\n", "\n", "    @Override public Integer previous(Integer value) {\n", "      return integers().previous(value);\n", "    }\n", "\n", "    @Override public long distance(Integer start, Integer end) {\n", "      return integers().distance(start, end);\n", "    }\n", "\n", "    @Override public Integer minValue() {\n", "      return integers().minValue();\n", "    }\n", "\n", "    @Override public Integer maxValue() {\n", "      return integers().maxValue();\n", "    }\n", "  };\n", "\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            ContiguousSet.create(Range.closed(1, 3), integers()),\n", "            ContiguousSet.create(Range.closedOpen(1, 4), integers()),\n", "            ContiguousSet.create(Range.openClosed(0, 3), integers()),\n", "            ContiguousSet.create(Range.open(0, 4), integers()),\n", "            ContiguousSet.create(Range.closed(1, 3), NOT_EQUAL_TO_INTEGERS),\n", "            ContiguousSet.create(Range.closedOpen(1, 4), NOT_EQUAL_TO_INTEGERS),\n", "            ContiguousSet.create(Range.openClosed(0, 3), NOT_EQUAL_TO_INTEGERS),\n", "            ContiguousSet.create(Range.open(0, 4), NOT_EQUAL_TO_INTEGERS),\n", "            ImmutableSortedSet.of(1, 2, 3))\n", "        .addEqualityGroup(\n", "            ContiguousSet.create(Range.closedOpen(1, 1), integers()),\n", "            ImmutableSortedSet.of(),\n", "            ImmutableSet.of())\n", "        .testEquals();\n", "    // not testing hashCode for these because it takes forever to compute\n", "    assertEquals(\n", "        ContiguousSet.create(Range.closed(Integer.MIN_VALUE, Integer.MAX_VALUE), integers()),\n", "        ContiguousSet.create(Range.<Integer>all(), integers()));\n", "    assertEquals(\n", "        ContiguousSet.create(Range.closed(Integer.MIN_VALUE, Integer.MAX_VALUE), integers()),\n", "        ContiguousSet.create(Range.atLeast(Integer.MIN_VALUE), integers()));\n", "    assertEquals(\n", "        ContiguousSet.create(Range.closed(Integer.MIN_VALUE, Integer.MAX_VALUE), integers()),\n", "        ContiguousSet.create(Range.atMost(Integer.MAX_VALUE), integers()));\n", "  }\n", "\n", "  public void testCreate_noMin() {\n", "    Range<Integer> range = Range.lessThan(0);\n", "    try {\n", "      ContiguousSet.create(range, RangeTest.UNBOUNDED_DOMAIN);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreate_noMax() {\n", "    Range<Integer> range = Range.greaterThan(0);\n", "    try {\n", "      ContiguousSet.create(range, RangeTest.UNBOUNDED_DOMAIN);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreate_empty() {\n", "    assertEquals(ImmutableSet.of(), ContiguousSet.create(Range.closedOpen(1, 1), integers()));\n", "    assertEquals(ImmutableSet.of(), ContiguousSet.create(Range.openClosed(5, 5), integers()));\n", "    assertEquals(ImmutableSet.of(),\n", "        ContiguousSet.create(Range.lessThan(Integer.MIN_VALUE), integers()));\n", "    assertEquals(ImmutableSet.of(),\n", "        ContiguousSet.create(Range.greaterThan(Integer.MAX_VALUE), integers()));\n", "  }\n", "\n", "  public void testHeadSet() {\n", "    ImmutableSortedSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());\n", "    assertThat(set.headSet(1)).isEmpty();\n", "    assertThat(set.headSet(2)).contains(1);\n", "    assertThat(set.headSet(3)).containsExactly(1, 2).inOrder();\n", "    assertThat(set.headSet(4)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.headSet(Integer.MAX_VALUE)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.headSet(1, true)).contains(1);\n", "    assertThat(set.headSet(2, true)).containsExactly(1, 2).inOrder();\n", "    assertThat(set.headSet(3, true)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.headSet(4, true)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.headSet(Integer.MAX_VALUE, true)).containsExactly(1, 2, 3).inOrder();\n", "  }\n", "\n", "  public void testHeadSet_tooSmall() {\n", "    assertThat(ContiguousSet.create(Range.closed(1, 3), integers()).headSet(0)).isEmpty();\n", "  }\n", "\n", "  public void testTailSet() {\n", "    ImmutableSortedSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());\n", "    assertThat(set.tailSet(Integer.MIN_VALUE)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.tailSet(1)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.tailSet(2)).containsExactly(2, 3).inOrder();\n", "    assertThat(set.tailSet(3)).contains(3);\n", "    assertThat(set.tailSet(Integer.MIN_VALUE, false)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.tailSet(1, false)).containsExactly(2, 3).inOrder();\n", "    assertThat(set.tailSet(2, false)).contains(3);\n", "    assertThat(set.tailSet(3, false)).isEmpty();\n", "  }\n", "\n", "  public void testTailSet_tooLarge() {\n", "    assertThat(ContiguousSet.create(Range.closed(1, 3), integers()).tailSet(4)).isEmpty();\n", "  }\n", "\n", "  public void testSubSet() {\n", "    ImmutableSortedSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());\n", "    assertThat(set.subSet(1, 4)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.subSet(2, 4)).containsExactly(2, 3).inOrder();\n", "    assertThat(set.subSet(3, 4)).contains(3);\n", "    assertThat(set.subSet(3, 3)).isEmpty();\n", "    assertThat(set.subSet(2, 3)).contains(2);\n", "    assertThat(set.subSet(1, 3)).containsExactly(1, 2).inOrder();\n", "    assertThat(set.subSet(1, 2)).contains(1);\n", "    assertThat(set.subSet(2, 2)).isEmpty();\n", "    assertThat(set.subSet(Integer.MIN_VALUE, Integer.MAX_VALUE)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.subSet(1, true, 3, true)).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(set.subSet(1, false, 3, true)).containsExactly(2, 3).inOrder();\n", "    assertThat(set.subSet(1, true, 3, false)).containsExactly(1, 2).inOrder();\n", "    assertThat(set.subSet(1, false, 3, false)).contains(2);\n", "  }\n", "\n", "  public void testSubSet_outOfOrder() {\n", "    ImmutableSortedSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());\n", "    try {\n", "      set.subSet(3, 2);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testSubSet_tooLarge() {\n", "    assertThat(ContiguousSet.create(Range.closed(1, 3), integers()).subSet(4, 6)).isEmpty();\n", "  }\n", "\n", "  public void testSubSet_tooSmall() {\n", "    assertThat(ContiguousSet.create(Range.closed(1, 3), integers()).subSet(-1, 0)).isEmpty();\n", "  }\n", "\n", "  public void testFirst() {\n", "    assertEquals(1, ContiguousSet.create(Range.closed(1, 3), integers()).first().intValue());\n", "    assertEquals(1, ContiguousSet.create(Range.open(0, 4), integers()).first().intValue());\n", "    assertEquals(Integer.MIN_VALUE,\n", "        ContiguousSet.create(Range.<Integer>all(), integers()).first().intValue());\n", "  }\n", "\n", "  public void testLast() {\n", "    assertEquals(3, ContiguousSet.create(Range.closed(1, 3), integers()).last().intValue());\n", "    assertEquals(3, ContiguousSet.create(Range.open(0, 4), integers()).last().intValue());\n", "    assertEquals(Integer.MAX_VALUE,\n", "        ContiguousSet.create(Range.<Integer>all(), integers()).last().intValue());\n", "  }\n", "\n", "  public void testContains() {\n", "    ImmutableSortedSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());\n", "    assertFalse(set.contains(0));\n", "    assertTrue(set.contains(1));\n", "    assertTrue(set.contains(2));\n", "    assertTrue(set.contains(3));\n", "    assertFalse(set.contains(4));\n", "    set = ContiguousSet.create(Range.open(0, 4), integers());\n", "    assertFalse(set.contains(0));\n", "    assertTrue(set.contains(1));\n", "    assertTrue(set.contains(2));\n", "    assertTrue(set.contains(3));\n", "    assertFalse(set.contains(4));\n", "    assertFalse(set.contains(\"blah\"));\n", "  }\n", "\n", "  public void testContainsAll() {\n", "    ImmutableSortedSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());\n", "    for (Set<Integer> subset : Sets.powerSet(ImmutableSet.of(1, 2, 3))) {\n", "      assertTrue(set.containsAll(subset));\n", "    }\n", "    for (Set<Integer> subset : Sets.powerSet(ImmutableSet.of(1, 2, 3))) {\n", "      assertFalse(set.containsAll(Sets.union(subset, ImmutableSet.of(9))));\n", "    }\n", "    assertFalse(set.containsAll(ImmutableSet.of(\"blah\")));\n", "  }\n", "\n", "  public void testRange() {\n", "    assertEquals(Range.closed(1, 3),\n", "        ContiguousSet.create(Range.closed(1, 3), integers()).range());\n", "    assertEquals(Range.closed(1, 3),\n", "        ContiguousSet.create(Range.closedOpen(1, 4), integers()).range());\n", "    assertEquals(Range.closed(1, 3), ContiguousSet.create(Range.open(0, 4), integers()).range());\n", "    assertEquals(Range.closed(1, 3),\n", "        ContiguousSet.create(Range.openClosed(0, 3), integers()).range());\n", "\n", "    assertEquals(Range.openClosed(0, 3),\n", "        ContiguousSet.create(Range.closed(1, 3), integers()).range(OPEN, CLOSED));\n", "    assertEquals(Range.openClosed(0, 3),\n", "        ContiguousSet.create(Range.closedOpen(1, 4), integers()).range(OPEN, CLOSED));\n", "    assertEquals(Range.openClosed(0, 3),\n", "        ContiguousSet.create(Range.open(0, 4), integers()).range(OPEN, CLOSED));\n", "    assertEquals(Range.openClosed(0, 3),\n", "        ContiguousSet.create(Range.openClosed(0, 3), integers()).range(OPEN, CLOSED));\n", "\n", "    assertEquals(Range.open(0, 4),\n", "        ContiguousSet.create(Range.closed(1, 3), integers()).range(OPEN, OPEN));\n", "    assertEquals(Range.open(0, 4),\n", "        ContiguousSet.create(Range.closedOpen(1, 4), integers()).range(OPEN, OPEN));\n", "    assertEquals(Range.open(0, 4),\n", "        ContiguousSet.create(Range.open(0, 4), integers()).range(OPEN, OPEN));\n", "    assertEquals(Range.open(0, 4),\n", "        ContiguousSet.create(Range.openClosed(0, 3), integers()).range(OPEN, OPEN));\n", "\n", "    assertEquals(Range.closedOpen(1, 4),\n", "        ContiguousSet.create(Range.closed(1, 3), integers()).range(CLOSED, OPEN));\n", "    assertEquals(Range.closedOpen(1, 4),\n", "        ContiguousSet.create(Range.closedOpen(1, 4), integers()).range(CLOSED, OPEN));\n", "    assertEquals(Range.closedOpen(1, 4),\n", "        ContiguousSet.create(Range.open(0, 4), integers()).range(CLOSED, OPEN));\n", "    assertEquals(Range.closedOpen(1, 4),\n", "        ContiguousSet.create(Range.openClosed(0, 3), integers()).range(CLOSED, OPEN));\n", "  }\n", "\n", "  public void testRange_unboundedRange() {\n", "    assertEquals(Range.closed(Integer.MIN_VALUE, Integer.MAX_VALUE),\n", "        ContiguousSet.create(Range.<Integer>all(), integers()).range());\n", "    assertEquals(Range.atLeast(Integer.MIN_VALUE),\n", "        ContiguousSet.create(Range.<Integer>all(), integers()).range(CLOSED, OPEN));\n", "    assertEquals(Range.all(),\n", "        ContiguousSet.create(Range.<Integer>all(), integers()).range(OPEN, OPEN));\n", "    assertEquals(Range.atMost(Integer.MAX_VALUE),\n", "        ContiguousSet.create(Range.<Integer>all(), integers()).range(OPEN, CLOSED));\n", "  }\n", "\n", "  public void testIntersection_empty() {\n", "    ContiguousSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());\n", "    ContiguousSet<Integer> emptySet = ContiguousSet.create(Range.closedOpen(2, 2), integers());\n", "    assertEquals(ImmutableSet.of(), set.intersection(emptySet));\n", "    assertEquals(ImmutableSet.of(), emptySet.intersection(set));\n", "    assertEquals(ImmutableSet.of(),\n", "        ContiguousSet.create(Range.closed(-5, -1), integers()).intersection(\n", "            ContiguousSet.create(Range.open(3, 64), integers())));\n", "  }\n", "\n", "  public void testIntersection() {\n", "    ContiguousSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());\n", "    assertEquals(ImmutableSet.of(1, 2, 3),\n", "        ContiguousSet.create(Range.open(-1, 4), integers()).intersection(set));\n", "    assertEquals(ImmutableSet.of(1, 2, 3),\n", "        set.intersection(ContiguousSet.create(Range.open(-1, 4), integers())));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286]}}, {"94": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/EmptyImmutableTableTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "/**\n", " * Tests {@link EmptyImmutableTable}\n", " *\n", " * @author Gregory Kick\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class EmptyImmutableTableTest extends AbstractImmutableTableTest {\n", "  private static final ImmutableTable<Character, Integer, String> INSTANCE = ImmutableTable.of();\n", "\n", "  @Override Iterable<ImmutableTable<Character, Integer, String>> getTestInstances() {\n", "    return ImmutableSet.of(INSTANCE);\n", "  }\n", "\n", "  public void testHashCode() {\n", "    assertEquals(0, INSTANCE.hashCode());\n", "  }\n", "\n", "  public void testEqualsObject() {\n", "    Table<Character, Integer, String> nonEmptyTable = HashBasedTable.create();\n", "    nonEmptyTable.put('A', 1, \"blah\");\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(INSTANCE, HashBasedTable.create(), TreeBasedTable.create())\n", "        .addEqualityGroup(nonEmptyTable)\n", "        .testEquals();\n", "  }\n", "\n", "  public void testToString() {\n", "    assertEquals(\"{}\", INSTANCE.toString());\n", "  }\n", "\n", "  public void testSize() {\n", "    assertEquals(0, INSTANCE.size());\n", "  }\n", "\n", "  public void testGet() {\n", "    assertNull(INSTANCE.get('a', 1));\n", "  }\n", "\n", "  public void testIsEmpty() {\n", "    assertTrue(INSTANCE.isEmpty());\n", "  }\n", "\n", "  public void testCellSet() {\n", "    assertEquals(ImmutableSet.of(), INSTANCE.cellSet());\n", "  }\n", "\n", "  public void testColumn() {\n", "    assertEquals(ImmutableMap.of(), INSTANCE.column(1));\n", "  }\n", "\n", "  public void testColumnKeySet() {\n", "    assertEquals(ImmutableSet.of(), INSTANCE.columnKeySet());\n", "  }\n", "\n", "  public void testColumnMap() {\n", "    assertEquals(ImmutableMap.of(), INSTANCE.columnMap());\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(INSTANCE.contains('a', 1));\n", "  }\n", "\n", "  public void testContainsColumn() {\n", "    assertFalse(INSTANCE.containsColumn(1));\n", "  }\n", "\n", "  public void testContainsRow() {\n", "    assertFalse(INSTANCE.containsRow('a'));\n", "  }\n", "\n", "  public void testContainsValue() {\n", "    assertFalse(INSTANCE.containsValue(\"blah\"));\n", "  }\n", "\n", "  public void testRow() {\n", "    assertEquals(ImmutableMap.of(), INSTANCE.row('a'));\n", "  }\n", "\n", "  public void testRowKeySet() {\n", "    assertEquals(ImmutableSet.of(), INSTANCE.rowKeySet());\n", "  }\n", "\n", "  public void testRowMap() {\n", "    assertEquals(ImmutableMap.of(), INSTANCE.rowMap());\n", "  }\n", "\n", "  public void testValues() {\n", "    assertTrue(INSTANCE.values().isEmpty());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113]}}, {"95": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/EnumBiMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.testing.Helpers.orderEntriesByKey;\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.google.TestBiMapGenerator;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "\n", "/**\n", " * Tests for {@code EnumBiMap}.\n", " *\n", " * @author Mike Bostock\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class EnumBiMapTest extends TestCase {\n", "  private enum Currency { DOLLAR, FRANC, PESO, POUND, YEN }\n", "  private enum Country { CANADA, CHILE, JAPAN, SWITZERLAND, UK }\n", "\n", "  public static final class EnumBiMapGenerator implements TestBiMapGenerator<Country, Currency> {\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public BiMap<Country, Currency> create(Object... entries) {\n", "      BiMap<Country, Currency> result = EnumBiMap.create(Country.class, Currency.class);\n", "      for (Object object : entries) {\n", "        Entry<Country, Currency> entry = (Entry<Country, Currency>) object;\n", "        result.put(entry.getKey(), entry.getValue());\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public SampleElements<Entry<Country, Currency>> samples() {\n", "      return new SampleElements<Entry<Country, Currency>>(\n", "          Helpers.mapEntry(Country.CANADA, Currency.DOLLAR),\n", "          Helpers.mapEntry(Country.CHILE, Currency.PESO),\n", "          Helpers.mapEntry(Country.UK, Currency.POUND),\n", "          Helpers.mapEntry(Country.JAPAN, Currency.YEN),\n", "          Helpers.mapEntry(Country.SWITZERLAND, Currency.FRANC));\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public Entry<Country, Currency>[] createArray(int length) {\n", "      return new Entry[length];\n", "    }\n", "\n", "    @Override\n", "    public Iterable<Entry<Country, Currency>> order(List<Entry<Country, Currency>> insertionOrder) {\n", "      return orderEntriesByKey(insertionOrder);\n", "    }\n", "\n", "    @Override\n", "    public Country[] createKeyArray(int length) {\n", "      return new Country[length];\n", "    }\n", "\n", "    @Override\n", "    public Currency[] createValueArray(int length) {\n", "      return new Currency[length];\n", "    }\n", "  }\n", "\n", "  public void testCreate() {\n", "    EnumBiMap<Currency, Country> bimap =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    assertTrue(bimap.isEmpty());\n", "    assertEquals(\"{}\", bimap.toString());\n", "    assertEquals(HashBiMap.create(), bimap);\n", "    bimap.put(Currency.DOLLAR, Country.CANADA);\n", "    assertEquals(Country.CANADA, bimap.get(Currency.DOLLAR));\n", "    assertEquals(Currency.DOLLAR, bimap.inverse().get(Country.CANADA));\n", "  }\n", "\n", "  public void testCreateFromMap() {\n", "    /* Test with non-empty Map. */\n", "    Map<Currency, Country> map = ImmutableMap.of(\n", "        Currency.DOLLAR, Country.CANADA,\n", "        Currency.PESO, Country.CHILE,\n", "        Currency.FRANC, Country.SWITZERLAND);\n", "    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(map);\n", "    assertEquals(Country.CANADA, bimap.get(Currency.DOLLAR));\n", "    assertEquals(Currency.DOLLAR, bimap.inverse().get(Country.CANADA));\n", "\n", "    /* Map must have at least one entry if not an EnumBiMap. */\n", "    try {\n", "      EnumBiMap.create(Collections.<Currency, Country>emptyMap());\n", "      fail(\"IllegalArgumentException expected\");\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      EnumBiMap.create(\n", "          EnumHashBiMap.<Currency, Country>create(Currency.class));\n", "      fail(\"IllegalArgumentException expected\");\n", "    } catch (IllegalArgumentException expected) {}\n", "\n", "    /* Map can be empty if it's an EnumBiMap. */\n", "    Map<Currency, Country> emptyBimap =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    bimap = EnumBiMap.create(emptyBimap);\n", "    assertTrue(bimap.isEmpty());\n", "  }\n", "\n", "  public void testEnumBiMapConstructor() {\n", "    /* Test that it copies existing entries. */\n", "    EnumBiMap<Currency, Country> bimap1 =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    bimap1.put(Currency.DOLLAR, Country.CANADA);\n", "    EnumBiMap<Currency, Country> bimap2 =\n", "        EnumBiMap.create(bimap1);\n", "    assertEquals(Country.CANADA, bimap2.get(Currency.DOLLAR));\n", "    assertEquals(bimap1, bimap2);\n", "    bimap2.inverse().put(Country.SWITZERLAND, Currency.FRANC);\n", "    assertEquals(Country.SWITZERLAND, bimap2.get(Currency.FRANC));\n", "    assertNull(bimap1.get(Currency.FRANC));\n", "    assertFalse(bimap2.equals(bimap1));\n", "\n", "    /* Test that it can be empty. */\n", "    EnumBiMap<Currency, Country> emptyBimap =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    EnumBiMap<Currency, Country> bimap3 =\n", "        EnumBiMap.create(emptyBimap);\n", "    assertEquals(bimap3, emptyBimap);\n", "  }\n", "\n", "  public void testKeyType() {\n", "    EnumBiMap<Currency, Country> bimap =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    assertEquals(Currency.class, bimap.keyType());\n", "  }\n", "\n", "  public void testValueType() {\n", "    EnumBiMap<Currency, Country> bimap =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    assertEquals(Country.class, bimap.valueType());\n", "  }\n", "\n", "  public void testIterationOrder() {\n", "    // The enum orderings are alphabetical, leading to the bimap and its inverse\n", "    // having inconsistent iteration orderings.\n", "    Map<Currency, Country> map = ImmutableMap.of(\n", "        Currency.DOLLAR, Country.CANADA,\n", "        Currency.PESO, Country.CHILE,\n", "        Currency.FRANC, Country.SWITZERLAND);\n", "    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(map);\n", "\n", "    // forward map ordered by currency\n", "    assertThat(bimap.keySet())\n", "        .containsExactly(Currency.DOLLAR, Currency.FRANC, Currency.PESO).inOrder();\n", "    // forward map ordered by currency (even for country values)\n", "    assertThat(bimap.values())\n", "        .containsExactly(Country.CANADA, Country.SWITZERLAND, Country.CHILE).inOrder();\n", "    // backward map ordered by country\n", "    assertThat(bimap.inverse().keySet())\n", "        .containsExactly(Country.CANADA, Country.CHILE, Country.SWITZERLAND).inOrder();\n", "    // backward map ordered by country (even for currency values)\n", "    assertThat(bimap.inverse().values())\n", "        .containsExactly(Currency.DOLLAR, Currency.PESO, Currency.FRANC).inOrder();\n", "  }\n", "\n", "  public void testKeySetIteratorRemove() {\n", "    // The enum orderings are alphabetical, leading to the bimap and its inverse\n", "    // having inconsistent iteration orderings.\n", "    Map<Currency, Country> map = ImmutableMap.of(\n", "        Currency.DOLLAR, Country.CANADA,\n", "        Currency.PESO, Country.CHILE,\n", "        Currency.FRANC, Country.SWITZERLAND);\n", "    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(map);\n", "\n", "    Iterator<Currency> iter = bimap.keySet().iterator();\n", "    assertEquals(Currency.DOLLAR, iter.next());\n", "    iter.remove();\n", "\n", "    // forward map ordered by currency\n", "    assertThat(bimap.keySet())\n", "        .containsExactly(Currency.FRANC, Currency.PESO).inOrder();\n", "    // forward map ordered by currency (even for country values)\n", "    assertThat(bimap.values())\n", "        .containsExactly(Country.SWITZERLAND, Country.CHILE).inOrder();\n", "    // backward map ordered by country\n", "    assertThat(bimap.inverse().keySet())\n", "        .containsExactly(Country.CHILE, Country.SWITZERLAND).inOrder();\n", "    // backward map ordered by country (even for currency values)\n", "    assertThat(bimap.inverse().values())\n", "        .containsExactly(Currency.PESO, Currency.FRANC).inOrder();\n", "  }\n", "\n", "  public void testValuesIteratorRemove() {\n", "    // The enum orderings are alphabetical, leading to the bimap and its inverse\n", "    // having inconsistent iteration orderings.\n", "    Map<Currency, Country> map = ImmutableMap.of(\n", "        Currency.DOLLAR, Country.CANADA,\n", "        Currency.PESO, Country.CHILE,\n", "        Currency.FRANC, Country.SWITZERLAND);\n", "    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(map);\n", "\n", "    Iterator<Currency> iter = bimap.keySet().iterator();\n", "    assertEquals(Currency.DOLLAR, iter.next());\n", "    assertEquals(Currency.FRANC, iter.next());\n", "    iter.remove();\n", "\n", "    // forward map ordered by currency\n", "    assertThat(bimap.keySet())\n", "        .containsExactly(Currency.DOLLAR, Currency.PESO).inOrder();\n", "    // forward map ordered by currency (even for country values)\n", "    assertThat(bimap.values())\n", "        .containsExactly(Country.CANADA, Country.CHILE).inOrder();\n", "    // backward map ordered by country\n", "    assertThat(bimap.inverse().keySet())\n", "        .containsExactly(Country.CANADA, Country.CHILE).inOrder();\n", "    // backward map ordered by country (even for currency values)\n", "    assertThat(bimap.inverse().values())\n", "        .containsExactly(Currency.DOLLAR, Currency.PESO).inOrder();\n", "  }\n", "\n", "  public void testEntrySet() {\n", "    // Bug 3168290\n", "    Map<Currency, Country> map = ImmutableMap.of(\n", "        Currency.DOLLAR, Country.CANADA,\n", "        Currency.PESO, Country.CHILE,\n", "        Currency.FRANC, Country.SWITZERLAND);\n", "    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(map);\n", "    Set<Object> uniqueEntries = Sets.newIdentityHashSet();\n", "    uniqueEntries.addAll(bimap.entrySet());\n", "    assertEquals(3, uniqueEntries.size());\n", "  }\n", "\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            EnumBiMap.create(ImmutableMap.of(Currency.DOLLAR, Country.CANADA)),\n", "            EnumBiMap.create(ImmutableMap.of(Currency.DOLLAR, Country.CANADA)))\n", "        .addEqualityGroup(EnumBiMap.create(ImmutableMap.of(Currency.DOLLAR, Country.CHILE)))\n", "        .addEqualityGroup(EnumBiMap.create(ImmutableMap.of(Currency.FRANC, Country.CANADA)))\n", "        .testEquals();\n", "  }\n", "\n", "  /* Remaining behavior tested by AbstractBiMapTest. */\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267]}}, {"96": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/EnumHashBiMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.google.TestBiMapGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collections;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "\n", "/**\n", " * Tests for {@code EnumHashBiMap}.\n", " *\n", " * @author Mike Bostock\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class EnumHashBiMapTest extends TestCase {\n", "  private enum Currency { DOLLAR, FRANC, PESO, POUND, YEN }\n", "  private enum Country { CANADA, CHILE, JAPAN, SWITZERLAND, UK }\n", "\n", "  public static final class EnumHashBiMapGenerator implements TestBiMapGenerator<Country, String> {\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public BiMap<Country, String> create(Object... entries) {\n", "      BiMap<Country, String> result = EnumHashBiMap.create(Country.class);\n", "      for (Object o : entries) {\n", "        Entry<Country, String> entry = (Entry<Country, String>) o;\n", "        result.put(entry.getKey(), entry.getValue());\n", "      }\n", "      return result;\n", "    }\n", "\n", "    @Override\n", "    public SampleElements<Entry<Country, String>> samples() {\n", "      return new SampleElements<Entry<Country, String>>(\n", "          Maps.immutableEntry(Country.CANADA, \"DOLLAR\"),\n", "          Maps.immutableEntry(Country.CHILE, \"PESO\"),\n", "          Maps.immutableEntry(Country.UK, \"POUND\"),\n", "          Maps.immutableEntry(Country.JAPAN, \"YEN\"),\n", "          Maps.immutableEntry(Country.SWITZERLAND, \"FRANC\"));\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    @Override\n", "    public Entry<Country, String>[] createArray(int length) {\n", "      return new Entry[length];\n", "    }\n", "\n", "    @Override\n", "    public Iterable<Entry<Country, String>> order(List<Entry<Country, String>> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "\n", "    @Override\n", "    public Country[] createKeyArray(int length) {\n", "      return new Country[length];\n", "    }\n", "\n", "    @Override\n", "    public String[] createValueArray(int length) {\n", "      return new String[length];\n", "    }\n", "  }\n", "\n", "  public void testCreate() {\n", "    EnumHashBiMap<Currency, String> bimap =\n", "        EnumHashBiMap.create(Currency.class);\n", "    assertTrue(bimap.isEmpty());\n", "    assertEquals(\"{}\", bimap.toString());\n", "    assertEquals(HashBiMap.create(), bimap);\n", "    bimap.put(Currency.DOLLAR, \"dollar\");\n", "    assertEquals(\"dollar\", bimap.get(Currency.DOLLAR));\n", "    assertEquals(Currency.DOLLAR, bimap.inverse().get(\"dollar\"));\n", "  }\n", "\n", "  public void testCreateFromMap() {\n", "    /* Test with non-empty Map. */\n", "    Map<Currency, String> map = ImmutableMap.of(\n", "        Currency.DOLLAR, \"dollar\",\n", "        Currency.PESO, \"peso\",\n", "        Currency.FRANC, \"franc\");\n", "    EnumHashBiMap<Currency, String> bimap\n", "        = EnumHashBiMap.create(map);\n", "    assertEquals(\"dollar\", bimap.get(Currency.DOLLAR));\n", "    assertEquals(Currency.DOLLAR, bimap.inverse().get(\"dollar\"));\n", "\n", "    /* Map must have at least one entry if not an EnumHashBiMap. */\n", "    try {\n", "      EnumHashBiMap.create(\n", "          Collections.<Currency, String>emptyMap());\n", "      fail(\"IllegalArgumentException expected\");\n", "    } catch (IllegalArgumentException expected) {}\n", "\n", "    /* Map can be empty if it's an EnumHashBiMap. */\n", "    Map<Currency, String> emptyBimap = EnumHashBiMap.create(Currency.class);\n", "    bimap = EnumHashBiMap.create(emptyBimap);\n", "    assertTrue(bimap.isEmpty());\n", "\n", "    /* Map can be empty if it's an EnumBiMap. */\n", "    Map<Currency, Country> emptyBimap2 =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    EnumHashBiMap<Currency, Country> bimap2\n", "        = EnumHashBiMap.create(emptyBimap2);\n", "    assertTrue(bimap2.isEmpty());\n", "  }\n", "\n", "  public void testEnumHashBiMapConstructor() {\n", "    /* Test that it copies existing entries. */\n", "    EnumHashBiMap<Currency, String> bimap1 =\n", "        EnumHashBiMap.create(Currency.class);\n", "    bimap1.put(Currency.DOLLAR, \"dollar\");\n", "    EnumHashBiMap<Currency, String> bimap2 =\n", "        EnumHashBiMap.create(bimap1);\n", "    assertEquals(\"dollar\", bimap2.get(Currency.DOLLAR));\n", "    assertEquals(bimap1, bimap2);\n", "    bimap2.inverse().put(\"franc\", Currency.FRANC);\n", "    assertEquals(\"franc\", bimap2.get(Currency.FRANC));\n", "    assertNull(bimap1.get(Currency.FRANC));\n", "    assertFalse(bimap2.equals(bimap1));\n", "\n", "    /* Test that it can be empty. */\n", "    EnumHashBiMap<Currency, String> emptyBimap =\n", "        EnumHashBiMap.create(Currency.class);\n", "    EnumHashBiMap<Currency, String> bimap3 =\n", "        EnumHashBiMap.create(emptyBimap);\n", "    assertEquals(bimap3, emptyBimap);\n", "  }\n", "\n", "  public void testEnumBiMapConstructor() {\n", "    /* Test that it copies existing entries. */\n", "    EnumBiMap<Currency, Country> bimap1 =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    bimap1.put(Currency.DOLLAR, Country.SWITZERLAND);\n", "    EnumHashBiMap<Currency, Object> bimap2 = // use supertype\n", "        EnumHashBiMap.<Currency, Object>create(bimap1);\n", "    assertEquals(Country.SWITZERLAND, bimap2.get(Currency.DOLLAR));\n", "    assertEquals(bimap1, bimap2);\n", "    bimap2.inverse().put(\"franc\", Currency.FRANC);\n", "    assertEquals(\"franc\", bimap2.get(Currency.FRANC));\n", "    assertNull(bimap1.get(Currency.FRANC));\n", "    assertFalse(bimap2.equals(bimap1));\n", "\n", "    /* Test that it can be empty. */\n", "    EnumBiMap<Currency, Country> emptyBimap =\n", "        EnumBiMap.create(Currency.class, Country.class);\n", "    EnumHashBiMap<Currency, Country> bimap3 = // use exact type\n", "        EnumHashBiMap.create(emptyBimap);\n", "    assertEquals(bimap3, emptyBimap);\n", "  }\n", "\n", "  public void testKeyType() {\n", "    EnumHashBiMap<Currency, String> bimap =\n", "        EnumHashBiMap.create(Currency.class);\n", "    assertEquals(Currency.class, bimap.keyType());\n", "  }\n", "\n", "  public void testEntrySet() {\n", "    // Bug 3168290\n", "    Map<Currency, String> map = ImmutableMap.of(\n", "        Currency.DOLLAR, \"dollar\",\n", "        Currency.PESO, \"peso\",\n", "        Currency.FRANC, \"franc\");\n", "    EnumHashBiMap<Currency, String> bimap\n", "        = EnumHashBiMap.create(map);\n", "\n", "    Set<Object> uniqueEntries = Sets.newIdentityHashSet();\n", "    uniqueEntries.addAll(bimap.entrySet());\n", "    assertEquals(3, uniqueEntries.size());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191]}}, {"97": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/EnumMultisetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AnEnum;\n", "import com.google.common.collect.testing.google.TestEnumMultisetGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collection;\n", "import java.util.EnumSet;\n", "import java.util.Set;\n", "\n", "/**\n", " * Tests for an {@link EnumMultiset}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class EnumMultisetTest extends TestCase {\n", "\n", "  private static TestEnumMultisetGenerator enumMultisetGenerator() {\n", "    return new TestEnumMultisetGenerator() {\n", "      @Override protected Multiset<AnEnum> create(AnEnum[] elements) {\n", "        return (elements.length == 0)\n", "            ? EnumMultiset.create(AnEnum.class)\n", "            : EnumMultiset.create(asList(elements));\n", "      }\n", "    };\n", "  }\n", "\n", "  private enum Color {\n", "    BLUE, RED, YELLOW, GREEN, WHITE\n", "  }\n", "\n", "  private enum Gender {\n", "    MALE, FEMALE\n", "  }\n", "\n", "  public void testClassCreate() {\n", "    Multiset<Color> ms = EnumMultiset.create(Color.class);\n", "    ms.add(Color.RED);\n", "    ms.add(Color.YELLOW);\n", "    ms.add(Color.RED);\n", "    assertEquals(0, ms.count(Color.BLUE));\n", "    assertEquals(1, ms.count(Color.YELLOW));\n", "    assertEquals(2, ms.count(Color.RED));\n", "  }\n", "\n", "  public void testCollectionCreate() {\n", "    Multiset<Color> ms = EnumMultiset.create(\n", "        asList(Color.RED, Color.YELLOW, Color.RED));\n", "    assertEquals(0, ms.count(Color.BLUE));\n", "    assertEquals(1, ms.count(Color.YELLOW));\n", "    assertEquals(2, ms.count(Color.RED));\n", "  }\n", "\n", "  public void testIllegalCreate() {\n", "    Collection<Color> empty = EnumSet.noneOf(Color.class);\n", "    try {\n", "      EnumMultiset.create(empty);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "  \n", "  public void testCreateEmptyWithClass() {\n", "    Multiset<Color> ms = EnumMultiset.create(ImmutableList.<Color>of(), Color.class);\n", "    ms.add(Color.RED);\n", "  }\n", "  \n", "  public void testCreateEmptyWithoutClassFails() {\n", "    try {\n", "      EnumMultiset.create(ImmutableList.<Color> of());\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToString() {\n", "    Multiset<Color> ms = EnumMultiset.create(Color.class);\n", "    ms.add(Color.BLUE, 3);\n", "    ms.add(Color.YELLOW, 1);\n", "    ms.add(Color.RED, 2);\n", "    assertEquals(\"[BLUE x 3, RED x 2, YELLOW]\", ms.toString());\n", "  }\n", "\n", "  public void testEntrySet() {\n", "    Multiset<Color> ms = EnumMultiset.create(Color.class);\n", "    ms.add(Color.BLUE, 3);\n", "    ms.add(Color.YELLOW, 1);\n", "    ms.add(Color.RED, 2);\n", "\n", "    Set<Object> uniqueEntries = Sets.newIdentityHashSet();\n", "    uniqueEntries.addAll(ms.entrySet());\n", "    assertEquals(3, uniqueEntries.size());\n", "  }\n", "\n", "  // Wrapper of EnumMultiset factory methods, because we need to skip create(Class).\n", "  // create(Enum1.class) is equal to create(Enum2.class) but testEquals() expects otherwise.\n", "  // For the same reason, we need to skip create(Iterable, Class).\n", "  private static class EnumMultisetFactory {\n", "    public static <E extends Enum<E>> EnumMultiset<E> create(Iterable<E> elements) {\n", "      return EnumMultiset.create(elements);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124]}}, {"98": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/EvictingQueueTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.testing.SerializableTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.NoSuchElementException;\n", "\n", "/**\n", " * Tests for {@link EvictingQueue}.\n", " *\n", " * @author Kurt Alfred Kluever\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class EvictingQueueTest extends TestCase {\n", "\n", "  public void testCreateWithNegativeSize() throws Exception {\n", "    try {\n", "      EvictingQueue.create(-1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCreateWithZeroSize() throws Exception {\n", "    EvictingQueue<String> queue = EvictingQueue.create(0);\n", "    assertEquals(0, queue.size());\n", "\n", "    assertTrue(queue.add(\"hi\"));\n", "    assertEquals(0, queue.size());\n", "\n", "    assertTrue(queue.offer(\"hi\"));\n", "    assertEquals(0, queue.size());\n", "\n", "    assertFalse(queue.remove(\"hi\"));\n", "    assertEquals(0, queue.size());\n", "\n", "    try {\n", "      queue.element();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {}\n", "\n", "    assertNull(queue.peek());\n", "    assertNull(queue.poll());\n", "    try {\n", "      queue.remove();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {}\n", "  }\n", "\n", "  public void testRemainingCapacity_maxSize0() {\n", "    EvictingQueue<String> queue = EvictingQueue.create(0);\n", "    assertEquals(0, queue.remainingCapacity());\n", "  }\n", "\n", "  public void testRemainingCapacity_maxSize1() {\n", "    EvictingQueue<String> queue = EvictingQueue.create(1);\n", "    assertEquals(1, queue.remainingCapacity());\n", "    queue.add(\"hi\");\n", "    assertEquals(0, queue.remainingCapacity());\n", "  }\n", "\n", "  public void testRemainingCapacity_maxSize3() {\n", "    EvictingQueue<String> queue = EvictingQueue.create(3);\n", "    assertEquals(3, queue.remainingCapacity());\n", "    queue.add(\"hi\");\n", "    assertEquals(2, queue.remainingCapacity());\n", "    queue.add(\"hi\");\n", "    assertEquals(1, queue.remainingCapacity());\n", "    queue.add(\"hi\");\n", "    assertEquals(0, queue.remainingCapacity());\n", "  }\n", "\n", "  public void testEvictingAfterOne() throws Exception {\n", "    EvictingQueue<String> queue = EvictingQueue.create(1);\n", "    assertEquals(0, queue.size());\n", "    assertEquals(1, queue.remainingCapacity());\n", "\n", "    assertTrue(queue.add(\"hi\"));\n", "    assertEquals(\"hi\", queue.element());\n", "    assertEquals(\"hi\", queue.peek());\n", "    assertEquals(1, queue.size());\n", "    assertEquals(0, queue.remainingCapacity());\n", "\n", "    assertTrue(queue.add(\"there\"));\n", "    assertEquals(\"there\", queue.element());\n", "    assertEquals(\"there\", queue.peek());\n", "    assertEquals(1, queue.size());\n", "    assertEquals(0, queue.remainingCapacity());\n", "\n", "    assertEquals(\"there\", queue.remove());\n", "    assertEquals(0, queue.size());\n", "    assertEquals(1, queue.remainingCapacity());\n", "  }\n", "\n", "  public void testEvictingAfterThree() throws Exception {\n", "    EvictingQueue<String> queue = EvictingQueue.create(3);\n", "    assertEquals(0, queue.size());\n", "    assertEquals(3, queue.remainingCapacity());\n", "\n", "    assertTrue(queue.add(\"one\"));\n", "    assertTrue(queue.add(\"two\"));\n", "    assertTrue(queue.add(\"three\"));\n", "    assertEquals(\"one\", queue.element());\n", "    assertEquals(\"one\", queue.peek());\n", "    assertEquals(3, queue.size());\n", "    assertEquals(0, queue.remainingCapacity());\n", "\n", "    assertTrue(queue.add(\"four\"));\n", "    assertEquals(\"two\", queue.element());\n", "    assertEquals(\"two\", queue.peek());\n", "    assertEquals(3, queue.size());\n", "    assertEquals(0, queue.remainingCapacity());\n", "\n", "    assertEquals(\"two\", queue.remove());\n", "    assertEquals(2, queue.size());\n", "    assertEquals(1, queue.remainingCapacity());\n", "  }\n", "\n", "  public void testAddAll() throws Exception {\n", "    EvictingQueue<String> queue = EvictingQueue.create(3);\n", "    assertEquals(0, queue.size());\n", "    assertEquals(3, queue.remainingCapacity());\n", "\n", "    assertTrue(queue.addAll(asList(\"one\", \"two\", \"three\")));\n", "    assertEquals(\"one\", queue.element());\n", "    assertEquals(\"one\", queue.peek());\n", "    assertEquals(3, queue.size());\n", "    assertEquals(0, queue.remainingCapacity());\n", "\n", "    assertTrue(queue.addAll(asList(\"four\")));\n", "    assertEquals(\"two\", queue.element());\n", "    assertEquals(\"two\", queue.peek());\n", "    assertEquals(3, queue.size());\n", "    assertEquals(0, queue.remainingCapacity());\n", "\n", "    assertEquals(\"two\", queue.remove());\n", "    assertEquals(2, queue.size());\n", "    assertEquals(1, queue.remainingCapacity());\n", "  }\n", "\n", "  public void testSerialization() {\n", "    EvictingQueue<String> original = EvictingQueue.create(5);\n", "    original.add(\"one\");\n", "    original.add(\"two\");\n", "    original.add(\"three\");\n", "\n", "    EvictingQueue<String> copy = SerializableTester.reserialize(original);\n", "    assertEquals(copy.maxSize, original.maxSize);\n", "    assertEquals(\"one\", copy.remove());\n", "    assertEquals(\"two\", copy.remove());\n", "    assertEquals(\"three\", copy.remove());\n", "    assertTrue(copy.isEmpty());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175]}}, {"99": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/GeneralRangeTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the\n", " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n", " * express or implied. See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.BoundType.CLOSED;\n", "import static com.google.common.collect.BoundType.OPEN;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Objects;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.List;\n", "\n", "/**\n", " * Tests for {@code GeneralRange}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class GeneralRangeTest extends TestCase {\n", "  private static final Ordering<Integer> ORDERING = Ordering.natural().nullsFirst();\n", "\n", "  private static final List<Integer> IN_ORDER_VALUES = Arrays.asList(null, 1, 2, 3, 4, 5);\n", "\n", "  public void testCreateEmptyRangeFails() {\n", "    for (BoundType lboundType : BoundType.values()) {\n", "      for (BoundType uboundType : BoundType.values()) {\n", "        try {\n", "          GeneralRange.range(ORDERING, 4, lboundType, 2, uboundType);\n", "          fail(\"Expected IAE\");\n", "        } catch (IllegalArgumentException expected) {}\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testCreateEmptyRangeOpenOpenFails() {\n", "    for (Integer i : IN_ORDER_VALUES) {\n", "      try {\n", "        GeneralRange.range(ORDERING, i, OPEN, i, OPEN);\n", "        fail(\"Expected IAE\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testCreateEmptyRangeClosedOpenSucceeds() {\n", "    for (Integer i : IN_ORDER_VALUES) {\n", "      GeneralRange<Integer> range = GeneralRange.range(ORDERING, i, CLOSED, i, OPEN);\n", "      for (Integer j : IN_ORDER_VALUES) {\n", "        assertFalse(range.contains(j));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testCreateEmptyRangeOpenClosedSucceeds() {\n", "    for (Integer i : IN_ORDER_VALUES) {\n", "      GeneralRange<Integer> range = GeneralRange.range(ORDERING, i, OPEN, i, CLOSED);\n", "      for (Integer j : IN_ORDER_VALUES) {\n", "        assertFalse(range.contains(j));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testCreateSingletonRangeSucceeds() {\n", "    for (Integer i : IN_ORDER_VALUES) {\n", "      GeneralRange<Integer> range = GeneralRange.range(ORDERING, i, CLOSED, i, CLOSED);\n", "      for (Integer j : IN_ORDER_VALUES) {\n", "        assertEquals(Objects.equal(i, j), range.contains(j));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testSingletonRange() {\n", "    GeneralRange<Integer> range = GeneralRange.range(ORDERING, 3, CLOSED, 3, CLOSED);\n", "    for (Integer i : IN_ORDER_VALUES) {\n", "      assertEquals(ORDERING.compare(i, 3) == 0, range.contains(i));\n", "    }\n", "  }\n", "\n", "  public void testLowerRange() {\n", "    for (BoundType lBoundType : BoundType.values()) {\n", "      GeneralRange<Integer> range = GeneralRange.downTo(ORDERING, 3, lBoundType);\n", "      for (Integer i : IN_ORDER_VALUES) {\n", "        assertEquals(ORDERING.compare(i, 3) > 0\n", "            || (ORDERING.compare(i, 3) == 0 && lBoundType == CLOSED), range.contains(i));\n", "        assertEquals(ORDERING.compare(i, 3) < 0\n", "            || (ORDERING.compare(i, 3) == 0 && lBoundType == OPEN), range.tooLow(i));\n", "        assertFalse(range.tooHigh(i));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testUpperRange() {\n", "    for (BoundType lBoundType : BoundType.values()) {\n", "      GeneralRange<Integer> range = GeneralRange.upTo(ORDERING, 3, lBoundType);\n", "      for (Integer i : IN_ORDER_VALUES) {\n", "        assertEquals(ORDERING.compare(i, 3) < 0\n", "            || (ORDERING.compare(i, 3) == 0 && lBoundType == CLOSED), range.contains(i));\n", "        assertEquals(ORDERING.compare(i, 3) > 0\n", "            || (ORDERING.compare(i, 3) == 0 && lBoundType == OPEN), range.tooHigh(i));\n", "        assertFalse(range.tooLow(i));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDoublyBoundedAgainstRange() {\n", "    for (BoundType lboundType : BoundType.values()) {\n", "      for (BoundType uboundType : BoundType.values()) {\n", "        Range<Integer> range = Range.range(2, lboundType, 4, uboundType);\n", "        GeneralRange<Integer> gRange = GeneralRange.range(ORDERING, 2, lboundType, 4, uboundType);\n", "        for (Integer i : IN_ORDER_VALUES) {\n", "          assertEquals(i != null && range.contains(i), gRange.contains(i));\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testIntersectAgainstMatchingEndpointsRange() {\n", "    GeneralRange<Integer> range = GeneralRange.range(ORDERING, 2, CLOSED, 4, OPEN);\n", "    assertEquals(GeneralRange.range(ORDERING, 2, OPEN, 4, OPEN),\n", "        range.intersect(GeneralRange.range(ORDERING, 2, OPEN, 4, CLOSED)));\n", "  }\n", "\n", "  public void testIntersectAgainstBiggerRange() {\n", "    GeneralRange<Integer> range = GeneralRange.range(ORDERING, 2, CLOSED, 4, OPEN);\n", "\n", "    assertEquals(GeneralRange.range(ORDERING, 2, CLOSED, 4, OPEN),\n", "        range.intersect(GeneralRange.range(ORDERING, null, OPEN, 5, CLOSED)));\n", "\n", "    assertEquals(GeneralRange.range(ORDERING, 2, OPEN, 4, OPEN),\n", "        range.intersect(GeneralRange.range(ORDERING, 2, OPEN, 5, CLOSED)));\n", "\n", "    assertEquals(GeneralRange.range(ORDERING, 2, CLOSED, 4, OPEN),\n", "        range.intersect(GeneralRange.range(ORDERING, 1, OPEN, 4, OPEN)));\n", "  }\n", "\n", "  public void testIntersectAgainstSmallerRange() {\n", "    GeneralRange<Integer> range = GeneralRange.range(ORDERING, 2, OPEN, 4, OPEN);\n", "    assertEquals(GeneralRange.range(ORDERING, 3, CLOSED, 4, OPEN),\n", "        range.intersect(GeneralRange.range(ORDERING, 3, CLOSED, 4, CLOSED)));\n", "  }\n", "\n", "  public void testIntersectOverlappingRange() {\n", "    GeneralRange<Integer> range = GeneralRange.range(ORDERING, 2, OPEN, 4, CLOSED);\n", "    assertEquals(GeneralRange.range(ORDERING, 3, CLOSED, 4, CLOSED),\n", "        range.intersect(GeneralRange.range(ORDERING, 3, CLOSED, 5, CLOSED)));\n", "    assertEquals(GeneralRange.range(ORDERING, 2, OPEN, 3, OPEN),\n", "        range.intersect(GeneralRange.range(ORDERING, 1, OPEN, 3, OPEN)));\n", "  }\n", "\n", "  public void testIntersectNonOverlappingRange() {\n", "    GeneralRange<Integer> range = GeneralRange.range(ORDERING, 2, OPEN, 4, CLOSED);\n", "    assertTrue(range.intersect(GeneralRange.range(ORDERING, 5, CLOSED, 6, CLOSED)).isEmpty());\n", "    assertTrue(range.intersect(GeneralRange.range(ORDERING, 1, OPEN, 2, OPEN)).isEmpty());\n", "  }\n", "\n", "  public void testFromRangeAll() {\n", "    assertEquals(GeneralRange.all(Ordering.natural()), GeneralRange.from(Range.all()));\n", "  }\n", "\n", "  public void testFromRangeOneEnd() {\n", "    for (BoundType endpointType : BoundType.values()) {\n", "      assertEquals(GeneralRange.upTo(Ordering.natural(), 3, endpointType),\n", "          GeneralRange.from(Range.upTo(3, endpointType)));\n", "\n", "      assertEquals(GeneralRange.downTo(Ordering.natural(), 3, endpointType),\n", "          GeneralRange.from(Range.downTo(3, endpointType)));\n", "    }\n", "  }\n", "\n", "  public void testFromRangeTwoEnds() {\n", "    for (BoundType lowerType : BoundType.values()) {\n", "      for (BoundType upperType : BoundType.values()) {\n", "        assertEquals(GeneralRange.range(Ordering.natural(), 3, lowerType, 4, upperType),\n", "            GeneralRange.from(Range.range(3, lowerType, 4, upperType)));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testReverse() {\n", "    assertEquals(GeneralRange.all(ORDERING.reverse()), GeneralRange.all(ORDERING).reverse());\n", "    assertEquals(GeneralRange.downTo(ORDERING.reverse(), 3, CLOSED),\n", "        GeneralRange.upTo(ORDERING, 3, CLOSED).reverse());\n", "    assertEquals(GeneralRange.upTo(ORDERING.reverse(), 3, OPEN),\n", "        GeneralRange.downTo(ORDERING, 3, OPEN).reverse());\n", "    assertEquals(GeneralRange.range(ORDERING.reverse(), 5, OPEN, 3, CLOSED),\n", "        GeneralRange.range(ORDERING, 3, CLOSED, 5, OPEN).reverse());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203]}}, {"100": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/HashBasedTableTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "/**\n", " * Test cases for {@link HashBasedTable}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class HashBasedTableTest extends AbstractTableTest {\n", "\n", "  @Override protected Table<String, Integer, Character> create(\n", "      Object... data) {\n", "    Table<String, Integer, Character> table = HashBasedTable.create();\n", "    table.put(\"foo\", 4, 'a');\n", "    table.put(\"cat\", 1, 'b');\n", "    table.clear();\n", "    populate(table, data);\n", "    return table;\n", "  }\n", "\n", "  public void testCreateWithValidSizes() {\n", "    Table<String, Integer, Character> table1 = HashBasedTable.create(100, 20);\n", "    table1.put(\"foo\", 1, 'a');\n", "    assertEquals((Character) 'a', table1.get(\"foo\", 1));\n", "\n", "    Table<String, Integer, Character> table2 = HashBasedTable.create(100, 0);\n", "    table2.put(\"foo\", 1, 'a');\n", "    assertEquals((Character) 'a', table2.get(\"foo\", 1));\n", "\n", "    Table<String, Integer, Character> table3 = HashBasedTable.create(0, 20);\n", "    table3.put(\"foo\", 1, 'a');\n", "    assertEquals((Character) 'a', table3.get(\"foo\", 1));\n", "\n", "    Table<String, Integer, Character> table4 = HashBasedTable.create(0, 0);\n", "    table4.put(\"foo\", 1, 'a');\n", "    assertEquals((Character) 'a', table4.get(\"foo\", 1));\n", "  }\n", "\n", "  public void testCreateWithInvalidSizes() {\n", "    try {\n", "      HashBasedTable.create(100, -5);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "\n", "    try {\n", "      HashBasedTable.create(-5, 20);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreateCopy() {\n", "    Table<String, Integer, Character> original\n", "        = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Table<String, Integer, Character> copy = HashBasedTable.create(original);\n", "    assertEquals(original, copy);\n", "    assertEquals((Character) 'a', copy.get(\"foo\", 1));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77]}}, {"101": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/HashBiMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.google.TestStringBiMapGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "\n", "/**\n", " * Tests for {@link HashBiMap}.\n", " *\n", " * @author Mike Bostock\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class HashBiMapTest extends TestCase {\n", "\n", "  public static final class HashBiMapGenerator extends TestStringBiMapGenerator {\n", "    @Override\n", "    protected BiMap<String, String> create(Entry<String, String>[] entries) {\n", "      BiMap<String, String> result = HashBiMap.create();\n", "      for (Entry<String, String> entry : entries) {\n", "        result.put(entry.getKey(), entry.getValue());\n", "      }\n", "      return result;\n", "    }\n", "  }\n", "\n", "  public void testMapConstructor() {\n", "    /* Test with non-empty Map. */\n", "    Map<String, String> map = ImmutableMap.of(\n", "        \"canada\", \"dollar\",\n", "        \"chile\", \"peso\",\n", "        \"switzerland\", \"franc\");\n", "    HashBiMap<String, String> bimap = HashBiMap.create(map);\n", "    assertEquals(\"dollar\", bimap.get(\"canada\"));\n", "    assertEquals(\"canada\", bimap.inverse().get(\"dollar\"));\n", "  }\n", "\n", "  private static final int N = 1000;\n", "\n", "  public void testBashIt() throws Exception {\n", "    BiMap<Integer, Integer> bimap = HashBiMap.create(N);\n", "    BiMap<Integer, Integer> inverse = bimap.inverse();\n", "\n", "    for (int i = 0; i < N; i++) {\n", "      assertNull(bimap.put(2 * i, 2 * i + 1));\n", "    }\n", "    for (int i = 0; i < N; i++) {\n", "      assertEquals(2 * i + 1, (int) bimap.get(2 * i));\n", "    }\n", "    for (int i = 0; i < N; i++) {\n", "      assertEquals(2 * i, (int) inverse.get(2 * i + 1));\n", "    }\n", "    for (int i = 0; i < N; i++) {\n", "      int oldValue = bimap.get(2 * i);\n", "      assertEquals(2 * i + 1, (int) bimap.put(2 * i, oldValue - 2));\n", "    }\n", "    for (int i = 0; i < N; i++) {\n", "      assertEquals(2 * i - 1, (int) bimap.get(2 * i));\n", "    }\n", "    for (int i = 0; i < N; i++) {\n", "      assertEquals(2 * i, (int) inverse.get(2 * i - 1));\n", "    }\n", "    Set<Entry<Integer, Integer>> entries = bimap.entrySet();\n", "    for (Entry<Integer, Integer> entry : entries) {\n", "      entry.setValue(entry.getValue() + 2 * N);\n", "    }\n", "    for (int i = 0; i < N; i++) {\n", "      assertEquals(2 * N + 2 * i - 1, (int) bimap.get(2 * i));\n", "    }\n", "  }\n", "\n", "  public void testBiMapEntrySetIteratorRemove() {\n", "    BiMap<Integer, String> map = HashBiMap.create();\n", "    map.put(1, \"one\");\n", "    Set<Map.Entry<Integer, String>> entries = map.entrySet();\n", "    Iterator<Map.Entry<Integer, String>> iterator = entries.iterator();\n", "    Map.Entry<Integer, String> entry = iterator.next();\n", "    entry.setValue(\"two\"); // changes the iterator's current entry value\n", "    assertEquals(\"two\", map.get(1));\n", "    assertEquals(Integer.valueOf(1), map.inverse().get(\"two\"));\n", "    iterator.remove(); // removes the updated entry\n", "    assertTrue(map.isEmpty());\n", "  }\n", "  \n", "  public void testInverseEntrySetValue() {\n", "    BiMap<Integer, String> map = HashBiMap.create();\n", "    map.put(1, \"one\");\n", "    Entry<String, Integer> inverseEntry = Iterables.getOnlyElement(map.inverse().entrySet());\n", "    inverseEntry.setValue(2);\n", "    assertEquals(Integer.valueOf(2), inverseEntry.getValue());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114]}}, {"102": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/HashMultimapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Unit tests for {@link HashMultimap}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class HashMultimapTest extends TestCase {\n", "\n", "  /*\n", "   * The behavior of toString() is tested by TreeMultimap, which shares a\n", "   * lot of code with HashMultimap and has deterministic iteration order.\n", "   */\n", "  public void testCreate() {\n", "    HashMultimap<String, Integer> multimap = HashMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"foo\", 3);\n", "    assertEquals(ImmutableSet.of(1, 3), multimap.get(\"foo\"));\n", "    assertEquals(2, multimap.expectedValuesPerKey);\n", "  }\n", "\n", "  public void testCreateFromMultimap() {\n", "    HashMultimap<String, Integer> multimap = HashMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"foo\", 3);\n", "    HashMultimap<String, Integer> copy = HashMultimap.create(multimap);\n", "    assertEquals(multimap, copy);\n", "    assertEquals(2, copy.expectedValuesPerKey);\n", "  }\n", "\n", "  public void testCreateFromSizes() {\n", "    HashMultimap<String, Integer> multimap = HashMultimap.create(20, 15);\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"foo\", 3);\n", "    assertEquals(ImmutableSet.of(1, 3), multimap.get(\"foo\"));\n", "    assertEquals(15, multimap.expectedValuesPerKey);\n", "  }\n", "\n", "  public void testCreateFromIllegalSizes() {\n", "    try {\n", "      HashMultimap.create(-20, 15);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "\n", "    try {\n", "      HashMultimap.create(20, -15);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testEmptyMultimapsEqual() {\n", "    Multimap<String, Integer> setMultimap = HashMultimap.create();\n", "    Multimap<String, Integer> listMultimap = ArrayListMultimap.create();\n", "    assertTrue(setMultimap.equals(listMultimap));\n", "    assertTrue(listMultimap.equals(setMultimap));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82]}}, {"103": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/HashMultisetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.google.TestStringMultisetGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "\n", "/**\n", " * Unit test for {@link HashMultiset}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class HashMultisetTest extends TestCase {\n", "\n", "  private static TestStringMultisetGenerator hashMultisetGenerator() {\n", "    return new TestStringMultisetGenerator() {\n", "      @Override protected Multiset<String> create(String[] elements) {\n", "        return HashMultiset.create(asList(elements));\n", "      }\n", "    };\n", "  }\n", "\n", "  public void testCreate() {\n", "    Multiset<String> multiset = HashMultiset.create();\n", "    multiset.add(\"foo\", 2);\n", "    multiset.add(\"bar\");\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "  }\n", "\n", "  public void testCreateWithSize() {\n", "    Multiset<String> multiset = HashMultiset.create(50);\n", "    multiset.add(\"foo\", 2);\n", "    multiset.add(\"bar\");\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "  }\n", "\n", "  public void testCreateFromIterable() {\n", "    Multiset<String> multiset\n", "        = HashMultiset.create(Arrays.asList(\"foo\", \"bar\", \"foo\"));\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "  }\n", "\n", "  /*\n", "   * The behavior of toString() and iteration is tested by LinkedHashMultiset,\n", "   * which shares a lot of code with HashMultiset and has deterministic\n", "   * iteration order.\n", "   */\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74]}}, {"104": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableBiMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Joiner;\n", "import com.google.common.collect.ImmutableBiMap.Builder;\n", "import com.google.common.collect.testing.MapInterfaceTest;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collections;\n", "import java.util.LinkedHashMap;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "\n", "/**\n", " * Tests for {@link ImmutableBiMap}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableBiMapTest extends TestCase {\n", "\n", "  // TODO: Reduce duplication of ImmutableMapTest code\n", "\n", "  public static abstract class AbstractMapTests<K, V>\n", "      extends MapInterfaceTest<K, V> {\n", "    public AbstractMapTests() {\n", "      super(false, false, false, false, false);\n", "    }\n", "\n", "    @Override protected Map<K, V> makeEmptyMap() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    private static final Joiner joiner = Joiner.on(\", \");\n", "\n", "    @Override protected void assertMoreInvariants(Map<K, V> map) {\n", "\n", "      BiMap<K, V> bimap = (BiMap<K, V>) map;\n", "\n", "      for (Entry<K, V> entry : map.entrySet()) {\n", "        assertEquals(entry.getKey() + \"=\" + entry.getValue(),\n", "            entry.toString());\n", "        assertEquals(entry.getKey(), bimap.inverse().get(entry.getValue()));\n", "      }\n", "\n", "      assertEquals(\"{\" + joiner.join(map.entrySet()) + \"}\",\n", "          map.toString());\n", "      assertEquals(\"[\" + joiner.join(map.entrySet()) + \"]\",\n", "          map.entrySet().toString());\n", "      assertEquals(\"[\" + joiner.join(map.keySet()) + \"]\",\n", "          map.keySet().toString());\n", "      assertEquals(\"[\" + joiner.join(map.values()) + \"]\",\n", "          map.values().toString());\n", "\n", "      assertEquals(Sets.newHashSet(map.entrySet()), map.entrySet());\n", "      assertEquals(Sets.newHashSet(map.keySet()), map.keySet());\n", "    }\n", "  }\n", "\n", "  public static class MapTests extends AbstractMapTests<String, Integer> {\n", "    @Override protected Map<String, Integer> makeEmptyMap() {\n", "      return ImmutableBiMap.of();\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      return ImmutableBiMap.of(\"one\", 1, \"two\", 2, \"three\", 3);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"minus one\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return -1;\n", "    }\n", "  }\n", "\n", "  public static class InverseMapTests\n", "      extends AbstractMapTests<String, Integer> {\n", "    @Override protected Map<String, Integer> makeEmptyMap() {\n", "      return ImmutableBiMap.of();\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      return ImmutableBiMap.of(1, \"one\", 2, \"two\", 3, \"three\").inverse();\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"minus one\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return -1;\n", "    }\n", "  }\n", "\n", "  public static class CreationTests extends TestCase {\n", "    public void testEmptyBuilder() {\n", "      ImmutableBiMap<String, Integer> map\n", "          = new Builder<String, Integer>().build();\n", "      assertEquals(Collections.<String, Integer>emptyMap(), map);\n", "      assertEquals(Collections.<Integer, String>emptyMap(), map.inverse());\n", "      assertSame(ImmutableBiMap.of(), map);\n", "    }\n", "\n", "    public void testSingletonBuilder() {\n", "      ImmutableBiMap<String, Integer> map = new Builder<String, Integer>()\n", "          .put(\"one\", 1)\n", "          .build();\n", "      assertMapEquals(map, \"one\", 1);\n", "      assertMapEquals(map.inverse(), 1, \"one\");\n", "    }\n", "\n", "    public void testBuilder_withImmutableEntry() {\n", "      ImmutableBiMap<String, Integer> map = new Builder<String, Integer>()\n", "          .put(Maps.immutableEntry(\"one\", 1))\n", "          .build();\n", "      assertMapEquals(map, \"one\", 1);\n", "    }\n", "\n", "    public void testBuilder() {\n", "      ImmutableBiMap<String, Integer> map\n", "          = ImmutableBiMap.<String, Integer>builder()\n", "            .put(\"one\", 1)\n", "            .put(\"two\", 2)\n", "            .put(\"three\", 3)\n", "            .put(\"four\", 4)\n", "            .put(\"five\", 5)\n", "            .build();\n", "      assertMapEquals(map,\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "      assertMapEquals(map.inverse(),\n", "          1, \"one\", 2, \"two\", 3, \"three\", 4, \"four\", 5, \"five\");\n", "    }\n", "    \n", "    public void testBuilder_orderEntriesByValue() {\n", "      ImmutableBiMap<String, Integer> map =\n", "          ImmutableBiMap.<String, Integer>builder()\n", "              .orderEntriesByValue(Ordering.natural())\n", "              .put(\"three\", 3)\n", "              .put(\"one\", 1)\n", "              .put(\"five\", 5)\n", "              .put(\"four\", 4)\n", "              .put(\"two\", 2)\n", "              .build();\n", "      assertMapEquals(map,\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "      assertMapEquals(map.inverse(),\n", "          1, \"one\", 2, \"two\", 3, \"three\", 4, \"four\", 5, \"five\");\n", "    }\n", "    \n", "    public void testBuilder_orderEntriesByValueAfterExactSizeBuild() {\n", "      ImmutableBiMap.Builder<String, Integer> builder =\n", "          new ImmutableBiMap.Builder<String, Integer>(2).put(\"four\", 4).put(\"one\", 1);\n", "      ImmutableMap<String, Integer> keyOrdered = builder.build();\n", "      ImmutableMap<String, Integer> valueOrdered =\n", "          builder.orderEntriesByValue(Ordering.natural()).build();\n", "      assertMapEquals(keyOrdered, \"four\", 4, \"one\", 1);\n", "      assertMapEquals(valueOrdered, \"one\", 1, \"four\", 4);\n", "    }\n", "    \n", "    public void testBuilder_orderEntriesByValue_usedTwiceFails() {\n", "      ImmutableBiMap.Builder<String, Integer> builder = new Builder<String, Integer>()\n", "          .orderEntriesByValue(Ordering.natural());\n", "      try {\n", "        builder.orderEntriesByValue(Ordering.natural());\n", "        fail(\"Expected IllegalStateException\");\n", "      } catch (IllegalStateException expected) {}\n", "    }\n", "\n", "    public void testBuilderPutAllWithEmptyMap() {\n", "      ImmutableBiMap<String, Integer> map = new Builder<String, Integer>()\n", "          .putAll(Collections.<String, Integer>emptyMap())\n", "          .build();\n", "      assertEquals(Collections.<String, Integer>emptyMap(), map);\n", "    }\n", "\n", "    public void testBuilderPutAll() {\n", "      Map<String, Integer> toPut = new LinkedHashMap<String, Integer>();\n", "      toPut.put(\"one\", 1);\n", "      toPut.put(\"two\", 2);\n", "      toPut.put(\"three\", 3);\n", "      Map<String, Integer> moreToPut = new LinkedHashMap<String, Integer>();\n", "      moreToPut.put(\"four\", 4);\n", "      moreToPut.put(\"five\", 5);\n", "\n", "      ImmutableBiMap<String, Integer> map = new Builder<String, Integer>()\n", "          .putAll(toPut)\n", "          .putAll(moreToPut)\n", "          .build();\n", "      assertMapEquals(map,\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "      assertMapEquals(map.inverse(),\n", "          1, \"one\", 2, \"two\", 3, \"three\", 4, \"four\", 5, \"five\");\n", "    }\n", "\n", "    public void testBuilderReuse() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      ImmutableBiMap<String, Integer> mapOne = builder\n", "          .put(\"one\", 1)\n", "          .put(\"two\", 2)\n", "          .build();\n", "      ImmutableBiMap<String, Integer> mapTwo = builder\n", "          .put(\"three\", 3)\n", "          .put(\"four\", 4)\n", "          .build();\n", "\n", "      assertMapEquals(mapOne, \"one\", 1, \"two\", 2);\n", "      assertMapEquals(mapOne.inverse(), 1, \"one\", 2, \"two\");\n", "      assertMapEquals(mapTwo, \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4);\n", "      assertMapEquals(mapTwo.inverse(),\n", "          1, \"one\", 2, \"two\", 3, \"three\", 4, \"four\");\n", "    }\n", "\n", "    public void testBuilderPutNullKey() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.put(null, 1);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullValue() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.put(\"one\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullKeyViaPutAll() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.putAll(Collections.<String, Integer>singletonMap(null, 1));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullValueViaPutAll() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.putAll(Collections.<String, Integer>singletonMap(\"one\", null));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testPuttingTheSameKeyTwiceThrowsOnBuild() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>()\n", "          .put(\"one\", 1)\n", "          .put(\"one\", 1); // throwing on this line would be even better\n", "\n", "      try {\n", "        builder.build();\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "        assertThat(expected.getMessage()).contains(\"one\");\n", "      }\n", "    }\n", "\n", "    public void testOf() {\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\"one\", 1),\n", "          \"one\", 1);\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\"one\", 1).inverse(),\n", "          1, \"one\");\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\"one\", 1, \"two\", 2),\n", "          \"one\", 1, \"two\", 2);\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\"one\", 1, \"two\", 2).inverse(),\n", "          1, \"one\", 2, \"two\");\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\"one\", 1, \"two\", 2, \"three\", 3),\n", "          \"one\", 1, \"two\", 2, \"three\", 3);\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\"one\", 1, \"two\", 2, \"three\", 3).inverse(),\n", "          1, \"one\", 2, \"two\", 3, \"three\");\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4),\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4);\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\n", "              \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4).inverse(),\n", "          1, \"one\", 2, \"two\", 3, \"three\", 4, \"four\");\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\n", "              \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5),\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "      assertMapEquals(\n", "          ImmutableBiMap.of(\n", "              \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5).inverse(),\n", "          1, \"one\", 2, \"two\", 3, \"three\", 4, \"four\", 5, \"five\");\n", "    }\n", "\n", "    public void testOfNullKey() {\n", "      try {\n", "        ImmutableBiMap.of(null, 1);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        ImmutableBiMap.of(\"one\", 1, null, 2);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testOfNullValue() {\n", "      try {\n", "        ImmutableBiMap.of(\"one\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        ImmutableBiMap.of(\"one\", 1, \"two\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testOfWithDuplicateKey() {\n", "      try {\n", "        ImmutableBiMap.of(\"one\", 1, \"one\", 1);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "        assertThat(expected.getMessage()).contains(\"one\");\n", "      }\n", "    }\n", "\n", "    public void testCopyOfEmptyMap() {\n", "      ImmutableBiMap<String, Integer> copy\n", "          = ImmutableBiMap.copyOf(Collections.<String, Integer>emptyMap());\n", "      assertEquals(Collections.<String, Integer>emptyMap(), copy);\n", "      assertSame(copy, ImmutableBiMap.copyOf(copy));\n", "      assertSame(ImmutableBiMap.of(), copy);\n", "    }\n", "\n", "    public void testCopyOfSingletonMap() {\n", "      ImmutableBiMap<String, Integer> copy\n", "          = ImmutableBiMap.copyOf(Collections.singletonMap(\"one\", 1));\n", "      assertMapEquals(copy, \"one\", 1);\n", "      assertSame(copy, ImmutableBiMap.copyOf(copy));\n", "    }\n", "\n", "    public void testCopyOf() {\n", "      Map<String, Integer> original = new LinkedHashMap<String, Integer>();\n", "      original.put(\"one\", 1);\n", "      original.put(\"two\", 2);\n", "      original.put(\"three\", 3);\n", "\n", "      ImmutableBiMap<String, Integer> copy = ImmutableBiMap.copyOf(original);\n", "      assertMapEquals(copy, \"one\", 1, \"two\", 2, \"three\", 3);\n", "      assertSame(copy, ImmutableBiMap.copyOf(copy));\n", "    }\n", "\n", "    public void testEmpty() {\n", "      ImmutableBiMap<String, Integer> bimap = ImmutableBiMap.of();\n", "      assertEquals(Collections.<String, Integer>emptyMap(), bimap);\n", "      assertEquals(Collections.<String, Integer>emptyMap(), bimap.inverse());\n", "    }\n", "\n", "    public void testFromHashMap() {\n", "      Map<String, Integer> hashMap = Maps.newLinkedHashMap();\n", "      hashMap.put(\"one\", 1);\n", "      hashMap.put(\"two\", 2);\n", "      ImmutableBiMap<String, Integer> bimap = ImmutableBiMap.copyOf(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2));\n", "      assertMapEquals(bimap, \"one\", 1, \"two\", 2);\n", "      assertMapEquals(bimap.inverse(), 1, \"one\", 2, \"two\");\n", "    }\n", "\n", "    public void testFromImmutableMap() {\n", "      ImmutableBiMap<String, Integer> bimap = ImmutableBiMap.copyOf(\n", "          new ImmutableMap.Builder<String, Integer>()\n", "              .put(\"one\", 1)\n", "              .put(\"two\", 2)\n", "              .put(\"three\", 3)\n", "              .put(\"four\", 4)\n", "              .put(\"five\", 5)\n", "              .build());\n", "      assertMapEquals(bimap,\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "      assertMapEquals(bimap.inverse(),\n", "          1, \"one\", 2, \"two\", 3, \"three\", 4, \"four\", 5, \"five\");\n", "    }\n", "\n", "    public void testDuplicateValues() {\n", "      ImmutableMap<String, Integer> map\n", "          = new ImmutableMap.Builder<String, Integer>()\n", "              .put(\"one\", 1)\n", "              .put(\"two\", 2)\n", "              .put(\"uno\", 1)\n", "              .put(\"dos\", 2)\n", "              .build();\n", "\n", "      try {\n", "        ImmutableBiMap.copyOf(map);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "        assertThat(expected.getMessage()).contains(\"1\");\n", "      }\n", "    }\n", "  }\n", "\n", "  public static class BiMapSpecificTests extends TestCase {\n", "\n", "    @SuppressWarnings(\"deprecation\")\n", "    public void testForcePut() {\n", "      ImmutableBiMap<String, Integer> bimap = ImmutableBiMap.copyOf(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2));\n", "      try {\n", "        bimap.forcePut(\"three\", 3);\n", "        fail();\n", "      } catch (UnsupportedOperationException expected) {}\n", "    }\n", "\n", "    public void testKeySet() {\n", "      ImmutableBiMap<String, Integer> bimap = ImmutableBiMap.copyOf(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4));\n", "      Set<String> keys = bimap.keySet();\n", "      assertEquals(Sets.newHashSet(\"one\", \"two\", \"three\", \"four\"), keys);\n", "      assertThat(keys).containsExactly(\"one\", \"two\", \"three\", \"four\").inOrder();\n", "    }\n", "\n", "    public void testValues() {\n", "      ImmutableBiMap<String, Integer> bimap = ImmutableBiMap.copyOf(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4));\n", "      Set<Integer> values = bimap.values();\n", "      assertEquals(Sets.newHashSet(1, 2, 3, 4), values);\n", "      assertThat(values).containsExactly(1, 2, 3, 4).inOrder();\n", "    }\n", "\n", "    public void testDoubleInverse() {\n", "      ImmutableBiMap<String, Integer> bimap = ImmutableBiMap.copyOf(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2));\n", "      assertSame(bimap, bimap.inverse().inverse());\n", "    }\n", "  }\n", "\n", "  private static <K, V> void assertMapEquals(Map<K, V> map,\n", "      Object... alternatingKeysAndValues) {\n", "    int i = 0;\n", "    for (Entry<K, V> entry : map.entrySet()) {\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getKey());\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getValue());\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476]}}, {"105": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableEnumMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AnEnum;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.TestEnumMapGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * Tests for {@code ImmutableEnumMap}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableEnumMapTest extends TestCase {\n", "  public static class ImmutableEnumMapGenerator extends TestEnumMapGenerator {\n", "    @Override\n", "    protected Map<AnEnum, String> create(Entry<AnEnum, String>[] entries) {\n", "      Map<AnEnum, String> map = Maps.newHashMap();\n", "      for (Entry<AnEnum, String> entry : entries) {\n", "        map.put(entry.getKey(), entry.getValue());\n", "      }\n", "      return Maps.immutableEnumMap(map);\n", "    }\n", "  }\n", "\n", "  public void testEmptyImmutableEnumMap() {\n", "    ImmutableMap<AnEnum, String> map = Maps.immutableEnumMap(ImmutableMap.<AnEnum, String>of());\n", "    assertEquals(ImmutableMap.of(), map);\n", "  }\n", "\n", "  public void testImmutableEnumMapOrdering() {\n", "    ImmutableMap<AnEnum, String> map = Maps.immutableEnumMap(\n", "        ImmutableMap.of(AnEnum.C, \"c\", AnEnum.A, \"a\", AnEnum.E, \"e\"));\n", "\n", "    assertThat(map.entrySet()).containsExactly(\n", "        Helpers.mapEntry(AnEnum.A, \"a\"),\n", "        Helpers.mapEntry(AnEnum.C, \"c\"),\n", "        Helpers.mapEntry(AnEnum.E, \"e\")).inOrder();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]}}, {"106": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableListMultimapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableListMultimap.Builder;\n", "import com.google.common.collect.testing.google.TestStringListMultimapGenerator;\n", "import com.google.common.collect.testing.google.UnmodifiableCollectionTests;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * Tests for {@link ImmutableListMultimap}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableListMultimapTest extends TestCase {\n", "  public static class ImmutableListMultimapGenerator extends TestStringListMultimapGenerator {\n", "    @Override\n", "    protected ListMultimap<String, String> create(Entry<String, String>[] entries) {\n", "      ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();\n", "      for (Entry<String, String> entry : entries) {\n", "        builder.put(entry.getKey(), entry.getValue());\n", "      }\n", "      return builder.build();\n", "    }\n", "  }\n", "  public static class ImmutableListMultimapCopyOfEntriesGenerator \n", "      extends TestStringListMultimapGenerator {\n", "    @Override\n", "    protected ListMultimap<String, String> create(Entry<String, String>[] entries) {\n", "      return ImmutableListMultimap.copyOf(Arrays.asList(entries));\n", "    }\n", "  }\n", "\n", "  public void testBuilder_withImmutableEntry() {\n", "    ImmutableListMultimap<String, Integer> multimap = new Builder<String, Integer>()\n", "        .put(Maps.immutableEntry(\"one\", 1))\n", "        .build();\n", "    assertEquals(Arrays.asList(1), multimap.get(\"one\"));\n", "  }\n", "\n", "  public void testBuilder_withImmutableEntryAndNullContents() {\n", "    Builder<String, Integer> builder = new Builder<String, Integer>();\n", "    try {\n", "      builder.put(Maps.immutableEntry(\"one\", (Integer) null));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    try {\n", "      builder.put(Maps.immutableEntry((String) null, 1));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  private static class StringHolder {\n", "    String string;\n", "  }\n", "\n", "  public void testBuilder_withMutableEntry() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder =\n", "        new Builder<String, Integer>();\n", "    final StringHolder holder = new StringHolder();\n", "    holder.string = \"one\";\n", "    Entry<String, Integer> entry = new AbstractMapEntry<String, Integer>() {\n", "      @Override public String getKey() {\n", "        return holder.string;\n", "      }\n", "      @Override public Integer getValue() {\n", "        return 1;\n", "      }\n", "    };\n", "\n", "    builder.put(entry);\n", "    holder.string = \"two\";\n", "    assertEquals(Arrays.asList(1), builder.build().get(\"one\"));\n", "  }\n", "\n", "  public void testBuilderPutAllIterable() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.putAll(\"foo\", Arrays.asList(1, 2, 3));\n", "    builder.putAll(\"bar\", Arrays.asList(4, 5));\n", "    builder.putAll(\"foo\", Arrays.asList(6, 7));\n", "    Multimap<String, Integer> multimap = builder.build();\n", "    assertEquals(Arrays.asList(1, 2, 3, 6, 7), multimap.get(\"foo\"));\n", "    assertEquals(Arrays.asList(4, 5), multimap.get(\"bar\"));\n", "    assertEquals(7, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutAllVarargs() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.putAll(\"foo\", 1, 2, 3);\n", "    builder.putAll(\"bar\", 4, 5);\n", "    builder.putAll(\"foo\", 6, 7);\n", "    Multimap<String, Integer> multimap = builder.build();\n", "    assertEquals(Arrays.asList(1, 2, 3, 6, 7), multimap.get(\"foo\"));\n", "    assertEquals(Arrays.asList(4, 5), multimap.get(\"bar\"));\n", "    assertEquals(7, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutAllMultimap() {\n", "    Multimap<String, Integer> toPut = LinkedListMultimap.create();\n", "    toPut.put(\"foo\", 1);\n", "    toPut.put(\"bar\", 4);\n", "    toPut.put(\"foo\", 2);\n", "    toPut.put(\"foo\", 3);\n", "    Multimap<String, Integer> moreToPut = LinkedListMultimap.create();\n", "    moreToPut.put(\"foo\", 6);\n", "    moreToPut.put(\"bar\", 5);\n", "    moreToPut.put(\"foo\", 7);\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.putAll(toPut);\n", "    builder.putAll(moreToPut);\n", "    Multimap<String, Integer> multimap = builder.build();\n", "    assertEquals(Arrays.asList(1, 2, 3, 6, 7), multimap.get(\"foo\"));\n", "    assertEquals(Arrays.asList(4, 5), multimap.get(\"bar\"));\n", "    assertEquals(7, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutAllWithDuplicates() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.putAll(\"foo\", 1, 2, 3);\n", "    builder.putAll(\"bar\", 4, 5);\n", "    builder.putAll(\"foo\", 1, 6, 7);\n", "    ImmutableListMultimap<String, Integer> multimap = builder.build();\n", "    assertEquals(Arrays.asList(1, 2, 3, 1, 6, 7), multimap.get(\"foo\"));\n", "    assertEquals(Arrays.asList(4, 5), multimap.get(\"bar\"));\n", "    assertEquals(8, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutWithDuplicates() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.putAll(\"foo\", 1, 2, 3);\n", "    builder.putAll(\"bar\", 4, 5);\n", "    builder.put(\"foo\", 1);\n", "    ImmutableListMultimap<String, Integer> multimap = builder.build();\n", "    assertEquals(Arrays.asList(1, 2, 3, 1), multimap.get(\"foo\"));\n", "    assertEquals(Arrays.asList(4, 5), multimap.get(\"bar\"));\n", "    assertEquals(6, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutAllMultimapWithDuplicates() {\n", "    Multimap<String, Integer> toPut = LinkedListMultimap.create();\n", "    toPut.put(\"foo\", 1);\n", "    toPut.put(\"bar\", 4);\n", "    toPut.put(\"foo\", 2);\n", "    toPut.put(\"foo\", 1);\n", "    toPut.put(\"bar\", 5);\n", "    Multimap<String, Integer> moreToPut = LinkedListMultimap.create();\n", "    moreToPut.put(\"foo\", 6);\n", "    moreToPut.put(\"bar\", 4);\n", "    moreToPut.put(\"foo\", 7);\n", "    moreToPut.put(\"foo\", 2);\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.putAll(toPut);\n", "    builder.putAll(moreToPut);\n", "    Multimap<String, Integer> multimap = builder.build();\n", "    assertEquals(Arrays.asList(1, 2, 1, 6, 7, 2), multimap.get(\"foo\"));\n", "    assertEquals(Arrays.asList(4, 5, 4), multimap.get(\"bar\"));\n", "    assertEquals(9, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutNullKey() {\n", "    Multimap<String, Integer> toPut = LinkedListMultimap.create();\n", "    toPut.put(\"foo\", null);\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    try {\n", "      builder.put(null, 1);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(null, Arrays.asList(1, 2, 3));\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(null, 1, 2, 3);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(toPut);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testBuilderPutNullValue() {\n", "    Multimap<String, Integer> toPut = LinkedListMultimap.create();\n", "    toPut.put(null, 1);\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    try {\n", "      builder.put(\"foo\", null);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(\"foo\", Arrays.asList(1, null, 3));\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(\"foo\", 1, null, 3);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(toPut);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testBuilderOrderKeysBy() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.put(\"b\", 3);\n", "    builder.put(\"d\", 2);\n", "    builder.put(\"a\", 5);\n", "    builder.orderKeysBy(Collections.reverseOrder());\n", "    builder.put(\"c\", 4);\n", "    builder.put(\"a\", 2);\n", "    builder.put(\"b\", 6);\n", "    ImmutableListMultimap<String, Integer> multimap = builder.build();\n", "    assertThat(multimap.keySet()).containsExactly(\"d\", \"c\", \"b\", \"a\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(2, 4, 3, 6, 5, 2).inOrder();\n", "    assertThat(multimap.get(\"a\")).containsExactly(5, 2).inOrder();\n", "    assertThat(multimap.get(\"b\")).containsExactly(3, 6).inOrder();\n", "  }\n", "\n", "  public void testBuilderOrderKeysByDuplicates() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.put(\"bb\", 3);\n", "    builder.put(\"d\", 2);\n", "    builder.put(\"a\", 5);\n", "    builder.orderKeysBy(new Ordering<String>() {\n", "      @Override\n", "      public int compare(String left, String right) {\n", "        return left.length() - right.length();\n", "      }\n", "    });\n", "    builder.put(\"cc\", 4);\n", "    builder.put(\"a\", 2);\n", "    builder.put(\"bb\", 6);\n", "    ImmutableListMultimap<String, Integer> multimap = builder.build();\n", "    assertThat(multimap.keySet()).containsExactly(\"d\", \"a\", \"bb\", \"cc\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(2, 5, 2, 3, 6, 4).inOrder();\n", "    assertThat(multimap.get(\"a\")).containsExactly(5, 2).inOrder();\n", "    assertThat(multimap.get(\"bb\")).containsExactly(3, 6).inOrder();\n", "  }\n", "\n", "  public void testBuilderOrderValuesBy() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.put(\"b\", 3);\n", "    builder.put(\"d\", 2);\n", "    builder.put(\"a\", 5);\n", "    builder.orderValuesBy(Collections.reverseOrder());\n", "    builder.put(\"c\", 4);\n", "    builder.put(\"a\", 2);\n", "    builder.put(\"b\", 6);\n", "    ImmutableListMultimap<String, Integer> multimap = builder.build();\n", "    assertThat(multimap.keySet()).containsExactly(\"b\", \"d\", \"a\", \"c\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(6, 3, 2, 5, 2, 4).inOrder();\n", "    assertThat(multimap.get(\"a\")).containsExactly(5, 2).inOrder();\n", "    assertThat(multimap.get(\"b\")).containsExactly(6, 3).inOrder();\n", "  }\n", "\n", "  public void testBuilderOrderKeysAndValuesBy() {\n", "    ImmutableListMultimap.Builder<String, Integer> builder\n", "        = ImmutableListMultimap.builder();\n", "    builder.put(\"b\", 3);\n", "    builder.put(\"d\", 2);\n", "    builder.put(\"a\", 5);\n", "    builder.orderKeysBy(Collections.reverseOrder());\n", "    builder.orderValuesBy(Collections.reverseOrder());\n", "    builder.put(\"c\", 4);\n", "    builder.put(\"a\", 2);\n", "    builder.put(\"b\", 6);\n", "    ImmutableListMultimap<String, Integer> multimap = builder.build();\n", "    assertThat(multimap.keySet()).containsExactly(\"d\", \"c\", \"b\", \"a\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(2, 4, 6, 3, 5, 2).inOrder();\n", "    assertThat(multimap.get(\"a\")).containsExactly(5, 2).inOrder();\n", "    assertThat(multimap.get(\"b\")).containsExactly(6, 3).inOrder();\n", "  }\n", "\n", "  public void testCopyOf() {\n", "    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();\n", "    input.put(\"foo\", 1);\n", "    input.put(\"bar\", 2);\n", "    input.put(\"foo\", 3);\n", "    Multimap<String, Integer> multimap = ImmutableListMultimap.copyOf(input);\n", "    assertEquals(multimap, input);\n", "    assertEquals(input, multimap);\n", "  }\n", "\n", "  public void testCopyOfWithDuplicates() {\n", "    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();\n", "    input.put(\"foo\", 1);\n", "    input.put(\"bar\", 2);\n", "    input.put(\"foo\", 3);\n", "    input.put(\"foo\", 1);\n", "    Multimap<String, Integer> multimap = ImmutableListMultimap.copyOf(input);\n", "    assertEquals(multimap, input);\n", "    assertEquals(input, multimap);\n", "  }\n", "\n", "  public void testCopyOfEmpty() {\n", "    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();\n", "    Multimap<String, Integer> multimap = ImmutableListMultimap.copyOf(input);\n", "    assertEquals(multimap, input);\n", "    assertEquals(input, multimap);\n", "  }\n", "\n", "  public void testCopyOfImmutableListMultimap() {\n", "    Multimap<String, Integer> multimap = createMultimap();\n", "    assertSame(multimap, ImmutableListMultimap.copyOf(multimap));\n", "  }\n", "\n", "  public void testCopyOfNullKey() {\n", "    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();\n", "    input.put(null, 1);\n", "    try {\n", "      ImmutableListMultimap.copyOf(input);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testCopyOfNullValue() {\n", "    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();\n", "    input.putAll(\"foo\", Arrays.asList(1, null, 3));\n", "    try {\n", "      ImmutableListMultimap.copyOf(input);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testEmptyMultimapReads() {\n", "    Multimap<String, Integer> multimap = ImmutableListMultimap.of();\n", "    assertFalse(multimap.containsKey(\"foo\"));\n", "    assertFalse(multimap.containsValue(1));\n", "    assertFalse(multimap.containsEntry(\"foo\", 1));\n", "    assertTrue(multimap.entries().isEmpty());\n", "    assertTrue(multimap.equals(ArrayListMultimap.create()));\n", "    assertEquals(Collections.emptyList(), multimap.get(\"foo\"));\n", "    assertEquals(0, multimap.hashCode());\n", "    assertTrue(multimap.isEmpty());\n", "    assertEquals(HashMultiset.create(), multimap.keys());\n", "    assertEquals(Collections.emptySet(), multimap.keySet());\n", "    assertEquals(0, multimap.size());\n", "    assertTrue(multimap.values().isEmpty());\n", "    assertEquals(\"{}\", multimap.toString());\n", "  }\n", "\n", "  public void testEmptyMultimapWrites() {\n", "    Multimap<String, Integer> multimap = ImmutableListMultimap.of();\n", "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(\n", "        multimap, \"foo\", 1);\n", "  }\n", "\n", "  private Multimap<String, Integer> createMultimap() {\n", "    return ImmutableListMultimap.<String, Integer>builder()\n", "        .put(\"foo\", 1).put(\"bar\", 2).put(\"foo\", 3).build();\n", "  }\n", "\n", "  public void testMultimapReads() {\n", "    Multimap<String, Integer> multimap = createMultimap();\n", "    assertTrue(multimap.containsKey(\"foo\"));\n", "    assertFalse(multimap.containsKey(\"cat\"));\n", "    assertTrue(multimap.containsValue(1));\n", "    assertFalse(multimap.containsValue(5));\n", "    assertTrue(multimap.containsEntry(\"foo\", 1));\n", "    assertFalse(multimap.containsEntry(\"cat\", 1));\n", "    assertFalse(multimap.containsEntry(\"foo\", 5));\n", "    assertFalse(multimap.entries().isEmpty());\n", "    assertEquals(3, multimap.size());\n", "    assertFalse(multimap.isEmpty());\n", "    assertEquals(\"{foo=[1, 3], bar=[2]}\", multimap.toString());\n", "  }\n", "\n", "  public void testMultimapWrites() {\n", "    Multimap<String, Integer> multimap = createMultimap();\n", "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(\n", "        multimap, \"bar\", 2);\n", "  }\n", "\n", "  public void testMultimapEquals() {\n", "    Multimap<String, Integer> multimap = createMultimap();\n", "    Multimap<String, Integer> arrayListMultimap\n", "        = ArrayListMultimap.create();\n", "    arrayListMultimap.putAll(\"foo\", Arrays.asList(1, 3));\n", "    arrayListMultimap.put(\"bar\", 2);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(multimap, createMultimap(), arrayListMultimap,\n", "            ImmutableListMultimap.<String, Integer>builder()\n", "                .put(\"bar\", 2).put(\"foo\", 1).put(\"foo\", 3).build())\n", "        .addEqualityGroup(ImmutableListMultimap.<String, Integer>builder()\n", "            .put(\"bar\", 2).put(\"foo\", 3).put(\"foo\", 1).build())\n", "        .addEqualityGroup(ImmutableListMultimap.<String, Integer>builder()\n", "            .put(\"foo\", 2).put(\"foo\", 3).put(\"foo\", 1).build())\n", "        .addEqualityGroup(ImmutableListMultimap.<String, Integer>builder()\n", "            .put(\"bar\", 2).put(\"foo\", 3).build())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testOf() {\n", "    assertMultimapEquals(\n", "        ImmutableListMultimap.of(\"one\", 1),\n", "        \"one\", 1);\n", "    assertMultimapEquals(\n", "        ImmutableListMultimap.of(\"one\", 1, \"two\", 2),\n", "        \"one\", 1, \"two\", 2);\n", "    assertMultimapEquals(\n", "        ImmutableListMultimap.of(\"one\", 1, \"two\", 2, \"three\", 3),\n", "        \"one\", 1, \"two\", 2, \"three\", 3);\n", "    assertMultimapEquals(\n", "        ImmutableListMultimap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4),\n", "        \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4);\n", "    assertMultimapEquals(\n", "        ImmutableListMultimap.of(\n", "            \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5),\n", "        \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "  }\n", "\n", "  public void testInverse() {\n", "    assertEquals(\n", "        ImmutableListMultimap.<Integer, String>of(),\n", "        ImmutableListMultimap.<String, Integer>of().inverse());\n", "    assertEquals(\n", "        ImmutableListMultimap.of(1, \"one\"),\n", "        ImmutableListMultimap.of(\"one\", 1).inverse());\n", "    assertEquals(\n", "        ImmutableListMultimap.of(1, \"one\", 2, \"two\"),\n", "        ImmutableListMultimap.of(\"one\", 1, \"two\", 2).inverse());\n", "    assertEquals(\n", "        ImmutableListMultimap.of(\"of\", 'o', \"of\", 'f', \"to\", 't', \"to\", 'o').inverse(),\n", "        ImmutableListMultimap.of('o', \"of\", 'f', \"of\", 't', \"to\", 'o', \"to\"));\n", "    assertEquals(\n", "        ImmutableListMultimap.of('f', \"foo\", 'o', \"foo\", 'o', \"foo\"),\n", "        ImmutableListMultimap.of(\"foo\", 'f', \"foo\", 'o', \"foo\", 'o').inverse());\n", "  }\n", "\n", "  public void testInverseMinimizesWork() {\n", "    ImmutableListMultimap<String, Character> multimap =\n", "        ImmutableListMultimap.<String, Character>builder()\n", "            .put(\"foo\", 'f')\n", "            .put(\"foo\", 'o')\n", "            .put(\"foo\", 'o')\n", "            .put(\"poo\", 'p')\n", "            .put(\"poo\", 'o')\n", "            .put(\"poo\", 'o')\n", "            .build();\n", "    assertSame(multimap.inverse(), multimap.inverse());\n", "    assertSame(multimap, multimap.inverse().inverse());\n", "  }\n", "\n", "  private static <K, V> void assertMultimapEquals(Multimap<K, V> multimap,\n", "      Object... alternatingKeysAndValues) {\n", "    assertEquals(multimap.size(), alternatingKeysAndValues.length / 2);\n", "    int i = 0;\n", "    for (Entry<K, V> entry : multimap.entries()) {\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getKey());\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getValue());\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493]}}, {"107": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableListTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.MinimalCollection;\n", "import com.google.common.collect.testing.MinimalIterable;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link ImmutableList}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author George van den Driessche\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableListTest extends TestCase {\n", "\n", "  public static class CreationTests extends TestCase {\n", "    public void testCreation_noArgs() {\n", "      List<String> list = ImmutableList.of();\n", "      assertEquals(Collections.emptyList(), list);\n", "    }\n", "\n", "    public void testCreation_oneElement() {\n", "      List<String> list = ImmutableList.of(\"a\");\n", "      assertEquals(Collections.singletonList(\"a\"), list);\n", "    }\n", "\n", "    public void testCreation_twoElements() {\n", "      List<String> list = ImmutableList.of(\"a\", \"b\");\n", "      assertEquals(Lists.newArrayList(\"a\", \"b\"), list);\n", "    }\n", "\n", "    public void testCreation_threeElements() {\n", "      List<String> list = ImmutableList.of(\"a\", \"b\", \"c\");\n", "      assertEquals(Lists.newArrayList(\"a\", \"b\", \"c\"), list);\n", "    }\n", "\n", "    public void testCreation_fourElements() {\n", "      List<String> list = ImmutableList.of(\"a\", \"b\", \"c\", \"d\");\n", "      assertEquals(Lists.newArrayList(\"a\", \"b\", \"c\", \"d\"), list);\n", "    }\n", "\n", "    public void testCreation_fiveElements() {\n", "      List<String> list = ImmutableList.of(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "      assertEquals(Lists.newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\"), list);\n", "    }\n", "\n", "    public void testCreation_sixElements() {\n", "      List<String> list = ImmutableList.of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n", "      assertEquals(Lists.newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"), list);\n", "    }\n", "\n", "    public void testCreation_sevenElements() {\n", "      List<String> list = ImmutableList.of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\");\n", "      assertEquals(Lists.newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"), list);\n", "    }\n", "\n", "    public void testCreation_eightElements() {\n", "      List<String> list = ImmutableList.of(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\");\n", "      assertEquals(Lists.newArrayList(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"), list);\n", "    }\n", "\n", "    public void testCreation_nineElements() {\n", "      List<String> list = ImmutableList.of(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\");\n", "      assertEquals(Lists.newArrayList(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"), list);\n", "    }\n", "\n", "    public void testCreation_tenElements() {\n", "      List<String> list = ImmutableList.of(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\");\n", "      assertEquals(Lists.newArrayList(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"), list);\n", "    }\n", "\n", "    public void testCreation_elevenElements() {\n", "      List<String> list = ImmutableList.of(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\");\n", "      assertEquals(Lists.newArrayList(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"), list);\n", "    }\n", "\n", "    // Varargs versions\n", "\n", "    public void testCreation_twelveElements() {\n", "      List<String> list = ImmutableList.of(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\");\n", "      assertEquals(Lists.newArrayList(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"), list);\n", "    }\n", "\n", "    public void testCreation_thirteenElements() {\n", "      List<String> list = ImmutableList.of(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\");\n", "      assertEquals(Lists.newArrayList(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"),\n", "          list);\n", "    }\n", "\n", "    public void testCreation_fourteenElements() {\n", "      List<String> list = ImmutableList.of(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\");\n", "      assertEquals(Lists.newArrayList(\n", "          \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"),\n", "          list);\n", "    }\n", "\n", "    public void testCreation_singletonNull() {\n", "      try {\n", "        ImmutableList.of((String) null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testCreation_withNull() {\n", "      try {\n", "        ImmutableList.of(\"a\", null, \"b\");\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testCreation_generic() {\n", "      List<String> a = ImmutableList.of(\"a\");\n", "      // only verify that there is no compile warning\n", "      ImmutableList.of(a, a);\n", "    }\n", "\n", "    public void testCreation_arrayOfArray() {\n", "      String[] array = new String[] { \"a\" };\n", "      List<String[]> list = ImmutableList.<String[]>of(array);\n", "      assertEquals(Collections.singletonList(array), list);\n", "    }\n", "\n", "    public void testCopyOf_emptyArray() {\n", "      String[] array = new String[0];\n", "      List<String> list = ImmutableList.copyOf(array);\n", "      assertEquals(Collections.emptyList(), list);\n", "    }\n", "\n", "    public void testCopyOf_arrayOfOneElement() {\n", "      String[] array = new String[] { \"a\" };\n", "      List<String> list = ImmutableList.copyOf(array);\n", "      assertEquals(Collections.singletonList(\"a\"), list);\n", "    }\n", "\n", "    public void testCopyOf_nullArray() {\n", "      try {\n", "        ImmutableList.copyOf((String[]) null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testCopyOf_arrayContainingOnlyNull() {\n", "      String[] array = new String[] { null };\n", "      try {\n", "        ImmutableList.copyOf(array);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testCopyOf_collection_empty() {\n", "      // \"<String>\" is required to work around a javac 1.5 bug.\n", "      Collection<String> c = MinimalCollection.<String>of();\n", "      List<String> list = ImmutableList.copyOf(c);\n", "      assertEquals(Collections.emptyList(), list);\n", "    }\n", "\n", "    public void testCopyOf_collection_oneElement() {\n", "      Collection<String> c = MinimalCollection.of(\"a\");\n", "      List<String> list = ImmutableList.copyOf(c);\n", "      assertEquals(Collections.singletonList(\"a\"), list);\n", "    }\n", "\n", "    public void testCopyOf_collection_general() {\n", "      Collection<String> c = MinimalCollection.of(\"a\", \"b\", \"a\");\n", "      List<String> list = ImmutableList.copyOf(c);\n", "      assertEquals(asList(\"a\", \"b\", \"a\"), list);\n", "      List<String> mutableList = asList(\"a\", \"b\");\n", "      list = ImmutableList.copyOf(mutableList);\n", "      mutableList.set(0, \"c\");\n", "      assertEquals(asList(\"a\", \"b\"), list);\n", "    }\n", "\n", "    public void testCopyOf_collectionContainingNull() {\n", "      Collection<String> c = MinimalCollection.of(\"a\", null, \"b\");\n", "      try {\n", "        ImmutableList.copyOf(c);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testCopyOf_iterator_empty() {\n", "      Iterator<String> iterator = Iterators.emptyIterator();\n", "      List<String> list = ImmutableList.copyOf(iterator);\n", "      assertEquals(Collections.emptyList(), list);\n", "    }\n", "\n", "    public void testCopyOf_iterator_oneElement() {\n", "      Iterator<String> iterator = Iterators.singletonIterator(\"a\");\n", "      List<String> list = ImmutableList.copyOf(iterator);\n", "      assertEquals(Collections.singletonList(\"a\"), list);\n", "    }\n", "\n", "    public void testCopyOf_iterator_general() {\n", "      Iterator<String> iterator = asList(\"a\", \"b\", \"a\").iterator();\n", "      List<String> list = ImmutableList.copyOf(iterator);\n", "      assertEquals(asList(\"a\", \"b\", \"a\"), list);\n", "    }\n", "\n", "    public void testCopyOf_iteratorContainingNull() {\n", "      Iterator<String> iterator = asList(\"a\", null, \"b\").iterator();\n", "      try {\n", "        ImmutableList.copyOf(iterator);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testCopyOf_iteratorNull() {\n", "      try {\n", "        ImmutableList.copyOf((Iterator<String>) null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testCopyOf_concurrentlyMutating() {\n", "      List<String> sample = Lists.newArrayList(\"a\", \"b\", \"c\");\n", "      for (int delta : new int[] {-1, 0, 1}) {\n", "        for (int i = 0; i < sample.size(); i++) {\n", "          Collection<String> misleading =\n", "              Helpers.misleadingSizeCollection(delta);\n", "          List<String> expected = sample.subList(0, i);\n", "          misleading.addAll(expected);\n", "          assertEquals(expected, ImmutableList.copyOf(misleading));\n", "          assertEquals(expected,\n", "              ImmutableList.copyOf((Iterable<String>) misleading));\n", "        }\n", "      }\n", "    }\n", "\n", "    private static class CountingIterable implements Iterable<String> {\n", "      int count = 0;\n", "      @Override\n", "      public Iterator<String> iterator() {\n", "        count++;\n", "        return asList(\"a\", \"b\", \"a\").iterator();\n", "      }\n", "    }\n", "\n", "    public void testCopyOf_plainIterable() {\n", "      CountingIterable iterable = new CountingIterable();\n", "      List<String> list = ImmutableList.copyOf(iterable);\n", "      assertEquals(asList(\"a\", \"b\", \"a\"), list);\n", "    }\n", "\n", "    public void testCopyOf_plainIterable_iteratesOnce() {\n", "      CountingIterable iterable = new CountingIterable();\n", "      ImmutableList.copyOf(iterable);\n", "      assertEquals(1, iterable.count);\n", "    }\n", "\n", "    public void testCopyOf_shortcut_empty() {\n", "      Collection<String> c = ImmutableList.of();\n", "      assertSame(c, ImmutableList.copyOf(c));\n", "    }\n", "\n", "    public void testCopyOf_shortcut_singleton() {\n", "      Collection<String> c = ImmutableList.of(\"a\");\n", "      assertSame(c, ImmutableList.copyOf(c));\n", "    }\n", "\n", "    public void testCopyOf_shortcut_immutableList() {\n", "      Collection<String> c = ImmutableList.of(\"a\", \"b\", \"c\");\n", "      assertSame(c, ImmutableList.copyOf(c));\n", "    }\n", "\n", "    public void testBuilderAddArrayHandlesNulls() {\n", "      String[] elements = {\"a\", null, \"b\"};\n", "      ImmutableList.Builder<String> builder = ImmutableList.builder();\n", "      try {\n", "        builder.add(elements);\n", "        fail (\"Expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "      ImmutableList<String> result = builder.build();\n", "\n", "      /*\n", "       * Maybe it rejects all elements, or maybe it adds \"a\" before failing.\n", "       * Either way is fine with us.\n", "       */\n", "      if (result.isEmpty()) {\n", "        return;\n", "      }\n", "      assertTrue(ImmutableList.of(\"a\").equals(result));\n", "      assertEquals(1, result.size());\n", "    }\n", "\n", "    public void testBuilderAddCollectionHandlesNulls() {\n", "      List<String> elements = Arrays.asList(\"a\", null, \"b\");\n", "      ImmutableList.Builder<String> builder = ImmutableList.builder();\n", "      try {\n", "        builder.addAll(elements);\n", "        fail (\"Expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "      ImmutableList<String> result = builder.build();\n", "      assertEquals(ImmutableList.of(\"a\"), result);\n", "      assertEquals(1, result.size());\n", "    }\n", "  }\n", "\n", "  public static class BasicTests extends TestCase {\n", "\n", "    public void testEquals_immutableList() {\n", "      Collection<String> c = ImmutableList.of(\"a\", \"b\", \"c\");\n", "      assertTrue(c.equals(ImmutableList.of(\"a\", \"b\", \"c\")));\n", "      assertFalse(c.equals(ImmutableList.of(\"a\", \"c\", \"b\")));\n", "      assertFalse(c.equals(ImmutableList.of(\"a\", \"b\")));\n", "      assertFalse(c.equals(ImmutableList.of(\"a\", \"b\", \"c\", \"d\")));\n", "    }\n", "\n", "    public void testBuilderAdd() {\n", "      ImmutableList<String> list = new ImmutableList.Builder<String>()\n", "          .add(\"a\")\n", "          .add(\"b\")\n", "          .add(\"a\")\n", "          .add(\"c\")\n", "          .build();\n", "      assertEquals(asList(\"a\", \"b\", \"a\", \"c\"), list);\n", "    }\n", "\n", "    public void testBuilderAdd_varargs() {\n", "      ImmutableList<String> list = new ImmutableList.Builder<String>()\n", "          .add(\"a\", \"b\", \"a\", \"c\")\n", "          .build();\n", "      assertEquals(asList(\"a\", \"b\", \"a\", \"c\"), list);\n", "    }\n", "\n", "    public void testBuilderAddAll_iterable() {\n", "      List<String> a = asList(\"a\", \"b\");\n", "      List<String> b = asList(\"c\", \"d\");\n", "      ImmutableList<String> list = new ImmutableList.Builder<String>()\n", "          .addAll(a)\n", "          .addAll(b)\n", "          .build();\n", "      assertEquals(asList( \"a\", \"b\", \"c\", \"d\"), list);\n", "      b.set(0, \"f\");\n", "      assertEquals(asList( \"a\", \"b\", \"c\", \"d\"), list);\n", "    }\n", "\n", "    public void testBuilderAddAll_iterator() {\n", "      List<String> a = asList(\"a\", \"b\");\n", "      List<String> b = asList(\"c\", \"d\");\n", "      ImmutableList<String> list = new ImmutableList.Builder<String>()\n", "          .addAll(a.iterator())\n", "          .addAll(b.iterator())\n", "          .build();\n", "      assertEquals(asList( \"a\", \"b\", \"c\", \"d\"), list);\n", "      b.set(0, \"f\");\n", "      assertEquals(asList( \"a\", \"b\", \"c\", \"d\"), list);\n", "    }\n", "\n", "    public void testComplexBuilder() {\n", "      List<Integer> colorElem = asList(0x00, 0x33, 0x66, 0x99, 0xCC, 0xFF);\n", "      ImmutableList.Builder<Integer> webSafeColorsBuilder\n", "          = ImmutableList.builder();\n", "      for (Integer red : colorElem) {\n", "        for (Integer green : colorElem) {\n", "          for (Integer blue : colorElem) {\n", "            webSafeColorsBuilder.add((red << 16) + (green << 8) + blue);\n", "          }\n", "        }\n", "      }\n", "      ImmutableList<Integer> webSafeColors = webSafeColorsBuilder.build();\n", "      assertEquals(216, webSafeColors.size());\n", "      Integer[] webSafeColorArray =\n", "          webSafeColors.toArray(new Integer[webSafeColors.size()]);\n", "      assertEquals(0x000000, (int) webSafeColorArray[0]);\n", "      assertEquals(0x000033, (int) webSafeColorArray[1]);\n", "      assertEquals(0x000066, (int) webSafeColorArray[2]);\n", "      assertEquals(0x003300, (int) webSafeColorArray[6]);\n", "      assertEquals(0x330000, (int) webSafeColorArray[36]);\n", "      assertEquals(0x000066, (int) webSafeColors.get(2));\n", "      assertEquals(0x003300, (int) webSafeColors.get(6));\n", "      ImmutableList<Integer> addedColor\n", "          = webSafeColorsBuilder.add(0x00BFFF).build();\n", "      assertEquals(\"Modifying the builder should not have changed any already\"\n", "          + \" built sets\", 216, webSafeColors.size());\n", "      assertEquals(\"the new array should be one bigger than webSafeColors\",\n", "          217, addedColor.size());\n", "      Integer[] appendColorArray =\n", "          addedColor.toArray(new Integer[addedColor.size()]);\n", "      assertEquals(0x00BFFF, (int) appendColorArray[216]);\n", "    }\n", "\n", "    public void testBuilderAddHandlesNullsCorrectly() {\n", "      ImmutableList.Builder<String> builder = ImmutableList.builder();\n", "      try {\n", "        builder.add((String) null);\n", "        fail(\"expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        builder.add((String[]) null);\n", "        fail(\"expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        builder.add(\"a\", null, \"b\");\n", "        fail(\"expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderAddAllHandlesNullsCorrectly() {\n", "      ImmutableList.Builder<String> builder = ImmutableList.builder();\n", "      try {\n", "        builder.addAll((Iterable<String>) null);\n", "        fail(\"expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        builder.addAll((Iterator<String>) null);\n", "        fail(\"expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      builder = ImmutableList.builder();\n", "      List<String> listWithNulls = asList(\"a\", null, \"b\");\n", "      try {\n", "        builder.addAll(listWithNulls);\n", "        fail(\"expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      builder = ImmutableList.builder();\n", "      Iterator<String> iteratorWithNulls = asList(\"a\", null, \"b\").iterator();\n", "      try {\n", "        builder.addAll(iteratorWithNulls);\n", "        fail(\"expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      Iterable<String> iterableWithNulls = MinimalIterable.of(\"a\", null, \"b\");\n", "      try {\n", "        builder.addAll(iterableWithNulls);\n", "        fail(\"expected NullPointerException\");\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testAsList() {\n", "      ImmutableList<String> list = ImmutableList.of(\"a\", \"b\");\n", "      assertSame(list, list.asList());\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497]}}, {"108": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Joiner;\n", "import com.google.common.collect.ImmutableMap.Builder;\n", "import com.google.common.collect.testing.AnEnum;\n", "import com.google.common.collect.testing.MapInterfaceTest;\n", "import com.google.common.collect.testing.MinimalSet;\n", "import com.google.common.collect.testing.SampleElements.Colliders;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.Collections;\n", "import java.util.EnumMap;\n", "import java.util.LinkedHashMap;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * Tests for {@link ImmutableMap}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jesse Wilson\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableMapTest extends TestCase {\n", "\n", "  public abstract static class AbstractMapTests<K, V>\n", "      extends MapInterfaceTest<K, V> {\n", "    public AbstractMapTests() {\n", "      super(false, false, false, false, false);\n", "    }\n", "\n", "    @Override protected Map<K, V> makeEmptyMap() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    private static final Joiner joiner = Joiner.on(\", \");\n", "\n", "    @Override protected void assertMoreInvariants(Map<K, V> map) {\n", "      // TODO: can these be moved to MapInterfaceTest?\n", "      for (Entry<K, V> entry : map.entrySet()) {\n", "        assertEquals(entry.getKey() + \"=\" + entry.getValue(),\n", "            entry.toString());\n", "      }\n", "\n", "      assertEquals(\"{\" + joiner.join(map.entrySet()) + \"}\",\n", "          map.toString());\n", "      assertEquals(\"[\" + joiner.join(map.entrySet()) + \"]\",\n", "          map.entrySet().toString());\n", "      assertEquals(\"[\" + joiner.join(map.keySet()) + \"]\",\n", "          map.keySet().toString());\n", "      assertEquals(\"[\" + joiner.join(map.values()) + \"]\",\n", "          map.values().toString());\n", "\n", "      assertEquals(MinimalSet.from(map.entrySet()), map.entrySet());\n", "      assertEquals(Sets.newHashSet(map.keySet()), map.keySet());\n", "    }\n", "  }\n", "\n", "  public static class MapTests extends AbstractMapTests<String, Integer> {\n", "    @Override protected Map<String, Integer> makeEmptyMap() {\n", "      return ImmutableMap.of();\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      return ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"minus one\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return -1;\n", "    }\n", "  }\n", "\n", "  public static class SingletonMapTests\n", "      extends AbstractMapTests<String, Integer> {\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      return ImmutableMap.of(\"one\", 1);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"minus one\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return -1;\n", "    }\n", "  }\n", "\n", "  public static class MapTestsWithBadHashes\n", "      extends AbstractMapTests<Object, Integer> {\n", "\n", "    @Override protected Map<Object, Integer> makeEmptyMap() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override protected Map<Object, Integer> makePopulatedMap() {\n", "      Colliders colliders = new Colliders();\n", "      return ImmutableMap.of(\n", "          colliders.e0(), 0,\n", "          colliders.e1(), 1,\n", "          colliders.e2(), 2,\n", "          colliders.e3(), 3);\n", "    }\n", "\n", "    @Override protected Object getKeyNotInPopulatedMap() {\n", "      return new Colliders().e4();\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return 4;\n", "    }\n", "  }\n", "\n", "  public static class CreationTests extends TestCase {\n", "    public void testEmptyBuilder() {\n", "      ImmutableMap<String, Integer> map\n", "          = new Builder<String, Integer>().build();\n", "      assertEquals(Collections.<String, Integer>emptyMap(), map);\n", "    }\n", "\n", "    public void testSingletonBuilder() {\n", "      ImmutableMap<String, Integer> map = new Builder<String, Integer>()\n", "          .put(\"one\", 1)\n", "          .build();\n", "      assertMapEquals(map, \"one\", 1);\n", "    }\n", "\n", "    public void testBuilder() {\n", "      ImmutableMap<String, Integer> map = new Builder<String, Integer>()\n", "          .put(\"one\", 1)\n", "          .put(\"two\", 2)\n", "          .put(\"three\", 3)\n", "          .put(\"four\", 4)\n", "          .put(\"five\", 5)\n", "          .build();\n", "      assertMapEquals(map,\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "    }\n", "    \n", "    public void testBuilder_orderEntriesByValue() {\n", "      ImmutableMap<String, Integer> map = new Builder<String, Integer>()\n", "          .orderEntriesByValue(Ordering.natural())\n", "          .put(\"three\", 3)\n", "          .put(\"one\", 1)\n", "          .put(\"five\", 5)\n", "          .put(\"four\", 4)\n", "          .put(\"two\", 2)\n", "          .build();\n", "      assertMapEquals(map,\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "    }\n", "    \n", "    public void testBuilder_orderEntriesByValueAfterExactSizeBuild() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>(2)\n", "          .put(\"four\", 4)\n", "          .put(\"one\", 1);\n", "      ImmutableMap<String, Integer> keyOrdered = builder.build();\n", "      ImmutableMap<String, Integer> valueOrdered =\n", "          builder.orderEntriesByValue(Ordering.natural()).build();\n", "      assertMapEquals(keyOrdered, \"four\", 4, \"one\", 1);\n", "      assertMapEquals(valueOrdered, \"one\", 1, \"four\", 4);\n", "    }\n", "    \n", "    public void testBuilder_orderEntriesByValue_usedTwiceFails() {\n", "      ImmutableMap.Builder<String, Integer> builder = new Builder<String, Integer>()\n", "          .orderEntriesByValue(Ordering.natural());\n", "      try {\n", "        builder.orderEntriesByValue(Ordering.natural());\n", "        fail(\"Expected IllegalStateException\");\n", "      } catch (IllegalStateException expected) {}\n", "    }\n", "\n", "    public void testBuilder_withImmutableEntry() {\n", "      ImmutableMap<String, Integer> map = new Builder<String, Integer>()\n", "          .put(Maps.immutableEntry(\"one\", 1))\n", "          .build();\n", "      assertMapEquals(map, \"one\", 1);\n", "    }\n", "\n", "    public void testBuilder_withImmutableEntryAndNullContents() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.put(Maps.immutableEntry(\"one\", (Integer) null));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "      try {\n", "        builder.put(Maps.immutableEntry((String) null, 1));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    private static class StringHolder {\n", "      String string;\n", "    }\n", "\n", "    public void testBuilder_withMutableEntry() {\n", "      ImmutableMap.Builder<String, Integer> builder =\n", "          new Builder<String, Integer>();\n", "      final StringHolder holder = new StringHolder();\n", "      holder.string = \"one\";\n", "      Entry<String, Integer> entry = new AbstractMapEntry<String, Integer>() {\n", "        @Override public String getKey() {\n", "          return holder.string;\n", "        }\n", "        @Override public Integer getValue() {\n", "          return 1;\n", "        }\n", "      };\n", "\n", "      builder.put(entry);\n", "      holder.string = \"two\";\n", "      assertMapEquals(builder.build(), \"one\", 1);\n", "    }\n", "\n", "    public void testBuilderPutAllWithEmptyMap() {\n", "      ImmutableMap<String, Integer> map = new Builder<String, Integer>()\n", "          .putAll(Collections.<String, Integer>emptyMap())\n", "          .build();\n", "      assertEquals(Collections.<String, Integer>emptyMap(), map);\n", "    }\n", "\n", "    public void testBuilderPutAll() {\n", "      Map<String, Integer> toPut = new LinkedHashMap<String, Integer>();\n", "      toPut.put(\"one\", 1);\n", "      toPut.put(\"two\", 2);\n", "      toPut.put(\"three\", 3);\n", "      Map<String, Integer> moreToPut = new LinkedHashMap<String, Integer>();\n", "      moreToPut.put(\"four\", 4);\n", "      moreToPut.put(\"five\", 5);\n", "\n", "      ImmutableMap<String, Integer> map = new Builder<String, Integer>()\n", "          .putAll(toPut)\n", "          .putAll(moreToPut)\n", "          .build();\n", "      assertMapEquals(map,\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "    }\n", "\n", "    public void testBuilderReuse() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      ImmutableMap<String, Integer> mapOne = builder\n", "          .put(\"one\", 1)\n", "          .put(\"two\", 2)\n", "          .build();\n", "      ImmutableMap<String, Integer> mapTwo = builder\n", "          .put(\"three\", 3)\n", "          .put(\"four\", 4)\n", "          .build();\n", "\n", "      assertMapEquals(mapOne, \"one\", 1, \"two\", 2);\n", "      assertMapEquals(mapTwo, \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4);\n", "    }\n", "    \n", "    public void testBuilderPutNullKeyFailsAtomically() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.put(null, 1);\n", "        fail();\n", "      } catch (NullPointerException expected) {}\n", "      builder.put(\"foo\", 2);\n", "      assertMapEquals(builder.build(), \"foo\", 2);\n", "    }\n", "    \n", "    public void testBuilderPutImmutableEntryWithNullKeyFailsAtomically() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.put(Maps.immutableEntry((String) null, 1));\n", "        fail();\n", "      } catch (NullPointerException expected) {}\n", "      builder.put(\"foo\", 2);\n", "      assertMapEquals(builder.build(), \"foo\", 2);\n", "    }\n", "    \n", "    // for GWT compatibility\n", "    static class SimpleEntry<K, V> extends AbstractMapEntry<K, V> {\n", "      public K key;\n", "      public V value;\n", "      \n", "      SimpleEntry(K key, V value) {\n", "        this.key = key;\n", "        this.value = value;\n", "      }\n", "\n", "      @Override\n", "      public K getKey() {\n", "        return key;\n", "      }\n", "\n", "      @Override\n", "      public V getValue() {\n", "        return value;\n", "      }\n", "    }\n", "    \n", "    public void testBuilderPutMutableEntryWithNullKeyFailsAtomically() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.put(new SimpleEntry<String, Integer>(null, 1));\n", "        fail();\n", "      } catch (NullPointerException expected) {}\n", "      builder.put(\"foo\", 2);\n", "      assertMapEquals(builder.build(), \"foo\", 2);\n", "    }\n", "\n", "    public void testBuilderPutNullKey() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.put(null, 1);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullValue() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.put(\"one\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullKeyViaPutAll() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.putAll(Collections.<String, Integer>singletonMap(null, 1));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullValueViaPutAll() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>();\n", "      try {\n", "        builder.putAll(Collections.<String, Integer>singletonMap(\"one\", null));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testPuttingTheSameKeyTwiceThrowsOnBuild() {\n", "      Builder<String, Integer> builder = new Builder<String, Integer>()\n", "          .put(\"one\", 1)\n", "          .put(\"one\", 1); // throwing on this line would be even better\n", "\n", "      try {\n", "        builder.build();\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "\n", "    public void testOf() {\n", "      assertMapEquals(\n", "          ImmutableMap.of(\"one\", 1),\n", "          \"one\", 1);\n", "      assertMapEquals(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2),\n", "          \"one\", 1, \"two\", 2);\n", "      assertMapEquals(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3),\n", "          \"one\", 1, \"two\", 2, \"three\", 3);\n", "      assertMapEquals(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4),\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4);\n", "      assertMapEquals(\n", "          ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5),\n", "          \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "    }\n", "\n", "    public void testOfNullKey() {\n", "      try {\n", "        ImmutableMap.of(null, 1);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        ImmutableMap.of(\"one\", 1, null, 2);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testOfNullValue() {\n", "      try {\n", "        ImmutableMap.of(\"one\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        ImmutableMap.of(\"one\", 1, \"two\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testOfWithDuplicateKey() {\n", "      try {\n", "        ImmutableMap.of(\"one\", 1, \"one\", 1);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "    \n", "    public void testCopyOfEmptyMap() {\n", "      ImmutableMap<String, Integer> copy\n", "          = ImmutableMap.copyOf(Collections.<String, Integer>emptyMap());\n", "      assertEquals(Collections.<String, Integer>emptyMap(), copy);\n", "      assertSame(copy, ImmutableMap.copyOf(copy));\n", "    }\n", "\n", "    public void testCopyOfSingletonMap() {\n", "      ImmutableMap<String, Integer> copy\n", "          = ImmutableMap.copyOf(Collections.singletonMap(\"one\", 1));\n", "      assertMapEquals(copy, \"one\", 1);\n", "      assertSame(copy, ImmutableMap.copyOf(copy));\n", "    }\n", "\n", "    public void testCopyOf() {\n", "      Map<String, Integer> original = new LinkedHashMap<String, Integer>();\n", "      original.put(\"one\", 1);\n", "      original.put(\"two\", 2);\n", "      original.put(\"three\", 3);\n", "\n", "      ImmutableMap<String, Integer> copy = ImmutableMap.copyOf(original);\n", "      assertMapEquals(copy, \"one\", 1, \"two\", 2, \"three\", 3);\n", "      assertSame(copy, ImmutableMap.copyOf(copy));\n", "    }\n", "  }\n", "\n", "  public void testNullGet() {\n", "    ImmutableMap<String, Integer> map = ImmutableMap.of(\"one\", 1);\n", "    assertNull(map.get(null));\n", "  }\n", "\n", "  public void testAsMultimap() {\n", "    ImmutableMap<String, Integer> map = ImmutableMap.of(\n", "        \"one\", 1, \"won\", 1, \"two\", 2, \"too\", 2, \"three\", 3);\n", "    ImmutableSetMultimap<String, Integer> expected = ImmutableSetMultimap.of(\n", "        \"one\", 1, \"won\", 1, \"two\", 2, \"too\", 2, \"three\", 3);\n", "    assertEquals(expected, map.asMultimap());\n", "  }\n", "\n", "  public void testAsMultimapWhenEmpty() {\n", "    ImmutableMap<String, Integer> map = ImmutableMap.of();\n", "    ImmutableSetMultimap<String, Integer> expected = ImmutableSetMultimap.of();\n", "    assertEquals(expected, map.asMultimap());\n", "  }\n", "\n", "  public void testAsMultimapCaches() {\n", "    ImmutableMap<String, Integer> map = ImmutableMap.of(\"one\", 1);\n", "    ImmutableSetMultimap<String, Integer> multimap1 = map.asMultimap();\n", "    ImmutableSetMultimap<String, Integer> multimap2 = map.asMultimap();\n", "    assertEquals(1, multimap1.asMap().size());\n", "    assertSame(multimap1, multimap2);\n", "  }\n", "\n", "  private static <K, V> void assertMapEquals(Map<K, V> map,\n", "      Object... alternatingKeysAndValues) {\n", "    assertEquals(map.size(), alternatingKeysAndValues.length / 2);\n", "    int i = 0;\n", "    for (Entry<K, V> entry : map.entrySet()) {\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getKey());\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getValue());\n", "    }\n", "  }\n", "\n", "  private static class IntHolder implements Serializable {\n", "    public int value;\n", "\n", "    public IntHolder(int value) {\n", "      this.value = value;\n", "    }\n", "\n", "    @Override public boolean equals(Object o) {\n", "      return (o instanceof IntHolder) && ((IntHolder) o).value == value;\n", "    }\n", "\n", "    @Override public int hashCode() {\n", "      return value;\n", "    }\n", "\n", "    private static final long serialVersionUID = 5;\n", "  }\n", "\n", "  public void testMutableValues() {\n", "    IntHolder holderA = new IntHolder(1);\n", "    IntHolder holderB = new IntHolder(2);\n", "    Map<String, IntHolder> map = ImmutableMap.of(\"a\", holderA, \"b\", holderB);\n", "    holderA.value = 3;\n", "    assertTrue(map.entrySet().contains(\n", "        Maps.immutableEntry(\"a\", new IntHolder(3))));\n", "    Map<String, Integer> intMap = ImmutableMap.of(\"a\", 3, \"b\", 2);\n", "    assertEquals(intMap.hashCode(), map.entrySet().hashCode());\n", "    assertEquals(intMap.hashCode(), map.hashCode());\n", "  }\n", "\n", "  public void testCopyOfEnumMap() {\n", "    EnumMap<AnEnum, String> map = new EnumMap<AnEnum, String>(AnEnum.class);\n", "    map.put(AnEnum.B, \"foo\");\n", "    map.put(AnEnum.C, \"bar\");\n", "    assertTrue(ImmutableMap.copyOf(map) instanceof ImmutableEnumMap);\n", "  }\n", "\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(ImmutableList.of(), ImmutableList.of())\n", "        .addEqualityGroup(ImmutableList.of(1), ImmutableList.of(1))\n", "        .addEqualityGroup(ImmutableList.of(1, 2), ImmutableList.of(1, 2))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 9))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(100, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 200, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 300, 4, 5, 6, 7, 8, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 400, 5, 6, 7, 8, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 500, 6, 7, 8, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 600, 7, 8, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 700, 8, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 800, 9, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 900, 10, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 1000, 11, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1100, 12))\n", "        .addEqualityGroup(ImmutableList.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 1200))\n", "        .testEquals();\n", "\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563]}}, {"109": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableMultimapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableMultimap.Builder;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.SampleElements.Unhashables;\n", "import com.google.common.collect.testing.UnhashableObject;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * Tests for {@link ImmutableMultimap}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableMultimapTest extends TestCase {\n", "\n", "  public void testBuilder_withImmutableEntry() {\n", "    ImmutableMultimap<String, Integer> multimap = new Builder<String, Integer>()\n", "        .put(Maps.immutableEntry(\"one\", 1))\n", "        .build();\n", "    assertEquals(Arrays.asList(1), multimap.get(\"one\"));\n", "  }\n", "\n", "  public void testBuilder_withImmutableEntryAndNullContents() {\n", "    Builder<String, Integer> builder = new Builder<String, Integer>();\n", "    try {\n", "      builder.put(Maps.immutableEntry(\"one\", (Integer) null));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    try {\n", "      builder.put(Maps.immutableEntry((String) null, 1));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  private static class StringHolder {\n", "    String string;\n", "  }\n", "\n", "  public void testBuilder_withMutableEntry() {\n", "    ImmutableMultimap.Builder<String, Integer> builder =\n", "        new Builder<String, Integer>();\n", "    final StringHolder holder = new StringHolder();\n", "    holder.string = \"one\";\n", "    Entry<String, Integer> entry = new AbstractMapEntry<String, Integer>() {\n", "      @Override public String getKey() {\n", "        return holder.string;\n", "      }\n", "      @Override public Integer getValue() {\n", "        return 1;\n", "      }\n", "    };\n", "\n", "    builder.put(entry);\n", "    holder.string = \"two\";\n", "    assertEquals(Arrays.asList(1), builder.build().get(\"one\"));\n", "  }\n", "\n", "  // TODO: test ImmutableMultimap builder and factory methods\n", "\n", "  public void testCopyOf() {\n", "    ImmutableSetMultimap<String, String> setMultimap\n", "        = ImmutableSetMultimap.of(\"k1\", \"v1\");\n", "    ImmutableMultimap<String, String> setMultimapCopy\n", "        = ImmutableMultimap.copyOf(setMultimap);\n", "    assertSame(\"copyOf(ImmutableSetMultimap) should not create a new instance\",\n", "        setMultimap, setMultimapCopy);\n", "\n", "    ImmutableListMultimap<String, String> listMultimap\n", "        = ImmutableListMultimap.of(\"k1\", \"v1\");\n", "    ImmutableMultimap<String, String> listMultimapCopy\n", "        = ImmutableMultimap.copyOf(listMultimap);\n", "    assertSame(\"copyOf(ImmutableListMultimap) should not create a new instance\",\n", "        listMultimap, listMultimapCopy);\n", "  }\n", "\n", "  public void testUnhashableSingletonValue() {\n", "    SampleElements<UnhashableObject> unhashables = new Unhashables();\n", "    Multimap<Integer, UnhashableObject> multimap = ImmutableMultimap.of(\n", "        0, unhashables.e0());\n", "    assertEquals(1, multimap.get(0).size());\n", "    assertTrue(multimap.get(0).contains(unhashables.e0()));\n", "  }\n", "\n", "  public void testUnhashableMixedValues() {\n", "    SampleElements<UnhashableObject> unhashables = new Unhashables();\n", "    Multimap<Integer, Object> multimap = ImmutableMultimap.<Integer, Object>of(\n", "        0, unhashables.e0(), 2, \"hey you\", 0, unhashables.e1());\n", "    assertEquals(2, multimap.get(0).size());\n", "    assertTrue(multimap.get(0).contains(unhashables.e0()));\n", "    assertTrue(multimap.get(0).contains(unhashables.e1()));\n", "    assertTrue(multimap.get(2).contains(\"hey you\"));\n", "  }\n", "\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(ImmutableMultimap.of(), ImmutableMultimap.of())\n", "        .addEqualityGroup(ImmutableMultimap.of(1, \"a\"), ImmutableMultimap.of(1, \"a\"))\n", "        .addEqualityGroup(\n", "            ImmutableMultimap.of(1, \"a\", 2, \"b\"),\n", "            ImmutableMultimap.of(2, \"b\", 1, \"a\"))\n", "        .testEquals();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129]}}, {"110": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableMultisetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.MinimalCollection;\n", "import com.google.common.collect.testing.google.UnmodifiableCollectionTests;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collection;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "\n", "/**\n", " * Tests for {@link ImmutableMultiset}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableMultisetTest extends TestCase {\n", "\n", "  public void testCreation_noArgs() {\n", "    Multiset<String> multiset = ImmutableMultiset.of();\n", "    assertTrue(multiset.isEmpty());\n", "  }\n", "\n", "  public void testCreation_oneElement() {\n", "    Multiset<String> multiset = ImmutableMultiset.of(\"a\");\n", "    assertEquals(HashMultiset.create(asList(\"a\")), multiset);\n", "  }\n", "\n", "  public void testCreation_twoElements() {\n", "    Multiset<String> multiset = ImmutableMultiset.of(\"a\", \"b\");\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\")), multiset);\n", "  }\n", "\n", "  public void testCreation_threeElements() {\n", "    Multiset<String> multiset = ImmutableMultiset.of(\"a\", \"b\", \"c\");\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"c\")), multiset);\n", "  }\n", "\n", "  public void testCreation_fourElements() {\n", "    Multiset<String> multiset = ImmutableMultiset.of(\"a\", \"b\", \"c\", \"d\");\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"c\", \"d\")), multiset);\n", "  }\n", "\n", "  public void testCreation_fiveElements() {\n", "    Multiset<String> multiset = ImmutableMultiset.of(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"c\", \"d\", \"e\")),\n", "        multiset);\n", "  }\n", "\n", "  public void testCreation_sixElements() {\n", "    Multiset<String> multiset = ImmutableMultiset.of(\n", "        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")),\n", "        multiset);\n", "  }\n", "\n", "  public void testCreation_sevenElements() {\n", "    Multiset<String> multiset = ImmutableMultiset.of(\n", "        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\");\n", "    assertEquals(\n", "        HashMultiset.create(asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\")),\n", "        multiset);\n", "  }\n", "\n", "  public void testCreation_emptyArray() {\n", "    String[] array = new String[0];\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(array);\n", "    assertTrue(multiset.isEmpty());\n", "  }\n", "\n", "  public void testCreation_arrayOfOneElement() {\n", "    String[] array = new String[] { \"a\" };\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(array);\n", "    assertEquals(HashMultiset.create(asList(\"a\")), multiset);\n", "  }\n", "\n", "  public void testCreation_arrayOfArray() {\n", "    String[] array = new String[] { \"a\" };\n", "    Multiset<String[]> multiset = ImmutableMultiset.<String[]>of(array);\n", "    Multiset<String[]> expected = HashMultiset.create();\n", "    expected.add(array);\n", "    assertEquals(expected, multiset);\n", "  }\n", "\n", "  public void testCreation_arrayContainingOnlyNull() {\n", "    String[] array = new String[] { null };\n", "    try {\n", "      ImmutableMultiset.copyOf(array);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testCopyOf_collection_empty() {\n", "    // \"<String>\" is required to work around a javac 1.5 bug.\n", "    Collection<String> c = MinimalCollection.<String>of();\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(c);\n", "    assertTrue(multiset.isEmpty());\n", "  }\n", "\n", "  public void testCopyOf_collection_oneElement() {\n", "    Collection<String> c = MinimalCollection.of(\"a\");\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(c);\n", "    assertEquals(HashMultiset.create(asList(\"a\")), multiset);\n", "  }\n", "\n", "  public void testCopyOf_collection_general() {\n", "    Collection<String> c = MinimalCollection.of(\"a\", \"b\", \"a\");\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(c);\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"a\")), multiset);\n", "  }\n", "\n", "  public void testCopyOf_collectionContainingNull() {\n", "    Collection<String> c = MinimalCollection.of(\"a\", null, \"b\");\n", "    try {\n", "      ImmutableMultiset.copyOf(c);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testCopyOf_multiset_empty() {\n", "    Multiset<String> c = HashMultiset.create();\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(c);\n", "    assertTrue(multiset.isEmpty());\n", "  }\n", "\n", "  public void testCopyOf_multiset_oneElement() {\n", "    Multiset<String> c = HashMultiset.create(asList(\"a\"));\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(c);\n", "    assertEquals(HashMultiset.create(asList(\"a\")), multiset);\n", "  }\n", "\n", "  public void testCopyOf_multiset_general() {\n", "    Multiset<String> c = HashMultiset.create(asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(c);\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"a\")), multiset);\n", "  }\n", "\n", "  public void testCopyOf_multisetContainingNull() {\n", "    Multiset<String> c = HashMultiset.create(asList(\"a\", null, \"b\"));\n", "    try {\n", "      ImmutableMultiset.copyOf(c);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testCopyOf_iterator_empty() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(iterator);\n", "    assertTrue(multiset.isEmpty());\n", "  }\n", "\n", "  public void testCopyOf_iterator_oneElement() {\n", "    Iterator<String> iterator = Iterators.singletonIterator(\"a\");\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(iterator);\n", "    assertEquals(HashMultiset.create(asList(\"a\")), multiset);\n", "  }\n", "\n", "  public void testCopyOf_iterator_general() {\n", "    Iterator<String> iterator = asList(\"a\", \"b\", \"a\").iterator();\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(iterator);\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"a\")), multiset);\n", "  }\n", "\n", "  public void testCopyOf_iteratorContainingNull() {\n", "    Iterator<String> iterator = asList(\"a\", null, \"b\").iterator();\n", "    try {\n", "      ImmutableMultiset.copyOf(iterator);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  private static class CountingIterable implements Iterable<String> {\n", "    int count = 0;\n", "    @Override\n", "    public Iterator<String> iterator() {\n", "      count++;\n", "      return asList(\"a\", \"b\", \"a\").iterator();\n", "    }\n", "  }\n", "\n", "  public void testCopyOf_plainIterable() {\n", "    CountingIterable iterable = new CountingIterable();\n", "    Multiset<String> multiset = ImmutableMultiset.copyOf(iterable);\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"a\")), multiset);\n", "    assertEquals(1, iterable.count);\n", "  }\n", "\n", "  public void testCopyOf_shortcut_empty() {\n", "    Collection<String> c = ImmutableMultiset.of();\n", "    assertSame(c, ImmutableMultiset.copyOf(c));\n", "  }\n", "\n", "  public void testCopyOf_shortcut_singleton() {\n", "    Collection<String> c = ImmutableMultiset.of(\"a\");\n", "    assertSame(c, ImmutableMultiset.copyOf(c));\n", "  }\n", "\n", "  public void testCopyOf_shortcut_immutableMultiset() {\n", "    Collection<String> c = ImmutableMultiset.of(\"a\", \"b\", \"c\");\n", "    assertSame(c, ImmutableMultiset.copyOf(c));\n", "  }\n", "\n", "  public void testBuilderAdd() {\n", "    ImmutableMultiset<String> multiset = new ImmutableMultiset.Builder<String>()\n", "        .add(\"a\")\n", "        .add(\"b\")\n", "        .add(\"a\")\n", "        .add(\"c\")\n", "        .build();\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"a\", \"c\")), multiset);\n", "  }\n", "\n", "  public void testBuilderAddAll() {\n", "    List<String> a = asList(\"a\", \"b\");\n", "    List<String> b = asList(\"c\", \"d\");\n", "    ImmutableMultiset<String> multiset = new ImmutableMultiset.Builder<String>()\n", "        .addAll(a)\n", "        .addAll(b)\n", "        .build();\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"c\", \"d\")), multiset);\n", "  }\n", "\n", "  public void testBuilderAddAllMultiset() {\n", "    Multiset<String> a = HashMultiset.create(asList(\"a\", \"b\", \"b\"));\n", "    Multiset<String> b = HashMultiset.create(asList(\"c\", \"b\"));\n", "    ImmutableMultiset<String> multiset = new ImmutableMultiset.Builder<String>()\n", "        .addAll(a)\n", "        .addAll(b)\n", "        .build();\n", "    assertEquals(\n", "        HashMultiset.create(asList(\"a\", \"b\", \"b\", \"b\", \"c\")), multiset);\n", "  }\n", "\n", "  public void testBuilderAddAllIterator() {\n", "    Iterator<String> iterator = asList(\"a\", \"b\", \"a\", \"c\").iterator();\n", "    ImmutableMultiset<String> multiset = new ImmutableMultiset.Builder<String>()\n", "        .addAll(iterator)\n", "        .build();\n", "    assertEquals(HashMultiset.create(asList(\"a\", \"b\", \"a\", \"c\")), multiset);\n", "  }\n", "\n", "  public void testBuilderAddCopies() {\n", "    ImmutableMultiset<String> multiset = new ImmutableMultiset.Builder<String>()\n", "        .addCopies(\"a\", 2)\n", "        .addCopies(\"b\", 3)\n", "        .addCopies(\"c\", 0)\n", "        .build();\n", "    assertEquals(\n", "        HashMultiset.create(asList(\"a\", \"a\", \"b\", \"b\", \"b\")), multiset);\n", "  }\n", "\n", "  public void testBuilderSetCount() {\n", "    ImmutableMultiset<String> multiset = new ImmutableMultiset.Builder<String>()\n", "        .add(\"a\")\n", "        .setCount(\"a\", 2)\n", "        .setCount(\"b\", 3)\n", "        .build();\n", "    assertEquals(\n", "        HashMultiset.create(asList(\"a\", \"a\", \"b\", \"b\", \"b\")), multiset);\n", "  }\n", "\n", "  public void testBuilderAddHandlesNullsCorrectly() {\n", "    ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();\n", "    try {\n", "      builder.add((String) null);\n", "      fail(\"expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testBuilderAddAllHandlesNullsCorrectly() {\n", "    ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();\n", "    try {\n", "      builder.addAll((Collection<String>) null);\n", "      fail(\"expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "\n", "    builder = ImmutableMultiset.builder();\n", "    List<String> listWithNulls = asList(\"a\", null, \"b\");\n", "    try {\n", "      builder.addAll(listWithNulls);\n", "      fail(\"expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "\n", "    builder = ImmutableMultiset.builder();\n", "    Multiset<String> multisetWithNull\n", "        = LinkedHashMultiset.create(asList(\"a\", null, \"b\"));\n", "    try {\n", "      builder.addAll(multisetWithNull);\n", "      fail(\"expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testBuilderAddCopiesHandlesNullsCorrectly() {\n", "    ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();\n", "    try {\n", "      builder.addCopies(null, 2);\n", "      fail(\"expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testBuilderAddCopiesIllegal() {\n", "    ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();\n", "    try {\n", "      builder.addCopies(\"a\", -2);\n", "      fail(\"expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testBuilderSetCountHandlesNullsCorrectly() {\n", "    ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();\n", "    try {\n", "      builder.setCount(null, 2);\n", "      fail(\"expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testBuilderSetCountIllegal() {\n", "    ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();\n", "    try {\n", "      builder.setCount(\"a\", -2);\n", "      fail(\"expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testEquals_immutableMultiset() {\n", "    Collection<String> c = ImmutableMultiset.of(\"a\", \"b\", \"a\");\n", "    assertEquals(c, ImmutableMultiset.of(\"a\", \"b\", \"a\"));\n", "    assertEquals(c, ImmutableMultiset.of(\"a\", \"a\", \"b\"));\n", "    assertThat(c).isNotEqualTo(ImmutableMultiset.of(\"a\", \"b\"));\n", "    assertThat(c).isNotEqualTo(ImmutableMultiset.of(\"a\", \"b\", \"c\", \"d\"));\n", "  }\n", "\n", "  public void testIterationOrder() {\n", "    Collection<String> c = ImmutableMultiset.of(\"a\", \"b\", \"a\");\n", "    assertThat(c).containsExactly(\"a\", \"a\", \"b\").inOrder();\n", "  }\n", "\n", "  public void testMultisetWrites() {\n", "    Multiset<String> multiset = ImmutableMultiset.of(\"a\", \"b\", \"a\");\n", "    UnmodifiableCollectionTests.assertMultisetIsUnmodifiable(multiset, \"test\");\n", "  }\n", "\n", "  public void testAsList() {\n", "    ImmutableMultiset<String> multiset\n", "        = ImmutableMultiset.of(\"a\", \"a\", \"b\", \"b\", \"b\");\n", "    ImmutableList<String> list = multiset.asList();\n", "    assertEquals(ImmutableList.of(\"a\", \"a\", \"b\", \"b\", \"b\"), list);\n", "    assertEquals(2, list.indexOf(\"b\"));\n", "    assertEquals(4, list.lastIndexOf(\"b\"));\n", "  }\n", "\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(ImmutableMultiset.of(), ImmutableMultiset.of())\n", "        .addEqualityGroup(ImmutableMultiset.of(1), ImmutableMultiset.of(1))\n", "        .addEqualityGroup(ImmutableMultiset.of(1, 1), ImmutableMultiset.of(1, 1))\n", "        .addEqualityGroup(ImmutableMultiset.of(1, 2, 1), ImmutableMultiset.of(2, 1, 1))\n", "        .testEquals();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383]}}, {"111": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableSetMultimapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableSetMultimap.Builder;\n", "import com.google.common.collect.testing.google.TestStringSetMultimapGenerator;\n", "import com.google.common.collect.testing.google.UnmodifiableCollectionTests;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * Tests for {@link ImmutableSetMultimap}.\n", " *\n", " * @author Mike Ward\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableSetMultimapTest extends TestCase {\n", "  private static final class ImmutableSetMultimapGenerator extends\n", "      TestStringSetMultimapGenerator {\n", "    @Override\n", "    protected SetMultimap<String, String> create(Entry<String, String>[] entries) {\n", "      ImmutableSetMultimap.Builder<String, String> builder = ImmutableSetMultimap.builder();\n", "      for (Entry<String, String> entry : entries) {\n", "        builder.put(entry.getKey(), entry.getValue());\n", "      }\n", "      return builder.build();\n", "    }\n", "  }\n", "  \n", "  private static final class ImmutableSetMultimapCopyOfEntriesGenerator extends\n", "      TestStringSetMultimapGenerator {\n", "    @Override\n", "    protected SetMultimap<String, String> create(Entry<String, String>[] entries) {\n", "      return ImmutableSetMultimap.copyOf(Arrays.asList(entries));\n", "    }\n", "  }\n", "\n", "  public void testBuilder_withImmutableEntry() {\n", "    ImmutableSetMultimap<String, Integer> multimap = new Builder<String, Integer>()\n", "        .put(Maps.immutableEntry(\"one\", 1))\n", "        .build();\n", "    assertEquals(ImmutableSet.of(1), multimap.get(\"one\"));\n", "  }\n", "\n", "  public void testBuilder_withImmutableEntryAndNullContents() {\n", "    Builder<String, Integer> builder = new Builder<String, Integer>();\n", "    try {\n", "      builder.put(Maps.immutableEntry(\"one\", (Integer) null));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    try {\n", "      builder.put(Maps.immutableEntry((String) null, 1));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  private static class StringHolder {\n", "    String string;\n", "  }\n", "\n", "  public void testBuilder_withMutableEntry() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder =\n", "        new Builder<String, Integer>();\n", "    final StringHolder holder = new StringHolder();\n", "    holder.string = \"one\";\n", "    Entry<String, Integer> entry = new AbstractMapEntry<String, Integer>() {\n", "      @Override public String getKey() {\n", "        return holder.string;\n", "      }\n", "      @Override public Integer getValue() {\n", "        return 1;\n", "      }\n", "    };\n", "\n", "    builder.put(entry);\n", "    holder.string = \"two\";\n", "    assertEquals(ImmutableSet.of(1), builder.build().get(\"one\"));\n", "  }\n", "\n", "  public void testBuilderPutAllIterable() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.putAll(\"foo\", Arrays.asList(1, 2, 3));\n", "    builder.putAll(\"bar\", Arrays.asList(4, 5));\n", "    builder.putAll(\"foo\", Arrays.asList(6, 7));\n", "    Multimap<String, Integer> multimap = builder.build();\n", "    assertEquals(ImmutableSet.of(1, 2, 3, 6, 7), multimap.get(\"foo\"));\n", "    assertEquals(ImmutableSet.of(4, 5), multimap.get(\"bar\"));\n", "    assertEquals(7, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutAllVarargs() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.putAll(\"foo\", 1, 2, 3);\n", "    builder.putAll(\"bar\", 4, 5);\n", "    builder.putAll(\"foo\", 6, 7);\n", "    Multimap<String, Integer> multimap = builder.build();\n", "    assertEquals(ImmutableSet.of(1, 2, 3, 6, 7), multimap.get(\"foo\"));\n", "    assertEquals(ImmutableSet.of(4, 5), multimap.get(\"bar\"));\n", "    assertEquals(7, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutAllMultimap() {\n", "    Multimap<String, Integer> toPut = LinkedListMultimap.create();\n", "    toPut.put(\"foo\", 1);\n", "    toPut.put(\"bar\", 4);\n", "    toPut.put(\"foo\", 2);\n", "    toPut.put(\"foo\", 3);\n", "    Multimap<String, Integer> moreToPut = LinkedListMultimap.create();\n", "    moreToPut.put(\"foo\", 6);\n", "    moreToPut.put(\"bar\", 5);\n", "    moreToPut.put(\"foo\", 7);\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.putAll(toPut);\n", "    builder.putAll(moreToPut);\n", "    Multimap<String, Integer> multimap = builder.build();\n", "    assertEquals(ImmutableSet.of(1, 2, 3, 6, 7), multimap.get(\"foo\"));\n", "    assertEquals(ImmutableSet.of(4, 5), multimap.get(\"bar\"));\n", "    assertEquals(7, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutAllWithDuplicates() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.putAll(\"foo\", 1, 2, 3);\n", "    builder.putAll(\"bar\", 4, 5);\n", "    builder.putAll(\"foo\", 1, 6, 7);\n", "    ImmutableSetMultimap<String, Integer> multimap = builder.build();\n", "    assertEquals(7, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutWithDuplicates() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.putAll(\"foo\", 1, 2, 3);\n", "    builder.putAll(\"bar\", 4, 5);\n", "    builder.put(\"foo\", 1);\n", "    ImmutableSetMultimap<String, Integer> multimap = builder.build();\n", "    assertEquals(5, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutAllMultimapWithDuplicates() {\n", "    Multimap<String, Integer> toPut = LinkedListMultimap.create();\n", "    toPut.put(\"foo\", 1);\n", "    toPut.put(\"bar\", 4);\n", "    toPut.put(\"foo\", 2);\n", "    toPut.put(\"foo\", 1);\n", "    toPut.put(\"bar\", 5);\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.putAll(toPut);\n", "    ImmutableSetMultimap<String, Integer> multimap = builder.build();\n", "    assertEquals(4, multimap.size());\n", "  }\n", "\n", "  public void testBuilderPutNullKey() {\n", "    Multimap<String, Integer> toPut = LinkedListMultimap.create();\n", "    toPut.put(\"foo\", null);\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    try {\n", "      builder.put(null, 1);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(null, Arrays.asList(1, 2, 3));\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(null, 1, 2, 3);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(toPut);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testBuilderPutNullValue() {\n", "    Multimap<String, Integer> toPut = LinkedListMultimap.create();\n", "    toPut.put(null, 1);\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    try {\n", "      builder.put(\"foo\", null);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(\"foo\", Arrays.asList(1, null, 3));\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(\"foo\", 4, null, 6);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      builder.putAll(toPut);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testBuilderOrderKeysBy() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.put(\"b\", 3);\n", "    builder.put(\"d\", 2);\n", "    builder.put(\"a\", 5);\n", "    builder.orderKeysBy(Collections.reverseOrder());\n", "    builder.put(\"c\", 4);\n", "    builder.put(\"a\", 2);\n", "    builder.put(\"b\", 6);\n", "    ImmutableSetMultimap<String, Integer> multimap = builder.build();\n", "    assertThat(multimap.keySet()).containsExactly(\"d\", \"c\", \"b\", \"a\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(2, 4, 3, 6, 5, 2).inOrder();\n", "    assertThat(multimap.get(\"a\")).containsExactly(5, 2).inOrder();\n", "    assertThat(multimap.get(\"b\")).containsExactly(3, 6).inOrder();\n", "    assertThat(multimap.get(\"a\")).isNotInstanceOf(ImmutableSortedSet.class);\n", "    assertThat(multimap.get(\"x\")).isNotInstanceOf(ImmutableSortedSet.class);\n", "    assertThat(multimap.asMap().get(\"a\")).isNotInstanceOf(ImmutableSortedSet.class);\n", "  }\n", "\n", "  public void testBuilderOrderKeysByDuplicates() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.put(\"bb\", 3);\n", "    builder.put(\"d\", 2);\n", "    builder.put(\"a\", 5);\n", "    builder.orderKeysBy(new Ordering<String>() {\n", "      @Override\n", "      public int compare(String left, String right) {\n", "        return left.length() - right.length();\n", "      }\n", "    });\n", "    builder.put(\"cc\", 4);\n", "    builder.put(\"a\", 2);\n", "    builder.put(\"bb\", 6);\n", "    ImmutableSetMultimap<String, Integer> multimap = builder.build();\n", "    assertThat(multimap.keySet()).containsExactly(\"d\", \"a\", \"bb\", \"cc\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(2, 5, 2, 3, 6, 4).inOrder();\n", "    assertThat(multimap.get(\"a\")).containsExactly(5, 2).inOrder();\n", "    assertThat(multimap.get(\"bb\")).containsExactly(3, 6).inOrder();\n", "    assertThat(multimap.get(\"a\")).isNotInstanceOf(ImmutableSortedSet.class);\n", "    assertThat(multimap.get(\"x\")).isNotInstanceOf(ImmutableSortedSet.class);\n", "    assertThat(multimap.asMap().get(\"a\")).isNotInstanceOf(ImmutableSortedSet.class);\n", "  }\n", "\n", "  public void testBuilderOrderValuesBy() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.put(\"b\", 3);\n", "    builder.put(\"d\", 2);\n", "    builder.put(\"a\", 5);\n", "    builder.orderValuesBy(Collections.reverseOrder());\n", "    builder.put(\"c\", 4);\n", "    builder.put(\"a\", 2);\n", "    builder.put(\"b\", 6);\n", "    ImmutableSetMultimap<String, Integer> multimap = builder.build();\n", "    assertThat(multimap.keySet()).containsExactly(\"b\", \"d\", \"a\", \"c\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(6, 3, 2, 5, 2, 4).inOrder();\n", "    assertThat(multimap.get(\"a\")).containsExactly(5, 2).inOrder();\n", "    assertThat(multimap.get(\"b\")).containsExactly(6, 3).inOrder();\n", "    assertTrue(multimap.get(\"a\") instanceof ImmutableSortedSet);\n", "    assertEquals(Collections.reverseOrder(),\n", "        ((ImmutableSortedSet<Integer>) multimap.get(\"a\")).comparator());\n", "    assertTrue(multimap.get(\"x\") instanceof ImmutableSortedSet);\n", "    assertEquals(Collections.reverseOrder(),\n", "        ((ImmutableSortedSet<Integer>) multimap.get(\"x\")).comparator());\n", "    assertTrue(multimap.asMap().get(\"a\") instanceof ImmutableSortedSet);\n", "    assertEquals(Collections.reverseOrder(),\n", "        ((ImmutableSortedSet<Integer>) multimap.asMap().get(\"a\")).comparator());\n", "  }\n", "\n", "  public void testBuilderOrderKeysAndValuesBy() {\n", "    ImmutableSetMultimap.Builder<String, Integer> builder\n", "        = ImmutableSetMultimap.builder();\n", "    builder.put(\"b\", 3);\n", "    builder.put(\"d\", 2);\n", "    builder.put(\"a\", 5);\n", "    builder.orderKeysBy(Collections.reverseOrder());\n", "    builder.orderValuesBy(Collections.reverseOrder());\n", "    builder.put(\"c\", 4);\n", "    builder.put(\"a\", 2);\n", "    builder.put(\"b\", 6);\n", "    ImmutableSetMultimap<String, Integer> multimap = builder.build();\n", "    assertThat(multimap.keySet()).containsExactly(\"d\", \"c\", \"b\", \"a\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(2, 4, 6, 3, 5, 2).inOrder();\n", "    assertThat(multimap.get(\"a\")).containsExactly(5, 2).inOrder();\n", "    assertThat(multimap.get(\"b\")).containsExactly(6, 3).inOrder();\n", "    assertTrue(multimap.get(\"a\") instanceof ImmutableSortedSet);\n", "    assertEquals(Collections.reverseOrder(),\n", "        ((ImmutableSortedSet<Integer>) multimap.get(\"a\")).comparator());\n", "    assertTrue(multimap.get(\"x\") instanceof ImmutableSortedSet);\n", "    assertEquals(Collections.reverseOrder(),\n", "        ((ImmutableSortedSet<Integer>) multimap.get(\"x\")).comparator());\n", "    assertTrue(multimap.asMap().get(\"a\") instanceof ImmutableSortedSet);\n", "    assertEquals(Collections.reverseOrder(),\n", "        ((ImmutableSortedSet<Integer>) multimap.asMap().get(\"a\")).comparator());\n", "  }\n", "\n", "  public void testCopyOf() {\n", "    HashMultimap<String, Integer> input = HashMultimap.create();\n", "    input.put(\"foo\", 1);\n", "    input.put(\"bar\", 2);\n", "    input.put(\"foo\", 3);\n", "    Multimap<String, Integer> multimap = ImmutableSetMultimap.copyOf(input);\n", "    assertEquals(multimap, input);\n", "    assertEquals(input, multimap);\n", "  }\n", "\n", "  public void testCopyOfWithDuplicates() {\n", "    ArrayListMultimap<Object, Object> input = ArrayListMultimap.create();\n", "    input.put(\"foo\", 1);\n", "    input.put(\"bar\", 2);\n", "    input.put(\"foo\", 3);\n", "    input.put(\"foo\", 1);\n", "    ImmutableSetMultimap<Object, Object> copy\n", "        = ImmutableSetMultimap.copyOf(input);\n", "    assertEquals(3, copy.size());\n", "  }\n", "\n", "  public void testCopyOfEmpty() {\n", "    HashMultimap<String, Integer> input = HashMultimap.create();\n", "    Multimap<String, Integer> multimap = ImmutableSetMultimap.copyOf(input);\n", "    assertEquals(multimap, input);\n", "    assertEquals(input, multimap);\n", "  }\n", "\n", "  public void testCopyOfImmutableSetMultimap() {\n", "    Multimap<String, Integer> multimap = createMultimap();\n", "    assertSame(multimap, ImmutableSetMultimap.copyOf(multimap));\n", "  }\n", "\n", "  public void testCopyOfNullKey() {\n", "    HashMultimap<String, Integer> input = HashMultimap.create();\n", "    input.put(null, 1);\n", "    try {\n", "      ImmutableSetMultimap.copyOf(input);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testCopyOfNullValue() {\n", "    HashMultimap<String, Integer> input = HashMultimap.create();\n", "    input.putAll(\"foo\", Arrays.asList(1, null, 3));\n", "    try {\n", "      ImmutableSetMultimap.copyOf(input);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testEmptyMultimapReads() {\n", "    Multimap<String, Integer> multimap = ImmutableSetMultimap.of();\n", "    assertFalse(multimap.containsKey(\"foo\"));\n", "    assertFalse(multimap.containsValue(1));\n", "    assertFalse(multimap.containsEntry(\"foo\", 1));\n", "    assertTrue(multimap.entries().isEmpty());\n", "    assertTrue(multimap.equals(HashMultimap.create()));\n", "    assertEquals(Collections.emptySet(), multimap.get(\"foo\"));\n", "    assertEquals(0, multimap.hashCode());\n", "    assertTrue(multimap.isEmpty());\n", "    assertEquals(HashMultiset.create(), multimap.keys());\n", "    assertEquals(Collections.emptySet(), multimap.keySet());\n", "    assertEquals(0, multimap.size());\n", "    assertTrue(multimap.values().isEmpty());\n", "    assertEquals(\"{}\", multimap.toString());\n", "  }\n", "\n", "  public void testEmptyMultimapWrites() {\n", "    Multimap<String, Integer> multimap = ImmutableSetMultimap.of();\n", "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(\n", "        multimap, \"foo\", 1);\n", "  }\n", "\n", "  public void testMultimapReads() {\n", "    Multimap<String, Integer> multimap = createMultimap();\n", "    assertTrue(multimap.containsKey(\"foo\"));\n", "    assertFalse(multimap.containsKey(\"cat\"));\n", "    assertTrue(multimap.containsValue(1));\n", "    assertFalse(multimap.containsValue(5));\n", "    assertTrue(multimap.containsEntry(\"foo\", 1));\n", "    assertFalse(multimap.containsEntry(\"cat\", 1));\n", "    assertFalse(multimap.containsEntry(\"foo\", 5));\n", "    assertFalse(multimap.entries().isEmpty());\n", "    assertEquals(3, multimap.size());\n", "    assertFalse(multimap.isEmpty());\n", "    assertEquals(\"{foo=[1, 3], bar=[2]}\", multimap.toString());\n", "  }\n", "\n", "  public void testMultimapWrites() {\n", "    Multimap<String, Integer> multimap = createMultimap();\n", "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(\n", "        multimap, \"bar\", 2);\n", "  }\n", "\n", "  public void testMultimapEquals() {\n", "    Multimap<String, Integer> multimap = createMultimap();\n", "    Multimap<String, Integer> hashMultimap = HashMultimap.create();\n", "    hashMultimap.putAll(\"foo\", Arrays.asList(1, 3));\n", "    hashMultimap.put(\"bar\", 2);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            multimap,\n", "            createMultimap(),\n", "            hashMultimap,\n", "            ImmutableSetMultimap.<String, Integer>builder()\n", "                .put(\"bar\", 2).put(\"foo\", 1).put(\"foo\", 3).build(),\n", "            ImmutableSetMultimap.<String, Integer>builder()\n", "                .put(\"bar\", 2).put(\"foo\", 3).put(\"foo\", 1).build())\n", "        .addEqualityGroup(ImmutableSetMultimap.<String, Integer>builder()\n", "            .put(\"foo\", 2).put(\"foo\", 3).put(\"foo\", 1).build())\n", "        .addEqualityGroup(ImmutableSetMultimap.<String, Integer>builder()\n", "            .put(\"bar\", 2).put(\"foo\", 3).build())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testOf() {\n", "    assertMultimapEquals(\n", "        ImmutableSetMultimap.of(\"one\", 1),\n", "        \"one\", 1);\n", "    assertMultimapEquals(\n", "        ImmutableSetMultimap.of(\"one\", 1, \"two\", 2),\n", "        \"one\", 1, \"two\", 2);\n", "    assertMultimapEquals(\n", "        ImmutableSetMultimap.of(\"one\", 1, \"two\", 2, \"three\", 3),\n", "        \"one\", 1, \"two\", 2, \"three\", 3);\n", "    assertMultimapEquals(\n", "        ImmutableSetMultimap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4),\n", "        \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4);\n", "    assertMultimapEquals(\n", "        ImmutableSetMultimap.of(\n", "            \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5),\n", "        \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5);\n", "  }\n", "\n", "  public void testInverse() {\n", "    assertEquals(\n", "        ImmutableSetMultimap.<Integer, String>of(),\n", "        ImmutableSetMultimap.<String, Integer>of().inverse());\n", "    assertEquals(\n", "        ImmutableSetMultimap.of(1, \"one\"),\n", "        ImmutableSetMultimap.of(\"one\", 1).inverse());\n", "    assertEquals(\n", "        ImmutableSetMultimap.of(1, \"one\", 2, \"two\"),\n", "        ImmutableSetMultimap.of(\"one\", 1, \"two\", 2).inverse());\n", "    assertEquals(\n", "        ImmutableSetMultimap.of('o', \"of\", 'f', \"of\", 't', \"to\", 'o', \"to\"),\n", "        ImmutableSetMultimap.of(\"of\", 'o', \"of\", 'f', \"to\", 't', \"to\", 'o').inverse());\n", "  }\n", "\n", "  public void testInverseMinimizesWork() {\n", "    ImmutableSetMultimap<String, Character> multimap =\n", "        ImmutableSetMultimap.of(\"of\", 'o', \"of\", 'f', \"to\", 't', \"to\", 'o');\n", "    assertSame(multimap.inverse(), multimap.inverse());\n", "    assertSame(multimap, multimap.inverse().inverse());\n", "  }\n", "\n", "  private static <K, V> void assertMultimapEquals(Multimap<K, V> multimap,\n", "      Object... alternatingKeysAndValues) {\n", "    assertEquals(multimap.size(), alternatingKeysAndValues.length / 2);\n", "    int i = 0;\n", "    for (Entry<K, V> entry : multimap.entries()) {\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getKey());\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getValue());\n", "    }\n", "  }\n", "\n", "  private ImmutableSetMultimap<String, Integer> createMultimap() {\n", "    return ImmutableSetMultimap.<String, Integer>builder()\n", "        .put(\"foo\", 1).put(\"bar\", 2).put(\"foo\", 3).build();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499]}}, {"112": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableSetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableSet.Builder;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.Set;\n", "\n", "/**\n", " * Unit test for {@link ImmutableSet}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " * @author Nick Kralevich\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableSetTest extends AbstractImmutableSetTest {\n", "\n", "  @Override protected Set<String> of() {\n", "    return ImmutableSet.of();\n", "  }\n", "\n", "  @Override protected Set<String> of(String e) {\n", "    return ImmutableSet.of(e);\n", "  }\n", "\n", "  @Override protected Set<String> of(String e1, String e2) {\n", "    return ImmutableSet.of(e1, e2);\n", "  }\n", "\n", "  @Override protected Set<String> of(String e1, String e2, String e3) {\n", "    return ImmutableSet.of(e1, e2, e3);\n", "  }\n", "\n", "  @Override protected Set<String> of(\n", "      String e1, String e2, String e3, String e4) {\n", "    return ImmutableSet.of(e1, e2, e3, e4);\n", "  }\n", "\n", "  @Override protected Set<String> of(\n", "      String e1, String e2, String e3, String e4, String e5) {\n", "    return ImmutableSet.of(e1, e2, e3, e4, e5);\n", "  }\n", "\n", "  @Override protected Set<String> of(String e1, String e2, String e3,\n", "      String e4, String e5, String e6, String... rest) {\n", "    return ImmutableSet.of(e1, e2, e3, e4, e5, e6, rest);\n", "  }\n", "\n", "  @Override protected Set<String> copyOf(String[] elements) {\n", "    return ImmutableSet.copyOf(elements);\n", "  }\n", "\n", "  @Override protected Set<String> copyOf(Collection<String> elements) {\n", "    return ImmutableSet.copyOf(elements);\n", "  }\n", "\n", "  @Override protected Set<String> copyOf(Iterable<String> elements) {\n", "    return ImmutableSet.copyOf(elements);\n", "  }\n", "\n", "  @Override protected Set<String> copyOf(Iterator<String> elements) {\n", "    return ImmutableSet.copyOf(elements);\n", "  }\n", "\n", "  public void testCreation_allDuplicates() {\n", "    ImmutableSet<String> set = ImmutableSet.copyOf(Lists.newArrayList(\"a\", \"a\"));\n", "    assertTrue(set instanceof SingletonImmutableSet);\n", "    assertEquals(Lists.newArrayList(\"a\"), Lists.newArrayList(set));\n", "  }\n", "\n", "  public void testCreation_oneDuplicate() {\n", "    // now we'll get the varargs overload\n", "    ImmutableSet<String> set = ImmutableSet.of(\n", "        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"a\");\n", "    assertEquals(Lists.newArrayList(\n", "        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"),\n", "        Lists.newArrayList(set));\n", "  }\n", "\n", "  public void testCreation_manyDuplicates() {\n", "    // now we'll get the varargs overload\n", "    ImmutableSet<String> set = ImmutableSet.of(\n", "        \"a\", \"b\", \"c\", \"c\", \"c\", \"c\", \"b\", \"b\", \"a\", \"a\", \"c\", \"c\", \"c\", \"a\");\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testCreation_arrayOfArray() {\n", "    String[] array = new String[] { \"a\" };\n", "    Set<String[]> set = ImmutableSet.<String[]>of(array);\n", "    assertEquals(Collections.singleton(array), set);\n", "  }\n", "\n", "  public void testCopyOf_copiesImmutableSortedSet() {\n", "    ImmutableSortedSet<String> sortedSet = ImmutableSortedSet.of(\"a\");\n", "    ImmutableSet<String> copy = ImmutableSet.copyOf(sortedSet);\n", "    assertNotSame(sortedSet, copy);\n", "  }\n", "\n", "  @Override <E extends Comparable<E>> Builder<E> builder() {\n", "    return ImmutableSet.builder();\n", "  }\n", "\n", "  @Override int getComplexBuilderSetLastElement() {\n", "    return LAST_COLOR_ADDED;\n", "  }\n", "\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(ImmutableSet.of(), ImmutableSet.of())\n", "        .addEqualityGroup(ImmutableSet.of(1), ImmutableSet.of(1), ImmutableSet.of(1, 1))\n", "        .addEqualityGroup(ImmutableSet.of(1, 2, 1), ImmutableSet.of(2, 1, 1))\n", "        .testEquals();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137]}}, {"113": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Joiner;\n", "import com.google.common.collect.ImmutableSortedMap.Builder;\n", "import com.google.common.collect.testing.SortedMapInterfaceTest;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.LinkedHashMap;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.SortedMap;\n", "\n", "/**\n", " * Tests for {@link ImmutableSortedMap}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jesse Wilson\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableSortedMapTest extends TestCase {\n", "  // TODO: Avoid duplicating code in ImmutableMapTest\n", "\n", "  public abstract static class AbstractMapTests<K, V>\n", "      extends SortedMapInterfaceTest<K, V> {\n", "    public AbstractMapTests() {\n", "      super(false, false, false, false, false);\n", "    }\n", "\n", "    @Override protected SortedMap<K, V> makeEmptyMap() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    private static final Joiner joiner = Joiner.on(\", \");\n", "\n", "    @Override protected void assertMoreInvariants(Map<K, V> map) {\n", "      // TODO: can these be moved to MapInterfaceTest?\n", "      for (Entry<K, V> entry : map.entrySet()) {\n", "        assertEquals(entry.getKey() + \"=\" + entry.getValue(),\n", "            entry.toString());\n", "      }\n", "\n", "      assertEquals(\"{\" + joiner.join(map.entrySet()) + \"}\",\n", "          map.toString());\n", "      assertEquals(\"[\" + joiner.join(map.entrySet()) + \"]\",\n", "          map.entrySet().toString());\n", "      assertEquals(\"[\" + joiner.join(map.keySet()) + \"]\",\n", "          map.keySet().toString());\n", "      assertEquals(\"[\" + joiner.join(map.values()) + \"]\",\n", "          map.values().toString());\n", "\n", "      assertEquals(Sets.newHashSet(map.entrySet()), map.entrySet());\n", "      assertEquals(Sets.newHashSet(map.keySet()), map.keySet());\n", "    }\n", "  }\n", "\n", "  public static class MapTests extends AbstractMapTests<String, Integer> {\n", "    @Override protected SortedMap<String, Integer> makeEmptyMap() {\n", "      return ImmutableSortedMap.of();\n", "    }\n", "\n", "    @Override protected SortedMap<String, Integer> makePopulatedMap() {\n", "      return ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"minus one\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return -1;\n", "    }\n", "  }\n", "\n", "  public static class SingletonMapTests\n", "      extends AbstractMapTests<String, Integer> {\n", "    @Override protected SortedMap<String, Integer> makePopulatedMap() {\n", "      return ImmutableSortedMap.of(\"one\", 1);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"minus one\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return -1;\n", "    }\n", "  }\n", "\n", "  public static class HeadMapTests extends AbstractMapTests<String, Integer> {\n", "    @Override protected SortedMap<String, Integer> makePopulatedMap() {\n", "      return ImmutableSortedMap.of(\"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4, \"e\", 5)\n", "          .headMap(\"d\");\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"d\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return 4;\n", "    }\n", "  }\n", "\n", "  public static class HeadMapInclusiveTests extends AbstractMapTests<String, Integer> {\n", "    @Override protected SortedMap<String, Integer> makePopulatedMap() {\n", "      return ImmutableSortedMap.of(\"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4, \"e\", 5)\n", "          .headMap(\"c\", true);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"d\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return 4;\n", "    }\n", "  }\n", "\n", "  public static class TailMapTests extends AbstractMapTests<String, Integer> {\n", "    @Override protected SortedMap<String, Integer> makePopulatedMap() {\n", "      return ImmutableSortedMap.of(\"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4, \"e\", 5)\n", "          .tailMap(\"b\");\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"a\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return 1;\n", "    }\n", "  }\n", "\n", "  public static class TailExclusiveMapTests extends AbstractMapTests<String, Integer> {\n", "    @Override protected SortedMap<String, Integer> makePopulatedMap() {\n", "      return ImmutableSortedMap.of(\"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4, \"e\", 5)\n", "          .tailMap(\"a\", false);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"a\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return 1;\n", "    }\n", "  }\n", "\n", "  public static class SubMapTests extends AbstractMapTests<String, Integer> {\n", "    @Override protected SortedMap<String, Integer> makePopulatedMap() {\n", "      return ImmutableSortedMap.of(\"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4, \"e\", 5)\n", "          .subMap(\"b\", \"d\");\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"a\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return 4;\n", "    }\n", "  }\n", "\n", "  public static class CreationTests extends TestCase {\n", "    public void testEmptyBuilder() {\n", "      ImmutableSortedMap<String, Integer> map\n", "          = ImmutableSortedMap.<String, Integer>naturalOrder().build();\n", "      assertEquals(Collections.<String, Integer>emptyMap(), map);\n", "    }\n", "\n", "    public void testSingletonBuilder() {\n", "      ImmutableSortedMap<String, Integer> map\n", "          = ImmutableSortedMap.<String, Integer>naturalOrder()\n", "              .put(\"one\", 1)\n", "              .build();\n", "      assertMapEquals(map, \"one\", 1);\n", "    }\n", "\n", "    public void testBuilder() {\n", "      ImmutableSortedMap<String, Integer> map\n", "          = ImmutableSortedMap.<String, Integer>naturalOrder()\n", "              .put(\"one\", 1)\n", "              .put(\"two\", 2)\n", "              .put(\"three\", 3)\n", "              .put(\"four\", 4)\n", "              .put(\"five\", 5)\n", "              .build();\n", "      assertMapEquals(map,\n", "          \"five\", 5, \"four\", 4, \"one\", 1, \"three\", 3, \"two\", 2);\n", "    }\n", "    \n", "    public void testBuilder_orderEntriesByValueFails() {\n", "      ImmutableSortedMap.Builder<String, Integer> builder = ImmutableSortedMap.naturalOrder();\n", "      try {\n", "        builder.orderEntriesByValue(Ordering.natural());\n", "        fail(\"Expected UnsupportedOperationException\");\n", "      } catch (UnsupportedOperationException expected) {}\n", "    }\n", "\n", "    public void testBuilder_withImmutableEntry() {\n", "      ImmutableSortedMap<String, Integer> map =\n", "          ImmutableSortedMap.<String, Integer>naturalOrder()\n", "              .put(Maps.immutableEntry(\"one\", 1))\n", "              .build();\n", "      assertMapEquals(map, \"one\", 1);\n", "    }\n", "\n", "    public void testBuilder_withImmutableEntryAndNullContents() {\n", "      Builder<String, Integer> builder =\n", "          ImmutableSortedMap.naturalOrder();\n", "      try {\n", "        builder.put(Maps.immutableEntry(\"one\", (Integer) null));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "      try {\n", "        builder.put(Maps.immutableEntry((String) null, 1));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    private static class StringHolder {\n", "      String string;\n", "    }\n", "\n", "    public void testBuilder_withMutableEntry() {\n", "      ImmutableSortedMap.Builder<String, Integer> builder =\n", "          ImmutableSortedMap.naturalOrder();\n", "      final StringHolder holder = new StringHolder();\n", "      holder.string = \"one\";\n", "      Entry<String, Integer> entry = new AbstractMapEntry<String, Integer>() {\n", "        @Override public String getKey() {\n", "          return holder.string;\n", "        }\n", "        @Override public Integer getValue() {\n", "          return 1;\n", "        }\n", "      };\n", "\n", "      builder.put(entry);\n", "      holder.string = \"two\";\n", "      assertMapEquals(builder.build(), \"one\", 1);\n", "    }\n", "\n", "    public void testBuilderPutAllWithEmptyMap() {\n", "      ImmutableSortedMap<String, Integer> map\n", "          = ImmutableSortedMap.<String, Integer>naturalOrder()\n", "              .putAll(Collections.<String, Integer>emptyMap())\n", "              .build();\n", "      assertEquals(Collections.<String, Integer>emptyMap(), map);\n", "    }\n", "\n", "    public void testBuilderPutAll() {\n", "      Map<String, Integer> toPut = new LinkedHashMap<String, Integer>();\n", "      toPut.put(\"one\", 1);\n", "      toPut.put(\"two\", 2);\n", "      toPut.put(\"three\", 3);\n", "      Map<String, Integer> moreToPut = new LinkedHashMap<String, Integer>();\n", "      moreToPut.put(\"four\", 4);\n", "      moreToPut.put(\"five\", 5);\n", "\n", "      ImmutableSortedMap<String, Integer> map\n", "          = ImmutableSortedMap.<String, Integer>naturalOrder()\n", "              .putAll(toPut)\n", "              .putAll(moreToPut)\n", "              .build();\n", "      assertMapEquals(map,\n", "          \"five\", 5, \"four\", 4, \"one\", 1, \"three\", 3, \"two\", 2);\n", "    }\n", "\n", "    public void testBuilderReuse() {\n", "      Builder<String, Integer> builder = ImmutableSortedMap.naturalOrder();\n", "      ImmutableSortedMap<String, Integer> mapOne = builder\n", "          .put(\"one\", 1)\n", "          .put(\"two\", 2)\n", "          .build();\n", "      ImmutableSortedMap<String, Integer> mapTwo = builder\n", "          .put(\"three\", 3)\n", "          .put(\"four\", 4)\n", "          .build();\n", "\n", "      assertMapEquals(mapOne, \"one\", 1, \"two\", 2);\n", "      assertMapEquals(mapTwo, \"four\", 4, \"one\", 1, \"three\", 3, \"two\", 2);\n", "    }\n", "\n", "    public void testBuilderPutNullKey() {\n", "      Builder<String, Integer> builder = ImmutableSortedMap.naturalOrder();\n", "      try {\n", "        builder.put(null, 1);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullValue() {\n", "      Builder<String, Integer> builder = ImmutableSortedMap.naturalOrder();\n", "      try {\n", "        builder.put(\"one\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullKeyViaPutAll() {\n", "      Builder<String, Integer> builder = ImmutableSortedMap.naturalOrder();\n", "      try {\n", "        builder.putAll(Collections.<String, Integer>singletonMap(null, 1));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testBuilderPutNullValueViaPutAll() {\n", "      Builder<String, Integer> builder = ImmutableSortedMap.naturalOrder();\n", "      try {\n", "        builder.putAll(Collections.<String, Integer>singletonMap(\"one\", null));\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testPuttingTheSameKeyTwiceThrowsOnBuild() {\n", "      Builder<String, Integer> builder\n", "          = ImmutableSortedMap.<String, Integer>naturalOrder()\n", "              .put(\"one\", 1)\n", "              .put(\"one\", 2); // throwing on this line would be even better\n", "\n", "      try {\n", "        builder.build();\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "\n", "    public void testOf() {\n", "      assertMapEquals(\n", "          ImmutableSortedMap.of(\"one\", 1),\n", "          \"one\", 1);\n", "      assertMapEquals(\n", "          ImmutableSortedMap.of(\"one\", 1, \"two\", 2),\n", "          \"one\", 1, \"two\", 2);\n", "      assertMapEquals(\n", "          ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3),\n", "          \"one\", 1, \"three\", 3, \"two\", 2);\n", "      assertMapEquals(\n", "          ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4),\n", "          \"four\", 4, \"one\", 1, \"three\", 3, \"two\", 2);\n", "      assertMapEquals(\n", "          ImmutableSortedMap.of(\n", "              \"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4, \"five\", 5),\n", "          \"five\", 5, \"four\", 4, \"one\", 1, \"three\", 3, \"two\", 2);\n", "    }\n", "\n", "    public void testOfNullKey() {\n", "      Integer n = null;\n", "      try {\n", "        ImmutableSortedMap.of(n, 1);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        ImmutableSortedMap.of(\"one\", 1, null, 2);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testOfNullValue() {\n", "      try {\n", "        ImmutableSortedMap.of(\"one\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "\n", "      try {\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", null);\n", "        fail();\n", "      } catch (NullPointerException expected) {\n", "      }\n", "    }\n", "\n", "    public void testOfWithDuplicateKey() {\n", "      try {\n", "        ImmutableSortedMap.of(\"one\", 1, \"one\", 1);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "\n", "    public void testCopyOfEmptyMap() {\n", "      ImmutableSortedMap<String, Integer> copy\n", "          = ImmutableSortedMap.copyOf(Collections.<String, Integer>emptyMap());\n", "      assertEquals(Collections.<String, Integer>emptyMap(), copy);\n", "      assertSame(copy, ImmutableSortedMap.copyOf(copy));\n", "      assertSame(Ordering.natural(), copy.comparator());\n", "    }\n", "\n", "    public void testCopyOfSingletonMap() {\n", "      ImmutableSortedMap<String, Integer> copy\n", "          = ImmutableSortedMap.copyOf(Collections.singletonMap(\"one\", 1));\n", "      assertMapEquals(copy, \"one\", 1);\n", "      assertSame(copy, ImmutableSortedMap.copyOf(copy));\n", "      assertSame(Ordering.natural(), copy.comparator());\n", "    }\n", "\n", "    public void testCopyOf() {\n", "      Map<String, Integer> original = new LinkedHashMap<String, Integer>();\n", "      original.put(\"one\", 1);\n", "      original.put(\"two\", 2);\n", "      original.put(\"three\", 3);\n", "\n", "      ImmutableSortedMap<String, Integer> copy\n", "          = ImmutableSortedMap.copyOf(original);\n", "      assertMapEquals(copy, \"one\", 1, \"three\", 3, \"two\", 2);\n", "      assertSame(copy, ImmutableSortedMap.copyOf(copy));\n", "      assertSame(Ordering.natural(), copy.comparator());\n", "    }\n", "\n", "    public void testCopyOfExplicitComparator() {\n", "      Comparator<String> comparator = Ordering.natural().reverse();\n", "      Map<String, Integer> original = new LinkedHashMap<String, Integer>();\n", "      original.put(\"one\", 1);\n", "      original.put(\"two\", 2);\n", "      original.put(\"three\", 3);\n", "\n", "      ImmutableSortedMap<String, Integer> copy\n", "          = ImmutableSortedMap.copyOf(original, comparator);\n", "      assertMapEquals(copy, \"two\", 2, \"three\", 3, \"one\", 1);\n", "      assertSame(copy, ImmutableSortedMap.copyOf(copy, comparator));\n", "      assertSame(comparator, copy.comparator());\n", "    }\n", "\n", "    public void testCopyOfImmutableSortedSetDifferentComparator() {\n", "      Comparator<String> comparator = Ordering.natural().reverse();\n", "      Map<String, Integer> original\n", "          = ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3);\n", "      ImmutableSortedMap<String, Integer> copy\n", "          = ImmutableSortedMap.copyOf(original, comparator);\n", "      assertMapEquals(copy, \"two\", 2, \"three\", 3, \"one\", 1);\n", "      assertSame(copy, ImmutableSortedMap.copyOf(copy, comparator));\n", "      assertSame(comparator, copy.comparator());\n", "    }\n", "\n", "    public void testCopyOfSortedNatural() {\n", "      SortedMap<String, Integer> original = Maps.newTreeMap();\n", "      original.put(\"one\", 1);\n", "      original.put(\"two\", 2);\n", "      original.put(\"three\", 3);\n", "\n", "      ImmutableSortedMap<String, Integer> copy\n", "          = ImmutableSortedMap.copyOfSorted(original);\n", "      assertMapEquals(copy, \"one\", 1, \"three\", 3, \"two\", 2);\n", "      assertSame(copy, ImmutableSortedMap.copyOfSorted(copy));\n", "      assertSame(Ordering.natural(), copy.comparator());\n", "    }\n", "\n", "    public void testCopyOfSortedExplicit() {\n", "      Comparator<String> comparator = Ordering.natural().reverse();\n", "      SortedMap<String, Integer> original = Maps.newTreeMap(comparator);\n", "      original.put(\"one\", 1);\n", "      original.put(\"two\", 2);\n", "      original.put(\"three\", 3);\n", "\n", "      ImmutableSortedMap<String, Integer> copy\n", "          = ImmutableSortedMap.copyOfSorted(original);\n", "      assertMapEquals(copy, \"two\", 2, \"three\", 3, \"one\", 1);\n", "      assertSame(copy, ImmutableSortedMap.copyOfSorted(copy));\n", "      assertSame(comparator, copy.comparator());\n", "    }\n", "\n", "    private static class IntegerDiv10 implements Comparable<IntegerDiv10> {\n", "      final int value;\n", "\n", "      IntegerDiv10(int value) {\n", "        this.value = value;\n", "      }\n", "\n", "      @Override\n", "      public int compareTo(IntegerDiv10 o) {\n", "        return value / 10 - o.value / 10;\n", "      }\n", "\n", "      @Override public String toString() {\n", "        return Integer.toString(value);\n", "      }\n", "    }\n", "\n", "    public void testCopyOfDuplicateKey() {\n", "      Map<IntegerDiv10, String> original = ImmutableMap.of(\n", "          new IntegerDiv10(3), \"three\",\n", "          new IntegerDiv10(20), \"twenty\",\n", "          new IntegerDiv10(11), \"eleven\",\n", "          new IntegerDiv10(35), \"thirty five\",\n", "          new IntegerDiv10(12), \"twelve\"\n", "      );\n", "\n", "      try {\n", "        ImmutableSortedMap.copyOf(original);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "\n", "    public void testImmutableMapCopyOfImmutableSortedMap() {\n", "      IntegerDiv10 three = new IntegerDiv10(3);\n", "      IntegerDiv10 eleven = new IntegerDiv10(11);\n", "      IntegerDiv10 twelve = new IntegerDiv10(12);\n", "      IntegerDiv10 twenty = new IntegerDiv10(20);\n", "      Map<IntegerDiv10, String> original = ImmutableSortedMap.of(\n", "          three, \"three\", eleven, \"eleven\", twenty, \"twenty\");\n", "      Map<IntegerDiv10, String> copy = ImmutableMap.copyOf(original);\n", "      assertTrue(original.containsKey(twelve));\n", "      assertFalse(copy.containsKey(twelve));\n", "    }\n", "\n", "    public void testBuilderReverseOrder() {\n", "      ImmutableSortedMap<String, Integer> map\n", "          = ImmutableSortedMap.<String, Integer>reverseOrder()\n", "              .put(\"one\", 1)\n", "              .put(\"two\", 2)\n", "              .put(\"three\", 3)\n", "              .put(\"four\", 4)\n", "              .put(\"five\", 5)\n", "              .build();\n", "      assertMapEquals(map,\n", "          \"two\", 2, \"three\", 3, \"one\", 1, \"four\", 4, \"five\", 5);\n", "      assertEquals(Ordering.natural().reverse(), map.comparator());\n", "    }\n", "\n", "    public void testBuilderComparator() {\n", "      Comparator<String> comparator = Ordering.natural().reverse();\n", "      ImmutableSortedMap<String, Integer> map\n", "          = new ImmutableSortedMap.Builder<String, Integer>(comparator)\n", "              .put(\"one\", 1)\n", "              .put(\"two\", 2)\n", "              .put(\"three\", 3)\n", "              .put(\"four\", 4)\n", "              .put(\"five\", 5)\n", "              .build();\n", "      assertMapEquals(map,\n", "          \"two\", 2, \"three\", 3, \"one\", 1, \"four\", 4, \"five\", 5);\n", "      assertSame(comparator, map.comparator());\n", "    }\n", "  }\n", "\n", "  public void testNullGet() {\n", "    ImmutableSortedMap<String, Integer> map = ImmutableSortedMap.of(\"one\", 1);\n", "    assertNull(map.get(null));\n", "  }\n", "\n", "  private static <K, V> void assertMapEquals(Map<K, V> map,\n", "      Object... alternatingKeysAndValues) {\n", "    assertEquals(map.size(), alternatingKeysAndValues.length / 2);\n", "    int i = 0;\n", "    for (Entry<K, V> entry : map.entrySet()) {\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getKey());\n", "      assertEquals(alternatingKeysAndValues[i++], entry.getValue());\n", "    }\n", "  }\n", "\n", "  private static class IntHolder implements Serializable {\n", "    public int value;\n", "\n", "    public IntHolder(int value) {\n", "      this.value = value;\n", "    }\n", "\n", "    @Override public boolean equals(Object o) {\n", "      return (o instanceof IntHolder) && ((IntHolder) o).value == value;\n", "    }\n", "\n", "    @Override public int hashCode() {\n", "      return value;\n", "    }\n", "\n", "    private static final long serialVersionUID = 5;\n", "  }\n", "\n", "  public void testMutableValues() {\n", "    IntHolder holderA = new IntHolder(1);\n", "    IntHolder holderB = new IntHolder(2);\n", "    Map<String, IntHolder> map\n", "        = ImmutableSortedMap.of(\"a\", holderA, \"b\", holderB);\n", "    holderA.value = 3;\n", "    assertTrue(map.entrySet().contains(Maps.immutableEntry(\"a\", new IntHolder(3))));\n", "    Map<String, Integer> intMap\n", "        = ImmutableSortedMap.of(\"a\", 3, \"b\", 2);\n", "    assertEquals(intMap.hashCode(), map.entrySet().hashCode());\n", "    assertEquals(intMap.hashCode(), map.hashCode());\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testHeadMapInclusive() {\n", "    Map<String, Integer> map =\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3).headMap(\"three\", true);\n", "    assertThat(map.entrySet()).containsExactly(\n", "        Maps.immutableEntry(\"one\", 1),\n", "        Maps.immutableEntry(\"three\", 3)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testHeadMapExclusive() {\n", "    Map<String, Integer> map =\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3).headMap(\"three\", false);\n", "    assertThat(map.entrySet()).containsExactly(Maps.immutableEntry(\"one\", 1));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testTailMapInclusive() {\n", "    Map<String, Integer> map =\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3).tailMap(\"three\", true);\n", "    assertThat(map.entrySet()).containsExactly(Maps.immutableEntry(\"three\", 3),\n", "        Maps.immutableEntry(\"two\", 2)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testTailMapExclusive() {\n", "    Map<String, Integer> map =\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3).tailMap(\"three\", false);\n", "    assertThat(map.entrySet()).containsExactly(Maps.immutableEntry(\"two\", 2));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testSubMapExclusiveExclusive() {\n", "    Map<String, Integer> map =\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3).subMap(\"one\", false, \"two\", false);\n", "    assertThat(map.entrySet()).containsExactly(Maps.immutableEntry(\"three\", 3));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testSubMapInclusiveExclusive() {\n", "    Map<String, Integer> map =\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3).subMap(\"one\", true, \"two\", false);\n", "    assertThat(map.entrySet()).containsExactly(Maps.immutableEntry(\"one\", 1),\n", "        Maps.immutableEntry(\"three\", 3)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testSubMapExclusiveInclusive() {\n", "    Map<String, Integer> map =\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3).subMap(\"one\", false, \"two\", true);\n", "    assertThat(map.entrySet()).containsExactly(Maps.immutableEntry(\"three\", 3),\n", "        Maps.immutableEntry(\"two\", 2)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs\n", "  public void testSubMapInclusiveInclusive() {\n", "    Map<String, Integer> map =\n", "        ImmutableSortedMap.of(\"one\", 1, \"two\", 2, \"three\", 3).subMap(\"one\", true, \"two\", true);\n", "    assertThat(map.entrySet()).containsExactly(Maps.immutableEntry(\"one\", 1),\n", "        Maps.immutableEntry(\"three\", 3), Maps.immutableEntry(\"two\", 2)).inOrder();\n", "  }\n", "\n", "  private static class SelfComparableExample implements Comparable<SelfComparableExample> {\n", "    @Override\n", "    public int compareTo(SelfComparableExample o) {\n", "      return 0;\n", "    }\n", "  }\n", "\n", "  public void testBuilderGenerics_SelfComparable() {\n", "    ImmutableSortedMap.Builder<SelfComparableExample, Object> natural =\n", "        ImmutableSortedMap.naturalOrder();\n", "\n", "    ImmutableSortedMap.Builder<SelfComparableExample, Object> reverse =\n", "        ImmutableSortedMap.reverseOrder();\n", "  }\n", "\n", "  private static class SuperComparableExample extends SelfComparableExample {}\n", "\n", "  public void testBuilderGenerics_SuperComparable() {\n", "    ImmutableSortedMap.Builder<SuperComparableExample, Object> natural =\n", "        ImmutableSortedMap.naturalOrder();\n", "\n", "    ImmutableSortedMap.Builder<SuperComparableExample, Object> reverse =\n", "        ImmutableSortedMap.reverseOrder();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705]}}, {"114": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedSetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.NoSuchElementException;\n", "import java.util.Set;\n", "import java.util.SortedSet;\n", "import java.util.TreeSet;\n", "\n", "/**\n", " * Unit tests for {@link ImmutableSortedSet}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableSortedSetTest extends AbstractImmutableSetTest {\n", "\n", "  // enum singleton pattern\n", "  private enum StringLengthComparator implements Comparator<String> {\n", "    INSTANCE;\n", "\n", "    @Override\n", "    public int compare(String a, String b) {\n", "      return a.length() - b.length();\n", "    }\n", "  }\n", "\n", "  private static final Comparator<String> STRING_LENGTH\n", "      = StringLengthComparator.INSTANCE;\n", "\n", "  @Override protected SortedSet<String> of() {\n", "    return ImmutableSortedSet.of();\n", "  }\n", "\n", "  @Override protected SortedSet<String> of(String e) {\n", "    return ImmutableSortedSet.of(e);\n", "  }\n", "\n", "  @Override protected SortedSet<String> of(String e1, String e2) {\n", "    return ImmutableSortedSet.of(e1, e2);\n", "  }\n", "\n", "  @Override protected SortedSet<String> of(String e1, String e2, String e3) {\n", "    return ImmutableSortedSet.of(e1, e2, e3);\n", "  }\n", "\n", "  @Override protected SortedSet<String> of(\n", "      String e1, String e2, String e3, String e4) {\n", "    return ImmutableSortedSet.of(e1, e2, e3, e4);\n", "  }\n", "\n", "  @Override protected SortedSet<String> of(\n", "      String e1, String e2, String e3, String e4, String e5) {\n", "    return ImmutableSortedSet.of(e1, e2, e3, e4, e5);\n", "  }\n", "\n", "  @Override protected SortedSet<String> of(String e1, String e2, String e3,\n", "      String e4, String e5, String e6, String... rest) {\n", "    return ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, rest);\n", "  }\n", "\n", "  @Override protected SortedSet<String> copyOf(String[] elements) {\n", "    return ImmutableSortedSet.copyOf(elements);\n", "  }\n", "\n", "  @Override protected SortedSet<String> copyOf(Collection<String> elements) {\n", "    return ImmutableSortedSet.copyOf(elements);\n", "  }\n", "\n", "  @Override protected SortedSet<String> copyOf(Iterable<String> elements) {\n", "    return ImmutableSortedSet.copyOf(elements);\n", "  }\n", "\n", "  @Override protected SortedSet<String> copyOf(Iterator<String> elements) {\n", "    return ImmutableSortedSet.copyOf(elements);\n", "  }\n", "\n", "  public void testEmpty_comparator() {\n", "    SortedSet<String> set = of();\n", "    assertSame(Ordering.natural(), set.comparator());\n", "  }\n", "\n", "  public void testEmpty_headSet() {\n", "    SortedSet<String> set = of();\n", "    assertSame(set, set.headSet(\"c\"));\n", "  }\n", "\n", "  public void testEmpty_tailSet() {\n", "    SortedSet<String> set = of();\n", "    assertSame(set, set.tailSet(\"f\"));\n", "  }\n", "\n", "  public void testEmpty_subSet() {\n", "    SortedSet<String> set = of();\n", "    assertSame(set, set.subSet(\"c\", \"f\"));\n", "  }\n", "\n", "  public void testEmpty_first() {\n", "    SortedSet<String> set = of();\n", "    try {\n", "      set.first();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testEmpty_last() {\n", "    SortedSet<String> set = of();\n", "    try {\n", "      set.last();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testSingle_comparator() {\n", "    SortedSet<String> set = of(\"e\");\n", "    assertSame(Ordering.natural(), set.comparator());\n", "  }\n", "\n", "  public void testSingle_headSet() {\n", "    SortedSet<String> set = of(\"e\");\n", "    assertTrue(set.headSet(\"g\") instanceof ImmutableSortedSet);\n", "    assertThat(set.headSet(\"g\")).contains(\"e\");\n", "    assertSame(of(), set.headSet(\"c\"));\n", "    assertSame(of(), set.headSet(\"e\"));\n", "  }\n", "\n", "  public void testSingle_tailSet() {\n", "    SortedSet<String> set = of(\"e\");\n", "    assertTrue(set.tailSet(\"c\") instanceof ImmutableSortedSet);\n", "    assertThat(set.tailSet(\"c\")).contains(\"e\");\n", "    assertThat(set.tailSet(\"e\")).contains(\"e\");\n", "    assertSame(of(), set.tailSet(\"g\"));\n", "  }\n", "\n", "  public void testSingle_subSet() {\n", "    SortedSet<String> set = of(\"e\");\n", "    assertTrue(set.subSet(\"c\", \"g\") instanceof ImmutableSortedSet);\n", "    assertThat(set.subSet(\"c\", \"g\")).contains(\"e\");\n", "    assertThat(set.subSet(\"e\", \"g\")).contains(\"e\");\n", "    assertSame(of(), set.subSet(\"f\", \"g\"));\n", "    assertSame(of(), set.subSet(\"c\", \"e\"));\n", "    assertSame(of(), set.subSet(\"c\", \"d\"));\n", "  }\n", "\n", "  public void testSingle_first() {\n", "    SortedSet<String> set = of(\"e\");\n", "    assertEquals(\"e\", set.first());\n", "  }\n", "\n", "  public void testSingle_last() {\n", "    SortedSet<String> set = of(\"e\");\n", "    assertEquals(\"e\", set.last());\n", "  }\n", "\n", "  public void testOf_ordering() {\n", "    SortedSet<String> set = of(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\");\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "  }\n", "\n", "  /*\n", "   * Tests that we workaround GWT bug #3621 (or that it is already fixed).\n", "   *\n", "   * A call to of() with a parameter that is not a plain Object[] (here,\n", "   * Interface[]) creates a RegularImmutableSortedSet backed by an array of that\n", "   * type. Later, RegularImmutableSortedSet.toArray() calls System.arraycopy()\n", "   * to copy from that array to the destination array. This would be fine, but\n", "   * GWT has a bug: It refuses to copy from an E[] to an Object[] when E is an\n", "   * interface type.\n", "   */\n", "  // TODO: test other collections for this problem\n", "  public void testOf_gwtArraycopyBug() {\n", "    /*\n", "     * The test requires:\n", "     *\n", "     * 1) An interface I extending Comparable<I> so that the created array is of\n", "     * an interface type. 2) An instance of a class implementing that interface\n", "     * so that we can pass non-null instances of the interface.\n", "     *\n", "     * (Currently it's safe to pass instances for which compareTo() always\n", "     * returns 0, but if we had a SingletonImmutableSortedSet, this might no\n", "     * longer be the case.)\n", "     *\n", "     * javax.naming.Name and java.util.concurrent.Delayed might work, but\n", "     * they're fairly obscure, we've invented our own interface and class.\n", "     */\n", "    Interface a = new Impl();\n", "    Interface b = new Impl();\n", "    ImmutableSortedSet<Interface> set = ImmutableSortedSet.of(a, b);\n", "    set.toArray();\n", "    set.toArray(new Object[2]);\n", "  }\n", "\n", "  interface Interface extends Comparable<Interface> {\n", "  }\n", "  static class Impl implements Interface {\n", "    static int nextId;\n", "    Integer id = nextId++;\n", "\n", "    @Override public int compareTo(Interface other) {\n", "      return id.compareTo(((Impl) other).id);\n", "    }\n", "  }\n", "\n", "  public void testOf_ordering_dupes() {\n", "    SortedSet<String> set = of(\"e\", \"a\", \"e\", \"f\", \"b\", \"b\", \"d\", \"a\", \"c\");\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "  }\n", "\n", "  public void testOf_comparator() {\n", "    SortedSet<String> set = of(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\");\n", "    assertSame(Ordering.natural(), set.comparator());\n", "  }\n", "\n", "  public void testOf_headSet() {\n", "    SortedSet<String> set = of(\"e\", \"f\", \"b\", \"d\", \"c\");\n", "    assertTrue(set.headSet(\"e\") instanceof ImmutableSortedSet);\n", "    assertThat(set.headSet(\"e\")).containsExactly(\"b\", \"c\", \"d\").inOrder();\n", "    assertThat(set.headSet(\"g\")).containsExactly(\"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "    assertSame(of(), set.headSet(\"a\"));\n", "    assertSame(of(), set.headSet(\"b\"));\n", "  }\n", "\n", "  public void testOf_tailSet() {\n", "    SortedSet<String> set = of(\"e\", \"f\", \"b\", \"d\", \"c\");\n", "    assertTrue(set.tailSet(\"e\") instanceof ImmutableSortedSet);\n", "    assertThat(set.tailSet(\"e\")).containsExactly(\"e\", \"f\").inOrder();\n", "    assertThat(set.tailSet(\"a\")).containsExactly(\"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "    assertSame(of(), set.tailSet(\"g\"));\n", "  }\n", "\n", "  public void testOf_subSet() {\n", "    SortedSet<String> set = of(\"e\", \"f\", \"b\", \"d\", \"c\");\n", "    assertTrue(set.subSet(\"c\", \"e\") instanceof ImmutableSortedSet);\n", "    assertThat(set.subSet(\"c\", \"e\")).containsExactly(\"c\", \"d\").inOrder();\n", "    assertThat(set.subSet(\"a\", \"g\")).containsExactly(\"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "    assertSame(of(), set.subSet(\"a\", \"b\"));\n", "    assertSame(of(), set.subSet(\"g\", \"h\"));\n", "    assertSame(of(), set.subSet(\"c\", \"c\"));\n", "    try {\n", "      set.subSet(\"e\", \"c\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testOf_first() {\n", "    SortedSet<String> set = of(\"e\", \"f\", \"b\", \"d\", \"c\");\n", "    assertEquals(\"b\", set.first());\n", "  }\n", "\n", "  public void testOf_last() {\n", "    SortedSet<String> set = of(\"e\", \"f\", \"b\", \"d\", \"c\");\n", "    assertEquals(\"f\", set.last());\n", "  }\n", "\n", "  /* \"Explicit\" indicates an explicit comparator. */\n", "\n", "  public void testExplicit_ordering() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "  }\n", "\n", "  public void testExplicit_ordering_dupes() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"brown\", \"fox\", \"jumped\",\n", "        \"over\", \"a\", \"lazy\", \"dog\").build();\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "  }\n", "\n", "  public void testExplicit_contains() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertTrue(set.contains(\"quick\"));\n", "    assertTrue(set.contains(\"google\"));\n", "    assertFalse(set.contains(\"\"));\n", "    assertFalse(set.contains(\"california\"));\n", "    assertFalse(set.contains(null));\n", "  }\n", "\n", "  public void testExplicit_containsMismatchedTypes() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertFalse(set.contains(3.7));\n", "  }\n", "\n", "  public void testExplicit_comparator() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertSame(STRING_LENGTH, set.comparator());\n", "  }\n", "\n", "  public void testExplicit_headSet() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertTrue(set.headSet(\"a\") instanceof ImmutableSortedSet);\n", "    assertTrue(set.headSet(\"fish\") instanceof ImmutableSortedSet);\n", "    assertThat(set.headSet(\"fish\")).containsExactly(\"a\", \"in\", \"the\").inOrder();\n", "    assertThat(set.headSet(\"california\"))\n", "        .containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "    assertTrue(set.headSet(\"a\").isEmpty());\n", "    assertTrue(set.headSet(\"\").isEmpty());\n", "  }\n", "\n", "  public void testExplicit_tailSet() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertTrue(set.tailSet(\"california\") instanceof ImmutableSortedSet);\n", "    assertTrue(set.tailSet(\"fish\") instanceof ImmutableSortedSet);\n", "    assertThat(set.tailSet(\"fish\")).containsExactly(\"over\", \"quick\", \"jumped\").inOrder();\n", "    assertThat(\n", "        set.tailSet(\"a\")).containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "    assertTrue(set.tailSet(\"california\").isEmpty());\n", "  }\n", "\n", "  public void testExplicit_subSet() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertTrue(set.subSet(\"the\", \"quick\") instanceof ImmutableSortedSet);\n", "    assertTrue(set.subSet(\"\", \"b\") instanceof ImmutableSortedSet);\n", "    assertThat(set.subSet(\"the\", \"quick\")).containsExactly(\"the\", \"over\").inOrder();\n", "    assertThat(set.subSet(\"a\", \"california\"))\n", "        .containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "    assertTrue(set.subSet(\"\", \"b\").isEmpty());\n", "    assertTrue(set.subSet(\"vermont\", \"california\").isEmpty());\n", "    assertTrue(set.subSet(\"aaa\", \"zzz\").isEmpty());\n", "    try {\n", "      set.subSet(\"quick\", \"the\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testExplicit_first() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertEquals(\"a\", set.first());\n", "  }\n", "\n", "  public void testExplicit_last() {\n", "    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    assertEquals(\"jumped\", set.last());\n", "  }\n", "\n", "  public void testCopyOf_ordering() {\n", "    SortedSet<String> set =\n", "        copyOf(asList(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\"));\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "  }\n", "\n", "  public void testCopyOf_ordering_dupes() {\n", "    SortedSet<String> set =\n", "        copyOf(asList(\"e\", \"a\", \"e\", \"f\", \"b\", \"b\", \"d\", \"a\", \"c\"));\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "  }\n", "\n", "  public void testCopyOf_subSet() {\n", "    SortedSet<String> set = of(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\");\n", "    SortedSet<String> subset = set.subSet(\"c\", \"e\");\n", "    SortedSet<String> copy = copyOf(subset);\n", "    assertEquals(subset, copy);\n", "  }\n", "\n", "  public void testCopyOf_headSet() {\n", "    SortedSet<String> set = of(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\");\n", "    SortedSet<String> headset = set.headSet(\"d\");\n", "    SortedSet<String> copy = copyOf(headset);\n", "    assertEquals(headset, copy);\n", "  }\n", "\n", "  public void testCopyOf_tailSet() {\n", "    SortedSet<String> set = of(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\");\n", "    SortedSet<String> tailset = set.tailSet(\"d\");\n", "    SortedSet<String> copy = copyOf(tailset);\n", "    assertEquals(tailset, copy);\n", "  }\n", "\n", "  public void testCopyOf_comparator() {\n", "    SortedSet<String> set = copyOf(asList(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\"));\n", "    assertSame(Ordering.natural(), set.comparator());\n", "  }\n", "\n", "  public void testCopyOf_iterator_ordering() {\n", "    SortedSet<String> set = copyOf(asIterator(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\"));\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "  }\n", "\n", "  public void testCopyOf_iterator_ordering_dupes() {\n", "    SortedSet<String> set =\n", "        copyOf(asIterator(\"e\", \"a\", \"e\", \"f\", \"b\", \"b\", \"d\", \"a\", \"c\"));\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "  }\n", "\n", "  public void testCopyOf_iterator_comparator() {\n", "    SortedSet<String> set = copyOf(asIterator(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\"));\n", "    assertSame(Ordering.natural(), set.comparator());\n", "  }\n", "\n", "  public void testCopyOf_sortedSet_ordering() {\n", "    SortedSet<String> set =\n", "        copyOf(Sets.newTreeSet(asList(\"e\", \"a\", \"f\", \"b\", \"d\", \"c\")));\n", "    assertThat(set).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "  }\n", "\n", "  public void testCopyOf_sortedSet_comparator() {\n", "    SortedSet<String> set = copyOf(Sets.<String>newTreeSet());\n", "    assertSame(Ordering.natural(), set.comparator());\n", "  }\n", "\n", "  public void testCopyOfExplicit_ordering() {\n", "    SortedSet<String> set =\n", "        ImmutableSortedSet.copyOf(STRING_LENGTH, asList(\n", "            \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\"));\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "  }\n", "\n", "  public void testCopyOfExplicit_ordering_dupes() {\n", "    SortedSet<String> set =\n", "        ImmutableSortedSet.copyOf(STRING_LENGTH, asList(\n", "            \"in\", \"the\", \"quick\", \"brown\", \"fox\", \"jumped\", \"over\", \"a\",\n", "            \"lazy\", \"dog\"));\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "  }\n", "\n", "  public void testCopyOfExplicit_comparator() {\n", "    SortedSet<String> set =\n", "        ImmutableSortedSet.copyOf(STRING_LENGTH, asList(\n", "            \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\"));\n", "    assertSame(STRING_LENGTH, set.comparator());\n", "  }\n", "\n", "  public void testCopyOfExplicit_iterator_ordering() {\n", "    SortedSet<String> set =\n", "        ImmutableSortedSet.copyOf(STRING_LENGTH, asIterator(\n", "            \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\"));\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "  }\n", "\n", "  public void testCopyOfExplicit_iterator_ordering_dupes() {\n", "    SortedSet<String> set =\n", "        ImmutableSortedSet.copyOf(STRING_LENGTH, asIterator(\n", "            \"in\", \"the\", \"quick\", \"brown\", \"fox\", \"jumped\", \"over\", \"a\",\n", "            \"lazy\", \"dog\"));\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "  }\n", "\n", "  public void testCopyOfExplicit_iterator_comparator() {\n", "    SortedSet<String> set =\n", "        ImmutableSortedSet.copyOf(STRING_LENGTH, asIterator(\n", "            \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\"));\n", "    assertSame(STRING_LENGTH, set.comparator());\n", "  }\n", "\n", "  public void testCopyOf_sortedSetIterable() {\n", "    SortedSet<String> input = Sets.newTreeSet(STRING_LENGTH);\n", "    Collections.addAll(input, \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\");\n", "    SortedSet<String> set = copyOf(input);\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"jumped\", \"over\", \"quick\", \"the\").inOrder();\n", "  }\n", "\n", "  public void testCopyOfSorted_natural_ordering() {\n", "    SortedSet<String> input = Sets.newTreeSet(\n", "        asList(\"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\"));\n", "    SortedSet<String> set = ImmutableSortedSet.copyOfSorted(input);\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"jumped\", \"over\", \"quick\", \"the\").inOrder();\n", "  }\n", "\n", "  public void testCopyOfSorted_natural_comparator() {\n", "    SortedSet<String> input =\n", "        Sets.newTreeSet(asList(\"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\"));\n", "    SortedSet<String> set = ImmutableSortedSet.copyOfSorted(input);\n", "    assertSame(Ordering.natural(), set.comparator());\n", "  }\n", "\n", "  public void testCopyOfSorted_explicit_ordering() {\n", "    SortedSet<String> input = Sets.newTreeSet(STRING_LENGTH);\n", "    Collections.addAll(input, \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\");\n", "    SortedSet<String> set = ImmutableSortedSet.copyOfSorted(input);\n", "    assertThat(set).containsExactly(\"a\", \"in\", \"the\", \"over\", \"quick\", \"jumped\").inOrder();\n", "    assertSame(STRING_LENGTH, set.comparator());\n", "  }\n", "\n", "  public void testEquals_bothDefaultOrdering() {\n", "    SortedSet<String> set = of(\"a\", \"b\", \"c\");\n", "    assertEquals(set, Sets.newTreeSet(asList(\"a\", \"b\", \"c\")));\n", "    assertEquals(Sets.newTreeSet(asList(\"a\", \"b\", \"c\")), set);\n", "    assertFalse(set.equals(Sets.newTreeSet(asList(\"a\", \"b\", \"d\"))));\n", "    assertFalse(Sets.newTreeSet(asList(\"a\", \"b\", \"d\")).equals(set));\n", "    assertFalse(set.equals(Sets.newHashSet(4, 5, 6)));\n", "    assertFalse(Sets.newHashSet(4, 5, 6).equals(set));\n", "  }\n", "\n", "  public void testEquals_bothExplicitOrdering() {\n", "    SortedSet<String> set = of(\"in\", \"the\", \"a\");\n", "    assertEquals(Sets.newTreeSet(asList(\"in\", \"the\", \"a\")), set);\n", "    assertFalse(set.equals(Sets.newTreeSet(asList(\"in\", \"the\", \"house\"))));\n", "    assertFalse(Sets.newTreeSet(asList(\"in\", \"the\", \"house\")).equals(set));\n", "    assertFalse(set.equals(Sets.newHashSet(4, 5, 6)));\n", "    assertFalse(Sets.newHashSet(4, 5, 6).equals(set));\n", "\n", "    Set<String> complex = Sets.newTreeSet(STRING_LENGTH);\n", "    Collections.addAll(complex, \"in\", \"the\", \"a\");\n", "    assertEquals(set, complex);\n", "  }\n", "\n", "  public void testEquals_bothDefaultOrdering_StringVsInt() {\n", "    SortedSet<String> set = of(\"a\", \"b\", \"c\");\n", "    assertFalse(set.equals(Sets.newTreeSet(asList(4, 5, 6))));\n", "    assertNotEqualLenient(Sets.newTreeSet(asList(4, 5, 6)), set);\n", "  }\n", "\n", "  public void testEquals_bothExplicitOrdering_StringVsInt() {\n", "    SortedSet<String> set = of(\"in\", \"the\", \"a\");\n", "    assertFalse(set.equals(Sets.newTreeSet(asList(4, 5, 6))));\n", "    assertNotEqualLenient(Sets.newTreeSet(asList(4, 5, 6)), set);\n", "  }\n", "\n", "  public void testContainsAll_notSortedSet() {\n", "    SortedSet<String> set = of(\"a\", \"b\", \"f\");\n", "    assertTrue(set.containsAll(Collections.emptyList()));\n", "    assertTrue(set.containsAll(asList(\"b\")));\n", "    assertTrue(set.containsAll(asList(\"b\", \"b\")));\n", "    assertTrue(set.containsAll(asList(\"b\", \"f\")));\n", "    assertTrue(set.containsAll(asList(\"b\", \"f\", \"a\")));\n", "    assertFalse(set.containsAll(asList(\"d\")));\n", "    assertFalse(set.containsAll(asList(\"z\")));\n", "    assertFalse(set.containsAll(asList(\"b\", \"d\")));\n", "    assertFalse(set.containsAll(asList(\"f\", \"d\", \"a\")));\n", "  }\n", "\n", "  public void testContainsAll_sameComparator() {\n", "    SortedSet<String> set = of(\"a\", \"b\", \"f\");\n", "    assertTrue(set.containsAll(Sets.newTreeSet()));\n", "    assertTrue(set.containsAll(Sets.newTreeSet(asList(\"b\"))));\n", "    assertTrue(set.containsAll(Sets.newTreeSet(asList(\"a\", \"f\"))));\n", "    assertTrue(set.containsAll(Sets.newTreeSet(asList(\"a\", \"b\", \"f\"))));\n", "    assertFalse(set.containsAll(Sets.newTreeSet(asList(\"d\"))));\n", "    assertFalse(set.containsAll(Sets.newTreeSet(asList(\"z\"))));\n", "    assertFalse(set.containsAll(Sets.newTreeSet(asList(\"b\", \"d\"))));\n", "    assertFalse(set.containsAll(Sets.newTreeSet(asList(\"f\", \"d\", \"a\"))));\n", "  }\n", "\n", "  public void testContainsAll_sameComparator_StringVsInt() {\n", "    SortedSet<String> set = of(\"a\", \"b\", \"f\");\n", "    SortedSet<Integer> unexpected = Sets.newTreeSet(Ordering.natural());\n", "    unexpected.addAll(asList(1, 2, 3));\n", "    assertFalse(set.containsAll(unexpected));\n", "  }\n", "\n", "  public void testContainsAll_differentComparator() {\n", "    Comparator<Comparable<?>> comparator = Collections.reverseOrder();\n", "    SortedSet<String> set = new ImmutableSortedSet.Builder<String>(comparator)\n", "        .add(\"a\", \"b\", \"f\").build();\n", "    assertTrue(set.containsAll(Sets.newTreeSet()));\n", "    assertTrue(set.containsAll(Sets.newTreeSet(asList(\"b\"))));\n", "    assertTrue(set.containsAll(Sets.newTreeSet(asList(\"a\", \"f\"))));\n", "    assertTrue(set.containsAll(Sets.newTreeSet(asList(\"a\", \"b\", \"f\"))));\n", "    assertFalse(set.containsAll(Sets.newTreeSet(asList(\"d\"))));\n", "    assertFalse(set.containsAll(Sets.newTreeSet(asList(\"z\"))));\n", "    assertFalse(set.containsAll(Sets.newTreeSet(asList(\"b\", \"d\"))));\n", "    assertFalse(set.containsAll(Sets.newTreeSet(asList(\"f\", \"d\", \"a\"))));\n", "  }\n", "\n", "  public void testReverseOrder() {\n", "    SortedSet<String> set = ImmutableSortedSet.<String>reverseOrder()\n", "        .add(\"a\", \"b\", \"c\").build();\n", "    assertThat(set).containsExactly(\"c\", \"b\", \"a\").inOrder();\n", "    assertEquals(Ordering.natural().reverse(), set.comparator());\n", "  }\n", "\n", "  private static final Comparator<Object> TO_STRING\n", "      = new Comparator<Object>() {\n", "          @Override\n", "          public int compare(Object o1, Object o2) {\n", "            return o1.toString().compareTo(o2.toString());\n", "          }\n", "        };\n", "\n", "  public void testSupertypeComparator() {\n", "    SortedSet<Integer> set = new ImmutableSortedSet.Builder<Integer>(TO_STRING)\n", "        .add(3, 12, 101, 44).build();\n", "    assertThat(set).containsExactly(101, 12, 3, 44).inOrder();\n", "  }\n", "\n", "  public void testSupertypeComparatorSubtypeElements() {\n", "    SortedSet<Number> set = new ImmutableSortedSet.Builder<Number>(TO_STRING)\n", "        .add(3, 12, 101, 44).build();\n", "    assertThat(set).containsExactly(101, 12, 3, 44).inOrder();\n", "  }\n", "\n", "  @Override <E extends Comparable<E>> ImmutableSortedSet.Builder<E> builder() {\n", "    return ImmutableSortedSet.naturalOrder();\n", "  }\n", "\n", "  @Override int getComplexBuilderSetLastElement() {\n", "    return 0x00FFFFFF;\n", "  }\n", "\n", "  public void testLegacyComparable_of() {\n", "    ImmutableSortedSet<LegacyComparable> set0 = ImmutableSortedSet.of();\n", "\n", "    @SuppressWarnings(\"unchecked\") // using a legacy comparable\n", "    ImmutableSortedSet<LegacyComparable> set1 = ImmutableSortedSet.of(\n", "        LegacyComparable.Z);\n", "\n", "    @SuppressWarnings(\"unchecked\") // using a legacy comparable\n", "    ImmutableSortedSet<LegacyComparable> set2 = ImmutableSortedSet.of(\n", "        LegacyComparable.Z, LegacyComparable.Y);\n", "  }\n", "\n", "  public void testLegacyComparable_copyOf_collection() {\n", "    ImmutableSortedSet<LegacyComparable> set\n", "        = ImmutableSortedSet.copyOf(LegacyComparable.VALUES_BACKWARD);\n", "    assertTrue(Iterables.elementsEqual(LegacyComparable.VALUES_FORWARD, set));\n", "  }\n", "\n", "  public void testLegacyComparable_copyOf_iterator() {\n", "    ImmutableSortedSet<LegacyComparable> set = ImmutableSortedSet.copyOf(\n", "        LegacyComparable.VALUES_BACKWARD.iterator());\n", "    assertTrue(Iterables.elementsEqual(LegacyComparable.VALUES_FORWARD, set));\n", "  }\n", "\n", "  public void testLegacyComparable_builder_natural() {\n", "    @SuppressWarnings(\"unchecked\")\n", "    // Note: IntelliJ wrongly reports an error for this statement\n", "    ImmutableSortedSet.Builder<LegacyComparable> builder\n", "        = ImmutableSortedSet.<LegacyComparable>naturalOrder();\n", "\n", "    builder.addAll(LegacyComparable.VALUES_BACKWARD);\n", "    builder.add(LegacyComparable.X);\n", "    builder.add(LegacyComparable.Y, LegacyComparable.Z);\n", "\n", "    ImmutableSortedSet<LegacyComparable> set = builder.build();\n", "    assertTrue(Iterables.elementsEqual(LegacyComparable.VALUES_FORWARD, set));\n", "  }\n", "\n", "  public void testLegacyComparable_builder_reverse() {\n", "    @SuppressWarnings(\"unchecked\")\n", "    // Note: IntelliJ wrongly reports an error for this statement\n", "    ImmutableSortedSet.Builder<LegacyComparable> builder\n", "        = ImmutableSortedSet.<LegacyComparable>reverseOrder();\n", "\n", "    builder.addAll(LegacyComparable.VALUES_FORWARD);\n", "    builder.add(LegacyComparable.X);\n", "    builder.add(LegacyComparable.Y, LegacyComparable.Z);\n", "\n", "    ImmutableSortedSet<LegacyComparable> set = builder.build();\n", "    assertTrue(Iterables.elementsEqual(LegacyComparable.VALUES_BACKWARD, set));\n", "  }\n", "\n", "  @SuppressWarnings({\"deprecation\", \"static-access\"})\n", "  public void testBuilderMethod() {\n", "    try {\n", "      ImmutableSortedSet.builder();\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsList() {\n", "    ImmutableSet<String> set = ImmutableSortedSet.of(\"a\", \"e\", \"i\", \"o\", \"u\");\n", "    ImmutableList<String> list = set.asList();\n", "    assertEquals(ImmutableList.of(\"a\", \"e\", \"i\", \"o\", \"u\"), list);\n", "    assertSame(list, ImmutableList.copyOf(set));\n", "  }\n", "\n", "  public void testSubsetAsList() {\n", "    ImmutableSet<String> set\n", "        = ImmutableSortedSet.of(\"a\", \"e\", \"i\", \"o\", \"u\").subSet(\"c\", \"r\");\n", "    ImmutableList<String> list = set.asList();\n", "    assertEquals(ImmutableList.of(\"e\", \"i\", \"o\"), list);\n", "    assertEquals(list, ImmutableList.copyOf(set));\n", "  }\n", "\n", "  public void testAsListInconsistentComprator() {\n", "    ImmutableSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).add(\n", "        \"in\", \"the\", \"quick\", \"jumped\", \"over\", \"a\").build();\n", "    ImmutableList<String> list = set.asList();\n", "    assertTrue(list.contains(\"the\"));\n", "    assertEquals(2, list.indexOf(\"the\"));\n", "    assertEquals(2, list.lastIndexOf(\"the\"));\n", "    assertFalse(list.contains(\"dog\"));\n", "    assertEquals(-1, list.indexOf(\"dog\"));\n", "    assertEquals(-1, list.lastIndexOf(\"dog\"));\n", "    assertFalse(list.contains(\"chicken\"));\n", "    assertEquals(-1, list.indexOf(\"chicken\"));\n", "    assertEquals(-1, list.lastIndexOf(\"chicken\"));\n", "  }\n", "\n", "  private static <E> Iterator<E> asIterator(E... elements) {\n", "    return asList(elements).iterator();\n", "  }\n", "\n", "  // In GWT, java.util.TreeSet throws ClassCastException when the comparator\n", "  // throws it, unlike JDK6.  Therefore, we accept ClassCastException as a\n", "  // valid result thrown by java.util.TreeSet#equals.\n", "  private static void assertNotEqualLenient(\n", "      TreeSet<?> unexpected, SortedSet<?> actual) {\n", "    try {\n", "      assertThat(actual).isNotEqualTo(unexpected);\n", "    } catch (ClassCastException accepted) {\n", "    }\n", "  }\n", "\n", "  public void testHeadSetInclusive() {\n", "    String[] strings = NUMBER_NAMES.toArray(new String[0]);\n", "    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);\n", "    Arrays.sort(strings);\n", "    for (int i = 0; i < strings.length; i++) {\n", "      assertThat(set.headSet(strings[i], true))\n", "          .containsExactlyElementsIn(sortedNumberNames(0, i + 1))\n", "          .inOrder();\n", "    }\n", "  }\n", "\n", "  public void testHeadSetExclusive() {\n", "    String[] strings = NUMBER_NAMES.toArray(new String[0]);\n", "    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);\n", "    Arrays.sort(strings);\n", "    for (int i = 0; i < strings.length; i++) {\n", "      assertThat(set.headSet(strings[i], false))\n", "          .containsExactlyElementsIn(sortedNumberNames(0, i))\n", "          .inOrder();\n", "    }\n", "  }\n", "\n", "  public void testTailSetInclusive() {\n", "    String[] strings = NUMBER_NAMES.toArray(new String[0]);\n", "    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);\n", "    Arrays.sort(strings);\n", "    for (int i = 0; i < strings.length; i++) {\n", "      assertThat(set.tailSet(strings[i], true))\n", "          .containsExactlyElementsIn(sortedNumberNames(i, strings.length))\n", "          .inOrder();\n", "    }\n", "  }\n", "\n", "  public void testTailSetExclusive() {\n", "    String[] strings = NUMBER_NAMES.toArray(new String[0]);\n", "    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);\n", "    Arrays.sort(strings);\n", "    for (int i = 0; i < strings.length; i++) {\n", "      assertThat(set.tailSet(strings[i], false))\n", "          .containsExactlyElementsIn(sortedNumberNames(i + 1, strings.length))\n", "          .inOrder();\n", "    }\n", "  }\n", "\n", "  public void testSubSetExclusiveExclusive() {\n", "    String[] strings = NUMBER_NAMES.toArray(new String[0]);\n", "    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);\n", "    Arrays.sort(strings);\n", "    for (int i = 0; i < strings.length; i++) {\n", "      for (int j = i; j < strings.length; j++) {\n", "        assertThat(set.subSet(strings[i], false, strings[j], false))\n", "            .containsExactlyElementsIn(sortedNumberNames(Math.min(i + 1, j), j))\n", "            .inOrder();\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testSubSetInclusiveExclusive() {\n", "    String[] strings = NUMBER_NAMES.toArray(new String[0]);\n", "    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);\n", "    Arrays.sort(strings);\n", "    for (int i = 0; i < strings.length; i++) {\n", "      for (int j = i; j < strings.length; j++) {\n", "        assertThat(set.subSet(strings[i], true, strings[j], false))\n", "            .containsExactlyElementsIn(sortedNumberNames(i, j))\n", "            .inOrder();\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testSubSetExclusiveInclusive() {\n", "    String[] strings = NUMBER_NAMES.toArray(new String[0]);\n", "    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);\n", "    Arrays.sort(strings);\n", "    for (int i = 0; i < strings.length; i++) {\n", "      for (int j = i; j < strings.length; j++) {\n", "        assertThat(set.subSet(strings[i], false, strings[j], true))\n", "            .containsExactlyElementsIn(sortedNumberNames(i + 1, j + 1))\n", "            .inOrder();\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testSubSetInclusiveInclusive() {\n", "    String[] strings = NUMBER_NAMES.toArray(new String[0]);\n", "    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);\n", "    Arrays.sort(strings);\n", "    for (int i = 0; i < strings.length; i++) {\n", "      for (int j = i; j < strings.length; j++) {\n", "        assertThat(set.subSet(strings[i], true, strings[j], true))\n", "            .containsExactlyElementsIn(sortedNumberNames(i, j + 1))\n", "            .inOrder();\n", "      }\n", "    }\n", "  }\n", "\n", "  private static ImmutableList<String> sortedNumberNames(int i, int j) {\n", "    return ImmutableList.copyOf(SORTED_NUMBER_NAMES.subList(i, j));\n", "  }\n", "\n", "  private static final ImmutableList<String> NUMBER_NAMES =\n", "      ImmutableList.of(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\");\n", "\n", "  private static final ImmutableList<String> SORTED_NUMBER_NAMES =\n", "      Ordering.natural().immutableSortedCopy(NUMBER_NAMES);\n", "\n", "  private static class SelfComparableExample implements Comparable<SelfComparableExample> {\n", "    @Override\n", "    public int compareTo(SelfComparableExample o) {\n", "      return 0;\n", "    }\n", "  }\n", "\n", "  public void testBuilderGenerics_SelfComparable() {\n", "    ImmutableSortedSet.Builder<SelfComparableExample> natural = ImmutableSortedSet.naturalOrder();\n", "    ImmutableSortedSet.Builder<SelfComparableExample> reverse = ImmutableSortedSet.reverseOrder();\n", "  }\n", "\n", "  private static class SuperComparableExample extends SelfComparableExample {}\n", "\n", "  public void testBuilderGenerics_SuperComparable() {\n", "    ImmutableSortedSet.Builder<SuperComparableExample> natural = ImmutableSortedSet.naturalOrder();\n", "    ImmutableSortedSet.Builder<SuperComparableExample> reverse = ImmutableSortedSet.reverseOrder();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857]}}, {"115": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ImmutableTableTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "/**\n", " * Tests common methods in {@link ImmutableTable}\n", " *\n", " * @author Gregory Kick\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ImmutableTableTest extends AbstractTableReadTest {\n", "  @Override protected Table<String, Integer, Character> create(Object... data) {\n", "    ImmutableTable.Builder<String, Integer, Character> builder =\n", "        ImmutableTable.builder();\n", "    for (int i = 0; i < data.length; i = i + 3) {\n", "      builder.put((String) data[i], (Integer) data[i + 1],\n", "          (Character) data[i + 2]);\n", "    }\n", "    return builder.build();\n", "  }\n", "\n", "  public void testBuilder() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder =\n", "        new ImmutableTable.Builder<Character, Integer, String>();\n", "    assertEquals(ImmutableTable.of(), builder.build());\n", "    assertEquals(ImmutableTable.of('a', 1, \"foo\"), builder\n", "        .put('a', 1, \"foo\")\n", "        .build());\n", "    Table<Character, Integer, String> expectedTable = HashBasedTable.create();\n", "    expectedTable.put('a', 1, \"foo\");\n", "    expectedTable.put('b', 1, \"bar\");\n", "    expectedTable.put('a', 2, \"baz\");\n", "    Table<Character, Integer, String> otherTable = HashBasedTable.create();\n", "    otherTable.put('b', 1, \"bar\");\n", "    otherTable.put('a', 2, \"baz\");\n", "    assertEquals(expectedTable, builder\n", "        .putAll(otherTable)\n", "        .build());\n", "  }\n", "\n", "  public void testBuilder_withImmutableCell() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder =\n", "        new ImmutableTable.Builder<Character, Integer, String>();\n", "    assertEquals(ImmutableTable.of('a', 1, \"foo\"), builder\n", "        .put(Tables.immutableCell('a', 1, \"foo\"))\n", "        .build());\n", "  }\n", "\n", "  public void testBuilder_withImmutableCellAndNullContents() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder =\n", "        new ImmutableTable.Builder<Character, Integer, String>();\n", "    try {\n", "      builder.put(Tables.immutableCell((Character) null, 1, \"foo\"));\n", "      fail();\n", "    } catch (NullPointerException e) {\n", "      // success\n", "    }\n", "    try {\n", "      builder.put(Tables.immutableCell('a', (Integer) null, \"foo\"));\n", "      fail();\n", "    } catch (NullPointerException e) {\n", "      // success\n", "    }\n", "    try {\n", "      builder.put(Tables.immutableCell('a', 1, (String) null));\n", "      fail();\n", "    } catch (NullPointerException e) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  private static class StringHolder {\n", "    String string;\n", "  }\n", "\n", "  public void testBuilder_withMutableCell() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder =\n", "        new ImmutableTable.Builder<Character, Integer, String>();\n", "\n", "    final StringHolder holder = new StringHolder();\n", "    holder.string = \"foo\";\n", "    Table.Cell<Character, Integer, String> mutableCell =\n", "        new Tables.AbstractCell<Character, Integer, String>() {\n", "          @Override public Character getRowKey() {\n", "            return 'K';\n", "          }\n", "          @Override public Integer getColumnKey() {\n", "            return 42;\n", "          }\n", "          @Override public String getValue() {\n", "            return holder.string;\n", "          }\n", "        };\n", "\n", "    // Add the mutable cell to the builder\n", "    builder.put(mutableCell);\n", "\n", "    // Mutate the value\n", "    holder.string = \"bar\";\n", "\n", "    // Make sure it uses the original value.\n", "    assertEquals(ImmutableTable.of('K', 42, \"foo\"), builder.build());\n", "  }\n", "\n", "  public void testBuilder_noDuplicates() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder =\n", "        new ImmutableTable.Builder<Character, Integer, String>()\n", "            .put('a', 1, \"foo\")\n", "            .put('a', 1, \"bar\");\n", "    try {\n", "      builder.build();\n", "      fail();\n", "    } catch (IllegalArgumentException e) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  public void testBuilder_noNulls() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder =\n", "        new ImmutableTable.Builder<Character, Integer, String>();\n", "    try {\n", "      builder.put(null, 1, \"foo\");\n", "      fail();\n", "    } catch (NullPointerException e) {\n", "      // success\n", "    }\n", "    try {\n", "      builder.put('a', null, \"foo\");\n", "      fail();\n", "    } catch (NullPointerException e) {\n", "      // success\n", "    }\n", "    try {\n", "      builder.put('a', 1, null);\n", "      fail();\n", "    } catch (NullPointerException e) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  private static <R, C, V> void validateTableCopies(Table<R, C, V> original) {\n", "    Table<R, C, V> copy = ImmutableTable.copyOf(original);\n", "    assertEquals(original, copy);\n", "    validateViewOrdering(original, copy);\n", "\n", "    Table<R, C, V> built\n", "        = ImmutableTable.<R, C, V>builder().putAll(original).build();\n", "    assertEquals(original, built);\n", "    validateViewOrdering(original, built);\n", "  }\n", "\n", "  private static <R, C, V> void validateViewOrdering(\n", "      Table<R, C, V> original, Table<R, C, V> copy) {\n", "    assertTrue(Iterables.elementsEqual(original.cellSet(), copy.cellSet()));\n", "    assertTrue(Iterables.elementsEqual(original.rowKeySet(), copy.rowKeySet()));\n", "    assertTrue(Iterables.elementsEqual(original.values(), copy.values()));\n", "  }\n", "\n", "  public void testCopyOf() {\n", "    Table<Character, Integer, String> table = TreeBasedTable.create();\n", "    validateTableCopies(table);\n", "    table.put('b', 2, \"foo\");\n", "    validateTableCopies(table);\n", "    table.put('b', 1, \"bar\");\n", "    table.put('a', 2, \"baz\");\n", "    validateTableCopies(table);\n", "    // Even though rowKeySet, columnKeySet, and cellSet have the same\n", "    // iteration ordering, row has an inconsistent ordering.\n", "    assertThat(table.row('b').keySet()).containsExactly(1, 2).inOrder();\n", "    assertThat(ImmutableTable.copyOf(table).row('b').keySet())\n", "        .containsExactly(2, 1).inOrder();\n", "  }\n", "\n", "  public void testCopyOfSparse() {\n", "    Table<Character, Integer, String> table = TreeBasedTable.create();\n", "    table.put('x', 2, \"foo\");\n", "    table.put('r', 1, \"bar\");\n", "    table.put('c', 3, \"baz\");\n", "    table.put('b', 7, \"cat\");\n", "    table.put('e', 5, \"dog\");\n", "    table.put('c', 0, \"axe\");\n", "    table.put('e', 3, \"tub\");\n", "    table.put('r', 4, \"foo\");\n", "    table.put('x', 5, \"bar\");\n", "    validateTableCopies(table);\n", "  }\n", "\n", "  public void testCopyOfDense() {\n", "    Table<Character, Integer, String> table = TreeBasedTable.create();\n", "    table.put('c', 3, \"foo\");\n", "    table.put('c', 2, \"bar\");\n", "    table.put('c', 1, \"baz\");\n", "    table.put('b', 3, \"cat\");\n", "    table.put('b', 1, \"dog\");\n", "    table.put('a', 3, \"foo\");\n", "    table.put('a', 2, \"bar\");\n", "    table.put('a', 1, \"baz\");\n", "    validateTableCopies(table);\n", "  }\n", "\n", "  public void testBuilder_orderRowsAndColumnsBy_putAll() {\n", "    Table<Character, Integer, String> table = HashBasedTable.create();\n", "    table.put('b', 2, \"foo\");\n", "    table.put('b', 1, \"bar\");\n", "    table.put('a', 2, \"baz\");\n", "    ImmutableTable.Builder<Character, Integer, String> builder\n", "        = ImmutableTable.builder();\n", "    Table<Character, Integer, String> copy\n", "        = builder.orderRowsBy(Ordering.natural())\n", "            .orderColumnsBy(Ordering.natural())\n", "            .putAll(table).build();\n", "    assertThat(copy.rowKeySet()).containsExactly('a', 'b').inOrder();\n", "    assertThat(copy.columnKeySet()).containsExactly(1, 2).inOrder();\n", "    assertThat(copy.values()).containsExactly(\"baz\", \"bar\", \"foo\").inOrder();\n", "    assertThat(copy.row('b').keySet()).containsExactly(1, 2).inOrder();\n", "  }\n", "\n", "  public void testBuilder_orderRowsAndColumnsBy_sparse() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder\n", "        = ImmutableTable.builder();\n", "    builder.orderRowsBy(Ordering.natural());\n", "    builder.orderColumnsBy(Ordering.natural());\n", "    builder.put('x', 2, \"foo\");\n", "    builder.put('r', 1, \"bar\");\n", "    builder.put('c', 3, \"baz\");\n", "    builder.put('b', 7, \"cat\");\n", "    builder.put('e', 5, \"dog\");\n", "    builder.put('c', 0, \"axe\");\n", "    builder.put('e', 3, \"tub\");\n", "    builder.put('r', 4, \"foo\");\n", "    builder.put('x', 5, \"bar\");\n", "    Table<Character, Integer, String> table = builder.build();\n", "    assertThat(table.rowKeySet()).containsExactly('b', 'c', 'e', 'r', 'x').inOrder();\n", "    assertThat(table.columnKeySet()).containsExactly(0, 1, 2, 3, 4, 5, 7).inOrder();\n", "    assertThat(table.values()).containsExactly(\"cat\", \"axe\", \"baz\", \"tub\",\n", "        \"dog\", \"bar\", \"foo\", \"foo\", \"bar\").inOrder();\n", "    assertThat(table.row('c').keySet()).containsExactly(0, 3).inOrder();\n", "    assertThat(table.column(5).keySet()).containsExactly('e', 'x').inOrder();\n", "  }\n", "\n", "  public void testBuilder_orderRowsAndColumnsBy_dense() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder\n", "        = ImmutableTable.builder();\n", "    builder.orderRowsBy(Ordering.natural());\n", "    builder.orderColumnsBy(Ordering.natural());\n", "    builder.put('c', 3, \"foo\");\n", "    builder.put('c', 2, \"bar\");\n", "    builder.put('c', 1, \"baz\");\n", "    builder.put('b', 3, \"cat\");\n", "    builder.put('b', 1, \"dog\");\n", "    builder.put('a', 3, \"foo\");\n", "    builder.put('a', 2, \"bar\");\n", "    builder.put('a', 1, \"baz\");\n", "    Table<Character, Integer, String> table = builder.build();\n", "    assertThat(table.rowKeySet()).containsExactly('a', 'b', 'c').inOrder();\n", "    assertThat(table.columnKeySet()).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(table.values()).containsExactly(\"baz\", \"bar\", \"foo\", \"dog\",\n", "        \"cat\", \"baz\", \"bar\", \"foo\").inOrder();\n", "    assertThat(table.row('c').keySet()).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(table.column(1).keySet()).containsExactly('a', 'b', 'c').inOrder();\n", "  }\n", "\n", "  public void testBuilder_orderRowsBy_sparse() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder\n", "        = ImmutableTable.builder();\n", "    builder.orderRowsBy(Ordering.natural());\n", "    builder.put('x', 2, \"foo\");\n", "    builder.put('r', 1, \"bar\");\n", "    builder.put('c', 3, \"baz\");\n", "    builder.put('b', 7, \"cat\");\n", "    builder.put('e', 5, \"dog\");\n", "    builder.put('c', 0, \"axe\");\n", "    builder.put('e', 3, \"tub\");\n", "    builder.put('r', 4, \"foo\");\n", "    builder.put('x', 5, \"bar\");\n", "    Table<Character, Integer, String> table = builder.build();\n", "    assertThat(table.rowKeySet()).containsExactly('b', 'c', 'e', 'r', 'x').inOrder();\n", "    assertThat(table.column(5).keySet()).containsExactly('e', 'x').inOrder();\n", "  }\n", "\n", "  public void testBuilder_orderRowsBy_dense() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder\n", "        = ImmutableTable.builder();\n", "    builder.orderRowsBy(Ordering.natural());\n", "    builder.put('c', 3, \"foo\");\n", "    builder.put('c', 2, \"bar\");\n", "    builder.put('c', 1, \"baz\");\n", "    builder.put('b', 3, \"cat\");\n", "    builder.put('b', 1, \"dog\");\n", "    builder.put('a', 3, \"foo\");\n", "    builder.put('a', 2, \"bar\");\n", "    builder.put('a', 1, \"baz\");\n", "    Table<Character, Integer, String> table = builder.build();\n", "    assertThat(table.rowKeySet()).containsExactly('a', 'b', 'c').inOrder();\n", "    assertThat(table.column(1).keySet()).containsExactly('a', 'b', 'c').inOrder();\n", "  }\n", "\n", "  public void testBuilder_orderColumnsBy_sparse() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder\n", "        = ImmutableTable.builder();\n", "    builder.orderColumnsBy(Ordering.natural());\n", "    builder.put('x', 2, \"foo\");\n", "    builder.put('r', 1, \"bar\");\n", "    builder.put('c', 3, \"baz\");\n", "    builder.put('b', 7, \"cat\");\n", "    builder.put('e', 5, \"dog\");\n", "    builder.put('c', 0, \"axe\");\n", "    builder.put('e', 3, \"tub\");\n", "    builder.put('r', 4, \"foo\");\n", "    builder.put('x', 5, \"bar\");\n", "    Table<Character, Integer, String> table = builder.build();\n", "    assertThat(table.columnKeySet()).containsExactly(0, 1, 2, 3, 4, 5, 7).inOrder();\n", "    assertThat(table.row('c').keySet()).containsExactly(0, 3).inOrder();\n", "  }\n", "\n", "  public void testBuilder_orderColumnsBy_dense() {\n", "    ImmutableTable.Builder<Character, Integer, String> builder\n", "        = ImmutableTable.builder();\n", "    builder.orderColumnsBy(Ordering.natural());\n", "    builder.put('c', 3, \"foo\");\n", "    builder.put('c', 2, \"bar\");\n", "    builder.put('c', 1, \"baz\");\n", "    builder.put('b', 3, \"cat\");\n", "    builder.put('b', 1, \"dog\");\n", "    builder.put('a', 3, \"foo\");\n", "    builder.put('a', 2, \"bar\");\n", "    builder.put('a', 1, \"baz\");\n", "    Table<Character, Integer, String> table = builder.build();\n", "    assertThat(table.columnKeySet()).containsExactly(1, 2, 3).inOrder();\n", "    assertThat(table.row('c').keySet()).containsExactly(1, 2, 3).inOrder();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351]}}, {"116": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/IterablesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.Iterables.skip;\n", "import static com.google.common.collect.Lists.newArrayList;\n", "import static com.google.common.collect.Sets.newLinkedHashSet;\n", "import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "import static java.util.Collections.emptyList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Predicate;\n", "import com.google.common.base.Predicates;\n", "import com.google.common.collect.testing.IteratorTester;\n", "\n", "import junit.framework.AssertionFailedError;\n", "import junit.framework.TestCase;\n", "\n", "import java.util.ArrayList;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.NoSuchElementException;\n", "import java.util.Queue;\n", "import java.util.RandomAccess;\n", "import java.util.Set;\n", "import java.util.SortedSet;\n", "import java.util.TreeSet;\n", "\n", "/**\n", " * Unit test for {@code Iterables}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class IterablesTest extends TestCase {\n", "\n", "  public void testSize0() {\n", "    Iterable<String> iterable = Collections.emptySet();\n", "    assertEquals(0, Iterables.size(iterable));\n", "  }\n", "\n", "  public void testSize1Collection() {\n", "    Iterable<String> iterable = Collections.singleton(\"a\");\n", "    assertEquals(1, Iterables.size(iterable));\n", "  }\n", "\n", "  public void testSize2NonCollection() {\n", "    Iterable<Integer> iterable = new Iterable<Integer>() {\n", "      @Override\n", "      public Iterator<Integer> iterator() {\n", "        return asList(0, 1).iterator();\n", "      }\n", "    };\n", "    assertEquals(2, Iterables.size(iterable));\n", "  }\n", "\n", "  @SuppressWarnings(\"serial\")\n", "  public void testSize_collection_doesntIterate() {\n", "    List<Integer> nums = asList(1, 2, 3, 4, 5);\n", "    List<Integer> collection = new ArrayList<Integer>(nums) {\n", "      @Override public Iterator<Integer> iterator() {\n", "        throw new AssertionFailedError(\"Don't iterate me!\");\n", "      }\n", "    };\n", "    assertEquals(5, Iterables.size(collection));\n", "  }\n", "\n", "  private static Iterable<String> iterable(String... elements) {\n", "    final List<String> list = asList(elements);\n", "    return new Iterable<String>() {\n", "      @Override\n", "      public Iterator<String> iterator() {\n", "        return list.iterator();\n", "      }\n", "    };\n", "  }\n", "\n", "  public void test_contains_null_set_yes() {\n", "    Iterable<String> set = Sets.newHashSet(\"a\", null, \"b\");\n", "    assertTrue(Iterables.contains(set, null));\n", "  }\n", "\n", "  public void test_contains_null_set_no() {\n", "    Iterable<String> set = Sets.newHashSet(\"a\", \"b\");\n", "    assertFalse(Iterables.contains(set, null));\n", "  }\n", "\n", "  public void test_contains_null_iterable_yes() {\n", "    Iterable<String> set = iterable(\"a\", null, \"b\");\n", "    assertTrue(Iterables.contains(set, null));\n", "  }\n", "\n", "  public void test_contains_null_iterable_no() {\n", "    Iterable<String> set = iterable(\"a\", \"b\");\n", "    assertFalse(Iterables.contains(set, null));\n", "  }\n", "\n", "  public void test_contains_nonnull_set_yes() {\n", "    Iterable<String> set = Sets.newHashSet(\"a\", null, \"b\");\n", "    assertTrue(Iterables.contains(set, \"b\"));\n", "  }\n", "\n", "  public void test_contains_nonnull_set_no() {\n", "    Iterable<String> set = Sets.newHashSet(\"a\", \"b\");\n", "    assertFalse(Iterables.contains(set, \"c\"));\n", "  }\n", "\n", "  public void test_contains_nonnull_iterable_yes() {\n", "    Iterable<String> set = iterable(\"a\", null, \"b\");\n", "    assertTrue(Iterables.contains(set, \"b\"));\n", "  }\n", "\n", "  public void test_contains_nonnull_iterable_no() {\n", "    Iterable<String> set = iterable(\"a\", \"b\");\n", "    assertFalse(Iterables.contains(set, \"c\"));\n", "  }\n", "\n", "  public void testGetOnlyElement_noDefault_valid() {\n", "    Iterable<String> iterable = Collections.singletonList(\"foo\");\n", "    assertEquals(\"foo\", Iterables.getOnlyElement(iterable));\n", "  }\n", "\n", "  public void testGetOnlyElement_noDefault_empty() {\n", "    Iterable<String> iterable = Collections.emptyList();\n", "    try {\n", "      Iterables.getOnlyElement(iterable);\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testGetOnlyElement_noDefault_multiple() {\n", "    Iterable<String> iterable = asList(\"foo\", \"bar\");\n", "    try {\n", "      Iterables.getOnlyElement(iterable);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testGetOnlyElement_withDefault_singleton() {\n", "    Iterable<String> iterable = Collections.singletonList(\"foo\");\n", "    assertEquals(\"foo\", Iterables.getOnlyElement(iterable, \"bar\"));\n", "  }\n", "\n", "  public void testGetOnlyElement_withDefault_empty() {\n", "    Iterable<String> iterable = Collections.emptyList();\n", "    assertEquals(\"bar\", Iterables.getOnlyElement(iterable, \"bar\"));\n", "  }\n", "\n", "  public void testGetOnlyElement_withDefault_empty_null() {\n", "    Iterable<String> iterable = Collections.emptyList();\n", "    assertNull(Iterables.getOnlyElement(iterable, null));\n", "  }\n", "\n", "  public void testGetOnlyElement_withDefault_multiple() {\n", "    Iterable<String> iterable = asList(\"foo\", \"bar\");\n", "    try {\n", "      Iterables.getOnlyElement(iterable, \"x\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAny() {\n", "    List<String> list = newArrayList();\n", "    Predicate<String> predicate = Predicates.equalTo(\"pants\");\n", "\n", "    assertFalse(Iterables.any(list, predicate));\n", "    list.add(\"cool\");\n", "    assertFalse(Iterables.any(list, predicate));\n", "    list.add(\"pants\");\n", "    assertTrue(Iterables.any(list, predicate));\n", "  }\n", "\n", "  public void testAll() {\n", "    List<String> list = newArrayList();\n", "    Predicate<String> predicate = Predicates.equalTo(\"cool\");\n", "\n", "    assertTrue(Iterables.all(list, predicate));\n", "    list.add(\"cool\");\n", "    assertTrue(Iterables.all(list, predicate));\n", "    list.add(\"pants\");\n", "    assertFalse(Iterables.all(list, predicate));\n", "  }\n", "\n", "  public void testFind() {\n", "    Iterable<String> list = newArrayList(\"cool\", \"pants\");\n", "    assertEquals(\"cool\", Iterables.find(list, Predicates.equalTo(\"cool\")));\n", "    assertEquals(\"pants\", Iterables.find(list, Predicates.equalTo(\"pants\")));\n", "    try {\n", "      Iterables.find(list, Predicates.alwaysFalse());\n", "      fail();\n", "    } catch (NoSuchElementException e) {\n", "    }\n", "    assertEquals(\"cool\", Iterables.find(list, Predicates.alwaysTrue()));\n", "    assertCanIterateAgain(list);\n", "  }\n", "\n", "  public void testFind_withDefault() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    assertEquals(\"cool\",\n", "        Iterables.find(list, Predicates.equalTo(\"cool\"), \"woot\"));\n", "    assertEquals(\"pants\",\n", "        Iterables.find(list, Predicates.equalTo(\"pants\"), \"woot\"));\n", "    assertEquals(\"woot\", Iterables.find(list,\n", "        Predicates.alwaysFalse(), \"woot\"));\n", "    assertNull(Iterables.find(list, Predicates.alwaysFalse(), null));\n", "    assertEquals(\"cool\",\n", "        Iterables.find(list, Predicates.alwaysTrue(), \"woot\"));\n", "    assertCanIterateAgain(list);\n", "  }\n", "\n", "  public void testTryFind() {\n", "    Iterable<String> list = newArrayList(\"cool\", \"pants\");\n", "    assertThat(Iterables.tryFind(list, Predicates.equalTo(\"cool\"))).hasValue(\"cool\");\n", "    assertThat(Iterables.tryFind(list, Predicates.equalTo(\"pants\"))).hasValue(\"pants\");\n", "    assertThat(Iterables.tryFind(list, Predicates.alwaysTrue())).hasValue(\"cool\");\n", "    assertThat(Iterables.tryFind(list, Predicates.alwaysFalse())).isAbsent();\n", "    assertCanIterateAgain(list);\n", "  }\n", "\n", "  private static class TypeA {}\n", "  private interface TypeB {}\n", "  private static class HasBoth extends TypeA implements TypeB {}\n", "\n", "  public void testTransform() {\n", "    List<String> input = asList(\"1\", \"2\", \"3\");\n", "    Iterable<Integer> result = Iterables.transform(input,\n", "        new Function<String, Integer>() {\n", "          @Override\n", "          public Integer apply(String from) {\n", "            return Integer.valueOf(from);\n", "          }\n", "        });\n", "\n", "    List<Integer> actual = newArrayList(result);\n", "    List<Integer> expected = asList(1, 2, 3);\n", "    assertEquals(expected, actual);\n", "    assertCanIterateAgain(result);\n", "    assertEquals(\"[1, 2, 3]\", result.toString());\n", "  }\n", "\n", "  public void testPoorlyBehavedTransform() {\n", "    List<String> input = asList(\"1\", null, \"3\");\n", "    Iterable<Integer> result = Iterables.transform(input,\n", "        new Function<String, Integer>() {\n", "          @Override\n", "          public Integer apply(String from) {\n", "            return Integer.valueOf(from);\n", "          }\n", "        });\n", "\n", "    Iterator<Integer> resultIterator = result.iterator();\n", "    resultIterator.next();\n", "\n", "    try {\n", "      resultIterator.next();\n", "      fail(\"Expected NFE\");\n", "    } catch (NumberFormatException nfe) {\n", "      // Expected to fail.\n", "    }\n", "  }\n", "\n", "  public void testNullFriendlyTransform() {\n", "    List<Integer> input = asList(1, 2, null, 3);\n", "    Iterable<String> result = Iterables.transform(input,\n", "        new Function<Integer, String>() {\n", "          @Override\n", "          public String apply(Integer from) {\n", "            return String.valueOf(from);\n", "          }\n", "        });\n", "\n", "    List<String> actual = newArrayList(result);\n", "    List<String> expected = asList(\"1\", \"2\", \"null\", \"3\");\n", "    assertEquals(expected, actual);\n", "  }\n", "\n", "  // Far less exhaustive than the tests in IteratorsTest\n", "  public void testCycle() {\n", "    Iterable<String> cycle = Iterables.cycle(\"a\", \"b\");\n", "\n", "    int howManyChecked = 0;\n", "    for (String string : cycle) {\n", "      String expected = (howManyChecked % 2 == 0) ? \"a\" : \"b\";\n", "      assertEquals(expected, string);\n", "      if (howManyChecked++ == 5) {\n", "        break;\n", "      }\n", "    }\n", "\n", "    // We left the last iterator pointing to \"b\". But a new iterator should\n", "    // always point to \"a\".\n", "    for (String string : cycle) {\n", "      assertEquals(\"a\", string);\n", "      break;\n", "    }\n", "\n", "    assertEquals(\"[a, b] (cycled)\", cycle.toString());\n", "  }\n", "\n", "  // Again, the exhaustive tests are in IteratorsTest\n", "  public void testConcatIterable() {\n", "    List<Integer> list1 = newArrayList(1);\n", "    List<Integer> list2 = newArrayList(4);\n", "\n", "    @SuppressWarnings(\"unchecked\")\n", "    List<List<Integer>> input = newArrayList(list1, list2);\n", "\n", "    Iterable<Integer> result = Iterables.concat(input);\n", "    assertEquals(asList(1, 4), newArrayList(result));\n", "\n", "    // Now change the inputs and see result dynamically change as well\n", "\n", "    list1.add(2);\n", "    List<Integer> list3 = newArrayList(3);\n", "    input.add(1, list3);\n", "\n", "    assertEquals(asList(1, 2, 3, 4), newArrayList(result));\n", "    assertEquals(\"[1, 2, 3, 4]\", result.toString());\n", "  }\n", "\n", "  public void testConcatVarargs() {\n", "    List<Integer> list1 = newArrayList(1);\n", "    List<Integer> list2 = newArrayList(4);\n", "    List<Integer> list3 = newArrayList(7, 8);\n", "    List<Integer> list4 = newArrayList(9);\n", "    List<Integer> list5 = newArrayList(10);\n", "    @SuppressWarnings(\"unchecked\")\n", "    Iterable<Integer> result =\n", "        Iterables.concat(list1, list2, list3, list4, list5);\n", "    assertEquals(asList(1, 4, 7, 8, 9, 10), newArrayList(result));\n", "    assertEquals(\"[1, 4, 7, 8, 9, 10]\", result.toString());\n", "  }\n", "\n", "  public void testConcatNullPointerException() {\n", "    List<Integer> list1 = newArrayList(1);\n", "    List<Integer> list2 = newArrayList(4);\n", "\n", "    try {\n", "      Iterables.concat(list1, null, list2);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testConcatPeformingFiniteCycle() {\n", "    Iterable<Integer> iterable = asList(1, 2, 3);\n", "    int n = 4;\n", "    Iterable<Integer> repeated\n", "        = Iterables.concat(Collections.nCopies(n, iterable));\n", "    assertThat(repeated).containsExactly(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3).inOrder();\n", "  }\n", "\n", "  public void testPartition_badSize() {\n", "    Iterable<Integer> source = Collections.singleton(1);\n", "    try {\n", "      Iterables.partition(source, 0);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testPartition_empty() {\n", "    Iterable<Integer> source = Collections.emptySet();\n", "    Iterable<List<Integer>> partitions = Iterables.partition(source, 1);\n", "    assertTrue(Iterables.isEmpty(partitions));\n", "  }\n", "\n", "  public void testPartition_singleton1() {\n", "    Iterable<Integer> source = Collections.singleton(1);\n", "    Iterable<List<Integer>> partitions = Iterables.partition(source, 1);\n", "    assertEquals(1, Iterables.size(partitions));\n", "    assertEquals(Collections.singletonList(1), partitions.iterator().next());\n", "  }\n", "\n", "  public void testPartition_view() {\n", "    List<Integer> list = asList(1, 2);\n", "    Iterable<List<Integer>> partitions = Iterables.partition(list, 2);\n", "\n", "    // Changes before the partition is retrieved are reflected\n", "    list.set(0, 3);\n", "\n", "    Iterator<List<Integer>> iterator = partitions.iterator();\n", "\n", "    // Changes before the partition is retrieved are reflected\n", "    list.set(1, 4);\n", "\n", "    List<Integer> first = iterator.next();\n", "\n", "    // Changes after are not\n", "    list.set(0, 5);\n", "\n", "    assertEquals(ImmutableList.of(3, 4), first);\n", "  }\n", "\n", "  public void testPaddedPartition_basic() {\n", "    List<Integer> list = asList(1, 2, 3, 4, 5);\n", "    Iterable<List<Integer>> partitions = Iterables.paddedPartition(list, 2);\n", "    assertEquals(3, Iterables.size(partitions));\n", "    assertEquals(asList(5, null), Iterables.getLast(partitions));\n", "  }\n", "\n", "  public void testPaddedPartitionRandomAccessInput() {\n", "    Iterable<Integer> source = asList(1, 2, 3);\n", "    Iterable<List<Integer>> partitions = Iterables.paddedPartition(source, 2);\n", "    Iterator<List<Integer>> iterator = partitions.iterator();\n", "    assertTrue(iterator.next() instanceof RandomAccess);\n", "    assertTrue(iterator.next() instanceof RandomAccess);\n", "  }\n", "\n", "  public void testPaddedPartitionNonRandomAccessInput() {\n", "    Iterable<Integer> source = Lists.newLinkedList(asList(1, 2, 3));\n", "    Iterable<List<Integer>> partitions = Iterables.paddedPartition(source, 2);\n", "    Iterator<List<Integer>> iterator = partitions.iterator();\n", "    // Even though the input list doesn't implement RandomAccess, the output\n", "    // lists do.\n", "    assertTrue(iterator.next() instanceof RandomAccess);\n", "    assertTrue(iterator.next() instanceof RandomAccess);\n", "  }\n", "\n", "  // More tests in IteratorsTest\n", "  public void testAddAllToList() {\n", "    List<String> alreadyThere = newArrayList(\"already\", \"there\");\n", "    List<String> freshlyAdded = newArrayList(\"freshly\", \"added\");\n", "\n", "    boolean changed = Iterables.addAll(alreadyThere, freshlyAdded);\n", "    assertThat(alreadyThere).containsExactly(\n", "        \"already\", \"there\", \"freshly\", \"added\").inOrder();\n", "    assertTrue(changed);\n", "  }\n", "\n", "  private static void assertCanIterateAgain(Iterable<?> iterable) {\n", "    for (@SuppressWarnings(\"unused\") Object obj : iterable) {\n", "    }\n", "  }\n", "\n", "  // More exhaustive tests are in IteratorsTest.\n", "  public void testElementsEqual() throws Exception {\n", "    Iterable<?> a;\n", "    Iterable<?> b;\n", "\n", "    // A few elements.\n", "    a = asList(4, 8, 15, 16, 23, 42);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertTrue(Iterables.elementsEqual(a, b));\n", "\n", "    // An element differs.\n", "    a = asList(4, 8, 15, 12, 23, 42);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertFalse(Iterables.elementsEqual(a, b));\n", "\n", "    // null versus non-null.\n", "    a = asList(4, 8, 15, null, 23, 42);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertFalse(Iterables.elementsEqual(a, b));\n", "    assertFalse(Iterables.elementsEqual(b, a));\n", "\n", "    // Different lengths.\n", "    a = asList(4, 8, 15, 16, 23);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertFalse(Iterables.elementsEqual(a, b));\n", "    assertFalse(Iterables.elementsEqual(b, a));\n", "  }\n", "\n", "  public void testToString() {\n", "    List<String> list = Collections.emptyList();\n", "    assertEquals(\"[]\", Iterables.toString(list));\n", "\n", "    list = newArrayList(\"yam\", \"bam\", \"jam\", \"ham\");\n", "    assertEquals(\"[yam, bam, jam, ham]\", Iterables.toString(list));\n", "  }\n", "\n", "  public void testLimit() {\n", "    Iterable<String> iterable = newArrayList(\"foo\", \"bar\", \"baz\");\n", "    Iterable<String> limited = Iterables.limit(iterable, 2);\n", "\n", "    List<String> expected = ImmutableList.of(\"foo\", \"bar\");\n", "    List<String> actual = newArrayList(limited);\n", "    assertEquals(expected, actual);\n", "    assertCanIterateAgain(limited);\n", "    assertEquals(\"[foo, bar]\", limited.toString());\n", "  }\n", "\n", "  public void testLimit_illegalArgument() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    try {\n", "      Iterables.limit(list, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testIsEmpty() {\n", "    Iterable<String> emptyList = Collections.emptyList();\n", "    assertTrue(Iterables.isEmpty(emptyList));\n", "\n", "    Iterable<String> singletonList = Collections.singletonList(\"foo\");\n", "    assertFalse(Iterables.isEmpty(singletonList));\n", "  }\n", "\n", "  public void testSkip_simple() {\n", "    Collection<String> set = ImmutableSet.of(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertEquals(newArrayList(\"c\", \"d\", \"e\"), newArrayList(skip(set, 2)));\n", "    assertEquals(\"[c, d, e]\", skip(set, 2).toString());\n", "  }\n", "\n", "  public void testSkip_simpleList() {\n", "    Collection<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertEquals(newArrayList(\"c\", \"d\", \"e\"), newArrayList(skip(list, 2)));\n", "    assertEquals(\"[c, d, e]\", skip(list, 2).toString());\n", "  }\n", "\n", "  public void testSkip_pastEnd() {\n", "    Collection<String> set = ImmutableSet.of(\"a\", \"b\");\n", "    assertEquals(emptyList(), newArrayList(skip(set, 20)));\n", "  }\n", "\n", "  public void testSkip_pastEndList() {\n", "    Collection<String> list = newArrayList(\"a\", \"b\");\n", "    assertEquals(emptyList(), newArrayList(skip(list, 20)));\n", "  }\n", "\n", "  public void testSkip_skipNone() {\n", "    Collection<String> set = ImmutableSet.of(\"a\", \"b\");\n", "    assertEquals(newArrayList(\"a\", \"b\"), newArrayList(skip(set, 0)));\n", "  }\n", "\n", "  public void testSkip_skipNoneList() {\n", "    Collection<String> list = newArrayList(\"a\", \"b\");\n", "    assertEquals(newArrayList(\"a\", \"b\"), newArrayList(skip(list, 0)));\n", "  }\n", "\n", "  public void testSkip_removal() {\n", "    Collection<String> set = Sets.newHashSet(\"a\", \"b\");\n", "    Iterator<String> iterator = skip(set, 2).iterator();\n", "    try {\n", "      iterator.next();\n", "    } catch (NoSuchElementException suppressed) {\n", "      // We want remove() to fail even after a failed call to next().\n", "    }\n", "    try {\n", "      iterator.remove();\n", "      fail(\"Expected IllegalStateException\");\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testSkip_allOfMutableList_modifiable() {\n", "    List<String> list = newArrayList(\"a\", \"b\");\n", "    Iterator<String> iterator = skip(list, 2).iterator();\n", "    try {\n", "      iterator.remove();\n", "      fail(\"Expected IllegalStateException\");\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testSkip_allOfImmutableList_modifiable() {\n", "    List<String> list = ImmutableList.of(\"a\", \"b\");\n", "    Iterator<String> iterator = skip(list, 2).iterator();\n", "    try {\n", "      iterator.remove();\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "  }\n", "\n", "  public void testSkip_nonStructurallyModifiedList() throws Exception {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    Iterable<String> tail = skip(list, 1);\n", "    Iterator<String> tailIterator = tail.iterator();\n", "    list.set(2, \"C\");\n", "    assertEquals(\"b\", tailIterator.next());\n", "    assertEquals(\"C\", tailIterator.next());\n", "    assertFalse(tailIterator.hasNext());\n", "  }\n", "\n", "  public void testSkip_structurallyModifiedSkipSome() throws Exception {\n", "    Collection<String> set = newLinkedHashSet(asList(\"a\", \"b\", \"c\"));\n", "    Iterable<String> tail = skip(set, 1);\n", "    set.remove(\"b\");\n", "    set.addAll(newArrayList(\"A\", \"B\", \"C\"));\n", "    assertThat(tail).containsExactly(\"c\", \"A\", \"B\", \"C\").inOrder();\n", "  }\n", "\n", "  public void testSkip_structurallyModifiedSkipSomeList() throws Exception {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    Iterable<String> tail = skip(list, 1);\n", "    list.subList(1, 3).clear();\n", "    list.addAll(0, newArrayList(\"A\", \"B\", \"C\"));\n", "    assertThat(tail).containsExactly(\"B\", \"C\", \"a\").inOrder();\n", "  }\n", "\n", "  public void testSkip_structurallyModifiedSkipAll() throws Exception {\n", "    Collection<String> set = newLinkedHashSet(asList(\"a\", \"b\", \"c\"));\n", "    Iterable<String> tail = skip(set, 2);\n", "    set.remove(\"a\");\n", "    set.remove(\"b\");\n", "    assertFalse(tail.iterator().hasNext());\n", "  }\n", "\n", "  public void testSkip_structurallyModifiedSkipAllList() throws Exception {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    Iterable<String> tail = skip(list, 2);\n", "    list.subList(0, 2).clear();\n", "    assertTrue(Iterables.isEmpty(tail));\n", "  }\n", "\n", "  public void testSkip_illegalArgument() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    try {\n", "      skip(list, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  private void testGetOnAbc(Iterable<String> iterable) {\n", "    try {\n", "      Iterables.get(iterable, -1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    assertEquals(\"a\", Iterables.get(iterable, 0));\n", "    assertEquals(\"b\", Iterables.get(iterable, 1));\n", "    assertEquals(\"c\", Iterables.get(iterable, 2));\n", "    try {\n", "      Iterables.get(iterable, 3);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException nsee) {}\n", "    try {\n", "      Iterables.get(iterable, 4);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException nsee) {}\n", "  }\n", "\n", "  private void testGetOnEmpty(Iterable<String> iterable) {\n", "    try {\n", "      Iterables.get(iterable, 0);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "  }\n", "\n", "  public void testGet_list() {\n", "    testGetOnAbc(newArrayList(\"a\", \"b\", \"c\"));\n", "  }\n", "\n", "  public void testGet_emptyList() {\n", "    testGetOnEmpty(Collections.<String>emptyList());\n", "  }\n", "\n", "  public void testGet_sortedSet() {\n", "    testGetOnAbc(ImmutableSortedSet.of(\"b\", \"c\", \"a\"));\n", "  }\n", "\n", "  public void testGet_emptySortedSet() {\n", "    testGetOnEmpty(ImmutableSortedSet.<String>of());\n", "  }\n", "\n", "  public void testGet_iterable() {\n", "    testGetOnAbc(ImmutableSet.of(\"a\", \"b\", \"c\"));\n", "  }\n", "\n", "  public void testGet_emptyIterable() {\n", "    testGetOnEmpty(Sets.<String>newHashSet());\n", "  }\n", "\n", "  public void testGet_withDefault_negativePosition() {\n", "    try {\n", "      Iterables.get(newArrayList(\"a\", \"b\", \"c\"), -1, \"d\");\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      // pass\n", "    }\n", "  }\n", "\n", "  public void testGet_withDefault_simple() {\n", "    ArrayList<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    assertEquals(\"b\", Iterables.get(list, 1, \"d\"));\n", "  }\n", "\n", "  public void testGet_withDefault_iterable() {\n", "    Set<String> set = ImmutableSet.of(\"a\", \"b\", \"c\");\n", "    assertEquals(\"b\", Iterables.get(set, 1, \"d\"));\n", "  }\n", "\n", "  public void testGet_withDefault_last() {\n", "    ArrayList<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    assertEquals(\"c\", Iterables.get(list, 2, \"d\"));\n", "  }\n", "\n", "  public void testGet_withDefault_lastPlusOne() {\n", "    ArrayList<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    assertEquals(\"d\", Iterables.get(list, 3, \"d\"));\n", "  }\n", "\n", "  public void testGet_withDefault_doesntIterate() {\n", "    List<String> list = new DiesOnIteratorArrayList();\n", "    list.add(\"a\");\n", "    assertEquals(\"a\", Iterables.get(list, 0, \"b\"));\n", "  }\n", "\n", "  public void testGetFirst_withDefault_singleton() {\n", "    Iterable<String> iterable = Collections.singletonList(\"foo\");\n", "    assertEquals(\"foo\", Iterables.getFirst(iterable, \"bar\"));\n", "  }\n", "\n", "  public void testGetFirst_withDefault_empty() {\n", "    Iterable<String> iterable = Collections.emptyList();\n", "    assertEquals(\"bar\", Iterables.getFirst(iterable, \"bar\"));\n", "  }\n", "\n", "  public void testGetFirst_withDefault_empty_null() {\n", "    Iterable<String> iterable = Collections.emptyList();\n", "    assertNull(Iterables.getFirst(iterable, null));\n", "  }\n", "\n", "  public void testGetFirst_withDefault_multiple() {\n", "    Iterable<String> iterable = asList(\"foo\", \"bar\");\n", "    assertEquals(\"foo\", Iterables.getFirst(iterable, \"qux\"));\n", "  }\n", "\n", "  public void testGetLast_list() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    assertEquals(\"c\", Iterables.getLast(list));\n", "  }\n", "\n", "  public void testGetLast_emptyList() {\n", "    List<String> list = Collections.emptyList();\n", "    try {\n", "      Iterables.getLast(list);\n", "      fail();\n", "    } catch (NoSuchElementException e) {}\n", "  }\n", "\n", "  public void testGetLast_sortedSet() {\n", "    SortedSet<String> sortedSet = ImmutableSortedSet.of(\"b\", \"c\", \"a\");\n", "    assertEquals(\"c\", Iterables.getLast(sortedSet));\n", "  }\n", "\n", "  public void testGetLast_withDefault_singleton() {\n", "    Iterable<String> iterable = Collections.singletonList(\"foo\");\n", "    assertEquals(\"foo\", Iterables.getLast(iterable, \"bar\"));\n", "  }\n", "\n", "  public void testGetLast_withDefault_empty() {\n", "    Iterable<String> iterable = Collections.emptyList();\n", "    assertEquals(\"bar\", Iterables.getLast(iterable, \"bar\"));\n", "  }\n", "\n", "  public void testGetLast_withDefault_empty_null() {\n", "    Iterable<String> iterable = Collections.emptyList();\n", "    assertNull(Iterables.getLast(iterable, null));\n", "  }\n", "\n", "  public void testGetLast_withDefault_multiple() {\n", "    Iterable<String> iterable = asList(\"foo\", \"bar\");\n", "    assertEquals(\"bar\", Iterables.getLast(iterable, \"qux\"));\n", "  }\n", "\n", "  /**\n", "   * {@link ArrayList} extension that forbids the use of\n", "   * {@link Collection#iterator} for tests that need to prove that it isn't\n", "   * called.\n", "   */\n", "  private static class DiesOnIteratorArrayList extends ArrayList<String> {\n", "    /**\n", "     * @throws UnsupportedOperationException all the time\n", "     */\n", "    @Override\n", "    public Iterator<String> iterator() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "  }\n", "\n", "  public void testGetLast_withDefault_not_empty_list() {\n", "    // TODO: verify that this is the best testing strategy.\n", "    List<String> diesOnIteratorList = new DiesOnIteratorArrayList();\n", "    diesOnIteratorList.add(\"bar\");\n", "\n", "    assertEquals(\"bar\", Iterables.getLast(diesOnIteratorList, \"qux\"));\n", "  }\n", "\n", "  /**\n", "   * {@link TreeSet} extension that forbids the use of\n", "   * {@link Collection#iterator} for tests that need to prove that it isn't\n", "   * called.\n", "   */\n", "  private static final class DiesOnIteratorTreeSet extends TreeSet<String> {\n", "    /**\n", "     * @throws UnsupportedOperationException all the time\n", "     */\n", "    @Override\n", "    public Iterator<String> iterator() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "  }\n", "\n", "  public void testGetLast_emptySortedSet() {\n", "    SortedSet<String> sortedSet = ImmutableSortedSet.of();\n", "    try {\n", "      Iterables.getLast(sortedSet);\n", "      fail();\n", "    } catch (NoSuchElementException e) {}\n", "  }\n", "\n", "  public void testGetLast_iterable() {\n", "    Set<String> set = ImmutableSet.of(\"a\", \"b\", \"c\");\n", "    assertEquals(\"c\", Iterables.getLast(set));\n", "  }\n", "\n", "  public void testGetLast_emptyIterable() {\n", "    Set<String> set = Sets.newHashSet();\n", "    try {\n", "      Iterables.getLast(set);\n", "      fail();\n", "    } catch (NoSuchElementException e) {}\n", "  }\n", "\n", "  public void testUnmodifiableIterable() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    Iterable<String> iterable = Iterables.unmodifiableIterable(list);\n", "    Iterator<String> iterator = iterable.iterator();\n", "    iterator.next();\n", "    try {\n", "      iterator.remove();\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertEquals(\"[a, b, c]\", iterable.toString());\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\") // test of deprecated method\n", "  public void testUnmodifiableIterableShortCircuit() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    Iterable<String> iterable = Iterables.unmodifiableIterable(list);\n", "    Iterable<String> iterable2 = Iterables.unmodifiableIterable(iterable);\n", "    assertSame(iterable, iterable2);\n", "    ImmutableList<String> immutableList = ImmutableList.of(\"a\", \"b\", \"c\");\n", "    assertSame(immutableList, Iterables.unmodifiableIterable(immutableList));\n", "    assertSame(immutableList,\n", "        Iterables.unmodifiableIterable((List<String>) immutableList));\n", "  }\n", "\n", "  public void testFrequency_multiset() {\n", "    Multiset<String> multiset\n", "        = ImmutableMultiset.of(\"a\", \"b\", \"a\", \"c\", \"b\", \"a\");\n", "    assertEquals(3, Iterables.frequency(multiset, \"a\"));\n", "    assertEquals(2, Iterables.frequency(multiset, \"b\"));\n", "    assertEquals(1, Iterables.frequency(multiset, \"c\"));\n", "    assertEquals(0, Iterables.frequency(multiset, \"d\"));\n", "    assertEquals(0, Iterables.frequency(multiset, 4.2));\n", "    assertEquals(0, Iterables.frequency(multiset, null));\n", "  }\n", "\n", "  public void testFrequency_set() {\n", "    Set<String> set = Sets.newHashSet(\"a\", \"b\", \"c\");\n", "    assertEquals(1, Iterables.frequency(set, \"a\"));\n", "    assertEquals(1, Iterables.frequency(set, \"b\"));\n", "    assertEquals(1, Iterables.frequency(set, \"c\"));\n", "    assertEquals(0, Iterables.frequency(set, \"d\"));\n", "    assertEquals(0, Iterables.frequency(set, 4.2));\n", "    assertEquals(0, Iterables.frequency(set, null));\n", "  }\n", "\n", "  public void testFrequency_list() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"a\", \"c\", \"b\", \"a\");\n", "    assertEquals(3, Iterables.frequency(list, \"a\"));\n", "    assertEquals(2, Iterables.frequency(list, \"b\"));\n", "    assertEquals(1, Iterables.frequency(list, \"c\"));\n", "    assertEquals(0, Iterables.frequency(list, \"d\"));\n", "    assertEquals(0, Iterables.frequency(list, 4.2));\n", "    assertEquals(0, Iterables.frequency(list, null));\n", "  }\n", "\n", "  public void testRemoveAll_collection() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertTrue(Iterables.removeAll(list, newArrayList(\"b\", \"d\", \"f\")));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "    assertFalse(Iterables.removeAll(list, newArrayList(\"x\", \"y\", \"z\")));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "  }\n", "\n", "  public void testRemoveAll_iterable() {\n", "    final List<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    Iterable<String> iterable = new Iterable<String>() {\n", "      @Override\n", "      public Iterator<String> iterator() {\n", "        return list.iterator();\n", "      }\n", "    };\n", "    assertTrue(Iterables.removeAll(iterable, newArrayList(\"b\", \"d\", \"f\")));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "    assertFalse(Iterables.removeAll(iterable, newArrayList(\"x\", \"y\", \"z\")));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "  }\n", "\n", "  public void testRetainAll_collection() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertTrue(Iterables.retainAll(list, newArrayList(\"b\", \"d\", \"f\")));\n", "    assertEquals(newArrayList(\"b\", \"d\"), list);\n", "    assertFalse(Iterables.retainAll(list, newArrayList(\"b\", \"e\", \"d\")));\n", "    assertEquals(newArrayList(\"b\", \"d\"), list);\n", "  }\n", "\n", "  public void testRetainAll_iterable() {\n", "    final List<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    Iterable<String> iterable = new Iterable<String>() {\n", "      @Override\n", "      public Iterator<String> iterator() {\n", "        return list.iterator();\n", "      }\n", "    };\n", "    assertTrue(Iterables.retainAll(iterable, newArrayList(\"b\", \"d\", \"f\")));\n", "    assertEquals(newArrayList(\"b\", \"d\"), list);\n", "    assertFalse(Iterables.retainAll(iterable, newArrayList(\"b\", \"e\", \"d\")));\n", "    assertEquals(newArrayList(\"b\", \"d\"), list);\n", "  }\n", "\n", "  public void testRemoveIf_randomAccess() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertTrue(Iterables.removeIf(list,\n", "        new Predicate<String>() {\n", "          @Override\n", "          public boolean apply(String s) {\n", "            return s.equals(\"b\") || s.equals(\"d\") || s.equals(\"f\");\n", "          }\n", "        }));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "    assertFalse(Iterables.removeIf(list,\n", "        new Predicate<String>() {\n", "          @Override\n", "          public boolean apply(String s) {\n", "            return s.equals(\"x\") || s.equals(\"y\") || s.equals(\"z\");\n", "          }\n", "        }));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "  }\n", "\n", "  public void testRemoveIf_transformedList() {\n", "    List<String> list = newArrayList(\"1\", \"2\", \"3\", \"4\", \"5\");\n", "    List<Integer> transformed = Lists.transform(list,\n", "        new Function<String, Integer>() {\n", "          @Override\n", "          public Integer apply(String s) {\n", "            return Integer.valueOf(s);\n", "          }\n", "        });\n", "    assertTrue(Iterables.removeIf(transformed,\n", "        new Predicate<Integer>() {\n", "          @Override\n", "          public boolean apply(Integer n) {\n", "            return (n & 1) == 0;  // isEven()\n", "          }\n", "        }));\n", "    assertEquals(newArrayList(\"1\", \"3\", \"5\"), list);\n", "    assertFalse(Iterables.removeIf(transformed,\n", "        new Predicate<Integer>() {\n", "          @Override\n", "          public boolean apply(Integer n) {\n", "            return (n & 1) == 0;  // isEven()\n", "          }\n", "        }));\n", "    assertEquals(newArrayList(\"1\", \"3\", \"5\"), list);\n", "  }\n", "\n", "  public void testRemoveIf_noRandomAccess() {\n", "    List<String> list = Lists.newLinkedList(asList(\"a\", \"b\", \"c\", \"d\", \"e\"));\n", "    assertTrue(Iterables.removeIf(list,\n", "        new Predicate<String>() {\n", "          @Override\n", "          public boolean apply(String s) {\n", "            return s.equals(\"b\") || s.equals(\"d\") || s.equals(\"f\");\n", "          }\n", "        }));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "    assertFalse(Iterables.removeIf(list,\n", "        new Predicate<String>() {\n", "          @Override\n", "          public boolean apply(String s) {\n", "            return s.equals(\"x\") || s.equals(\"y\") || s.equals(\"z\");\n", "          }\n", "        }));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "  }\n", "\n", "  // The Maps returned by Maps.filterEntries(), Maps.filterKeys(), and\n", "  // Maps.filterValues() are not tested with removeIf() since Maps are not\n", "  // Iterable.  Those returned by Iterators.filter() and Iterables.filter()\n", "  // are not tested because they are unmodifiable.\n", "\n", "  public void testIterableWithToString() {\n", "    assertEquals(\"[]\", create().toString());\n", "    assertEquals(\"[a]\", create(\"a\").toString());\n", "    assertEquals(\"[a, b, c]\", create(\"a\", \"b\", \"c\").toString());\n", "    assertEquals(\"[c, a, a]\", create(\"c\", \"a\", \"a\").toString());\n", "  }\n", "\n", "  public void testIterableWithToStringNull() {\n", "    assertEquals(\"[null]\", create((String) null).toString());\n", "    assertEquals(\"[null, null]\", create(null, null).toString());\n", "    assertEquals(\"[, null, a]\", create(\"\", null, \"a\").toString());\n", "  }\n", "\n", "  /** Returns a new iterable over the specified strings. */\n", "  private static Iterable<String> create(String... strings) {\n", "    final List<String> list = asList(strings);\n", "    return new FluentIterable<String>() {\n", "      @Override\n", "      public Iterator<String> iterator() {\n", "        return list.iterator();\n", "      }\n", "    };\n", "  }\n", "\n", "  public void testConsumingIterable() {\n", "    // Test data\n", "    List<String> list = Lists.newArrayList(asList(\"a\", \"b\"));\n", "\n", "    // Test & Verify\n", "    Iterable<String> consumingIterable = Iterables.consumingIterable(list);\n", "    assertEquals(\"Iterables.consumingIterable(...)\", consumingIterable.toString());\n", "    Iterator<String> consumingIterator = consumingIterable.iterator();\n", "\n", "    assertThat(list).containsExactly(\"a\", \"b\").inOrder();\n", "\n", "    assertTrue(consumingIterator.hasNext());\n", "    assertThat(list).containsExactly(\"a\", \"b\").inOrder();\n", "    assertEquals(\"a\", consumingIterator.next());\n", "    assertThat(list).contains(\"b\");\n", "\n", "    assertTrue(consumingIterator.hasNext());\n", "    assertEquals(\"b\", consumingIterator.next());\n", "    assertThat(list).isEmpty();\n", "\n", "    assertFalse(consumingIterator.hasNext());\n", "  }\n", "\n", "  public void testConsumingIterable_queue_iterator() {\n", "    final List<Integer> items = ImmutableList.of(4, 8, 15, 16, 23, 42);\n", "    new IteratorTester<Integer>(\n", "        3,\n", "        UNMODIFIABLE,\n", "        items,\n", "        IteratorTester.KnownOrder.KNOWN_ORDER) {\n", "      @Override protected Iterator<Integer> newTargetIterator() {\n", "        return Iterables.consumingIterable(Lists.newLinkedList(items))\n", "            .iterator();\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  public void testConsumingIterable_queue_removesFromQueue() {\n", "    Queue<Integer> queue = Lists.newLinkedList(asList(5, 14));\n", "\n", "    Iterator<Integer> consumingIterator =\n", "        Iterables.consumingIterable(queue).iterator();\n", "\n", "    assertEquals(5, queue.peek().intValue());\n", "    assertEquals(5, consumingIterator.next().intValue());\n", "\n", "    assertEquals(14, queue.peek().intValue());\n", "    assertTrue(consumingIterator.hasNext());\n", "    assertTrue(queue.isEmpty());\n", "  }\n", "\n", "  public void testConsumingIterable_noIteratorCall() {\n", "    Queue<Integer> queue =\n", "        new UnIterableQueue<Integer>(Lists.newLinkedList(asList(5, 14)));\n", "\n", "    Iterator<Integer> consumingIterator =\n", "        Iterables.consumingIterable(queue).iterator();\n", "    /*\n", "     * Make sure that we can get an element off without calling\n", "     * UnIterableQueue.iterator().\n", "     */\n", "    assertEquals(5, consumingIterator.next().intValue());\n", "  }\n", "\n", "  private static class UnIterableQueue<T> extends ForwardingQueue<T> {\n", "    private Queue<T> queue;\n", "\n", "    UnIterableQueue(Queue<T> queue) {\n", "      this.queue = queue;\n", "    }\n", "\n", "    @Override public Iterator<T> iterator() {\n", "      throw new UnsupportedOperationException();\n", "    }\n", "\n", "    @Override protected Queue<T> delegate() {\n", "      return queue;\n", "    }\n", "  }\n", "\n", "  public void testIndexOf_empty() {\n", "    List<String> list = new ArrayList<String>();\n", "    assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo(\"\")));\n", "  }\n", "\n", "  public void testIndexOf_oneElement() {\n", "    List<String> list = Lists.newArrayList(\"bob\");\n", "    assertEquals(0, Iterables.indexOf(list, Predicates.equalTo(\"bob\")));\n", "    assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo(\"jack\")));\n", "  }\n", "\n", "  public void testIndexOf_twoElements() {\n", "    List<String> list = Lists.newArrayList(\"mary\", \"bob\");\n", "    assertEquals(0, Iterables.indexOf(list, Predicates.equalTo(\"mary\")));\n", "    assertEquals(1, Iterables.indexOf(list, Predicates.equalTo(\"bob\")));\n", "    assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo(\"jack\")));\n", "  }\n", "\n", "  public void testIndexOf_withDuplicates() {\n", "    List<String> list =\n", "        Lists.newArrayList(\"mary\", \"bob\", \"bob\", \"bob\", \"sam\");\n", "    assertEquals(0, Iterables.indexOf(list, Predicates.equalTo(\"mary\")));\n", "    assertEquals(1, Iterables.indexOf(list, Predicates.equalTo(\"bob\")));\n", "    assertEquals(4, Iterables.indexOf(list, Predicates.equalTo(\"sam\")));\n", "    assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo(\"jack\")));\n", "  }\n", "\n", "  private static final Predicate<CharSequence> STARTSWITH_A =\n", "      new Predicate<CharSequence>() {\n", "        @Override public boolean apply(CharSequence input) {\n", "          return (input.length() > 0) && (input.charAt(0) == 'a');\n", "        }\n", "      };\n", "\n", "  public void testIndexOf_genericPredicate() {\n", "    List<CharSequence> sequences = Lists.newArrayList();\n", "    sequences.add(\"bob\");\n", "    sequences.add(new StringBuilder(\"charlie\"));\n", "    sequences.add(new StringBuffer(\"henry\"));\n", "    sequences.add(new StringBuilder(\"apple\"));\n", "    sequences.add(\"lemon\");\n", "\n", "    assertEquals(3, Iterables.indexOf(sequences, STARTSWITH_A));\n", "  }\n", "\n", "  public void testIndexOf_genericPredicate2() {\n", "    List<String> sequences =\n", "        Lists.newArrayList(\"bob\", \"charlie\", \"henry\", \"apple\", \"lemon\");\n", "    assertEquals(3, Iterables.indexOf(sequences, STARTSWITH_A));\n", "  }\n", "\n", "  public void testMergeSorted_empty() {\n", "    // Setup\n", "    Iterable<Iterable<Integer>> elements = ImmutableList.of();\n", "\n", "    // Test\n", "    Iterable<Integer> iterable =\n", "        Iterables.mergeSorted(elements, Ordering.natural());\n", "\n", "    // Verify\n", "    Iterator<Integer> iterator = iterable.iterator();\n", "    assertFalse(iterator.hasNext());\n", "    try {\n", "      iterator.next();\n", "      fail(\"next() on empty iterator should throw NoSuchElementException\");\n", "    } catch (NoSuchElementException e) {\n", "      // Huzzah!\n", "    }\n", "  }\n", "\n", "  public void testMergeSorted_single_empty() {\n", "    // Setup\n", "    Iterable<Integer> iterable0 = ImmutableList.of();\n", "    Iterable<Iterable<Integer>> iterables = ImmutableList.of(iterable0);\n", "\n", "    // Test & Verify\n", "    verifyMergeSorted(iterables, ImmutableList.<Integer>of());\n", "  }\n", "\n", "  public void testMergeSorted_single() {\n", "    // Setup\n", "    Iterable<Integer> iterable0 = ImmutableList.of(1, 2, 3);\n", "    Iterable<Iterable<Integer>> iterables = ImmutableList.of(iterable0);\n", "\n", "    // Test & Verify\n", "    verifyMergeSorted(iterables, iterable0);\n", "  }\n", "\n", "  public void testMergeSorted_pyramid() {\n", "    List<Iterable<Integer>> iterables = Lists.newLinkedList();\n", "    List<Integer> allIntegers = Lists.newArrayList();\n", "\n", "    // Creates iterators like: {{}, {0}, {0, 1}, {0, 1, 2}, ...}\n", "    for (int i = 0; i < 10; i++) {\n", "      List<Integer> list = Lists.newLinkedList();\n", "      for (int j = 0; j < i; j++) {\n", "        list.add(j);\n", "        allIntegers.add(j);\n", "      }\n", "      iterables.add(Ordering.natural().sortedCopy(list));\n", "    }\n", "\n", "    verifyMergeSorted(iterables, allIntegers);\n", "  }\n", "\n", "  // Like the pyramid, but creates more unique values, along with repeated ones.\n", "  public void testMergeSorted_skipping_pyramid() {\n", "    List<Iterable<Integer>> iterables = Lists.newLinkedList();\n", "    List<Integer> allIntegers = Lists.newArrayList();\n", "\n", "    for (int i = 0; i < 20; i++) {\n", "      List<Integer> list = Lists.newLinkedList();\n", "      for (int j = 0; j < i; j++) {\n", "        list.add(j * i);\n", "        allIntegers.add(j * i);\n", "      }\n", "      iterables.add(Ordering.natural().sortedCopy(list));\n", "    }\n", "\n", "    verifyMergeSorted(iterables, allIntegers);\n", "  }\n", "\n", "  private static void verifyMergeSorted(Iterable<Iterable<Integer>> iterables,\n", "      Iterable<Integer> unsortedExpected) {\n", "    Iterable<Integer> expected =\n", "        Ordering.natural().sortedCopy(unsortedExpected);\n", "\n", "    Iterable<Integer> mergedIterator =\n", "        Iterables.mergeSorted(iterables, Ordering.natural());\n", "\n", "    assertEquals(Lists.newLinkedList(expected),\n", "        Lists.newLinkedList(mergedIterator));\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243]}}, {"117": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/IteratorsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.CollectPreconditions.checkRemove;\n", "import static com.google.common.collect.Iterators.advance;\n", "import static com.google.common.collect.Iterators.get;\n", "import static com.google.common.collect.Iterators.getLast;\n", "import static com.google.common.collect.Lists.newArrayList;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Predicate;\n", "import com.google.common.base.Predicates;\n", "\n", "import junit.framework.AssertionFailedError;\n", "import junit.framework.TestCase;\n", "\n", "import java.util.ArrayList;\n", "import java.util.Collections;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Enumeration;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.NoSuchElementException;\n", "import java.util.RandomAccess;\n", "import java.util.Set;\n", "import java.util.Vector;\n", "\n", "/**\n", " * Unit test for {@code Iterators}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class IteratorsTest extends TestCase {\n", "\n", "  public void testEmptyIterator() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    assertFalse(iterator.hasNext());\n", "    try {\n", "      iterator.next();\n", "      fail(\"no exception thrown\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "    try {\n", "      iterator.remove();\n", "      fail(\"no exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testEmptyListIterator() {\n", "    ListIterator<String> iterator = Iterators.emptyListIterator();\n", "    assertFalse(iterator.hasNext());\n", "    assertFalse(iterator.hasPrevious());\n", "    assertEquals(0, iterator.nextIndex());\n", "    assertEquals(-1, iterator.previousIndex());\n", "    try {\n", "      iterator.next();\n", "      fail(\"no exception thrown\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "    try {\n", "      iterator.previous();\n", "      fail(\"no exception thrown\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "    try {\n", "      iterator.remove();\n", "      fail(\"no exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      iterator.set(\"a\");\n", "      fail(\"no exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      iterator.add(\"a\");\n", "      fail(\"no exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testEmptyModifiableIterator() {\n", "    Iterator<String> iterator = Iterators.emptyModifiableIterator();\n", "    assertFalse(iterator.hasNext());\n", "    try {\n", "      iterator.next();\n", "      fail(\"Expected NoSuchElementException\");\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "    try {\n", "      iterator.remove();\n", "      fail(\"Expected IllegalStateException\");\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  public void testSize0() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    assertEquals(0, Iterators.size(iterator));\n", "  }\n", "\n", "  public void testSize1() {\n", "    Iterator<Integer> iterator = Collections.singleton(0).iterator();\n", "    assertEquals(1, Iterators.size(iterator));\n", "  }\n", "\n", "  public void testSize_partiallyConsumed() {\n", "    Iterator<Integer> iterator = asList(1, 2, 3, 4, 5).iterator();\n", "    iterator.next();\n", "    iterator.next();\n", "    assertEquals(3, Iterators.size(iterator));\n", "  }\n", "\n", "  public void test_contains_nonnull_yes() {\n", "    Iterator<String> set = asList(\"a\", null, \"b\").iterator();\n", "    assertTrue(Iterators.contains(set, \"b\"));\n", "  }\n", "\n", "  public void test_contains_nonnull_no() {\n", "    Iterator<String> set = asList(\"a\", \"b\").iterator();\n", "    assertFalse(Iterators.contains(set, \"c\"));\n", "  }\n", "\n", "  public void test_contains_null_yes() {\n", "    Iterator<String> set = asList(\"a\", null, \"b\").iterator();\n", "    assertTrue(Iterators.contains(set, null));\n", "  }\n", "\n", "  public void test_contains_null_no() {\n", "    Iterator<String> set = asList(\"a\", \"b\").iterator();\n", "    assertFalse(Iterators.contains(set, null));\n", "  }\n", "\n", "  public void testGetOnlyElement_noDefault_valid() {\n", "    Iterator<String> iterator = Collections.singletonList(\"foo\").iterator();\n", "    assertEquals(\"foo\", Iterators.getOnlyElement(iterator));\n", "  }\n", "\n", "  public void testGetOnlyElement_noDefault_empty() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    try {\n", "      Iterators.getOnlyElement(iterator);\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testGetOnlyElement_noDefault_moreThanOneLessThanFiveElements() {\n", "    Iterator<String> iterator = asList(\"one\", \"two\").iterator();\n", "    try {\n", "      Iterators.getOnlyElement(iterator);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected).hasMessage(\"expected one element but was: <one, two>\");\n", "    }\n", "  }\n", "\n", "  public void testGetOnlyElement_noDefault_fiveElements() {\n", "    Iterator<String> iterator =\n", "        asList(\"one\", \"two\", \"three\", \"four\", \"five\").iterator();\n", "    try {\n", "      Iterators.getOnlyElement(iterator);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected)\n", "          .hasMessage(\"expected one element but was: <one, two, three, four, five>\");\n", "    }\n", "  }\n", "\n", "  public void testGetOnlyElement_noDefault_moreThanFiveElements() {\n", "    Iterator<String> iterator =\n", "        asList(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\").iterator();\n", "    try {\n", "      Iterators.getOnlyElement(iterator);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected)\n", "          .hasMessage(\"expected one element but was: <one, two, three, four, five, ...>\");\n", "    }\n", "  }\n", "\n", "  public void testGetOnlyElement_withDefault_singleton() {\n", "    Iterator<String> iterator = Collections.singletonList(\"foo\").iterator();\n", "    assertEquals(\"foo\", Iterators.getOnlyElement(iterator, \"bar\"));\n", "  }\n", "\n", "  public void testGetOnlyElement_withDefault_empty() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    assertEquals(\"bar\", Iterators.getOnlyElement(iterator, \"bar\"));\n", "  }\n", "\n", "  public void testGetOnlyElement_withDefault_empty_null() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    assertNull(Iterators.getOnlyElement(iterator, null));\n", "  }\n", "\n", "  public void testGetOnlyElement_withDefault_two() {\n", "    Iterator<String> iterator = asList(\"foo\", \"bar\").iterator();\n", "    try {\n", "      Iterators.getOnlyElement(iterator, \"x\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected).hasMessage(\"expected one element but was: <foo, bar>\");\n", "    }\n", "  }\n", "\n", "  public void testFilterSimple() {\n", "    Iterator<String> unfiltered = Lists.newArrayList(\"foo\", \"bar\").iterator();\n", "    Iterator<String> filtered = Iterators.filter(unfiltered,\n", "                                                 Predicates.equalTo(\"foo\"));\n", "    List<String> expected = Collections.singletonList(\"foo\");\n", "    List<String> actual = Lists.newArrayList(filtered);\n", "    assertEquals(expected, actual);\n", "  }\n", "\n", "  public void testFilterNoMatch() {\n", "    Iterator<String> unfiltered = Lists.newArrayList(\"foo\", \"bar\").iterator();\n", "    Iterator<String> filtered = Iterators.filter(unfiltered,\n", "                                                 Predicates.alwaysFalse());\n", "    List<String> expected = Collections.emptyList();\n", "    List<String> actual = Lists.newArrayList(filtered);\n", "    assertEquals(expected, actual);\n", "  }\n", "\n", "  public void testFilterMatchAll() {\n", "    Iterator<String> unfiltered = Lists.newArrayList(\"foo\", \"bar\").iterator();\n", "    Iterator<String> filtered = Iterators.filter(unfiltered,\n", "                                                 Predicates.alwaysTrue());\n", "    List<String> expected = Lists.newArrayList(\"foo\", \"bar\");\n", "    List<String> actual = Lists.newArrayList(filtered);\n", "    assertEquals(expected, actual);\n", "  }\n", "\n", "  public void testFilterNothing() {\n", "    Iterator<String> unfiltered = Collections.<String>emptyList().iterator();\n", "    Iterator<String> filtered = Iterators.filter(unfiltered,\n", "        new Predicate<String>() {\n", "          @Override\n", "          public boolean apply(String s) {\n", "            throw new AssertionFailedError(\"Should never be evaluated\");\n", "          }\n", "        });\n", "\n", "    List<String> expected = Collections.emptyList();\n", "    List<String> actual = Lists.newArrayList(filtered);\n", "    assertEquals(expected, actual);\n", "  }\n", "\n", "  public void testAny() {\n", "    List<String> list = Lists.newArrayList();\n", "    Predicate<String> predicate = Predicates.equalTo(\"pants\");\n", "\n", "    assertFalse(Iterators.any(list.iterator(), predicate));\n", "    list.add(\"cool\");\n", "    assertFalse(Iterators.any(list.iterator(), predicate));\n", "    list.add(\"pants\");\n", "    assertTrue(Iterators.any(list.iterator(), predicate));\n", "  }\n", "\n", "  public void testAll() {\n", "    List<String> list = Lists.newArrayList();\n", "    Predicate<String> predicate = Predicates.equalTo(\"cool\");\n", "\n", "    assertTrue(Iterators.all(list.iterator(), predicate));\n", "    list.add(\"cool\");\n", "    assertTrue(Iterators.all(list.iterator(), predicate));\n", "    list.add(\"pants\");\n", "    assertFalse(Iterators.all(list.iterator(), predicate));\n", "  }\n", "\n", "  public void testFind_firstElement() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"cool\", Iterators.find(iterator, Predicates.equalTo(\"cool\")));\n", "    assertEquals(\"pants\", iterator.next());\n", "  }\n", "\n", "  public void testFind_lastElement() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"pants\", Iterators.find(iterator,\n", "        Predicates.equalTo(\"pants\")));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testFind_notPresent() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    try {\n", "      Iterators.find(iterator, Predicates.alwaysFalse());\n", "      fail();\n", "    } catch (NoSuchElementException e) {\n", "    }\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testFind_matchAlways() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"cool\", Iterators.find(iterator, Predicates.alwaysTrue()));\n", "  }\n", "\n", "  public void testFind_withDefault_first() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"cool\",\n", "        Iterators.find(iterator, Predicates.equalTo(\"cool\"), \"woot\"));\n", "    assertEquals(\"pants\", iterator.next());\n", "  }\n", "\n", "  public void testFind_withDefault_last() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"pants\",\n", "        Iterators.find(iterator, Predicates.equalTo(\"pants\"), \"woot\"));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testFind_withDefault_notPresent() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"woot\",\n", "        Iterators.find(iterator, Predicates.alwaysFalse(), \"woot\"));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testFind_withDefault_notPresent_nullReturn() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertNull(\n", "        Iterators.find(iterator, Predicates.alwaysFalse(), null));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testFind_withDefault_matchAlways() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"cool\",\n", "        Iterators.find(iterator, Predicates.alwaysTrue(), \"woot\"));\n", "    assertEquals(\"pants\", iterator.next());\n", "  }\n", "\n", "  public void testTryFind_firstElement() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertThat(Iterators.tryFind(iterator, Predicates.equalTo(\"cool\"))).hasValue(\"cool\");\n", "  }\n", "\n", "  public void testTryFind_lastElement() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertThat(Iterators.tryFind(iterator, Predicates.equalTo(\"pants\"))).hasValue(\"pants\");\n", "  }\n", "\n", "  public void testTryFind_alwaysTrue() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertThat(Iterators.tryFind(iterator, Predicates.alwaysTrue())).hasValue(\"cool\");\n", "  }\n", "\n", "  public void testTryFind_alwaysFalse_orDefault() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"woot\",\n", "        Iterators.tryFind(iterator, Predicates.alwaysFalse()).or(\"woot\"));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testTryFind_alwaysFalse_isPresent() {\n", "    Iterable<String> list = Lists.newArrayList(\"cool\", \"pants\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertThat(Iterators.tryFind(iterator, Predicates.alwaysFalse())).isAbsent();\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testTransform() {\n", "    Iterator<String> input = asList(\"1\", \"2\", \"3\").iterator();\n", "    Iterator<Integer> result = Iterators.transform(input,\n", "        new Function<String, Integer>() {\n", "          @Override\n", "          public Integer apply(String from) {\n", "            return Integer.valueOf(from);\n", "          }\n", "        });\n", "\n", "    List<Integer> actual = Lists.newArrayList(result);\n", "    List<Integer> expected = asList(1, 2, 3);\n", "    assertEquals(expected, actual);\n", "  }\n", "\n", "  public void testTransformRemove() {\n", "    List<String> list = Lists.newArrayList(\"1\", \"2\", \"3\");\n", "    Iterator<String> input = list.iterator();\n", "    Iterator<Integer> iterator = Iterators.transform(input,\n", "        new Function<String, Integer>() {\n", "          @Override\n", "          public Integer apply(String from) {\n", "            return Integer.valueOf(from);\n", "          }\n", "        });\n", "\n", "    assertEquals(Integer.valueOf(1), iterator.next());\n", "    assertEquals(Integer.valueOf(2), iterator.next());\n", "    iterator.remove();\n", "    assertEquals(asList(\"1\", \"3\"), list);\n", "  }\n", "\n", "  public void testPoorlyBehavedTransform() {\n", "    Iterator<String> input = asList(\"1\", null, \"3\").iterator();\n", "    Iterator<Integer> result = Iterators.transform(input,\n", "        new Function<String, Integer>() {\n", "          @Override\n", "          public Integer apply(String from) {\n", "            return Integer.valueOf(from);\n", "          }\n", "        });\n", "\n", "    result.next();\n", "    try {\n", "      result.next();\n", "      fail(\"Expected NFE\");\n", "    } catch (NumberFormatException nfe) {\n", "      // Expected to fail.\n", "    }\n", "  }\n", "\n", "  public void testNullFriendlyTransform() {\n", "    Iterator<Integer> input = asList(1, 2, null, 3).iterator();\n", "    Iterator<String> result = Iterators.transform(input,\n", "        new Function<Integer, String>() {\n", "          @Override\n", "          public String apply(Integer from) {\n", "            return String.valueOf(from);\n", "          }\n", "        });\n", "\n", "    List<String> actual = Lists.newArrayList(result);\n", "    List<String> expected = asList(\"1\", \"2\", \"null\", \"3\");\n", "    assertEquals(expected, actual);\n", "  }\n", "\n", "  public void testCycleOfEmpty() {\n", "    // \"<String>\" for javac 1.5.\n", "    Iterator<String> cycle = Iterators.<String>cycle();\n", "    assertFalse(cycle.hasNext());\n", "  }\n", "\n", "  public void testCycleOfOne() {\n", "    Iterator<String> cycle = Iterators.cycle(\"a\");\n", "    for (int i = 0; i < 3; i++) {\n", "      assertTrue(cycle.hasNext());\n", "      assertEquals(\"a\", cycle.next());\n", "    }\n", "  }\n", "\n", "  public void testCycleOfOneWithRemove() {\n", "    Iterable<String> iterable = Lists.newArrayList(\"a\");\n", "    Iterator<String> cycle = Iterators.cycle(iterable);\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"a\", cycle.next());\n", "    cycle.remove();\n", "    assertEquals(Collections.emptyList(), iterable);\n", "    assertFalse(cycle.hasNext());\n", "  }\n", "\n", "  public void testCycleOfTwo() {\n", "    Iterator<String> cycle = Iterators.cycle(\"a\", \"b\");\n", "    for (int i = 0; i < 3; i++) {\n", "      assertTrue(cycle.hasNext());\n", "      assertEquals(\"a\", cycle.next());\n", "      assertTrue(cycle.hasNext());\n", "      assertEquals(\"b\", cycle.next());\n", "    }\n", "  }\n", "\n", "  public void testCycleOfTwoWithRemove() {\n", "    Iterable<String> iterable = Lists.newArrayList(\"a\", \"b\");\n", "    Iterator<String> cycle = Iterators.cycle(iterable);\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"a\", cycle.next());\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"b\", cycle.next());\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"a\", cycle.next());\n", "    cycle.remove();\n", "    assertEquals(Collections.singletonList(\"b\"), iterable);\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"b\", cycle.next());\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"b\", cycle.next());\n", "    cycle.remove();\n", "    assertEquals(Collections.emptyList(), iterable);\n", "    assertFalse(cycle.hasNext());\n", "  }\n", "\n", "  public void testCycleRemoveWithoutNext() {\n", "    Iterator<String> cycle = Iterators.cycle(\"a\", \"b\");\n", "    assertTrue(cycle.hasNext());\n", "    try {\n", "      cycle.remove();\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCycleRemoveSameElementTwice() {\n", "    Iterator<String> cycle = Iterators.cycle(\"a\", \"b\");\n", "    cycle.next();\n", "    cycle.remove();\n", "    try {\n", "      cycle.remove();\n", "      fail(\"no exception thrown\");\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCycleWhenRemoveIsNotSupported() {\n", "    Iterable<String> iterable = asList(\"a\", \"b\");\n", "    Iterator<String> cycle = Iterators.cycle(iterable);\n", "    cycle.next();\n", "    try {\n", "      cycle.remove();\n", "      fail(\"no exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCycleRemoveAfterHasNext() {\n", "    Iterable<String> iterable = Lists.newArrayList(\"a\");\n", "    Iterator<String> cycle = Iterators.cycle(iterable);\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"a\", cycle.next());\n", "    assertTrue(cycle.hasNext());\n", "    cycle.remove();\n", "    assertEquals(Collections.emptyList(), iterable);\n", "    assertFalse(cycle.hasNext());\n", "  }\n", "\n", "  /** An Iterable whose Iterator is rigorous in checking for concurrent modification. */\n", "  private static final class PickyIterable<E> implements Iterable<E> {\n", "    final List<E> elements;\n", "    int modCount = 0;\n", "\n", "    PickyIterable(E... elements) {\n", "      this.elements = new ArrayList<E>(asList(elements));\n", "    }\n", "\n", "    @Override\n", "    public Iterator<E> iterator() {\n", "      return new PickyIterator();\n", "    }\n", "\n", "    final class PickyIterator implements Iterator<E> {\n", "      int expectedModCount = modCount;\n", "      int index = 0;\n", "      boolean canRemove;\n", "\n", "      @Override\n", "      public boolean hasNext() {\n", "        checkConcurrentModification();\n", "        return index < elements.size();\n", "      }\n", "\n", "      @Override\n", "      public E next() {\n", "        checkConcurrentModification();\n", "        if (!hasNext()) {\n", "          throw new NoSuchElementException();\n", "        }\n", "        canRemove = true;\n", "        return elements.get(index++);\n", "      }\n", "\n", "      @Override\n", "      public void remove() {\n", "        checkConcurrentModification();\n", "        checkRemove(canRemove);\n", "        elements.remove(--index);\n", "        expectedModCount = ++modCount;\n", "        canRemove = false;\n", "      }\n", "\n", "      void checkConcurrentModification() {\n", "        if (expectedModCount != modCount) {\n", "          throw new ConcurrentModificationException();\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testCycleRemoveAfterHasNextExtraPicky() {\n", "    PickyIterable<String> iterable = new PickyIterable(\"a\");\n", "    Iterator<String> cycle = Iterators.cycle(iterable);\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"a\", cycle.next());\n", "    assertTrue(cycle.hasNext());\n", "    cycle.remove();\n", "    assertTrue(iterable.elements.isEmpty());\n", "    assertFalse(cycle.hasNext());\n", "  }\n", "\n", "  public void testCycleNoSuchElementException() {\n", "    Iterable<String> iterable = Lists.newArrayList(\"a\");\n", "    Iterator<String> cycle = Iterators.cycle(iterable);\n", "    assertTrue(cycle.hasNext());\n", "    assertEquals(\"a\", cycle.next());\n", "    cycle.remove();\n", "    assertFalse(cycle.hasNext());\n", "    try {\n", "      cycle.next();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {}\n", "  }\n", "\n", "  /**\n", "   * Illustrates the somewhat bizarre behavior when a null is passed in.\n", "   */\n", "  public void testConcatContainingNull() {\n", "    @SuppressWarnings(\"unchecked\")\n", "    Iterator<Iterator<Integer>> input\n", "        = asList(iterateOver(1, 2), null, iterateOver(3)).iterator();\n", "    Iterator<Integer> result = Iterators.concat(input);\n", "    assertEquals(1, (int) result.next());\n", "    assertEquals(2, (int) result.next());\n", "    try {\n", "      result.hasNext();\n", "      fail(\"no exception thrown\");\n", "    } catch (NullPointerException e) {\n", "    }\n", "    try {\n", "      result.next();\n", "      fail(\"no exception thrown\");\n", "    } catch (NullPointerException e) {\n", "    }\n", "    // There is no way to get \"through\" to the 3.  Buh-bye\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testConcatVarArgsContainingNull() {\n", "    try {\n", "      Iterators.concat(iterateOver(1, 2), null, iterateOver(3), iterateOver(4),\n", "          iterateOver(5));\n", "      fail(\"no exception thrown\");\n", "    } catch (NullPointerException e) {\n", "    }\n", "  }\n", "\n", "  public void testAddAllWithEmptyIterator() {\n", "    List<String> alreadyThere = Lists.newArrayList(\"already\", \"there\");\n", "\n", "    boolean changed = Iterators.addAll(alreadyThere,\n", "                                       Iterators.<String>emptyIterator());\n", "    assertThat(alreadyThere).containsExactly(\"already\", \"there\").inOrder();\n", "    assertFalse(changed);\n", "  }\n", "\n", "  public void testAddAllToList() {\n", "    List<String> alreadyThere = Lists.newArrayList(\"already\", \"there\");\n", "    List<String> freshlyAdded = Lists.newArrayList(\"freshly\", \"added\");\n", "\n", "    boolean changed = Iterators.addAll(alreadyThere, freshlyAdded.iterator());\n", "\n", "    assertThat(alreadyThere).containsExactly(\"already\", \"there\", \"freshly\", \"added\");\n", "    assertTrue(changed);\n", "  }\n", "\n", "  public void testAddAllToSet() {\n", "    Set<String> alreadyThere\n", "        = Sets.newLinkedHashSet(asList(\"already\", \"there\"));\n", "    List<String> oneMore = Lists.newArrayList(\"there\");\n", "\n", "    boolean changed = Iterators.addAll(alreadyThere, oneMore.iterator());\n", "    assertThat(alreadyThere).containsExactly(\"already\", \"there\").inOrder();\n", "    assertFalse(changed);\n", "  }\n", "\n", "  private static Iterator<Integer> iterateOver(final Integer... values) {\n", "    return newArrayList(values).iterator();\n", "  }\n", "\n", "  public void testElementsEqual() {\n", "    Iterable<?> a;\n", "    Iterable<?> b;\n", "\n", "    // Base case.\n", "    a = Lists.newArrayList();\n", "    b = Collections.emptySet();\n", "    assertTrue(Iterators.elementsEqual(a.iterator(), b.iterator()));\n", "\n", "    // A few elements.\n", "    a = asList(4, 8, 15, 16, 23, 42);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertTrue(Iterators.elementsEqual(a.iterator(), b.iterator()));\n", "\n", "    // The same, but with nulls.\n", "    a = asList(4, 8, null, 16, 23, 42);\n", "    b = asList(4, 8, null, 16, 23, 42);\n", "    assertTrue(Iterators.elementsEqual(a.iterator(), b.iterator()));\n", "\n", "    // Different Iterable types (still equal elements, though).\n", "    a = ImmutableList.of(4, 8, 15, 16, 23, 42);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertTrue(Iterators.elementsEqual(a.iterator(), b.iterator()));\n", "\n", "    // An element differs.\n", "    a = asList(4, 8, 15, 12, 23, 42);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertFalse(Iterators.elementsEqual(a.iterator(), b.iterator()));\n", "\n", "    // null versus non-null.\n", "    a = asList(4, 8, 15, null, 23, 42);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertFalse(Iterators.elementsEqual(a.iterator(), b.iterator()));\n", "    assertFalse(Iterators.elementsEqual(b.iterator(), a.iterator()));\n", "\n", "    // Different lengths.\n", "    a = asList(4, 8, 15, 16, 23);\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertFalse(Iterators.elementsEqual(a.iterator(), b.iterator()));\n", "    assertFalse(Iterators.elementsEqual(b.iterator(), a.iterator()));\n", "\n", "    // Different lengths, one is empty.\n", "    a = Collections.emptySet();\n", "    b = asList(4, 8, 15, 16, 23, 42);\n", "    assertFalse(Iterators.elementsEqual(a.iterator(), b.iterator()));\n", "    assertFalse(Iterators.elementsEqual(b.iterator(), a.iterator()));\n", "  }\n", "\n", "  public void testPartition_badSize() {\n", "    Iterator<Integer> source = Iterators.singletonIterator(1);\n", "    try {\n", "      Iterators.partition(source, 0);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testPartition_empty() {\n", "    Iterator<Integer> source = Iterators.emptyIterator();\n", "    Iterator<List<Integer>> partitions = Iterators.partition(source, 1);\n", "    assertFalse(partitions.hasNext());\n", "  }\n", "\n", "  public void testPartition_singleton1() {\n", "    Iterator<Integer> source = Iterators.singletonIterator(1);\n", "    Iterator<List<Integer>> partitions = Iterators.partition(source, 1);\n", "    assertTrue(partitions.hasNext());\n", "    assertTrue(partitions.hasNext());\n", "    assertEquals(ImmutableList.of(1), partitions.next());\n", "    assertFalse(partitions.hasNext());\n", "  }\n", "\n", "  public void testPartition_singleton2() {\n", "    Iterator<Integer> source = Iterators.singletonIterator(1);\n", "    Iterator<List<Integer>> partitions = Iterators.partition(source, 2);\n", "    assertTrue(partitions.hasNext());\n", "    assertTrue(partitions.hasNext());\n", "    assertEquals(ImmutableList.of(1), partitions.next());\n", "    assertFalse(partitions.hasNext());\n", "  }\n", "\n", "  public void testPartition_view() {\n", "    List<Integer> list = asList(1, 2);\n", "    Iterator<List<Integer>> partitions\n", "        = Iterators.partition(list.iterator(), 1);\n", "\n", "    // Changes before the partition is retrieved are reflected\n", "    list.set(0, 3);\n", "    List<Integer> first = partitions.next();\n", "\n", "    // Changes after are not\n", "    list.set(0, 4);\n", "\n", "    assertEquals(ImmutableList.of(3), first);\n", "  }\n", "\n", "  public void testPaddedPartition_badSize() {\n", "    Iterator<Integer> source = Iterators.singletonIterator(1);\n", "    try {\n", "      Iterators.paddedPartition(source, 0);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testPaddedPartition_empty() {\n", "    Iterator<Integer> source = Iterators.emptyIterator();\n", "    Iterator<List<Integer>> partitions = Iterators.paddedPartition(source, 1);\n", "    assertFalse(partitions.hasNext());\n", "  }\n", "\n", "  public void testPaddedPartition_singleton1() {\n", "    Iterator<Integer> source = Iterators.singletonIterator(1);\n", "    Iterator<List<Integer>> partitions = Iterators.paddedPartition(source, 1);\n", "    assertTrue(partitions.hasNext());\n", "    assertTrue(partitions.hasNext());\n", "    assertEquals(ImmutableList.of(1), partitions.next());\n", "    assertFalse(partitions.hasNext());\n", "  }\n", "\n", "  public void testPaddedPartition_singleton2() {\n", "    Iterator<Integer> source = Iterators.singletonIterator(1);\n", "    Iterator<List<Integer>> partitions = Iterators.paddedPartition(source, 2);\n", "    assertTrue(partitions.hasNext());\n", "    assertTrue(partitions.hasNext());\n", "    assertEquals(asList(1, null), partitions.next());\n", "    assertFalse(partitions.hasNext());\n", "  }\n", "\n", "  public void testPaddedPartition_view() {\n", "    List<Integer> list = asList(1, 2);\n", "    Iterator<List<Integer>> partitions\n", "        = Iterators.paddedPartition(list.iterator(), 1);\n", "\n", "    // Changes before the PaddedPartition is retrieved are reflected\n", "    list.set(0, 3);\n", "    List<Integer> first = partitions.next();\n", "\n", "    // Changes after are not\n", "    list.set(0, 4);\n", "\n", "    assertEquals(ImmutableList.of(3), first);\n", "  }\n", "\n", "  public void testPaddedPartitionRandomAccess() {\n", "    Iterator<Integer> source = asList(1, 2, 3).iterator();\n", "    Iterator<List<Integer>> partitions = Iterators.paddedPartition(source, 2);\n", "    assertTrue(partitions.next() instanceof RandomAccess);\n", "    assertTrue(partitions.next() instanceof RandomAccess);\n", "  }\n", "\n", "  public void testForArrayEmpty() {\n", "    String[] array = new String[0];\n", "    Iterator<String> iterator = Iterators.forArray(array);\n", "    assertFalse(iterator.hasNext());\n", "    try {\n", "      iterator.next();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {}\n", "  }\n", "\n", "  public void testForArrayTypical() {\n", "    String[] array = {\"foo\", \"bar\"};\n", "    Iterator<String> iterator = Iterators.forArray(array);\n", "    assertTrue(iterator.hasNext());\n", "    assertEquals(\"foo\", iterator.next());\n", "    assertTrue(iterator.hasNext());\n", "    try {\n", "      iterator.remove();\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertEquals(\"bar\", iterator.next());\n", "    assertFalse(iterator.hasNext());\n", "    try {\n", "      iterator.next();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {}\n", "  }\n", "\n", "  public void testForArrayOffset() {\n", "    String[] array = {\"foo\", \"bar\", \"cat\", \"dog\"};\n", "    Iterator<String> iterator = Iterators.forArray(array, 1, 2, 0);\n", "    assertTrue(iterator.hasNext());\n", "    assertEquals(\"bar\", iterator.next());\n", "    assertTrue(iterator.hasNext());\n", "    assertEquals(\"cat\", iterator.next());\n", "    assertFalse(iterator.hasNext());\n", "    try {\n", "      Iterators.forArray(array, 2, 3, 0);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "  }\n", "\n", "  public void testForArrayLength0() {\n", "    String[] array = {\"foo\", \"bar\"};\n", "    assertFalse(Iterators.forArray(array, 0, 0, 0).hasNext());\n", "    assertFalse(Iterators.forArray(array, 1, 0, 0).hasNext());\n", "    assertFalse(Iterators.forArray(array, 2, 0, 0).hasNext());\n", "    try {\n", "      Iterators.forArray(array, -1, 0, 0);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    try {\n", "      Iterators.forArray(array, 3, 0, 0);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "  }\n", "\n", "  public void testForEnumerationEmpty() {\n", "    Enumeration<Integer> enumer = enumerate();\n", "    Iterator<Integer> iter = Iterators.forEnumeration(enumer);\n", "\n", "    assertFalse(iter.hasNext());\n", "    try {\n", "      iter.next();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testForEnumerationSingleton() {\n", "    Enumeration<Integer> enumer = enumerate(1);\n", "    Iterator<Integer> iter = Iterators.forEnumeration(enumer);\n", "\n", "    assertTrue(iter.hasNext());\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(1, (int) iter.next());\n", "    try {\n", "      iter.remove();\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    assertFalse(iter.hasNext());\n", "    try {\n", "      iter.next();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testForEnumerationTypical() {\n", "    Enumeration<Integer> enumer = enumerate(1, 2, 3);\n", "    Iterator<Integer> iter = Iterators.forEnumeration(enumer);\n", "\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(1, (int) iter.next());\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(2, (int) iter.next());\n", "    assertTrue(iter.hasNext());\n", "    assertEquals(3, (int) iter.next());\n", "    assertFalse(iter.hasNext());\n", "  }\n", "\n", "  public void testAsEnumerationEmpty() {\n", "    Iterator<Integer> iter = Iterators.emptyIterator();\n", "    Enumeration<Integer> enumer = Iterators.asEnumeration(iter);\n", "\n", "    assertFalse(enumer.hasMoreElements());\n", "    try {\n", "      enumer.nextElement();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsEnumerationSingleton() {\n", "    Iterator<Integer> iter = ImmutableList.of(1).iterator();\n", "    Enumeration<Integer> enumer = Iterators.asEnumeration(iter);\n", "\n", "    assertTrue(enumer.hasMoreElements());\n", "    assertTrue(enumer.hasMoreElements());\n", "    assertEquals(1, (int) enumer.nextElement());\n", "    assertFalse(enumer.hasMoreElements());\n", "    try {\n", "      enumer.nextElement();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsEnumerationTypical() {\n", "    Iterator<Integer> iter = ImmutableList.of(1, 2, 3).iterator();\n", "    Enumeration<Integer> enumer = Iterators.asEnumeration(iter);\n", "\n", "    assertTrue(enumer.hasMoreElements());\n", "    assertEquals(1, (int) enumer.nextElement());\n", "    assertTrue(enumer.hasMoreElements());\n", "    assertEquals(2, (int) enumer.nextElement());\n", "    assertTrue(enumer.hasMoreElements());\n", "    assertEquals(3, (int) enumer.nextElement());\n", "    assertFalse(enumer.hasMoreElements());\n", "  }\n", "\n", "  private static Enumeration<Integer> enumerate(Integer... ints) {\n", "    Vector<Integer> vector = new Vector<Integer>();\n", "    vector.addAll(asList(ints));\n", "    return vector.elements();\n", "  }\n", "\n", "  public void testToString() {\n", "    Iterator<String> iterator = Lists.newArrayList(\"yam\", \"bam\", \"jam\", \"ham\").iterator();\n", "    assertEquals(\"[yam, bam, jam, ham]\", Iterators.toString(iterator));\n", "  }\n", "\n", "  public void testToStringWithNull() {\n", "    Iterator<String> iterator = Lists.newArrayList(\"hello\", null, \"world\").iterator();\n", "    assertEquals(\"[hello, null, world]\", Iterators.toString(iterator));\n", "  }\n", "\n", "  public void testToStringEmptyIterator() {\n", "    Iterator<String> iterator = Collections.<String>emptyList().iterator();\n", "    assertEquals(\"[]\", Iterators.toString(iterator));\n", "  }\n", "\n", "  public void testLimit() {\n", "    List<String> list = newArrayList();\n", "    try {\n", "      Iterators.limit(list.iterator(), -1);\n", "      fail(\"expected exception\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // expected\n", "    }\n", "\n", "    assertFalse(Iterators.limit(list.iterator(), 0).hasNext());\n", "    assertFalse(Iterators.limit(list.iterator(), 1).hasNext());\n", "\n", "    list.add(\"cool\");\n", "    assertFalse(Iterators.limit(list.iterator(), 0).hasNext());\n", "    assertEquals(list, newArrayList(Iterators.limit(list.iterator(), 1)));\n", "    assertEquals(list, newArrayList(Iterators.limit(list.iterator(), 2)));\n", "\n", "    list.add(\"pants\");\n", "    assertFalse(Iterators.limit(list.iterator(), 0).hasNext());\n", "    assertEquals(ImmutableList.of(\"cool\"),\n", "        newArrayList(Iterators.limit(list.iterator(), 1)));\n", "    assertEquals(list, newArrayList(Iterators.limit(list.iterator(), 2)));\n", "    assertEquals(list, newArrayList(Iterators.limit(list.iterator(), 3)));\n", "  }\n", "\n", "  public void testLimitRemove() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"cool\");\n", "    list.add(\"pants\");\n", "    Iterator<String> iterator = Iterators.limit(list.iterator(), 1);\n", "    iterator.next();\n", "    iterator.remove();\n", "    assertFalse(iterator.hasNext());\n", "    assertEquals(1, list.size());\n", "    assertEquals(\"pants\", list.get(0));\n", "  }\n", "\n", "  public void testGetNext_withDefault_singleton() {\n", "    Iterator<String> iterator = Collections.singletonList(\"foo\").iterator();\n", "    assertEquals(\"foo\", Iterators.getNext(iterator, \"bar\"));\n", "  }\n", "\n", "  public void testGetNext_withDefault_empty() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    assertEquals(\"bar\", Iterators.getNext(iterator, \"bar\"));\n", "  }\n", "\n", "  public void testGetNext_withDefault_empty_null() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    assertNull(Iterators.getNext(iterator, null));\n", "  }\n", "\n", "  public void testGetNext_withDefault_two() {\n", "    Iterator<String> iterator = asList(\"foo\", \"bar\").iterator();\n", "    assertEquals(\"foo\", Iterators.getNext(iterator, \"x\"));\n", "  }\n", "\n", "  public void testGetLast_basic() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    assertEquals(\"b\", getLast(list.iterator()));\n", "  }\n", "\n", "  public void testGetLast_exception() {\n", "    List<String> list = newArrayList();\n", "    try {\n", "      getLast(list.iterator());\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testGetLast_withDefault_singleton() {\n", "    Iterator<String> iterator = Collections.singletonList(\"foo\").iterator();\n", "    assertEquals(\"foo\", Iterators.getLast(iterator, \"bar\"));\n", "  }\n", "\n", "  public void testGetLast_withDefault_empty() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    assertEquals(\"bar\", Iterators.getLast(iterator, \"bar\"));\n", "  }\n", "\n", "  public void testGetLast_withDefault_empty_null() {\n", "    Iterator<String> iterator = Iterators.emptyIterator();\n", "    assertNull(Iterators.getLast(iterator, null));\n", "  }\n", "\n", "  public void testGetLast_withDefault_two() {\n", "    Iterator<String> iterator = asList(\"foo\", \"bar\").iterator();\n", "    assertEquals(\"bar\", Iterators.getLast(iterator, \"x\"));\n", "  }\n", "\n", "  public void testGet_basic() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"b\", get(iterator, 1));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testGet_atSize() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    try {\n", "      get(iterator, 2);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testGet_pastEnd() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    try {\n", "      get(iterator, 5);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testGet_empty() {\n", "    List<String> list = newArrayList();\n", "    Iterator<String> iterator = list.iterator();\n", "    try {\n", "      get(iterator, 0);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testGet_negativeIndex() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    Iterator<String> iterator = list.iterator();\n", "    try {\n", "      get(iterator, -1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {}\n", "  }\n", "\n", "  public void testGet_withDefault_basic() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"a\", get(iterator, 0, \"c\"));\n", "    assertTrue(iterator.hasNext());\n", "  }\n", "\n", "  public void testGet_withDefault_atSize() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"c\", get(iterator, 2, \"c\"));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testGet_withDefault_pastEnd() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    assertEquals(\"c\", get(iterator, 3, \"c\"));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testGet_withDefault_negativeIndex() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    try {\n", "      get(iterator, -1, \"c\");\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      // pass\n", "    }\n", "    assertTrue(iterator.hasNext());\n", "  }\n", "\n", "  public void testAdvance_basic() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    advance(iterator, 1);\n", "    assertEquals(\"b\", iterator.next());\n", "  }\n", "\n", "  public void testAdvance_pastEnd() {\n", "    List<String> list = newArrayList();\n", "    list.add(\"a\");\n", "    list.add(\"b\");\n", "    Iterator<String> iterator = list.iterator();\n", "    advance(iterator, 5);\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testAdvance_illegalArgument() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\");\n", "    Iterator<String> iterator = list.iterator();\n", "    try {\n", "      advance(iterator, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testFrequency() {\n", "    List<String> list = newArrayList(\"a\", null, \"b\", null, \"a\", null);\n", "    assertEquals(2, Iterators.frequency(list.iterator(), \"a\"));\n", "    assertEquals(1, Iterators.frequency(list.iterator(), \"b\"));\n", "    assertEquals(0, Iterators.frequency(list.iterator(), \"c\"));\n", "    assertEquals(0, Iterators.frequency(list.iterator(), 4.2));\n", "    assertEquals(3, Iterators.frequency(list.iterator(), null));\n", "  }\n", "\n", "  public void testRemoveAll() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertTrue(Iterators.removeAll(\n", "        list.iterator(), newArrayList(\"b\", \"d\", \"f\")));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "    assertFalse(Iterators.removeAll(\n", "        list.iterator(), newArrayList(\"x\", \"y\", \"z\")));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "  }\n", "\n", "  public void testRemoveIf() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertTrue(Iterators.removeIf(\n", "        list.iterator(),\n", "        new Predicate<String>() {\n", "          @Override\n", "          public boolean apply(String s) {\n", "            return s.equals(\"b\") || s.equals(\"d\") || s.equals(\"f\");\n", "          }\n", "        }));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "    assertFalse(Iterators.removeIf(\n", "        list.iterator(),\n", "        new Predicate<String>() {\n", "          @Override\n", "          public boolean apply(String s) {\n", "            return s.equals(\"x\") || s.equals(\"y\") || s.equals(\"z\");\n", "          }\n", "        }));\n", "    assertEquals(newArrayList(\"a\", \"c\", \"e\"), list);\n", "  }\n", "\n", "  public void testRetainAll() {\n", "    List<String> list = newArrayList(\"a\", \"b\", \"c\", \"d\", \"e\");\n", "    assertTrue(Iterators.retainAll(\n", "        list.iterator(), newArrayList(\"b\", \"d\", \"f\")));\n", "    assertEquals(newArrayList(\"b\", \"d\"), list);\n", "    assertFalse(Iterators.retainAll(\n", "        list.iterator(), newArrayList(\"b\", \"e\", \"d\")));\n", "    assertEquals(newArrayList(\"b\", \"d\"), list);\n", "  }\n", "\n", "  public void testConsumingIterator() {\n", "    // Test data\n", "    List<String> list = Lists.newArrayList(\"a\", \"b\");\n", "\n", "    // Test & Verify\n", "    Iterator<String> consumingIterator =\n", "        Iterators.consumingIterator(list.iterator());\n", "\n", "    assertEquals(\"Iterators.consumingIterator(...)\", consumingIterator.toString());\n", "\n", "    assertThat(list).containsExactly(\"a\", \"b\").inOrder();\n", "\n", "    assertTrue(consumingIterator.hasNext());\n", "    assertThat(list).containsExactly(\"a\", \"b\").inOrder();\n", "    assertEquals(\"a\", consumingIterator.next());\n", "    assertThat(list).contains(\"b\");\n", "\n", "    assertTrue(consumingIterator.hasNext());\n", "    assertEquals(\"b\", consumingIterator.next());\n", "    assertThat(list).isEmpty();\n", "\n", "    assertFalse(consumingIterator.hasNext());\n", "  }\n", "\n", "  public void testIndexOf_consumedData() {\n", "    Iterator<String> iterator =\n", "        Lists.newArrayList(\"manny\", \"mo\", \"jack\").iterator();\n", "    assertEquals(1, Iterators.indexOf(iterator, Predicates.equalTo(\"mo\")));\n", "    assertEquals(\"jack\", iterator.next());\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testIndexOf_consumedDataWithDuplicates() {\n", "    Iterator<String> iterator =\n", "        Lists.newArrayList(\"manny\", \"mo\", \"mo\", \"jack\").iterator();\n", "    assertEquals(1, Iterators.indexOf(iterator, Predicates.equalTo(\"mo\")));\n", "    assertEquals(\"mo\", iterator.next());\n", "    assertEquals(\"jack\", iterator.next());\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testIndexOf_consumedDataNoMatch() {\n", "    Iterator<String> iterator =\n", "        Lists.newArrayList(\"manny\", \"mo\", \"mo\", \"jack\").iterator();\n", "    assertEquals(-1, Iterators.indexOf(iterator, Predicates.equalTo(\"bob\")));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testUnmodifiableIteratorShortCircuit() {\n", "    Iterator<String> mod = Lists.newArrayList(\"a\", \"b\", \"c\").iterator();\n", "    UnmodifiableIterator<String> unmod = Iterators.unmodifiableIterator(mod);\n", "    assertNotSame(mod, unmod);\n", "    assertSame(unmod, Iterators.unmodifiableIterator(unmod));\n", "    assertSame(unmod, Iterators.unmodifiableIterator((Iterator<String>) unmod));\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testPeekingIteratorShortCircuit() {\n", "    Iterator<String> nonpeek = Lists.newArrayList(\"a\", \"b\", \"c\").iterator();\n", "    PeekingIterator<String> peek = Iterators.peekingIterator(nonpeek);\n", "    assertNotSame(peek, nonpeek);\n", "    assertSame(peek, Iterators.peekingIterator(peek));\n", "    assertSame(peek, Iterators.peekingIterator((Iterator<String>) peek));\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345]}}, {"118": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/LenientSerializableTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "/**\n", " * Variant of {@link SerializableTester} that does not require the reserialized object's class to be\n", " * identical to the original.\n", " *\n", " * @author Chris Povirk\n", " */\n", "/*\n", " * The whole thing is really @GwtIncompatible, but GwtJUnitConvertedTestModule doesn't have a\n", " * parameter for non-GWT, non-test files, and it didn't seem worth adding one for this unusual case.\n", " */\n", "@GwtCompatible(emulated = true)\n", "final class LenientSerializableTester {\n", "  /*\n", "   * TODO(cpovirk): move this to c.g.c.testing if we allow for c.g.c.annotations dependencies so\n", "   * that it can be GWTified?\n", "   */\n", "\n", "  private LenientSerializableTester() {}\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]}}, {"119": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultimapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "\n", "/**\n", " * Unit tests for {@code LinkedHashMultimap}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class LinkedHashMultimapTest extends TestCase {\n", "\n", "  public void testValueSetHashTableExpansion() {\n", "    LinkedHashMultimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    for (int z = 1; z <= 100; z++) {\n", "      multimap.put(\"a\", z);\n", "      // The Eclipse compiler (and hence GWT) rejects a parameterized cast.\n", "      @SuppressWarnings(\"unchecked\")\n", "      LinkedHashMultimap<String, Integer>.ValueSet valueSet =\n", "          (LinkedHashMultimap.ValueSet) multimap.backingMap().get(\"a\");\n", "      assertEquals(z, valueSet.size());\n", "      assertFalse(Hashing.needsResizing(valueSet.size(), valueSet.hashTable.length, \n", "          LinkedHashMultimap.VALUE_SET_LOAD_FACTOR));\n", "    }\n", "  }\n", "\n", "  private Multimap<String, Integer> initializeMultimap5() {\n", "    Multimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    multimap.put(\"foo\", 5);\n", "    multimap.put(\"bar\", 4);\n", "    multimap.put(\"foo\", 3);\n", "    multimap.put(\"cow\", 2);\n", "    multimap.put(\"bar\", 1);\n", "    return multimap;\n", "  }\n", "\n", "  public void testToString() {\n", "    Multimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    multimap.put(\"foo\", 3);\n", "    multimap.put(\"bar\", 1);\n", "    multimap.putAll(\"foo\", Arrays.asList(-1, 2, 4));\n", "    multimap.putAll(\"bar\", Arrays.asList(2, 3));\n", "    multimap.put(\"foo\", 1);\n", "    assertEquals(\"{foo=[3, -1, 2, 4, 1], bar=[1, 2, 3]}\",\n", "        multimap.toString());\n", "  }\n", "\n", "  public void testOrderingReadOnly() {\n", "    Multimap<String, Integer> multimap = initializeMultimap5();\n", "    assertOrderingReadOnly(multimap);\n", "  }\n", "\n", "  public void testOrderingUnmodifiable() {\n", "    Multimap<String, Integer> multimap = initializeMultimap5();\n", "    assertOrderingReadOnly(Multimaps.unmodifiableMultimap(multimap));\n", "  }\n", "\n", "  public void testOrderingSynchronized() {\n", "    Multimap<String, Integer> multimap = initializeMultimap5();\n", "    assertOrderingReadOnly(Multimaps.synchronizedMultimap(multimap));\n", "  }\n", "\n", "  private void assertOrderingReadOnly(Multimap<String, Integer> multimap) {\n", "    assertThat(multimap.get(\"foo\")).containsExactly(5, 3).inOrder();\n", "    assertThat(multimap.get(\"bar\")).containsExactly(4, 1).inOrder();\n", "    assertThat(multimap.get(\"cow\")).contains(2);\n", "\n", "    assertThat(multimap.keySet()).containsExactly(\"foo\", \"bar\", \"cow\").inOrder();\n", "    assertThat(multimap.values()).containsExactly(5, 4, 3, 2, 1).inOrder();\n", "\n", "    Iterator<Map.Entry<String, Integer>> entryIterator =\n", "        multimap.entries().iterator();\n", "    assertEquals(Maps.immutableEntry(\"foo\", 5), entryIterator.next());\n", "    assertEquals(Maps.immutableEntry(\"bar\", 4), entryIterator.next());\n", "    assertEquals(Maps.immutableEntry(\"foo\", 3), entryIterator.next());\n", "    assertEquals(Maps.immutableEntry(\"cow\", 2), entryIterator.next());\n", "    assertEquals(Maps.immutableEntry(\"bar\", 1), entryIterator.next());\n", "\n", "    Iterator<Map.Entry<String, Collection<Integer>>> collectionIterator =\n", "        multimap.asMap().entrySet().iterator();\n", "    Map.Entry<String, Collection<Integer>> entry = collectionIterator.next();\n", "    assertEquals(\"foo\", entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(5, 3).inOrder();\n", "    entry = collectionIterator.next();\n", "    assertEquals(\"bar\", entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(4, 1).inOrder();\n", "    entry = collectionIterator.next();\n", "    assertEquals(\"cow\", entry.getKey());\n", "    assertThat(entry.getValue()).contains(2);\n", "  }\n", "\n", "  public void testOrderingUpdates() {\n", "    Multimap<String, Integer> multimap = initializeMultimap5();\n", "\n", "    assertThat(multimap.replaceValues(\"foo\", asList(6, 7))).containsExactly(5, 3).inOrder();\n", "    assertThat(multimap.keySet()).containsExactly(\"foo\", \"bar\", \"cow\").inOrder();\n", "    assertThat(multimap.removeAll(\"foo\")).containsExactly(6, 7).inOrder();\n", "    assertThat(multimap.keySet()).containsExactly(\"bar\", \"cow\").inOrder();\n", "    assertTrue(multimap.remove(\"bar\", 4));\n", "    assertThat(multimap.keySet()).containsExactly(\"bar\", \"cow\").inOrder();\n", "    assertTrue(multimap.remove(\"bar\", 1));\n", "    assertThat(multimap.keySet()).contains(\"cow\");\n", "    multimap.put(\"bar\", 9);\n", "    assertThat(multimap.keySet()).containsExactly(\"cow\", \"bar\").inOrder();\n", "  }\n", "\n", "  public void testToStringNullExact() {\n", "    Multimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "\n", "    multimap.put(\"foo\", 3);\n", "    multimap.put(\"foo\", -1);\n", "    multimap.put(null, null);\n", "    multimap.put(\"bar\", 1);\n", "    multimap.put(\"foo\", 2);\n", "    multimap.put(null, 0);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"bar\", null);\n", "    multimap.put(\"foo\", null);\n", "    multimap.put(\"foo\", 4);\n", "    multimap.put(null, -1);\n", "    multimap.put(\"bar\", 3);\n", "    multimap.put(\"bar\", 1);\n", "    multimap.put(\"foo\", 1);\n", "\n", "    assertEquals(\n", "        \"{foo=[3, -1, 2, null, 4, 1], null=[null, 0, -1], bar=[1, 2, null, 3]}\",\n", "        multimap.toString());\n", "  }\n", "\n", "  public void testPutMultimapOrdered() {\n", "    Multimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    multimap.putAll(initializeMultimap5());\n", "    assertOrderingReadOnly(multimap);\n", "  }\n", "\n", "  public void testKeysToString_ordering() {\n", "    Multimap<String, Integer> multimap = initializeMultimap5();\n", "    assertEquals(\"[foo x 2, bar x 2, cow]\", multimap.keys().toString());\n", "  }\n", "\n", "  public void testCreate() {\n", "    LinkedHashMultimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"foo\", 3);\n", "    assertEquals(ImmutableSet.of(1, 3), multimap.get(\"foo\"));\n", "  }\n", "\n", "  public void testCreateFromMultimap() {\n", "    Multimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    multimap.put(\"a\", 1);\n", "    multimap.put(\"b\", 2);\n", "    multimap.put(\"a\", 3);\n", "    multimap.put(\"c\", 4);\n", "    LinkedHashMultimap<String, Integer> copy =\n", "        LinkedHashMultimap.create(multimap);\n", "    new EqualsTester()\n", "        .addEqualityGroup(multimap, copy)\n", "        .testEquals();\n", "  }\n", "\n", "  public void testCreateFromSizes() {\n", "    LinkedHashMultimap<String, Integer> multimap\n", "        = LinkedHashMultimap.create(20, 15);\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"foo\", 3);\n", "    assertEquals(ImmutableSet.of(1, 3), multimap.get(\"foo\"));\n", "  }\n", "\n", "  public void testCreateFromIllegalSizes() {\n", "    try {\n", "      LinkedHashMultimap.create(-20, 15);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "\n", "    try {\n", "      LinkedHashMultimap.create(20, -15);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210]}}, {"120": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/LinkedHashMultisetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.google.TestStringMultisetGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link LinkedHashMultiset}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class LinkedHashMultisetTest extends TestCase {\n", "\n", "  private static TestStringMultisetGenerator linkedHashMultisetGenerator() {\n", "    return new TestStringMultisetGenerator() {\n", "      @Override protected Multiset<String> create(String[] elements) {\n", "        return LinkedHashMultiset.create(asList(elements));\n", "      }\n", "\n", "      @Override\n", "      public List<String> order(List<String> insertionOrder) {\n", "        List<String> order = Lists.newArrayList();\n", "        for (String s : insertionOrder) {\n", "          int index = order.indexOf(s);\n", "          if (index == -1) {\n", "            order.add(s);\n", "          } else {\n", "            order.add(index, s);\n", "          }\n", "        }\n", "        return order;\n", "      }\n", "    };\n", "  }\n", "\n", "  public void testCreate() {\n", "    Multiset<String> multiset = LinkedHashMultiset.create();\n", "    multiset.add(\"foo\", 2);\n", "    multiset.add(\"bar\");\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "    assertEquals(\"[foo x 2, bar]\", multiset.toString());\n", "  }\n", "\n", "  public void testCreateWithSize() {\n", "    Multiset<String> multiset = LinkedHashMultiset.create(50);\n", "    multiset.add(\"foo\", 2);\n", "    multiset.add(\"bar\");\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "    assertEquals(\"[foo x 2, bar]\", multiset.toString());\n", "  }\n", "\n", "  public void testCreateFromIterable() {\n", "    Multiset<String> multiset\n", "        = LinkedHashMultiset.create(Arrays.asList(\"foo\", \"bar\", \"foo\"));\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "    assertEquals(\"[foo x 2, bar]\", multiset.toString());\n", "  }\n", "\n", "  public void testToString() {\n", "    Multiset<String> ms = LinkedHashMultiset.create();\n", "    ms.add(\"a\", 3);\n", "    ms.add(\"c\", 1);\n", "    ms.add(\"b\", 2);\n", "\n", "    assertEquals(\"[a x 3, c, b x 2]\", ms.toString());\n", "  }\n", "\n", "  public void testLosesPlaceInLine() throws Exception {\n", "    Multiset<String> ms = LinkedHashMultiset.create();\n", "    ms.add(\"a\");\n", "    ms.add(\"b\", 2);\n", "    ms.add(\"c\");\n", "    assertThat(ms.elementSet()).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "    ms.remove(\"b\");\n", "    assertThat(ms.elementSet()).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "    ms.add(\"b\");\n", "    assertThat(ms.elementSet()).containsExactly(\"a\", \"b\", \"c\").inOrder();\n", "    ms.remove(\"b\", 2);\n", "    ms.add(\"b\");\n", "    assertThat(ms.elementSet()).containsExactly(\"a\", \"c\", \"b\").inOrder();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110]}}, {"121": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/LinkedListMultimapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.RandomAccess;\n", "\n", "/**\n", " * Tests for {@code LinkedListMultimap}.\n", " *\n", " * @author Mike Bostock\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class LinkedListMultimapTest extends TestCase {\n", "\n", "  protected LinkedListMultimap<String, Integer> create() {\n", "    return LinkedListMultimap.create();\n", "  }\n", "\n", "  /**\n", "   * Confirm that get() returns a List that doesn't implement RandomAccess.\n", "   */\n", "  public void testGetRandomAccess() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 3);\n", "    assertThat(multimap.get(\"foo\")).isNotInstanceOf(RandomAccess.class);\n", "    assertThat(multimap.get(\"bar\")).isNotInstanceOf(RandomAccess.class);\n", "  }\n", "\n", "  /**\n", "   * Confirm that removeAll() returns a List that implements RandomAccess, even\n", "   * though get() doesn't.\n", "   */\n", "  public void testRemoveAllRandomAccess() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 3);\n", "    assertTrue(multimap.removeAll(\"foo\") instanceof RandomAccess);\n", "    assertTrue(multimap.removeAll(\"bar\") instanceof RandomAccess);\n", "  }\n", "\n", "  /**\n", "   * Confirm that replaceValues() returns a List that implements RandomAccess,\n", "   * even though get() doesn't.\n", "   */\n", "  public void testReplaceValuesRandomAccess() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 3);\n", "    assertTrue(multimap.replaceValues(\"foo\", Arrays.asList(2, 4))\n", "        instanceof RandomAccess);\n", "    assertTrue(multimap.replaceValues(\"bar\", Arrays.asList(2, 4))\n", "        instanceof RandomAccess);\n", "  }\n", "\n", "  public void testCreateFromMultimap() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 3);\n", "    multimap.put(\"foo\", 2);\n", "    LinkedListMultimap<String, Integer> copy =\n", "        LinkedListMultimap.create(multimap);\n", "    assertEquals(multimap, copy);\n", "    assertThat(copy.entries()).containsExactlyElementsIn(multimap.entries()).inOrder();\n", "  }\n", "\n", "  public void testCreateFromSize() {\n", "    LinkedListMultimap<String, Integer> multimap\n", "        = LinkedListMultimap.create(20);\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"foo\", 3);\n", "    assertEquals(ImmutableList.of(1, 3), multimap.get(\"foo\"));\n", "  }\n", "\n", "  public void testCreateFromIllegalSize() {\n", "    try {\n", "      LinkedListMultimap.create(-20);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testLinkedGetAdd() {\n", "    LinkedListMultimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    Collection<Integer> foos = map.get(\"foo\");\n", "    foos.add(2);\n", "    foos.add(3);\n", "    map.put(\"bar\", 4);\n", "    map.put(\"foo\", 5);\n", "    assertEquals(\"{bar=[1, 4], foo=[2, 3, 5]}\", map.toString());\n", "    assertEquals(\"[bar=1, foo=2, foo=3, bar=4, foo=5]\",\n", "        map.entries().toString());\n", "  }\n", "\n", "  public void testLinkedGetInsert() {\n", "    ListMultimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    List<Integer> foos = map.get(\"foo\");\n", "    foos.add(2);\n", "    foos.add(0, 3);\n", "    map.put(\"bar\", 4);\n", "    map.put(\"foo\", 5);\n", "    assertEquals(\"{bar=[1, 4], foo=[3, 2, 5]}\", map.toString());\n", "    assertEquals(\"[bar=1, foo=3, foo=2, bar=4, foo=5]\",\n", "        map.entries().toString());\n", "  }\n", "\n", "  public void testLinkedPutInOrder() {\n", "    Multimap<String, Integer> map = create();\n", "    map.put(\"foo\", 1);\n", "    map.put(\"bar\", 2);\n", "    map.put(\"bar\", 3);\n", "    assertEquals(\"{foo=[1], bar=[2, 3]}\", map.toString());\n", "    assertEquals(\"[foo=1, bar=2, bar=3]\", map.entries().toString());\n", "  }\n", "\n", "  public void testLinkedPutOutOfOrder() {\n", "    Multimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    map.put(\"foo\", 2);\n", "    map.put(\"bar\", 3);\n", "    assertEquals(\"{bar=[1, 3], foo=[2]}\", map.toString());\n", "    assertEquals(\"[bar=1, foo=2, bar=3]\", map.entries().toString());\n", "  }\n", "\n", "  public void testLinkedPutAllMultimap() {\n", "    Multimap<String, Integer> src = create();\n", "    src.put(\"bar\", 1);\n", "    src.put(\"foo\", 2);\n", "    src.put(\"bar\", 3);\n", "    Multimap<String, Integer> dst = create();\n", "    dst.putAll(src);\n", "    assertEquals(\"{bar=[1, 3], foo=[2]}\", dst.toString());\n", "    assertEquals(\"[bar=1, foo=2, bar=3]\", src.entries().toString());\n", "  }\n", "\n", "  public void testLinkedReplaceValues() {\n", "    Multimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    map.put(\"foo\", 2);\n", "    map.put(\"bar\", 3);\n", "    map.put(\"bar\", 4);\n", "    assertEquals(\"{bar=[1, 3, 4], foo=[2]}\", map.toString());\n", "    map.replaceValues(\"bar\", asList(1, 2));\n", "    assertEquals(\"[bar=1, foo=2, bar=2]\", map.entries().toString());\n", "    assertEquals(\"{bar=[1, 2], foo=[2]}\", map.toString());\n", "  }\n", "\n", "  public void testLinkedClear() {\n", "    ListMultimap<String, Integer> map = create();\n", "    map.put(\"foo\", 1);\n", "    map.put(\"foo\", 2);\n", "    map.put(\"bar\", 3);\n", "    List<Integer> foos = map.get(\"foo\");\n", "    Collection<Integer> values = map.values();\n", "    assertEquals(asList(1, 2), foos);\n", "    assertThat(values).containsExactly(1, 2, 3).inOrder();\n", "    map.clear();\n", "    assertEquals(Collections.emptyList(), foos);\n", "    assertThat(values).isEmpty();\n", "    assertEquals(\"[]\", map.entries().toString());\n", "    assertEquals(\"{}\", map.toString());\n", "  }\n", "\n", "  public void testLinkedKeySet() {\n", "    Multimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    map.put(\"foo\", 2);\n", "    map.put(\"bar\", 3);\n", "    map.put(\"bar\", 4);\n", "    assertEquals(\"[bar, foo]\", map.keySet().toString());\n", "    map.keySet().remove(\"bar\");\n", "    assertEquals(\"{foo=[2]}\", map.toString());\n", "  }\n", "\n", "  public void testLinkedKeys() {\n", "    Multimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    map.put(\"foo\", 2);\n", "    map.put(\"bar\", 3);\n", "    map.put(\"bar\", 4);\n", "    assertEquals(\"[bar=1, foo=2, bar=3, bar=4]\",\n", "        map.entries().toString());\n", "    assertThat(map.keys()).containsExactly(\"bar\", \"foo\", \"bar\", \"bar\").inOrder();\n", "    map.keys().remove(\"bar\"); // bar is no longer the first key!\n", "    assertEquals(\"{foo=[2], bar=[3, 4]}\", map.toString());\n", "  }\n", "\n", "  public void testLinkedValues() {\n", "    Multimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    map.put(\"foo\", 2);\n", "    map.put(\"bar\", 3);\n", "    map.put(\"bar\", 4);\n", "    assertEquals(\"[1, 2, 3, 4]\", map.values().toString());\n", "    map.values().remove(2);\n", "    assertEquals(\"{bar=[1, 3, 4]}\", map.toString());\n", "  }\n", "\n", "  public void testLinkedEntries() {\n", "    Multimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    map.put(\"foo\", 2);\n", "    map.put(\"bar\", 3);\n", "    Iterator<Map.Entry<String, Integer>> entries = map.entries().iterator();\n", "    Map.Entry<String, Integer> entry = entries.next();\n", "    assertEquals(\"bar\", entry.getKey());\n", "    assertEquals(1, (int) entry.getValue());\n", "    entry = entries.next();\n", "    assertEquals(\"foo\", entry.getKey());\n", "    assertEquals(2, (int) entry.getValue());\n", "    entry.setValue(4);\n", "    entry = entries.next();\n", "    assertEquals(\"bar\", entry.getKey());\n", "    assertEquals(3, (int) entry.getValue());\n", "    assertFalse(entries.hasNext());\n", "    entries.remove();\n", "    assertEquals(\"{bar=[1], foo=[4]}\", map.toString());\n", "  }\n", "\n", "  public void testLinkedAsMapEntries() {\n", "    Multimap<String, Integer> map = create();\n", "    map.put(\"bar\", 1);\n", "    map.put(\"foo\", 2);\n", "    map.put(\"bar\", 3);\n", "    Iterator<Map.Entry<String, Collection<Integer>>> entries\n", "        = map.asMap().entrySet().iterator();\n", "    Map.Entry<String, Collection<Integer>> entry = entries.next();\n", "    assertEquals(\"bar\", entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(1, 3).inOrder();\n", "    try {\n", "      entry.setValue(Arrays.<Integer>asList());\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    entries.remove(); // clear\n", "    entry = entries.next();\n", "    assertEquals(\"foo\", entry.getKey());\n", "    assertThat(entry.getValue()).contains(2);\n", "    assertFalse(entries.hasNext());\n", "    assertEquals(\"{foo=[2]}\", map.toString());\n", "  }\n", "\n", "  public void testEntriesAfterMultimapUpdate() {\n", "    ListMultimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 2);\n", "    multimap.put(\"bar\", 3);\n", "    Collection<Map.Entry<String, Integer>> entries = multimap.entries();\n", "    Iterator<Map.Entry<String, Integer>> iterator = entries.iterator();\n", "    Map.Entry<String, Integer> entrya = iterator.next();\n", "    Map.Entry<String, Integer> entryb = iterator.next();\n", "\n", "    assertEquals(2, (int) multimap.get(\"foo\").set(0, 4));\n", "    assertFalse(multimap.containsEntry(\"foo\", 2));\n", "    assertTrue(multimap.containsEntry(\"foo\", 4));\n", "    assertTrue(multimap.containsEntry(\"bar\", 3));\n", "    assertEquals(4, (int) entrya.getValue());\n", "    assertEquals(3, (int) entryb.getValue());\n", "\n", "    assertTrue(multimap.put(\"foo\", 5));\n", "    assertTrue(multimap.containsEntry(\"foo\", 5));\n", "    assertTrue(multimap.containsEntry(\"foo\", 4));\n", "    assertTrue(multimap.containsEntry(\"bar\", 3));\n", "    assertEquals(4, (int) entrya.getValue());\n", "    assertEquals(3, (int) entryb.getValue());\n", "  }\n", "\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            LinkedListMultimap.create(),\n", "            LinkedListMultimap.create(),\n", "            LinkedListMultimap.create(1))\n", "        .testEquals();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305]}}, {"122": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ListsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "import static java.util.Collections.singletonList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.collect.testing.IteratorTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.ArrayList;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.LinkedList;\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.NoSuchElementException;\n", "import java.util.RandomAccess;\n", "\n", "/**\n", " * Unit test for {@code Lists}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Mike Bostock\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ListsTest extends TestCase {\n", "\n", "  private static final Collection<Integer> SOME_COLLECTION\n", "      = asList(0, 1, 1);\n", "\n", "  private static final Iterable<Integer> SOME_ITERABLE = new SomeIterable();\n", "\n", "  private static final class RemoveFirstFunction\n", "      implements Function<String, String>, Serializable {\n", "    @Override\n", "    public String apply(String from) {\n", "      return (from.length() == 0) ? from : from.substring(1);\n", "    }\n", "  }\n", "\n", "  private static class SomeIterable implements Iterable<Integer>, Serializable {\n", "    @Override\n", "    public Iterator<Integer> iterator() {\n", "      return SOME_COLLECTION.iterator();\n", "    }\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  private static final List<Integer> SOME_LIST\n", "      = Lists.newArrayList(1, 2, 3, 4);\n", "\n", "  private static final List<Integer> SOME_SEQUENTIAL_LIST\n", "      = Lists.newLinkedList(asList(1, 2, 3, 4));\n", "\n", "  private static final List<String> SOME_STRING_LIST\n", "      = asList(\"1\", \"2\", \"3\", \"4\");\n", "\n", "  private static final Function<Number, String> SOME_FUNCTION\n", "      = new SomeFunction();\n", "\n", "  private static class SomeFunction\n", "      implements Function<Number, String>, Serializable {\n", "    @Override\n", "    public String apply(Number n) {\n", "      return String.valueOf(n);\n", "    }\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  public void testCharactersOfIsView() {\n", "    StringBuilder builder = new StringBuilder(\"abc\");\n", "    List<Character> chars = Lists.charactersOf(builder);\n", "    assertEquals(asList('a', 'b', 'c'), chars);\n", "    builder.append(\"def\");\n", "    assertEquals(\n", "        asList('a', 'b', 'c', 'd', 'e', 'f'), chars);\n", "    builder.deleteCharAt(5);\n", "    assertEquals(\n", "        asList('a', 'b', 'c', 'd', 'e'), chars);\n", "  }\n", "\n", "  public void testNewArrayListEmpty() {\n", "    ArrayList<Integer> list = Lists.newArrayList();\n", "    assertEquals(Collections.emptyList(), list);\n", "  }\n", "\n", "  public void testNewArrayListWithCapacity() {\n", "    ArrayList<Integer> list = Lists.newArrayListWithCapacity(0);\n", "    assertEquals(Collections.emptyList(), list);\n", "\n", "    ArrayList<Integer> bigger = Lists.newArrayListWithCapacity(256);\n", "    assertEquals(Collections.emptyList(), bigger);\n", "  }\n", "\n", "  public void testNewArrayListWithCapacity_negative() {\n", "    try {\n", "      Lists.newArrayListWithCapacity(-1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testNewArrayListWithExpectedSize() {\n", "    ArrayList<Integer> list = Lists.newArrayListWithExpectedSize(0);\n", "    assertEquals(Collections.emptyList(), list);\n", "\n", "    ArrayList<Integer> bigger = Lists.newArrayListWithExpectedSize(256);\n", "    assertEquals(Collections.emptyList(), bigger);\n", "  }\n", "\n", "  public void testNewArrayListWithExpectedSize_negative() {\n", "    try {\n", "      Lists.newArrayListWithExpectedSize(-1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testNewArrayListVarArgs() {\n", "    ArrayList<Integer> list = Lists.newArrayList(0, 1, 1);\n", "    assertEquals(SOME_COLLECTION, list);\n", "  }\n", "\n", "  public void testComputeArrayListCapacity() {\n", "    assertEquals(5, Lists.computeArrayListCapacity(0));\n", "    assertEquals(13, Lists.computeArrayListCapacity(8));\n", "    assertEquals(89, Lists.computeArrayListCapacity(77));\n", "    assertEquals(22000005, Lists.computeArrayListCapacity(20000000));\n", "    assertEquals(Integer.MAX_VALUE,\n", "        Lists.computeArrayListCapacity(Integer.MAX_VALUE - 1000));\n", "  }\n", "\n", "  public void testNewArrayListFromCollection() {\n", "    ArrayList<Integer> list = Lists.newArrayList(SOME_COLLECTION);\n", "    assertEquals(SOME_COLLECTION, list);\n", "  }\n", "\n", "  public void testNewArrayListFromIterable() {\n", "    ArrayList<Integer> list = Lists.newArrayList(SOME_ITERABLE);\n", "    assertEquals(SOME_COLLECTION, list);\n", "  }\n", "\n", "  public void testNewArrayListFromIterator() {\n", "    ArrayList<Integer> list = Lists.newArrayList(SOME_COLLECTION.iterator());\n", "    assertEquals(SOME_COLLECTION, list);\n", "  }\n", "\n", "  public void testNewLinkedListEmpty() {\n", "    LinkedList<Integer> list = Lists.newLinkedList();\n", "    assertEquals(Collections.emptyList(), list);\n", "  }\n", "\n", "  public void testNewLinkedListFromCollection() {\n", "    LinkedList<Integer> list = Lists.newLinkedList(SOME_COLLECTION);\n", "    assertEquals(SOME_COLLECTION, list);\n", "  }\n", "\n", "  public void testNewLinkedListFromIterable() {\n", "    LinkedList<Integer> list = Lists.newLinkedList(SOME_ITERABLE);\n", "    assertEquals(SOME_COLLECTION, list);\n", "  }\n", "\n", "  /**\n", "   * This is just here to illustrate how {@code Arrays#asList} differs from\n", "   * {@code Lists#newArrayList}.\n", "   */\n", "  public void testArraysAsList() {\n", "    List<String> ourWay = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n", "    List<String> otherWay = asList(\"foo\", \"bar\", \"baz\");\n", "\n", "    // They're logically equal\n", "    assertEquals(ourWay, otherWay);\n", "\n", "    // The result of Arrays.asList() is mutable\n", "    otherWay.set(0, \"FOO\");\n", "    assertEquals(\"FOO\", otherWay.get(0));\n", "\n", "    // But it can't grow\n", "    try {\n", "      otherWay.add(\"nope\");\n", "      fail(\"no exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "\n", "    // And it can't shrink\n", "    try {\n", "      otherWay.remove(2);\n", "      fail(\"no exception thrown\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  private void checkFooBarBazList(List<String> list) {\n", "    assertThat(list).containsExactly(\"foo\", \"bar\", \"baz\").inOrder();\n", "    assertEquals(3, list.size());\n", "    assertIndexIsOutOfBounds(list, -1);\n", "    assertEquals(\"foo\", list.get(0));\n", "    assertEquals(\"bar\", list.get(1));\n", "    assertEquals(\"baz\", list.get(2));\n", "    assertIndexIsOutOfBounds(list, 3);\n", "  }\n", "\n", "  public void testAsList1Small() {\n", "    List<String> list = Lists.asList(\"foo\", new String[0]);\n", "    assertThat(list).contains(\"foo\");\n", "    assertEquals(1, list.size());\n", "    assertIndexIsOutOfBounds(list, -1);\n", "    assertEquals(\"foo\", list.get(0));\n", "    assertIndexIsOutOfBounds(list, 1);\n", "    assertTrue(list instanceof RandomAccess);\n", "\n", "    new IteratorTester<String>(3, UNMODIFIABLE, singletonList(\"foo\"),\n", "        IteratorTester.KnownOrder.KNOWN_ORDER) {\n", "      @Override protected Iterator<String> newTargetIterator() {\n", "        return Lists.asList(\"foo\", new String[0]).iterator();\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  public void testAsList2() {\n", "    List<String> list = Lists.asList(\"foo\", \"bar\", new String[] { \"baz\" });\n", "    checkFooBarBazList(list);\n", "    assertTrue(list instanceof RandomAccess);\n", "\n", "    new IteratorTester<String>(5, UNMODIFIABLE, asList(\"foo\", \"bar\",\n", "        \"baz\"), IteratorTester.KnownOrder.KNOWN_ORDER) {\n", "      @Override protected Iterator<String> newTargetIterator() {\n", "        return Lists.asList(\"foo\", \"bar\", new String[] {\"baz\"}).iterator();\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  private static void assertIndexIsOutOfBounds(List<String> list, int index) {\n", "    try {\n", "      list.get(index);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "  }\n", "\n", "  public void testReverseViewRandomAccess() {\n", "    List<Integer> fromList = Lists.newArrayList(SOME_LIST);\n", "    List<Integer> toList = Lists.reverse(fromList);\n", "    assertReverseView(fromList, toList);\n", "  }\n", "\n", "  public void testReverseViewSequential() {\n", "    List<Integer> fromList = Lists.newLinkedList(SOME_SEQUENTIAL_LIST);\n", "    List<Integer> toList = Lists.reverse(fromList);\n", "    assertReverseView(fromList, toList);\n", "  }\n", "\n", "  private static void assertReverseView(List<Integer> fromList,\n", "      List<Integer> toList) {\n", "    /* fromList modifications reflected in toList */\n", "    fromList.set(0, 5);\n", "    assertEquals(asList(4, 3, 2, 5), toList);\n", "    fromList.add(6);\n", "    assertEquals(asList(6, 4, 3, 2, 5), toList);\n", "    fromList.add(2, 9);\n", "    assertEquals(asList(6, 4, 3, 9, 2, 5), toList);\n", "    fromList.remove(Integer.valueOf(2));\n", "    assertEquals(asList(6, 4, 3, 9, 5), toList);\n", "    fromList.remove(3);\n", "    assertEquals(asList(6, 3, 9, 5), toList);\n", "\n", "    /* toList modifications reflected in fromList */\n", "    toList.remove(0);\n", "    assertEquals(asList(5, 9, 3), fromList);\n", "    toList.add(7);\n", "    assertEquals(asList(7, 5, 9, 3), fromList);\n", "    toList.add(5);\n", "    assertEquals(asList(5, 7, 5, 9, 3), fromList);\n", "    toList.remove(Integer.valueOf(5));\n", "    assertEquals(asList(5, 7, 9, 3), fromList);\n", "    toList.set(1, 8);\n", "    assertEquals(asList(5, 7, 8, 3), fromList);\n", "    toList.clear();\n", "    assertEquals(Collections.emptyList(), fromList);\n", "  }\n", "\n", "  private static <E> List<E> list(E... elements) {\n", "    return ImmutableList.copyOf(elements);\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary1x1() {\n", "    assertThat(Lists.cartesianProduct(list(1), list(2))).contains(list(1, 2));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary1x2() {\n", "    assertThat(Lists.cartesianProduct(list(1), list(2, 3)))\n", "        .containsExactly(list(1, 2), list(1, 3)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary2x2() {\n", "    assertThat(Lists.cartesianProduct(list(1, 2), list(3, 4)))\n", "        .containsExactly(list(1, 3), list(1, 4), list(2, 3), list(2, 4)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_2x2x2() {\n", "    assertThat(Lists.cartesianProduct(list(0, 1), list(0, 1), list(0, 1))).containsExactly(\n", "        list(0, 0, 0), list(0, 0, 1), list(0, 1, 0), list(0, 1, 1),\n", "        list(1, 0, 0), list(1, 0, 1), list(1, 1, 0), list(1, 1, 1)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_contains() {\n", "    List<List<Integer>> actual = Lists.cartesianProduct(list(1, 2), list(3, 4));\n", "    assertTrue(actual.contains(list(1, 3)));\n", "    assertTrue(actual.contains(list(1, 4)));\n", "    assertTrue(actual.contains(list(2, 3)));\n", "    assertTrue(actual.contains(list(2, 4)));\n", "    assertFalse(actual.contains(list(3, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_unrelatedTypes() {\n", "    List<Integer> x = list(1, 2);\n", "    List<String> y = list(\"3\", \"4\");\n", "\n", "    List<Object> exp1 = list((Object) 1, \"3\");\n", "    List<Object> exp2 = list((Object) 1, \"4\");\n", "    List<Object> exp3 = list((Object) 2, \"3\");\n", "    List<Object> exp4 = list((Object) 2, \"4\");\n", "\n", "    assertThat(Lists.<Object>cartesianProduct(x, y))\n", "        .containsExactly(exp1, exp2, exp3, exp4).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProductTooBig() {\n", "    List<String> list = Collections.nCopies(10000, \"foo\");\n", "    try {\n", "      Lists.cartesianProduct(list, list, list, list, list);\n", "      fail(\"Expected IAE\");\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testTransformHashCodeRandomAccess() {\n", "    List<String> list = Lists.transform(SOME_LIST, SOME_FUNCTION);\n", "    assertEquals(SOME_STRING_LIST.hashCode(), list.hashCode());\n", "  }\n", "\n", "  public void testTransformHashCodeSequential() {\n", "    List<String> list = Lists.transform(SOME_SEQUENTIAL_LIST, SOME_FUNCTION);\n", "    assertEquals(SOME_STRING_LIST.hashCode(), list.hashCode());\n", "  }\n", "\n", "  public void testTransformModifiableRandomAccess() {\n", "    List<Integer> fromList = Lists.newArrayList(SOME_LIST);\n", "    List<String> list = Lists.transform(fromList, SOME_FUNCTION);\n", "    assertTransformModifiable(list);\n", "  }\n", "\n", "  public void testTransformModifiableSequential() {\n", "    List<Integer> fromList = Lists.newLinkedList(SOME_SEQUENTIAL_LIST);\n", "    List<String> list = Lists.transform(fromList, SOME_FUNCTION);\n", "    assertTransformModifiable(list);\n", "  }\n", "\n", "  private static void assertTransformModifiable(List<String> list) {\n", "    try {\n", "      list.add(\"5\");\n", "      fail(\"transformed list is addable\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    list.remove(0);\n", "    assertEquals(asList(\"2\", \"3\", \"4\"), list);\n", "    list.remove(\"3\");\n", "    assertEquals(asList(\"2\", \"4\"), list);\n", "    try {\n", "      list.set(0, \"5\");\n", "      fail(\"transformed list is setable\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    list.clear();\n", "    assertEquals(Collections.emptyList(), list);\n", "  }\n", "\n", "  public void testTransformViewRandomAccess() {\n", "    List<Integer> fromList = Lists.newArrayList(SOME_LIST);\n", "    List<String> toList = Lists.transform(fromList, SOME_FUNCTION);\n", "    assertTransformView(fromList, toList);\n", "  }\n", "\n", "  public void testTransformViewSequential() {\n", "    List<Integer> fromList = Lists.newLinkedList(SOME_SEQUENTIAL_LIST);\n", "    List<String> toList = Lists.transform(fromList, SOME_FUNCTION);\n", "    assertTransformView(fromList, toList);\n", "  }\n", "\n", "  private static void assertTransformView(List<Integer> fromList,\n", "      List<String> toList) {\n", "    /* fromList modifications reflected in toList */\n", "    fromList.set(0, 5);\n", "    assertEquals(asList(\"5\", \"2\", \"3\", \"4\"), toList);\n", "    fromList.add(6);\n", "    assertEquals(asList(\"5\", \"2\", \"3\", \"4\", \"6\"), toList);\n", "    fromList.remove(Integer.valueOf(2));\n", "    assertEquals(asList(\"5\", \"3\", \"4\", \"6\"), toList);\n", "    fromList.remove(2);\n", "    assertEquals(asList(\"5\", \"3\", \"6\"), toList);\n", "\n", "    /* toList modifications reflected in fromList */\n", "    toList.remove(2);\n", "    assertEquals(asList(5, 3), fromList);\n", "    toList.remove(\"5\");\n", "    assertEquals(asList(3), fromList);\n", "    toList.clear();\n", "    assertEquals(Collections.emptyList(), fromList);\n", "  }\n", "\n", "  public void testTransformRandomAccess() {\n", "    List<String> list = Lists.transform(SOME_LIST, SOME_FUNCTION);\n", "    assertTrue(list instanceof RandomAccess);\n", "  }\n", "\n", "  public void testTransformSequential() {\n", "    List<String> list = Lists.transform(SOME_SEQUENTIAL_LIST, SOME_FUNCTION);\n", "    assertThat(list).isNotInstanceOf(RandomAccess.class);\n", "  }\n", "\n", "  public void testTransformListIteratorRandomAccess() {\n", "    List<Integer> fromList = Lists.newArrayList(SOME_LIST);\n", "    List<String> list = Lists.transform(fromList, SOME_FUNCTION);\n", "    assertTransformListIterator(list);\n", "  }\n", "\n", "  public void testTransformListIteratorSequential() {\n", "    List<Integer> fromList = Lists.newLinkedList(SOME_SEQUENTIAL_LIST);\n", "    List<String> list = Lists.transform(fromList, SOME_FUNCTION);\n", "    assertTransformListIterator(list);\n", "  }\n", "\n", "  public void testTransformPreservesIOOBEsThrownByFunction() {\n", "    try {\n", "      Lists.transform(ImmutableList.of(\"foo\", \"bar\"), new Function<String, String>() {\n", "        @Override\n", "        public String apply(String input) {\n", "          throw new IndexOutOfBoundsException();\n", "        }\n", "      }).toArray();\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  private static void assertTransformListIterator(List<String> list) {\n", "    ListIterator<String> iterator = list.listIterator(1);\n", "    assertEquals(1, iterator.nextIndex());\n", "    assertEquals(\"2\", iterator.next());\n", "    assertEquals(\"3\", iterator.next());\n", "    assertEquals(\"4\", iterator.next());\n", "    assertEquals(4, iterator.nextIndex());\n", "    try {\n", "      iterator.next();\n", "      fail(\"did not detect end of list\");\n", "    } catch (NoSuchElementException expected) {}\n", "    assertEquals(3, iterator.previousIndex());\n", "    assertEquals(\"4\", iterator.previous());\n", "    assertEquals(\"3\", iterator.previous());\n", "    assertEquals(\"2\", iterator.previous());\n", "    assertTrue(iterator.hasPrevious());\n", "    assertEquals(\"1\", iterator.previous());\n", "    assertFalse(iterator.hasPrevious());\n", "    assertEquals(-1, iterator.previousIndex());\n", "    try {\n", "      iterator.previous();\n", "      fail(\"did not detect beginning of list\");\n", "    } catch (NoSuchElementException expected) {}\n", "    iterator.remove();\n", "    assertEquals(asList(\"2\", \"3\", \"4\"), list);\n", "    assertFalse(list.isEmpty());\n", "\n", "    // An UnsupportedOperationException or IllegalStateException may occur.\n", "    try {\n", "      iterator.add(\"1\");\n", "      fail(\"transformed list iterator is addable\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    } catch (IllegalStateException expected) {}\n", "    try {\n", "      iterator.set(\"1\");\n", "      fail(\"transformed list iterator is settable\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testTransformIteratorRandomAccess() {\n", "    List<Integer> fromList = Lists.newArrayList(SOME_LIST);\n", "    List<String> list = Lists.transform(fromList, SOME_FUNCTION);\n", "    assertTransformIterator(list);\n", "  }\n", "\n", "  public void testTransformIteratorSequential() {\n", "    List<Integer> fromList = Lists.newLinkedList(SOME_SEQUENTIAL_LIST);\n", "    List<String> list = Lists.transform(fromList, SOME_FUNCTION);\n", "    assertTransformIterator(list);\n", "  }\n", "\n", "  /**\n", "   * We use this class to avoid the need to suppress generics checks with\n", "   * easy mock.\n", "   */\n", "  private interface IntegerList extends List<Integer> {}\n", "\n", "  private static void assertTransformIterator(List<String> list) {\n", "    Iterator<String> iterator = list.iterator();\n", "    assertTrue(iterator.hasNext());\n", "    assertEquals(\"1\", iterator.next());\n", "    assertTrue(iterator.hasNext());\n", "    assertEquals(\"2\", iterator.next());\n", "    assertTrue(iterator.hasNext());\n", "    assertEquals(\"3\", iterator.next());\n", "    assertTrue(iterator.hasNext());\n", "    assertEquals(\"4\", iterator.next());\n", "    assertFalse(iterator.hasNext());\n", "    try {\n", "      iterator.next();\n", "      fail(\"did not detect end of list\");\n", "    } catch (NoSuchElementException expected) {}\n", "    iterator.remove();\n", "    assertEquals(asList(\"1\", \"2\", \"3\"), list);\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testPartition_badSize() {\n", "    List<Integer> source = Collections.singletonList(1);\n", "    try {\n", "      Lists.partition(source, 0);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testPartition_empty() {\n", "    List<Integer> source = Collections.emptyList();\n", "    List<List<Integer>> partitions = Lists.partition(source, 1);\n", "    assertTrue(partitions.isEmpty());\n", "    assertEquals(0, partitions.size());\n", "  }\n", "\n", "  public void testPartition_1_1() {\n", "    List<Integer> source = Collections.singletonList(1);\n", "    List<List<Integer>> partitions = Lists.partition(source, 1);\n", "    assertEquals(1, partitions.size());\n", "    assertEquals(Collections.singletonList(1), partitions.get(0));\n", "  }\n", "\n", "  public void testPartition_1_2() {\n", "    List<Integer> source = Collections.singletonList(1);\n", "    List<List<Integer>> partitions = Lists.partition(source, 2);\n", "    assertEquals(1, partitions.size());\n", "    assertEquals(Collections.singletonList(1), partitions.get(0));\n", "  }\n", "\n", "  public void testPartition_2_1() {\n", "    List<Integer> source = asList(1, 2);\n", "    List<List<Integer>> partitions = Lists.partition(source, 1);\n", "    assertEquals(2, partitions.size());\n", "    assertEquals(Collections.singletonList(1), partitions.get(0));\n", "    assertEquals(Collections.singletonList(2), partitions.get(1));\n", "  }\n", "\n", "  public void testPartition_3_2() {\n", "    List<Integer> source = asList(1, 2, 3);\n", "    List<List<Integer>> partitions = Lists.partition(source, 2);\n", "    assertEquals(2, partitions.size());\n", "    assertEquals(asList(1, 2), partitions.get(0));\n", "    assertEquals(asList(3), partitions.get(1));\n", "  }\n", "\n", "  public void testPartitionRandomAccessFalse() {\n", "    List<Integer> source = Lists.newLinkedList(asList(1, 2, 3));\n", "    List<List<Integer>> partitions = Lists.partition(source, 2);\n", "    assertThat(partitions).isNotInstanceOf(RandomAccess.class);\n", "    assertThat(partitions.get(0)).isNotInstanceOf(RandomAccess.class);\n", "    assertThat(partitions.get(1)).isNotInstanceOf(RandomAccess.class);\n", "  }\n", "\n", "  // TODO: use the ListTestSuiteBuilder\n", "\n", "  public void testPartition_view() {\n", "    List<Integer> list = asList(1, 2, 3);\n", "    List<List<Integer>> partitions = Lists.partition(list, 3);\n", "\n", "    // Changes before the partition is retrieved are reflected\n", "    list.set(0, 3);\n", "\n", "    Iterator<List<Integer>> iterator = partitions.iterator();\n", "\n", "    // Changes before the partition is retrieved are reflected\n", "    list.set(1, 4);\n", "\n", "    List<Integer> first = iterator.next();\n", "\n", "    // Changes after are too (unlike Iterables.partition)\n", "    list.set(2, 5);\n", "\n", "    assertEquals(asList(3, 4, 5), first);\n", "\n", "    // Changes to a sublist also write through to the original list\n", "    first.set(1, 6);\n", "    assertEquals(asList(3, 6, 5), list);\n", "  }\n", "\n", "  public void testPartitionSize_1() {\n", "    List<Integer> list = asList(1, 2, 3);\n", "    assertEquals(1, Lists.partition(list, Integer.MAX_VALUE).size());\n", "    assertEquals(1, Lists.partition(list, Integer.MAX_VALUE - 1).size());\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637]}}, {"123": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/MapConstraintsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.testing.Helpers.nefariousMapEntry;\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Supplier;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.AbstractMap;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.HashMap;\n", "import java.util.Iterator;\n", "import java.util.LinkedList;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Queue;\n", "import java.util.RandomAccess;\n", "import java.util.Set;\n", "import java.util.SortedSet;\n", "\n", "/**\n", " * Tests for {@code MapConstraints}.\n", " *\n", " * @author Mike Bostock\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MapConstraintsTest extends TestCase {\n", "\n", "  private static final String TEST_KEY = \"test\";\n", "\n", "  private static final Integer TEST_VALUE = 42;\n", "\n", "  static final class TestKeyException extends IllegalArgumentException {\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static final class TestValueException extends IllegalArgumentException {\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  static final MapConstraint<String, Integer> TEST_CONSTRAINT\n", "      = new TestConstraint();\n", "\n", "  private static final class TestConstraint\n", "      implements MapConstraint<String, Integer>, Serializable {\n", "    @Override\n", "    public void checkKeyValue(String key, Integer value) {\n", "      if (TEST_KEY.equals(key)) {\n", "        throw new TestKeyException();\n", "      }\n", "      if (TEST_VALUE.equals(value)) {\n", "        throw new TestValueException();\n", "      }\n", "    }\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  public void testNotNull() {\n", "    MapConstraint<Object, Object> constraint = MapConstraints.notNull();\n", "    constraint.checkKeyValue(\"foo\", 1);\n", "    assertEquals(\"Not null\", constraint.toString());\n", "    try {\n", "      constraint.checkKeyValue(null, 1);\n", "      fail(\"NullPointerException expected\");\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      constraint.checkKeyValue(\"foo\", null);\n", "      fail(\"NullPointerException expected\");\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      constraint.checkKeyValue(null, null);\n", "      fail(\"NullPointerException expected\");\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  public void testConstrainedMapLegal() {\n", "    Map<String, Integer> map = Maps.newLinkedHashMap();\n", "    Map<String, Integer> constrained = MapConstraints.constrainedMap(\n", "        map, TEST_CONSTRAINT);\n", "    map.put(TEST_KEY, TEST_VALUE);\n", "    constrained.put(\"foo\", 1);\n", "    map.putAll(ImmutableMap.of(\"bar\", 2));\n", "    constrained.putAll(ImmutableMap.of(\"baz\", 3));\n", "    assertTrue(map.equals(constrained));\n", "    assertTrue(constrained.equals(map));\n", "    assertEquals(map.entrySet(), constrained.entrySet());\n", "    assertEquals(map.keySet(), constrained.keySet());\n", "    assertEquals(HashMultiset.create(map.values()),\n", "        HashMultiset.create(constrained.values()));\n", "    assertThat(map.values()).isNotInstanceOf(Serializable.class);\n", "    assertEquals(map.toString(), constrained.toString());\n", "    assertEquals(map.hashCode(), constrained.hashCode());\n", "    assertThat(map.entrySet()).containsExactly(\n", "        Maps.immutableEntry(TEST_KEY, TEST_VALUE),\n", "        Maps.immutableEntry(\"foo\", 1),\n", "        Maps.immutableEntry(\"bar\", 2),\n", "        Maps.immutableEntry(\"baz\", 3)).inOrder();\n", "  }\n", "\n", "  public void testConstrainedMapIllegal() {\n", "    Map<String, Integer> map = Maps.newLinkedHashMap();\n", "    Map<String, Integer> constrained = MapConstraints.constrainedMap(\n", "        map, TEST_CONSTRAINT);\n", "    try {\n", "      constrained.put(TEST_KEY, TEST_VALUE);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.put(\"baz\", TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.put(TEST_KEY, 3);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.putAll(ImmutableMap.of(\"baz\", 3, TEST_KEY, 4));\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    assertEquals(Collections.emptySet(), map.entrySet());\n", "    assertEquals(Collections.emptySet(), constrained.entrySet());\n", "  }\n", "\n", "  public void testConstrainedBiMapLegal() {\n", "    BiMap<String, Integer> map = new AbstractBiMap<String, Integer>(\n", "        Maps.<String, Integer>newLinkedHashMap(),\n", "        Maps.<Integer, String>newLinkedHashMap()) {};\n", "    BiMap<String, Integer> constrained = MapConstraints.constrainedBiMap(\n", "        map, TEST_CONSTRAINT);\n", "    map.put(TEST_KEY, TEST_VALUE);\n", "    constrained.put(\"foo\", 1);\n", "    map.putAll(ImmutableMap.of(\"bar\", 2));\n", "    constrained.putAll(ImmutableMap.of(\"baz\", 3));\n", "    assertTrue(map.equals(constrained));\n", "    assertTrue(constrained.equals(map));\n", "    assertEquals(map.entrySet(), constrained.entrySet());\n", "    assertEquals(map.keySet(), constrained.keySet());\n", "    assertEquals(map.values(), constrained.values());\n", "    assertEquals(map.toString(), constrained.toString());\n", "    assertEquals(map.hashCode(), constrained.hashCode());\n", "    assertThat(map.entrySet()).containsExactly(\n", "        Maps.immutableEntry(TEST_KEY, TEST_VALUE),\n", "        Maps.immutableEntry(\"foo\", 1),\n", "        Maps.immutableEntry(\"bar\", 2),\n", "        Maps.immutableEntry(\"baz\", 3)).inOrder();\n", "  }\n", "\n", "  public void testConstrainedBiMapIllegal() {\n", "    BiMap<String, Integer> map = new AbstractBiMap<String, Integer>(\n", "        Maps.<String, Integer>newLinkedHashMap(),\n", "        Maps.<Integer, String>newLinkedHashMap()) {};\n", "    BiMap<String, Integer> constrained = MapConstraints.constrainedBiMap(\n", "        map, TEST_CONSTRAINT);\n", "    try {\n", "      constrained.put(TEST_KEY, TEST_VALUE);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.put(\"baz\", TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.put(TEST_KEY, 3);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.putAll(ImmutableMap.of(\"baz\", 3, TEST_KEY, 4));\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.forcePut(TEST_KEY, 3);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.inverse().forcePut(TEST_VALUE, \"baz\");\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.inverse().forcePut(3, TEST_KEY);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    assertEquals(Collections.emptySet(), map.entrySet());\n", "    assertEquals(Collections.emptySet(), constrained.entrySet());\n", "  }\n", "\n", "  public void testConstrainedMultimapLegal() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained = MapConstraints.constrainedMultimap(\n", "        multimap, TEST_CONSTRAINT);\n", "    multimap.put(TEST_KEY, TEST_VALUE);\n", "    constrained.put(\"foo\", 1);\n", "    multimap.get(\"bar\").add(2);\n", "    constrained.get(\"baz\").add(3);\n", "    multimap.get(\"qux\").addAll(Arrays.asList(4));\n", "    constrained.get(\"zig\").addAll(Arrays.asList(5));\n", "    multimap.putAll(\"zag\", Arrays.asList(6));\n", "    constrained.putAll(\"bee\", Arrays.asList(7));\n", "    multimap.putAll(new ImmutableMultimap.Builder<String, Integer>()\n", "        .put(\"bim\", 8).build());\n", "    constrained.putAll(new ImmutableMultimap.Builder<String, Integer>()\n", "        .put(\"bop\", 9).build());\n", "    multimap.putAll(new ImmutableMultimap.Builder<String, Integer>()\n", "        .put(\"dig\", 10).build());\n", "    constrained.putAll(new ImmutableMultimap.Builder<String, Integer>()\n", "        .put(\"dag\", 11).build());\n", "    assertTrue(multimap.equals(constrained));\n", "    assertTrue(constrained.equals(multimap));\n", "    assertThat(ImmutableList.copyOf(multimap.entries())).isEqualTo(\n", "        ImmutableList.copyOf(constrained.entries()));\n", "    assertThat(constrained.asMap().get(\"foo\")).contains(1);\n", "    assertNull(constrained.asMap().get(\"missing\"));\n", "    assertEquals(multimap.asMap(), constrained.asMap());\n", "    assertEquals(multimap.values(), constrained.values());\n", "    assertEquals(multimap.keys(), constrained.keys());\n", "    assertEquals(multimap.keySet(), constrained.keySet());\n", "    assertEquals(multimap.toString(), constrained.toString());\n", "    assertEquals(multimap.hashCode(), constrained.hashCode());\n", "    assertThat(multimap.entries()).containsExactly(\n", "        Maps.immutableEntry(TEST_KEY, TEST_VALUE),\n", "        Maps.immutableEntry(\"foo\", 1),\n", "        Maps.immutableEntry(\"bar\", 2),\n", "        Maps.immutableEntry(\"baz\", 3),\n", "        Maps.immutableEntry(\"qux\", 4),\n", "        Maps.immutableEntry(\"zig\", 5),\n", "        Maps.immutableEntry(\"zag\", 6),\n", "        Maps.immutableEntry(\"bee\", 7),\n", "        Maps.immutableEntry(\"bim\", 8),\n", "        Maps.immutableEntry(\"bop\", 9),\n", "        Maps.immutableEntry(\"dig\", 10),\n", "        Maps.immutableEntry(\"dag\", 11)).inOrder();\n", "    assertThat(constrained.asMap().values()).isNotInstanceOf(Serializable.class);\n", "    Iterator<Collection<Integer>> iterator = constrained.asMap().values().iterator();\n", "    iterator.next();\n", "    iterator.next().add(12);\n", "    assertTrue(multimap.containsEntry(\"foo\", 12));\n", "  }\n", "\n", "  public void testConstrainedTypePreservingList() {\n", "    ListMultimap<String, Integer> multimap\n", "        = MapConstraints.constrainedListMultimap(\n", "            LinkedListMultimap.<String, Integer>create(),\n", "            TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    Map.Entry<String, Collection<Integer>> entry\n", "        = multimap.asMap().entrySet().iterator().next();\n", "    assertTrue(entry.getValue() instanceof List);\n", "    assertFalse(multimap.entries() instanceof Set);\n", "    assertFalse(multimap.get(\"foo\") instanceof RandomAccess);\n", "  }\n", "\n", "  public void testConstrainedTypePreservingRandomAccessList() {\n", "    ListMultimap<String, Integer> multimap\n", "        = MapConstraints.constrainedListMultimap(\n", "            ArrayListMultimap.<String, Integer>create(),\n", "            TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    Map.Entry<String, Collection<Integer>> entry\n", "        = multimap.asMap().entrySet().iterator().next();\n", "    assertTrue(entry.getValue() instanceof List);\n", "    assertFalse(multimap.entries() instanceof Set);\n", "    assertTrue(multimap.get(\"foo\") instanceof RandomAccess);\n", "  }\n", "\n", "  public void testConstrainedTypePreservingSet() {\n", "    SetMultimap<String, Integer> multimap\n", "        = MapConstraints.constrainedSetMultimap(\n", "            LinkedHashMultimap.<String, Integer>create(),\n", "            TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    Map.Entry<String, Collection<Integer>> entry\n", "        = multimap.asMap().entrySet().iterator().next();\n", "    assertTrue(entry.getValue() instanceof Set);\n", "  }\n", "\n", "  public void testConstrainedTypePreservingSortedSet() {\n", "    Comparator<Integer> comparator = Collections.reverseOrder();\n", "    SortedSetMultimap<String, Integer> delegate\n", "        = TreeMultimap.create(Ordering.<String>natural(), comparator);\n", "    SortedSetMultimap<String, Integer> multimap\n", "        = MapConstraints.constrainedSortedSetMultimap(delegate,\n", "            TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    Map.Entry<String, Collection<Integer>> entry\n", "        = multimap.asMap().entrySet().iterator().next();\n", "    assertTrue(entry.getValue() instanceof SortedSet);\n", "    assertSame(comparator, multimap.valueComparator());\n", "    assertSame(comparator, multimap.get(\"foo\").comparator());\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testConstrainedMultimapIllegal() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained = MapConstraints.constrainedMultimap(\n", "        multimap, TEST_CONSTRAINT);\n", "    try {\n", "      constrained.put(TEST_KEY, 1);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.put(\"foo\", TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.put(TEST_KEY, TEST_VALUE);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.get(TEST_KEY).add(1);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.get(\"foo\").add(TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.get(TEST_KEY).add(TEST_VALUE);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.get(TEST_KEY).addAll(Arrays.asList(1));\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.get(\"foo\").addAll(Arrays.asList(1, TEST_VALUE));\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.get(TEST_KEY).addAll(Arrays.asList(1, TEST_VALUE));\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.putAll(TEST_KEY, Arrays.asList(1));\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.putAll(\"foo\", Arrays.asList(1, TEST_VALUE));\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.putAll(TEST_KEY, Arrays.asList(1, TEST_VALUE));\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.putAll(new ImmutableMultimap.Builder<String, Integer>()\n", "          .put(TEST_KEY, 2).put(\"foo\", 1).build());\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.putAll(new ImmutableMultimap.Builder<String, Integer>()\n", "          .put(\"bar\", TEST_VALUE).put(\"foo\", 1).build());\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.putAll(new ImmutableMultimap.Builder<String, Integer>()\n", "          .put(TEST_KEY, TEST_VALUE).put(\"foo\", 1).build());\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.entries().add(Maps.immutableEntry(TEST_KEY, 1));\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      constrained.entries().addAll(Arrays.asList(\n", "          Maps.immutableEntry(\"foo\", 1),\n", "          Maps.immutableEntry(TEST_KEY, 2)));\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertTrue(multimap.isEmpty());\n", "    assertTrue(constrained.isEmpty());\n", "    constrained.put(\"foo\", 1);\n", "    try {\n", "      constrained.asMap().get(\"foo\").add(TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.asMap().values().iterator().next().add(TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      ((Collection<Integer>) constrained.asMap().values().toArray()[0])\n", "          .add(TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    assertThat(ImmutableList.copyOf(multimap.entries())).isEqualTo(\n", "        ImmutableList.copyOf(constrained.entries()));\n", "    assertEquals(multimap.asMap(), constrained.asMap());\n", "    assertEquals(multimap.values(), constrained.values());\n", "    assertEquals(multimap.keys(), constrained.keys());\n", "    assertEquals(multimap.keySet(), constrained.keySet());\n", "    assertEquals(multimap.toString(), constrained.toString());\n", "    assertEquals(multimap.hashCode(), constrained.hashCode());\n", "  }\n", "\n", "  private static class QueueSupplier implements Supplier<Queue<Integer>> {\n", "    @Override\n", "    public Queue<Integer> get() {\n", "      return new LinkedList<Integer>();\n", "    }\n", "  }\n", "\n", "  public void testConstrainedMultimapQueue() {\n", "    Multimap<String, Integer> multimap = Multimaps.newMultimap(\n", "        new HashMap<String, Collection<Integer>>(), new QueueSupplier());\n", "    Multimap<String, Integer> constrained = MapConstraints.constrainedMultimap(\n", "        multimap, TEST_CONSTRAINT);\n", "    constrained.put(\"foo\", 1);\n", "    assertTrue(constrained.get(\"foo\").contains(1));\n", "    assertTrue(multimap.get(\"foo\").contains(1));\n", "    try {\n", "      constrained.put(TEST_KEY, 1);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    try {\n", "      constrained.put(\"foo\", TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.get(\"foo\").add(TEST_VALUE);\n", "      fail(\"TestKeyException expected\");\n", "    } catch (TestValueException expected) {}\n", "    try {\n", "      constrained.get(TEST_KEY).add(1);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestKeyException expected) {}\n", "    assertEquals(1, constrained.size());\n", "    assertEquals(1, multimap.size());\n", "  }\n", "\n", "  public void testMapEntrySetToArray() {\n", "    Map<String, Integer> map = Maps.newLinkedHashMap();\n", "    Map<String, Integer> constrained\n", "        = MapConstraints.constrainedMap(map, TEST_CONSTRAINT);\n", "    map.put(\"foo\", 1);\n", "    @SuppressWarnings(\"unchecked\")\n", "    Map.Entry<String, Integer> entry\n", "        = (Map.Entry) constrained.entrySet().toArray()[0];\n", "    try {\n", "      entry.setValue(TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    assertFalse(map.containsValue(TEST_VALUE));\n", "  }\n", "\n", "  public void testMapEntrySetContainsNefariousEntry() {\n", "    Map<String, Integer> map = Maps.newTreeMap();\n", "    Map<String, Integer> constrained\n", "        = MapConstraints.constrainedMap(map, TEST_CONSTRAINT);\n", "    map.put(\"foo\", 1);\n", "    Map.Entry<String, Integer> nefariousEntry\n", "        = nefariousMapEntry(TEST_KEY, TEST_VALUE);\n", "    Set<Map.Entry<String, Integer>> entries = constrained.entrySet();\n", "    assertFalse(entries.contains(nefariousEntry));\n", "    assertFalse(map.containsValue(TEST_VALUE));\n", "    assertFalse(entries.containsAll(Collections.singleton(nefariousEntry)));\n", "    assertFalse(map.containsValue(TEST_VALUE));\n", "  }\n", "\n", "  public void testMultimapAsMapEntriesToArray() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained\n", "        = MapConstraints.constrainedMultimap(multimap, TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    @SuppressWarnings(\"unchecked\")\n", "    Map.Entry<String, Collection<Integer>> entry\n", "        = (Map.Entry<String, Collection<Integer>>)\n", "            constrained.asMap().entrySet().toArray()[0];\n", "    try {\n", "      entry.setValue(Collections.<Integer>emptySet());\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      entry.getValue().add(TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "  }\n", "\n", "  public void testMultimapAsMapValuesToArray() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained\n", "        = MapConstraints.constrainedMultimap(multimap, TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    @SuppressWarnings(\"unchecked\")\n", "    Collection<Integer> collection\n", "        = (Collection<Integer>) constrained.asMap().values().toArray()[0];\n", "    try {\n", "      collection.add(TEST_VALUE);\n", "      fail(\"TestValueException expected\");\n", "    } catch (TestValueException expected) {}\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "  }\n", "\n", "  public void testMultimapEntriesContainsNefariousEntry() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained\n", "        = MapConstraints.constrainedMultimap(multimap, TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    Map.Entry<String, Integer> nefariousEntry\n", "        = nefariousMapEntry(TEST_KEY, TEST_VALUE);\n", "    Collection<Map.Entry<String, Integer>> entries = constrained.entries();\n", "    assertFalse(entries.contains(nefariousEntry));\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "    assertFalse(entries.containsAll(Collections.singleton(nefariousEntry)));\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "  }\n", "\n", "  public void testMultimapEntriesRemoveNefariousEntry() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained\n", "        = MapConstraints.constrainedMultimap(multimap, TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    Map.Entry<String, Integer> nefariousEntry\n", "        = nefariousMapEntry(TEST_KEY, TEST_VALUE);\n", "    Collection<Map.Entry<String, Integer>> entries = constrained.entries();\n", "    assertFalse(entries.remove(nefariousEntry));\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "    /*\n", "     * Either the Multimap should reject the nefarious internalEntry.setValue() call that\n", "     * queryEntry.equals() makes, or it should arrange for internalEntry.equals(queryEntry) to be\n", "     * used instead of the reverse so that queryEntry.equals(internalEntry) is never invoked.\n", "     *\n", "     * Probably the other tests should be similarly tolerant of either outcome. But for now, this is\n", "     * the only one failing in any of our environments.\n", "     */\n", "    try {\n", "      assertFalse(entries.removeAll(Collections.singleton(nefariousEntry)));\n", "    } catch (TestValueException tolerated) {\n", "    }\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "  }\n", "\n", "  public void testMultimapAsMapEntriesContainsNefariousEntry() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained\n", "        = MapConstraints.constrainedMultimap(multimap, TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    Map.Entry<String, ? extends Collection<Integer>> nefariousEntry\n", "        = nefariousMapEntry(TEST_KEY, Collections.singleton(TEST_VALUE));\n", "    Set<Map.Entry<String, Collection<Integer>>> entries\n", "        = constrained.asMap().entrySet();\n", "    assertFalse(entries.contains(nefariousEntry));\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "    assertFalse(entries.containsAll(Collections.singleton(nefariousEntry)));\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "  }\n", "\n", "  public void testMultimapAsMapEntriesRemoveNefariousEntry() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained\n", "        = MapConstraints.constrainedMultimap(multimap, TEST_CONSTRAINT);\n", "    multimap.put(\"foo\", 1);\n", "    Map.Entry<String, ? extends Collection<Integer>> nefariousEntry\n", "        = nefariousMapEntry(TEST_KEY, Collections.singleton(TEST_VALUE));\n", "    Set<Map.Entry<String, Collection<Integer>>> entries\n", "        = constrained.asMap().entrySet();\n", "    assertFalse(entries.remove(nefariousEntry));\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "    assertFalse(entries.removeAll(Collections.singleton(nefariousEntry)));\n", "    assertFalse(multimap.containsValue(TEST_VALUE));\n", "  }\n", "\n", "  public void testNefariousMapPutAll() {\n", "    Map<String, Integer> map = Maps.newLinkedHashMap();\n", "    Map<String, Integer> constrained = MapConstraints.constrainedMap(\n", "        map, TEST_CONSTRAINT);\n", "    Map<String, Integer> onceIterable = onceIterableMap(\"foo\", 1);\n", "    constrained.putAll(onceIterable);\n", "    assertEquals((Integer) 1, constrained.get(\"foo\"));\n", "  }\n", "\n", "  public void testNefariousMultimapPutAllIterable() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained = MapConstraints.constrainedMultimap(\n", "        multimap, TEST_CONSTRAINT);\n", "    Collection<Integer> onceIterable\n", "        = ConstraintsTest.onceIterableCollection(1);\n", "    constrained.putAll(\"foo\", onceIterable);\n", "    assertEquals(ImmutableList.of(1), constrained.get(\"foo\"));\n", "  }\n", "\n", "  public void testNefariousMultimapPutAllMultimap() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained = MapConstraints.constrainedMultimap(\n", "        multimap, TEST_CONSTRAINT);\n", "    Multimap<String, Integer> onceIterable\n", "        = Multimaps.forMap(onceIterableMap(\"foo\", 1));\n", "    constrained.putAll(onceIterable);\n", "    assertEquals(ImmutableList.of(1), constrained.get(\"foo\"));\n", "  }\n", "\n", "  public void testNefariousMultimapGetAddAll() {\n", "    Multimap<String, Integer> multimap = LinkedListMultimap.create();\n", "    Multimap<String, Integer> constrained = MapConstraints.constrainedMultimap(\n", "        multimap, TEST_CONSTRAINT);\n", "    Collection<Integer> onceIterable\n", "        = ConstraintsTest.onceIterableCollection(1);\n", "    constrained.get(\"foo\").addAll(onceIterable);\n", "    assertEquals(ImmutableList.of(1), constrained.get(\"foo\"));\n", "  }\n", "\n", "  /**\n", "   * Returns a \"nefarious\" map, which permits only one call to its views'\n", "   * iterator() methods. This verifies that the constrained map uses a\n", "   * defensive copy instead of potentially checking the elements in one snapshot\n", "   * and adding the elements from another.\n", "   *\n", "   * @param key the key to be contained in the map\n", "   * @param value the value to be contained in the map\n", "   */\n", "  static <K, V> Map<K, V> onceIterableMap(K key, V value) {\n", "    final Map.Entry<K, V> entry = Maps.immutableEntry(key, value);\n", "    return new AbstractMap<K, V>() {\n", "      boolean iteratorCalled;\n", "      @Override public int size() {\n", "        /*\n", "         * We could make the map empty, but that seems more likely to trigger\n", "         * special cases (so maybe we should test both empty and nonempty...).\n", "         */\n", "        return 1;\n", "      }\n", "      @Override public Set<Entry<K, V>> entrySet() {\n", "        return new ForwardingSet<Entry<K, V>>() {\n", "          @Override protected Set<Entry<K, V>> delegate() {\n", "            return Collections.singleton(entry);\n", "          }\n", "          @Override public Iterator<Entry<K, V>> iterator() {\n", "            assertFalse(\"Expected only one call to iterator()\", iteratorCalled);\n", "            iteratorCalled = true;\n", "            return super.iterator();\n", "          }\n", "        };\n", "      }\n", "      @Override public Set<K> keySet() {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "      @Override public Collection<V> values() {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "    };\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665]}}, {"124": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/MapMakerTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static java.util.concurrent.TimeUnit.HOURS;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Map;\n", "import java.util.concurrent.ConcurrentHashMap;\n", "import java.util.concurrent.ConcurrentMap;\n", "\n", "/**\n", " * @author Charles Fry\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MapMakerTest extends TestCase {\n", "\n", "  // \"Basher tests\", where we throw a bunch of stuff at a Cache and check basic invariants.\n", "\n", "  /*\n", "   * TODO(cpovirk): eliminate duplication between these tests and those in LegacyMapMakerTests and\n", "   * anywhere else\n", "   */\n", "\n", "  /** Tests for the builder. */\n", "  public static class MakerTest extends TestCase {\n", "    public void testInitialCapacity_negative() {\n", "      MapMaker maker = new MapMaker();\n", "      try {\n", "        maker.initialCapacity(-1);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "\n", "    // TODO(cpovirk): enable when ready\n", "    public void xtestInitialCapacity_setTwice() {\n", "      MapMaker maker = new MapMaker().initialCapacity(16);\n", "      try {\n", "        // even to the same value is not allowed\n", "        maker.initialCapacity(16);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {\n", "      }\n", "    }\n", "\n", "    @SuppressWarnings(\"deprecation\") // test of deprecated method\n", "    public void testExpiration_setTwice() {\n", "      MapMaker maker = new MapMaker().expireAfterWrite(1, HOURS);\n", "      try {\n", "        // even to the same value is not allowed\n", "        maker.expireAfterWrite(1, HOURS);\n", "        fail();\n", "      } catch (IllegalStateException expected) {\n", "      }\n", "    }\n", "\n", "    public void testMaximumSize_setTwice() {\n", "      MapMaker maker = new MapMaker().maximumSize(16);\n", "      try {\n", "        // even to the same value is not allowed\n", "        maker.maximumSize(16);\n", "        fail();\n", "      } catch (IllegalStateException expected) {\n", "      }\n", "    }\n", "\n", "    public void testReturnsPlainConcurrentHashMapWhenPossible() {\n", "      Map<?, ?> map = new MapMaker()\n", "          .initialCapacity(5)\n", "          .makeMap();\n", "      assertTrue(map instanceof ConcurrentHashMap);\n", "    }\n", "  }\n", "\n", "  /** Tests of the built map with maximumSize. */\n", "  public static class MaximumSizeTest extends TestCase {\n", "    public void testPut_sizeIsZero() {\n", "      ConcurrentMap<Object, Object> map =\n", "          new MapMaker().maximumSize(0).makeMap();\n", "      assertEquals(0, map.size());\n", "      map.put(new Object(), new Object());\n", "      assertEquals(0, map.size());\n", "    }\n", "\n", "    public void testSizeBasedEviction() {\n", "      int numKeys = 10;\n", "      int mapSize = 5;\n", "      ConcurrentMap<Object, Object> map =\n", "          new MapMaker().maximumSize(mapSize).makeMap();\n", "      for (int i = 0; i < numKeys; i++) {\n", "        map.put(i, i);\n", "      }\n", "      assertEquals(mapSize, map.size());\n", "      for (int i = numKeys - mapSize; i < mapSize; i++) {\n", "        assertTrue(map.containsKey(i));\n", "      }\n", "    }\n", "  }\n", "\n", "  /** Tests for recursive computation. */\n", "  public static class RecursiveComputationTest extends TestCase {\n", "    Function<Integer, String> recursiveComputer\n", "        = new Function<Integer, String>() {\n", "      @Override\n", "      public String apply(Integer key) {\n", "        if (key > 0) {\n", "          return key + \", \" + recursiveMap.get(key - 1);\n", "        } else {\n", "          return \"0\";\n", "        }\n", "      }\n", "    };\n", "\n", "    ConcurrentMap<Integer, String> recursiveMap = new MapMaker()\n", "        .makeComputingMap(recursiveComputer);\n", "\n", "    public void testRecursiveComputation() {\n", "      assertEquals(\"3, 2, 1, 0\", recursiveMap.get(3));\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Tests for computing functionality.\n", "   */\n", "  public static class ComputingTest extends TestCase {\n", "    public void testComputerThatReturnsNull() {\n", "      ConcurrentMap<Integer, String> map = new MapMaker()\n", "          .makeComputingMap(new Function<Integer, String>() {\n", "            @Override\n", "            public String apply(Integer key) {\n", "              return null;\n", "            }\n", "          });\n", "      try {\n", "        map.get(1);\n", "        fail();\n", "      } catch (NullPointerException e) { /* expected */ }\n", "    }\n", "\n", "    public void testRuntimeException() {\n", "      final RuntimeException e = new RuntimeException();\n", "\n", "      ConcurrentMap<Object, Object> map = new MapMaker().makeComputingMap(\n", "          new Function<Object, Object>() {\n", "        @Override\n", "        public Object apply(Object from) {\n", "          throw e;\n", "        }\n", "      });\n", "\n", "      try {\n", "        map.get(new Object());\n", "        fail();\n", "      } catch (ComputationException ce) {\n", "        assertSame(e, ce.getCause());\n", "      }\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179]}}, {"125": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/MapsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.Maps.transformEntries;\n", "import static com.google.common.collect.Maps.transformValues;\n", "import static com.google.common.collect.testing.Helpers.mapEntry;\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "import com.google.common.base.Equivalence;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Functions;\n", "import com.google.common.base.Predicate;\n", "import com.google.common.base.Predicates;\n", "import com.google.common.collect.Maps.EntryTransformer;\n", "import com.google.common.collect.Maps.ValueDifferenceImpl;\n", "import com.google.common.collect.SetsTest.Derived;\n", "import com.google.common.testing.EqualsTester;\n", "import com.google.common.testing.SerializableTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.EnumMap;\n", "import java.util.HashMap;\n", "import java.util.IdentityHashMap;\n", "import java.util.Iterator;\n", "import java.util.LinkedHashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "import java.util.SortedMap;\n", "import java.util.SortedSet;\n", "import java.util.TreeMap;\n", "import java.util.concurrent.ConcurrentMap;\n", "\n", "/**\n", " * Unit test for {@code Maps}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Mike Bostock\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MapsTest extends TestCase {\n", "\n", "  private static final Comparator<Integer> SOME_COMPARATOR =\n", "      Collections.reverseOrder();\n", "\n", "  public void testHashMap() {\n", "    HashMap<Integer, Integer> map = Maps.newHashMap();\n", "    assertEquals(Collections.emptyMap(), map);\n", "  }\n", "\n", "  public void testHashMapWithInitialMap() {\n", "    Map<String, Integer> original = new TreeMap<String, Integer>();\n", "    original.put(\"a\", 1);\n", "    original.put(\"b\", 2);\n", "    original.put(\"c\", 3);\n", "    HashMap<String, Integer> map = Maps.newHashMap(original);\n", "    assertEquals(original, map);\n", "  }\n", "\n", "  public void testHashMapGeneralizesTypes() {\n", "    Map<String, Integer> original = new TreeMap<String, Integer>();\n", "    original.put(\"a\", 1);\n", "    original.put(\"b\", 2);\n", "    original.put(\"c\", 3);\n", "    HashMap<Object, Object> map =\n", "        Maps.newHashMap((Map<? extends Object, ? extends Object>) original);\n", "    assertEquals(original, map);\n", "  }\n", "\n", "  public void testCapacityForNegativeSizeFails() {\n", "    try {\n", "      Maps.capacity(-1);\n", "      fail(\"Negative expected size must result in IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCapacityForLargeSizes() {\n", "    int[] largeExpectedSizes = new int[] {\n", "      Integer.MAX_VALUE / 2 - 1,\n", "      Integer.MAX_VALUE / 2,\n", "      Integer.MAX_VALUE / 2 + 1,\n", "      Integer.MAX_VALUE - 1,\n", "      Integer.MAX_VALUE};\n", "    for (int expectedSize : largeExpectedSizes) {\n", "      int capacity = Maps.capacity(expectedSize);\n", "      assertTrue(\n", "          \"capacity (\" + capacity + \") must be >= expectedSize (\" + expectedSize + \")\",\n", "          capacity >= expectedSize);\n", "    }\n", "  }\n", "\n", "  public void testLinkedHashMap() {\n", "    LinkedHashMap<Integer, Integer> map = Maps.newLinkedHashMap();\n", "    assertEquals(Collections.emptyMap(), map);\n", "  }\n", "\n", "  @SuppressWarnings(\"serial\")\n", "  public void testLinkedHashMapWithInitialMap() {\n", "    Map<String, String> map = new LinkedHashMap<String, String>() {{\n", "      put(\"Hello\", \"World\");\n", "      put(\"first\", \"second\");\n", "      put(\"polygene\", \"lubricants\");\n", "      put(\"alpha\", \"betical\");\n", "    }};\n", "\n", "    LinkedHashMap<String, String> copy = Maps.newLinkedHashMap(map);\n", "\n", "    Iterator<Entry<String, String>> iter = copy.entrySet().iterator();\n", "    assertTrue(iter.hasNext());\n", "    Entry<String, String> entry = iter.next();\n", "    assertEquals(\"Hello\", entry.getKey());\n", "    assertEquals(\"World\", entry.getValue());\n", "    assertTrue(iter.hasNext());\n", "\n", "    entry = iter.next();\n", "    assertEquals(\"first\", entry.getKey());\n", "    assertEquals(\"second\", entry.getValue());\n", "    assertTrue(iter.hasNext());\n", "\n", "    entry = iter.next();\n", "    assertEquals(\"polygene\", entry.getKey());\n", "    assertEquals(\"lubricants\", entry.getValue());\n", "    assertTrue(iter.hasNext());\n", "\n", "    entry = iter.next();\n", "    assertEquals(\"alpha\", entry.getKey());\n", "    assertEquals(\"betical\", entry.getValue());\n", "    assertFalse(iter.hasNext());\n", "  }\n", "\n", "  public void testLinkedHashMapGeneralizesTypes() {\n", "    Map<String, Integer> original = new LinkedHashMap<String, Integer>();\n", "    original.put(\"a\", 1);\n", "    original.put(\"b\", 2);\n", "    original.put(\"c\", 3);\n", "    HashMap<Object, Object> map\n", "        = Maps.<Object, Object>newLinkedHashMap(original);\n", "    assertEquals(original, map);\n", "  }\n", "\n", "  public void testIdentityHashMap() {\n", "    IdentityHashMap<Integer, Integer> map = Maps.newIdentityHashMap();\n", "    assertEquals(Collections.emptyMap(), map);\n", "  }\n", "\n", "  public void testConcurrentMap() {\n", "    ConcurrentMap<Integer, Integer> map = Maps.newConcurrentMap();\n", "    assertEquals(Collections.emptyMap(), map);\n", "  }\n", "\n", "  public void testTreeMap() {\n", "    TreeMap<Integer, Integer> map = Maps.newTreeMap();\n", "    assertEquals(Collections.emptyMap(), map);\n", "    assertNull(map.comparator());\n", "  }\n", "\n", "  public void testTreeMapDerived() {\n", "    TreeMap<Derived, Integer> map = Maps.newTreeMap();\n", "    assertEquals(Collections.emptyMap(), map);\n", "    map.put(new Derived(\"foo\"), 1);\n", "    map.put(new Derived(\"bar\"), 2);\n", "    assertThat(map.keySet()).containsExactly(\n", "        new Derived(\"bar\"), new Derived(\"foo\")).inOrder();\n", "    assertThat(map.values()).containsExactly(2, 1).inOrder();\n", "    assertNull(map.comparator());\n", "  }\n", "\n", "  public void testTreeMapNonGeneric() {\n", "    TreeMap<LegacyComparable, Integer> map = Maps.newTreeMap();\n", "    assertEquals(Collections.emptyMap(), map);\n", "    map.put(new LegacyComparable(\"foo\"), 1);\n", "    map.put(new LegacyComparable(\"bar\"), 2);\n", "    assertThat(map.keySet()).containsExactly(\n", "        new LegacyComparable(\"bar\"), new LegacyComparable(\"foo\")).inOrder();\n", "    assertThat(map.values()).containsExactly(2, 1).inOrder();\n", "    assertNull(map.comparator());\n", "  }\n", "\n", "  public void testTreeMapWithComparator() {\n", "    TreeMap<Integer, Integer> map = Maps.newTreeMap(SOME_COMPARATOR);\n", "    assertEquals(Collections.emptyMap(), map);\n", "    assertSame(SOME_COMPARATOR, map.comparator());\n", "  }\n", "\n", "  public void testTreeMapWithInitialMap() {\n", "    SortedMap<Integer, Integer> map = Maps.newTreeMap();\n", "    map.put(5, 10);\n", "    map.put(3, 20);\n", "    map.put(1, 30);\n", "    TreeMap<Integer, Integer> copy = Maps.newTreeMap(map);\n", "    assertEquals(copy, map);\n", "    assertSame(copy.comparator(), map.comparator());\n", "  }\n", "\n", "  public enum SomeEnum { SOME_INSTANCE }\n", "\n", "  public void testEnumMap() {\n", "    EnumMap<SomeEnum, Integer> map = Maps.newEnumMap(SomeEnum.class);\n", "    assertEquals(Collections.emptyMap(), map);\n", "    map.put(SomeEnum.SOME_INSTANCE, 0);\n", "    assertEquals(Collections.singletonMap(SomeEnum.SOME_INSTANCE, 0), map);\n", "  }\n", "\n", "  public void testEnumMapNullClass() {\n", "    try {\n", "      Maps.<SomeEnum, Long>newEnumMap((Class<MapsTest.SomeEnum>) null);\n", "      fail(\"no exception thrown\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testEnumMapWithInitialEnumMap() {\n", "    EnumMap<SomeEnum, Integer> original = Maps.newEnumMap(SomeEnum.class);\n", "    original.put(SomeEnum.SOME_INSTANCE, 0);\n", "    EnumMap<SomeEnum, Integer> copy = Maps.newEnumMap(original);\n", "    assertEquals(original, copy);\n", "  }\n", "\n", "  public void testEnumMapWithInitialEmptyEnumMap() {\n", "    EnumMap<SomeEnum, Integer> original = Maps.newEnumMap(SomeEnum.class);\n", "    EnumMap<SomeEnum, Integer> copy = Maps.newEnumMap(original);\n", "    assertEquals(original, copy);\n", "    assertNotSame(original, copy);\n", "  }\n", "\n", "  public void testEnumMapWithInitialMap() {\n", "    HashMap<SomeEnum, Integer> original = Maps.newHashMap();\n", "    original.put(SomeEnum.SOME_INSTANCE, 0);\n", "    EnumMap<SomeEnum, Integer> copy = Maps.newEnumMap(original);\n", "    assertEquals(original, copy);\n", "  }\n", "\n", "  public void testEnumMapWithInitialEmptyMap() {\n", "    Map<SomeEnum, Integer> original = Maps.newHashMap();\n", "    try {\n", "      Maps.newEnumMap(original);\n", "      fail(\"Empty map must result in an IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testToStringImplWithNullKeys() throws Exception {\n", "    Map<String, String> hashmap = Maps.newHashMap();\n", "    hashmap.put(\"foo\", \"bar\");\n", "    hashmap.put(null, \"baz\");\n", "\n", "    assertEquals(hashmap.toString(), Maps.toStringImpl(hashmap));\n", "  }\n", "\n", "  public void testToStringImplWithNullValues() throws Exception {\n", "    Map<String, String> hashmap = Maps.newHashMap();\n", "    hashmap.put(\"foo\", \"bar\");\n", "    hashmap.put(\"baz\", null);\n", "\n", "    assertEquals(hashmap.toString(), Maps.toStringImpl(hashmap));\n", "  }\n", "\n", "  private static final Map<Integer, Integer> EMPTY\n", "      = Collections.emptyMap();\n", "  private static final Map<Integer, Integer> SINGLETON\n", "      = Collections.singletonMap(1, 2);\n", "\n", "  public void testMapDifferenceEmptyEmpty() {\n", "    MapDifference<Integer, Integer> diff = Maps.difference(EMPTY, EMPTY);\n", "    assertTrue(diff.areEqual());\n", "    assertEquals(EMPTY, diff.entriesOnlyOnLeft());\n", "    assertEquals(EMPTY, diff.entriesOnlyOnRight());\n", "    assertEquals(EMPTY, diff.entriesInCommon());\n", "    assertEquals(EMPTY, diff.entriesDiffering());\n", "    assertEquals(\"equal\", diff.toString());\n", "  }\n", "\n", "  public void testMapDifferenceEmptySingleton() {\n", "    MapDifference<Integer, Integer> diff = Maps.difference(EMPTY, SINGLETON);\n", "    assertFalse(diff.areEqual());\n", "    assertEquals(EMPTY, diff.entriesOnlyOnLeft());\n", "    assertEquals(SINGLETON, diff.entriesOnlyOnRight());\n", "    assertEquals(EMPTY, diff.entriesInCommon());\n", "    assertEquals(EMPTY, diff.entriesDiffering());\n", "    assertEquals(\"not equal: only on right={1=2}\", diff.toString());\n", "  }\n", "\n", "  public void testMapDifferenceSingletonEmpty() {\n", "    MapDifference<Integer, Integer> diff = Maps.difference(SINGLETON, EMPTY);\n", "    assertFalse(diff.areEqual());\n", "    assertEquals(SINGLETON, diff.entriesOnlyOnLeft());\n", "    assertEquals(EMPTY, diff.entriesOnlyOnRight());\n", "    assertEquals(EMPTY, diff.entriesInCommon());\n", "    assertEquals(EMPTY, diff.entriesDiffering());\n", "    assertEquals(\"not equal: only on left={1=2}\", diff.toString());\n", "  }\n", "\n", "  public void testMapDifferenceTypical() {\n", "    Map<Integer, String> left = ImmutableMap.of(\n", "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n", "    Map<Integer, String> right = ImmutableMap.of(\n", "        1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n", "\n", "    MapDifference<Integer, String> diff1 = Maps.difference(left, right);\n", "    assertFalse(diff1.areEqual());\n", "    assertEquals(ImmutableMap.of(2, \"b\", 4, \"d\"), diff1.entriesOnlyOnLeft());\n", "    assertEquals(ImmutableMap.of(6, \"z\"), diff1.entriesOnlyOnRight());\n", "    assertEquals(ImmutableMap.of(1, \"a\"), diff1.entriesInCommon());\n", "    assertEquals(ImmutableMap.of(3,\n", "        ValueDifferenceImpl.create(\"c\", \"f\"), 5,\n", "        ValueDifferenceImpl.create(\"e\", \"g\")),\n", "        diff1.entriesDiffering());\n", "    assertEquals(\"not equal: only on left={2=b, 4=d}: only on right={6=z}: \"\n", "        + \"value differences={3=(c, f), 5=(e, g)}\", diff1.toString());\n", "\n", "    MapDifference<Integer, String> diff2 = Maps.difference(right, left);\n", "    assertFalse(diff2.areEqual());\n", "    assertEquals(ImmutableMap.of(6, \"z\"), diff2.entriesOnlyOnLeft());\n", "    assertEquals(ImmutableMap.of(2, \"b\", 4, \"d\"), diff2.entriesOnlyOnRight());\n", "    assertEquals(ImmutableMap.of(1, \"a\"), diff2.entriesInCommon());\n", "    assertEquals(ImmutableMap.of(3,\n", "        ValueDifferenceImpl.create(\"f\", \"c\"), 5,\n", "        ValueDifferenceImpl.create(\"g\", \"e\")),\n", "        diff2.entriesDiffering());\n", "    assertEquals(\"not equal: only on left={6=z}: only on right={2=b, 4=d}: \"\n", "        + \"value differences={3=(f, c), 5=(g, e)}\", diff2.toString());\n", "  }\n", "\n", "  public void testMapDifferenceEquals() {\n", "    Map<Integer, String> left = ImmutableMap.of(\n", "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n", "    Map<Integer, String> right = ImmutableMap.of(\n", "        1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n", "    Map<Integer, String> right2 = ImmutableMap.of(\n", "        1, \"a\", 3, \"h\", 5, \"g\", 6, \"z\");\n", "    MapDifference<Integer, String> original = Maps.difference(left, right);\n", "    MapDifference<Integer, String> same = Maps.difference(left, right);\n", "    MapDifference<Integer, String> reverse = Maps.difference(right, left);\n", "    MapDifference<Integer, String> diff2 = Maps.difference(left, right2);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(original, same)\n", "        .addEqualityGroup(reverse)\n", "        .addEqualityGroup(diff2)\n", "        .testEquals();\n", "  }\n", "\n", "  public void testMapDifferencePredicateTypical() {\n", "    Map<Integer, String> left = ImmutableMap.of(\n", "        1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n", "    Map<Integer, String> right = ImmutableMap.of(\n", "        1, \"A\", 3, \"F\", 5, \"G\", 6, \"Z\");\n", "\n", "    // TODO(kevinb): replace with Ascii.caseInsensitiveEquivalence() when it\n", "    // exists\n", "    Equivalence<String> caseInsensitiveEquivalence = Equivalence.equals().onResultOf(\n", "        new Function<String, String>() {\n", "          @Override public String apply(String input) {\n", "            return input.toLowerCase();\n", "          }\n", "        });\n", "\n", "    MapDifference<Integer, String> diff1 = Maps.difference(left, right,\n", "        caseInsensitiveEquivalence);\n", "    assertFalse(diff1.areEqual());\n", "    assertEquals(ImmutableMap.of(2, \"b\", 4, \"d\"), diff1.entriesOnlyOnLeft());\n", "    assertEquals(ImmutableMap.of(6, \"Z\"), diff1.entriesOnlyOnRight());\n", "    assertEquals(ImmutableMap.of(1, \"a\"), diff1.entriesInCommon());\n", "    assertEquals(ImmutableMap.of(3,\n", "        ValueDifferenceImpl.create(\"c\", \"F\"), 5,\n", "        ValueDifferenceImpl.create(\"e\", \"G\")),\n", "        diff1.entriesDiffering());\n", "    assertEquals(\"not equal: only on left={2=b, 4=d}: only on right={6=Z}: \"\n", "        + \"value differences={3=(c, F), 5=(e, G)}\", diff1.toString());\n", "\n", "    MapDifference<Integer, String> diff2 = Maps.difference(right, left,\n", "        caseInsensitiveEquivalence);\n", "    assertFalse(diff2.areEqual());\n", "    assertEquals(ImmutableMap.of(6, \"Z\"), diff2.entriesOnlyOnLeft());\n", "    assertEquals(ImmutableMap.of(2, \"b\", 4, \"d\"), diff2.entriesOnlyOnRight());\n", "    assertEquals(ImmutableMap.of(1, \"A\"), diff2.entriesInCommon());\n", "    assertEquals(ImmutableMap.of(3,\n", "        ValueDifferenceImpl.create(\"F\", \"c\"), 5,\n", "        ValueDifferenceImpl.create(\"G\", \"e\")),\n", "        diff2.entriesDiffering());\n", "    assertEquals(\"not equal: only on left={6=Z}: only on right={2=b, 4=d}: \"\n", "        + \"value differences={3=(F, c), 5=(G, e)}\", diff2.toString());\n", "  }\n", "\n", "  private static final SortedMap<Integer, Integer> SORTED_EMPTY = Maps.newTreeMap();\n", "  private static final SortedMap<Integer, Integer> SORTED_SINGLETON =\n", "      ImmutableSortedMap.of(1, 2);\n", "\n", "  public void testMapDifferenceOfSortedMapIsSorted() {\n", "    Map<Integer, Integer> map = SORTED_SINGLETON;\n", "    MapDifference<Integer, Integer> difference = Maps.difference(map, EMPTY);\n", "    assertTrue(difference instanceof SortedMapDifference);\n", "  }\n", "\n", "  public void testSortedMapDifferenceEmptyEmpty() {\n", "    SortedMapDifference<Integer, Integer> diff =\n", "        Maps.difference(SORTED_EMPTY, SORTED_EMPTY);\n", "    assertTrue(diff.areEqual());\n", "    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnLeft());\n", "    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnRight());\n", "    assertEquals(SORTED_EMPTY, diff.entriesInCommon());\n", "    assertEquals(SORTED_EMPTY, diff.entriesDiffering());\n", "    assertEquals(\"equal\", diff.toString());\n", "  }\n", "\n", "  public void testSortedMapDifferenceEmptySingleton() {\n", "    SortedMapDifference<Integer, Integer> diff =\n", "        Maps.difference(SORTED_EMPTY, SORTED_SINGLETON);\n", "    assertFalse(diff.areEqual());\n", "    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnLeft());\n", "    assertEquals(SORTED_SINGLETON, diff.entriesOnlyOnRight());\n", "    assertEquals(SORTED_EMPTY, diff.entriesInCommon());\n", "    assertEquals(SORTED_EMPTY, diff.entriesDiffering());\n", "    assertEquals(\"not equal: only on right={1=2}\", diff.toString());\n", "  }\n", "\n", "  public void testSortedMapDifferenceSingletonEmpty() {\n", "    SortedMapDifference<Integer, Integer> diff =\n", "        Maps.difference(SORTED_SINGLETON, SORTED_EMPTY);\n", "    assertFalse(diff.areEqual());\n", "    assertEquals(SORTED_SINGLETON, diff.entriesOnlyOnLeft());\n", "    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnRight());\n", "    assertEquals(SORTED_EMPTY, diff.entriesInCommon());\n", "    assertEquals(SORTED_EMPTY, diff.entriesDiffering());\n", "    assertEquals(\"not equal: only on left={1=2}\", diff.toString());\n", "  }\n", "\n", "  public void testSortedMapDifferenceTypical() {\n", "    SortedMap<Integer, String> left =\n", "        ImmutableSortedMap.<Integer, String>reverseOrder()\n", "        .put(1, \"a\").put(2, \"b\").put(3, \"c\").put(4, \"d\").put(5, \"e\")\n", "        .build();\n", "\n", "    SortedMap<Integer, String> right =\n", "        ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n", "\n", "    SortedMapDifference<Integer, String> diff1 =\n", "        Maps.difference(left, right);\n", "    assertFalse(diff1.areEqual());\n", "    assertThat(diff1.entriesOnlyOnLeft().entrySet()).containsExactly(\n", "        Maps.immutableEntry(4, \"d\"), Maps.immutableEntry(2, \"b\")).inOrder();\n", "    assertThat(diff1.entriesOnlyOnRight().entrySet()).contains(\n", "        Maps.immutableEntry(6, \"z\"));\n", "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n", "        Maps.immutableEntry(1, \"a\"));\n", "    assertThat(diff1.entriesDiffering().entrySet()).containsExactly(\n", "        Maps.immutableEntry(5, ValueDifferenceImpl.create(\"e\", \"g\")),\n", "        Maps.immutableEntry(3, ValueDifferenceImpl.create(\"c\", \"f\"))).inOrder();\n", "    assertEquals(\"not equal: only on left={4=d, 2=b}: only on right={6=z}: \"\n", "        + \"value differences={5=(e, g), 3=(c, f)}\", diff1.toString());\n", "\n", "    SortedMapDifference<Integer, String> diff2 =\n", "        Maps.difference(right, left);\n", "    assertFalse(diff2.areEqual());\n", "    assertThat(diff2.entriesOnlyOnLeft().entrySet()).contains(\n", "        Maps.immutableEntry(6, \"z\"));\n", "    assertThat(diff2.entriesOnlyOnRight().entrySet()).containsExactly(\n", "        Maps.immutableEntry(2, \"b\"), Maps.immutableEntry(4, \"d\")).inOrder();\n", "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n", "        Maps.immutableEntry(1, \"a\"));\n", "    assertEquals(ImmutableMap.of(\n", "            3, ValueDifferenceImpl.create(\"f\", \"c\"),\n", "            5, ValueDifferenceImpl.create(\"g\", \"e\")),\n", "        diff2.entriesDiffering());\n", "    assertEquals(\"not equal: only on left={6=z}: only on right={2=b, 4=d}: \"\n", "        + \"value differences={3=(f, c), 5=(g, e)}\", diff2.toString());\n", "  }\n", "\n", "  public void testSortedMapDifferenceImmutable() {\n", "    SortedMap<Integer, String> left = Maps.newTreeMap(\n", "        ImmutableSortedMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\"));\n", "    SortedMap<Integer, String> right =\n", "        Maps.newTreeMap(ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\"));\n", "\n", "    SortedMapDifference<Integer, String> diff1 =\n", "        Maps.difference(left, right);\n", "    left.put(6, \"z\");\n", "    assertFalse(diff1.areEqual());\n", "    assertThat(diff1.entriesOnlyOnLeft().entrySet()).containsExactly(\n", "        Maps.immutableEntry(2, \"b\"), Maps.immutableEntry(4, \"d\")).inOrder();\n", "    assertThat(diff1.entriesOnlyOnRight().entrySet()).contains(\n", "        Maps.immutableEntry(6, \"z\"));\n", "    assertThat(diff1.entriesInCommon().entrySet()).contains(\n", "        Maps.immutableEntry(1, \"a\"));\n", "    assertThat(diff1.entriesDiffering().entrySet()).containsExactly(\n", "        Maps.immutableEntry(3, ValueDifferenceImpl.create(\"c\", \"f\")),\n", "        Maps.immutableEntry(5, ValueDifferenceImpl.create(\"e\", \"g\"))).inOrder();\n", "    try {\n", "      diff1.entriesInCommon().put(7, \"x\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      diff1.entriesOnlyOnLeft().put(7, \"x\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      diff1.entriesOnlyOnRight().put(7, \"x\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testSortedMapDifferenceEquals() {\n", "    SortedMap<Integer, String> left =\n", "        ImmutableSortedMap.of(1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\", 5, \"e\");\n", "    SortedMap<Integer, String> right =\n", "        ImmutableSortedMap.of(1, \"a\", 3, \"f\", 5, \"g\", 6, \"z\");\n", "    SortedMap<Integer, String> right2 =\n", "        ImmutableSortedMap.of(1, \"a\", 3, \"h\", 5, \"g\", 6, \"z\");\n", "    SortedMapDifference<Integer, String> original =\n", "        Maps.difference(left, right);\n", "    SortedMapDifference<Integer, String> same =\n", "        Maps.difference(left, right);\n", "    SortedMapDifference<Integer, String> reverse =\n", "        Maps.difference(right, left);\n", "    SortedMapDifference<Integer, String> diff2 =\n", "        Maps.difference(left, right2);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(original, same)\n", "        .addEqualityGroup(reverse)\n", "        .addEqualityGroup(diff2)\n", "        .testEquals();\n", "  }\n", "\n", "  private static final Function<String, Integer> LENGTH_FUNCTION =\n", "      new Function<String, Integer>() {\n", "        @Override\n", "        public Integer apply(String input) {\n", "          return input.length();\n", "        }\n", "      };\n", "\n", "  public void testAsMap() {\n", "    Set<String> strings = ImmutableSet.of(\"one\", \"two\", \"three\");\n", "    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertEquals(Integer.valueOf(5), map.get(\"three\"));\n", "    assertNull(map.get(\"five\"));\n", "    assertThat(map.entrySet()).containsExactly(\n", "        mapEntry(\"one\", 3),\n", "        mapEntry(\"two\", 3),\n", "        mapEntry(\"three\", 5)).inOrder();\n", "  }\n", "\n", "  public void testAsMapReadsThrough() {\n", "    Set<String> strings = Sets.newLinkedHashSet();\n", "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n", "    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertNull(map.get(\"four\"));\n", "    strings.add(\"four\");\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5, \"four\", 4), map);\n", "    assertEquals(Integer.valueOf(4), map.get(\"four\"));\n", "  }\n", "\n", "  public void testAsMapWritesThrough() {\n", "    Set<String> strings = Sets.newLinkedHashSet();\n", "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n", "    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertEquals(Integer.valueOf(3), map.remove(\"two\"));\n", "    assertThat(strings).containsExactly(\"one\", \"three\").inOrder();\n", "  }\n", "\n", "  public void testAsMapEmpty() {\n", "    Set<String> strings = ImmutableSet.of();\n", "    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n", "    assertThat(map.entrySet()).isEmpty();\n", "    assertTrue(map.isEmpty());\n", "    assertNull(map.get(\"five\"));\n", "  }\n", "\n", "  private static class NonNavigableSortedSet\n", "      extends ForwardingSortedSet<String> {\n", "    private final SortedSet<String> delegate = Sets.newTreeSet();\n", "\n", "    @Override\n", "    protected SortedSet<String> delegate() {\n", "      return delegate;\n", "    }\n", "  }\n", "\n", "  public void testAsMapReturnsSortedMapForSortedSetInput() {\n", "    Set<String> set = new NonNavigableSortedSet();\n", "    assertTrue(Maps.asMap(set, Functions.identity()) instanceof SortedMap);\n", "  }\n", "\n", "  public void testAsMapSorted() {\n", "    SortedSet<String> strings = new NonNavigableSortedSet();\n", "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n", "    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertEquals(Integer.valueOf(5), map.get(\"three\"));\n", "    assertNull(map.get(\"five\"));\n", "    assertThat(map.entrySet()).containsExactly(\n", "        mapEntry(\"one\", 3),\n", "        mapEntry(\"three\", 5),\n", "        mapEntry(\"two\", 3)).inOrder();\n", "    assertThat(map.tailMap(\"onea\").entrySet()).containsExactly(\n", "        mapEntry(\"three\", 5),\n", "        mapEntry(\"two\", 3)).inOrder();\n", "    assertThat(map.subMap(\"one\", \"two\").entrySet()).containsExactly(\n", "        mapEntry(\"one\", 3),\n", "        mapEntry(\"three\", 5)).inOrder();\n", "  }\n", "\n", "  public void testAsMapSortedReadsThrough() {\n", "    SortedSet<String> strings = new NonNavigableSortedSet();\n", "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n", "    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n", "    assertNull(map.comparator());\n", "    assertEquals(ImmutableSortedMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertNull(map.get(\"four\"));\n", "    strings.add(\"four\");\n", "    assertEquals(\n", "        ImmutableSortedMap.of(\"one\", 3, \"two\", 3, \"three\", 5, \"four\", 4),\n", "        map);\n", "    assertEquals(Integer.valueOf(4), map.get(\"four\"));\n", "    SortedMap<String, Integer> headMap = map.headMap(\"two\");\n", "    assertEquals(\n", "        ImmutableSortedMap.of(\"four\", 4, \"one\", 3, \"three\", 5),\n", "        headMap);\n", "    strings.add(\"five\");\n", "    strings.remove(\"one\");\n", "    assertEquals(\n", "        ImmutableSortedMap.of(\"five\", 4, \"four\", 4, \"three\", 5),\n", "        headMap);\n", "    assertThat(map.entrySet()).containsExactly(\n", "        mapEntry(\"five\", 4),\n", "        mapEntry(\"four\", 4),\n", "        mapEntry(\"three\", 5),\n", "        mapEntry(\"two\", 3)).inOrder();\n", "  }\n", "\n", "  public void testAsMapSortedWritesThrough() {\n", "    SortedSet<String> strings = new NonNavigableSortedSet();\n", "    Collections.addAll(strings, \"one\", \"two\", \"three\");\n", "    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertEquals(Integer.valueOf(3), map.remove(\"two\"));\n", "    assertThat(strings).containsExactly(\"one\", \"three\").inOrder();\n", "  }\n", "\n", "  public void testAsMapSortedSubViewKeySetsDoNotSupportAdd() {\n", "    SortedMap<String, Integer> map = Maps.asMap(\n", "        new NonNavigableSortedSet(), LENGTH_FUNCTION);\n", "    try {\n", "      map.subMap(\"a\", \"z\").keySet().add(\"a\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      map.tailMap(\"a\").keySet().add(\"a\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      map.headMap(\"r\").keySet().add(\"a\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      map.headMap(\"r\").tailMap(\"m\").keySet().add(\"a\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsMapSortedEmpty() {\n", "    SortedSet<String> strings = new NonNavigableSortedSet();\n", "    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);\n", "    assertThat(map.entrySet()).isEmpty();\n", "    assertTrue(map.isEmpty());\n", "    assertNull(map.get(\"five\"));\n", "  }\n", "\n", "  public void testToMap() {\n", "    Iterable<String> strings = ImmutableList.of(\"one\", \"two\", \"three\");\n", "    ImmutableMap<String, Integer> map = Maps.toMap(strings, LENGTH_FUNCTION);\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertThat(map.entrySet()).containsExactly(\n", "        mapEntry(\"one\", 3),\n", "        mapEntry(\"two\", 3),\n", "        mapEntry(\"three\", 5)).inOrder();\n", "  }\n", "\n", "  public void testToMapIterator() {\n", "    Iterator<String> strings = ImmutableList.of(\"one\", \"two\", \"three\").iterator();\n", "    ImmutableMap<String, Integer> map = Maps.toMap(strings, LENGTH_FUNCTION);\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertThat(map.entrySet()).containsExactly(\n", "        mapEntry(\"one\", 3),\n", "        mapEntry(\"two\", 3),\n", "        mapEntry(\"three\", 5)).inOrder();\n", "  }\n", "\n", "  public void testToMapWithDuplicateKeys() {\n", "    Iterable<String> strings = ImmutableList.of(\"one\", \"two\", \"three\", \"two\", \"one\");\n", "    ImmutableMap<String, Integer> map = Maps.toMap(strings, LENGTH_FUNCTION);\n", "    assertEquals(ImmutableMap.of(\"one\", 3, \"two\", 3, \"three\", 5), map);\n", "    assertThat(map.entrySet()).containsExactly(\n", "        mapEntry(\"one\", 3),\n", "        mapEntry(\"two\", 3),\n", "        mapEntry(\"three\", 5)).inOrder();\n", "  }\n", "\n", "  public void testToMapWithNullKeys() {\n", "    Iterable<String> strings = Arrays.asList(\"one\", null, \"three\");\n", "    try {\n", "      Maps.toMap(strings, Functions.constant(\"foo\"));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToMapWithNullValues() {\n", "    Iterable<String> strings = ImmutableList.of(\"one\", \"two\", \"three\");\n", "    try {\n", "      Maps.toMap(strings, Functions.constant(null));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  private static final BiMap<Integer, String> INT_TO_STRING_MAP =\n", "      new ImmutableBiMap.Builder<Integer, String>()\n", "          .put(1, \"one\")\n", "          .put(2, \"two\")\n", "          .put(3, \"three\")\n", "          .build();\n", "\n", "  public void testUniqueIndexCollection() {\n", "    ImmutableMap<Integer, String> outputMap =\n", "        Maps.uniqueIndex(INT_TO_STRING_MAP.values(),\n", "            Functions.forMap(INT_TO_STRING_MAP.inverse()));\n", "    assertEquals(INT_TO_STRING_MAP, outputMap);\n", "  }\n", "\n", "  public void testUniqueIndexIterable() {\n", "    ImmutableMap<Integer, String> outputMap =\n", "        Maps.uniqueIndex(new Iterable<String>() {\n", "          @Override\n", "          public Iterator<String> iterator() {\n", "            return INT_TO_STRING_MAP.values().iterator();\n", "          }\n", "        },\n", "        Functions.forMap(INT_TO_STRING_MAP.inverse()));\n", "    assertEquals(INT_TO_STRING_MAP, outputMap);\n", "  }\n", "\n", "  public void testUniqueIndexIterator() {\n", "    ImmutableMap<Integer, String> outputMap =\n", "        Maps.uniqueIndex(INT_TO_STRING_MAP.values().iterator(),\n", "            Functions.forMap(INT_TO_STRING_MAP.inverse()));\n", "    assertEquals(INT_TO_STRING_MAP, outputMap);\n", "  }\n", "\n", "  /** Can't create the map if more than one value maps to the same key. */\n", "  public void testUniqueIndexDuplicates() {\n", "    try {\n", "      Maps.uniqueIndex(ImmutableSet.of(\"one\", \"uno\"), Functions.constant(1));\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "      assertThat(expected.getMessage()).contains(\"Multimaps.index\");\n", "    }\n", "  }\n", "\n", "  /** Null values are not allowed. */\n", "  public void testUniqueIndexNullValue() {\n", "    List<String> listWithNull = Lists.newArrayList((String) null);\n", "    try {\n", "      Maps.uniqueIndex(listWithNull, Functions.constant(1));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  /** Null keys aren't allowed either. */\n", "  public void testUniqueIndexNullKey() {\n", "    List<String> oneStringList = Lists.newArrayList(\"foo\");\n", "    try {\n", "      Maps.uniqueIndex(oneStringList, Functions.constant(null));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsConverter_nominal() throws Exception {\n", "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n", "        \"one\", 1,\n", "        \"two\", 2);\n", "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n", "    for (Entry<String, Integer> entry : biMap.entrySet()) {\n", "      assertSame(entry.getValue(), converter.convert(entry.getKey()));\n", "    }\n", "  }\n", "\n", "  public void testAsConverter_inverse() throws Exception {\n", "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n", "        \"one\", 1,\n", "        \"two\", 2);\n", "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n", "    for (Entry<String, Integer> entry : biMap.entrySet()) {\n", "      assertSame(entry.getKey(), converter.reverse().convert(entry.getValue()));\n", "    }\n", "  }\n", "\n", "  public void testAsConverter_noMapping() throws Exception {\n", "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n", "        \"one\", 1,\n", "        \"two\", 2);\n", "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n", "    try {\n", "      converter.convert(\"three\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsConverter_nullConversions() throws Exception {\n", "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n", "        \"one\", 1,\n", "        \"two\", 2);\n", "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n", "    assertNull(converter.convert(null));\n", "    assertNull(converter.reverse().convert(null));\n", "  }\n", "\n", "  public void testAsConverter_isAView() throws Exception {\n", "    BiMap<String, Integer> biMap = HashBiMap.create();\n", "    biMap.put(\"one\", 1);\n", "    biMap.put(\"two\", 2);\n", "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n", "\n", "    assertSame(1, converter.convert(\"one\"));\n", "    assertSame(2, converter.convert(\"two\"));\n", "    try {\n", "      converter.convert(\"three\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "\n", "    biMap.put(\"three\", 3);\n", "\n", "    assertSame(1, converter.convert(\"one\"));\n", "    assertSame(2, converter.convert(\"two\"));\n", "    assertSame(3, converter.convert(\"three\"));\n", "  }\n", "\n", "  public void testAsConverter_withNullMapping() throws Exception {\n", "    BiMap<String, Integer> biMap = HashBiMap.create();\n", "    biMap.put(\"one\", 1);\n", "    biMap.put(\"two\", 2);\n", "    biMap.put(\"three\", null);\n", "    try {\n", "      Maps.asConverter(biMap).convert(\"three\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsConverter_toString() {\n", "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n", "        \"one\", 1,\n", "        \"two\", 2);\n", "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n", "    assertEquals(\"Maps.asConverter({one=1, two=2})\", converter.toString());\n", "  }\n", "\n", "  public void testAsConverter_serialization() {\n", "    ImmutableBiMap<String, Integer> biMap = ImmutableBiMap.of(\n", "        \"one\", 1,\n", "        \"two\", 2);\n", "    Converter<String, Integer> converter = Maps.asConverter(biMap);\n", "    SerializableTester.reserializeAndAssert(converter);\n", "  }\n", "\n", "  public void testUnmodifiableBiMap() {\n", "    BiMap<Integer, String> mod = HashBiMap.create();\n", "    mod.put(1, \"one\");\n", "    mod.put(2, \"two\");\n", "    mod.put(3, \"three\");\n", "\n", "    BiMap<Number, String> unmod = Maps.<Number, String>unmodifiableBiMap(mod);\n", "\n", "    /* No aliasing on inverse operations. */\n", "    assertSame(unmod.inverse(), unmod.inverse());\n", "    assertSame(unmod, unmod.inverse().inverse());\n", "\n", "    /* Unmodifiable is a view. */\n", "    mod.put(4, \"four\");\n", "    assertEquals(true, unmod.get(4).equals(\"four\"));\n", "    assertEquals(true, unmod.inverse().get(\"four\").equals(4));\n", "\n", "    /* UnsupportedOperationException on direct modifications. */\n", "    try {\n", "      unmod.put(4, \"four\");\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      unmod.forcePut(4, \"four\");\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      unmod.putAll(Collections.singletonMap(4, \"four\"));\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "\n", "    /* UnsupportedOperationException on indirect modifications. */\n", "    BiMap<String, Number> inverse = unmod.inverse();\n", "    try {\n", "      inverse.put(\"four\", 4);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      inverse.forcePut(\"four\", 4);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      inverse.putAll(Collections.singletonMap(\"four\", 4));\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    Set<String> values = unmod.values();\n", "    try {\n", "      values.remove(\"four\");\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    Set<Map.Entry<Number, String>> entries = unmod.entrySet();\n", "    Map.Entry<Number, String> entry = entries.iterator().next();\n", "    try {\n", "      entry.setValue(\"four\");\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    @SuppressWarnings(\"unchecked\")\n", "    Map.Entry<Integer, String> entry2\n", "        = (Map.Entry<Integer, String>) entries.toArray()[0];\n", "    try {\n", "      entry2.setValue(\"four\");\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "  }\n", "\n", "  public void testImmutableEntry() {\n", "    Map.Entry<String, Integer> e = Maps.immutableEntry(\"foo\", 1);\n", "    assertEquals(\"foo\", e.getKey());\n", "    assertEquals(1, (int) e.getValue());\n", "    try {\n", "      e.setValue(2);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertEquals(\"foo=1\", e.toString());\n", "    assertEquals(101575, e.hashCode());\n", "  }\n", "\n", "  public void testImmutableEntryNull() {\n", "    Map.Entry<String, Integer> e\n", "        = Maps.immutableEntry((String) null, (Integer) null);\n", "    assertNull(e.getKey());\n", "    assertNull(e.getValue());\n", "    try {\n", "      e.setValue(null);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertEquals(\"null=null\", e.toString());\n", "    assertEquals(0, e.hashCode());\n", "  }\n", "\n", "  /** See {@link SynchronizedBiMapTest} for more tests. */\n", "  public void testSynchronizedBiMap() {\n", "    BiMap<String, Integer> bimap = HashBiMap.create();\n", "    bimap.put(\"one\", 1);\n", "    BiMap<String, Integer> sync = Maps.synchronizedBiMap(bimap);\n", "    bimap.put(\"two\", 2);\n", "    sync.put(\"three\", 3);\n", "    assertEquals(ImmutableSet.of(1, 2, 3), bimap.inverse().keySet());\n", "    assertEquals(ImmutableSet.of(1, 2, 3), sync.inverse().keySet());\n", "  }\n", "\n", "  private static final Predicate<String> NOT_LENGTH_3\n", "      = new Predicate<String>() {\n", "        @Override\n", "        public boolean apply(String input) {\n", "          return input == null || input.length() != 3;\n", "        }\n", "      };\n", "\n", "  private static final Predicate<Integer> EVEN\n", "      = new Predicate<Integer>() {\n", "        @Override\n", "        public boolean apply(Integer input) {\n", "          return input == null || input % 2 == 0;\n", "        }\n", "      };\n", "\n", "  private static final Predicate<Entry<String, Integer>> CORRECT_LENGTH\n", "      = new Predicate<Entry<String, Integer>>() {\n", "        @Override\n", "        public boolean apply(Entry<String, Integer> input) {\n", "          return input.getKey().length() == input.getValue();\n", "        }\n", "      };\n", "\n", "  private static final Function<Integer, Double> SQRT_FUNCTION = new Function<Integer, Double>() {\n", "      @Override\n", "      public Double apply(Integer in) {\n", "        return Math.sqrt(in);\n", "      }\n", "    };\n", "\n", "  public static class FilteredMapTest extends TestCase {\n", "    Map<String, Integer> createUnfiltered() {\n", "      return Maps.newHashMap();\n", "    }\n", "\n", "    public void testFilteredKeysIllegalPut() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);\n", "      filtered.put(\"a\", 1);\n", "      filtered.put(\"b\", 2);\n", "      assertEquals(ImmutableMap.of(\"a\", 1, \"b\", 2), filtered);\n", "\n", "      try {\n", "        filtered.put(\"yyy\", 3);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "\n", "    public void testFilteredKeysIllegalPutAll() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);\n", "      filtered.put(\"a\", 1);\n", "      filtered.put(\"b\", 2);\n", "      assertEquals(ImmutableMap.of(\"a\", 1, \"b\", 2), filtered);\n", "\n", "      try {\n", "        filtered.putAll(ImmutableMap.of(\"c\", 3, \"zzz\", 4, \"b\", 5));\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {}\n", "\n", "      assertEquals(ImmutableMap.of(\"a\", 1, \"b\", 2), filtered);\n", "    }\n", "\n", "    public void testFilteredKeysFilteredReflectsBackingChanges() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);\n", "      unfiltered.put(\"two\", 2);\n", "      unfiltered.put(\"three\", 3);\n", "      unfiltered.put(\"four\", 4);\n", "      assertEquals(ImmutableMap.of(\"two\", 2, \"three\", 3, \"four\", 4), unfiltered);\n", "      assertEquals(ImmutableMap.of(\"three\", 3, \"four\", 4), filtered);\n", "\n", "      unfiltered.remove(\"three\");\n", "      assertEquals(ImmutableMap.of(\"two\", 2, \"four\", 4), unfiltered);\n", "      assertEquals(ImmutableMap.of(\"four\", 4), filtered);\n", "\n", "      unfiltered.clear();\n", "      assertEquals(ImmutableMap.of(), unfiltered);\n", "      assertEquals(ImmutableMap.of(), filtered);\n", "    }\n", "\n", "    public void testFilteredValuesIllegalPut() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);\n", "      filtered.put(\"a\", 2);\n", "      unfiltered.put(\"b\", 4);\n", "      unfiltered.put(\"c\", 5);\n", "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n", "\n", "      try {\n", "        filtered.put(\"yyy\", 3);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {}\n", "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n", "    }\n", "\n", "    public void testFilteredValuesIllegalPutAll() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);\n", "      filtered.put(\"a\", 2);\n", "      unfiltered.put(\"b\", 4);\n", "      unfiltered.put(\"c\", 5);\n", "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n", "\n", "      try {\n", "        filtered.putAll(ImmutableMap.of(\"c\", 4, \"zzz\", 5, \"b\", 6));\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {}\n", "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n", "    }\n", "\n", "    public void testFilteredValuesIllegalSetValue() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);\n", "      filtered.put(\"a\", 2);\n", "      filtered.put(\"b\", 4);\n", "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n", "\n", "      Entry<String, Integer> entry = filtered.entrySet().iterator().next();\n", "      try {\n", "        entry.setValue(5);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {}\n", "\n", "      assertEquals(ImmutableMap.of(\"a\", 2, \"b\", 4), filtered);\n", "    }\n", "\n", "    public void testFilteredValuesClear() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      unfiltered.put(\"one\", 1);\n", "      unfiltered.put(\"two\", 2);\n", "      unfiltered.put(\"three\", 3);\n", "      unfiltered.put(\"four\", 4);\n", "      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);\n", "      assertEquals(ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4),\n", "          unfiltered);\n", "      assertEquals(ImmutableMap.of(\"two\", 2, \"four\", 4), filtered);\n", "\n", "      filtered.clear();\n", "      assertEquals(ImmutableMap.of(\"one\", 1, \"three\", 3), unfiltered);\n", "      assertTrue(filtered.isEmpty());\n", "    }\n", "\n", "    public void testFilteredEntriesIllegalPut() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      unfiltered.put(\"cat\", 3);\n", "      unfiltered.put(\"dog\", 2);\n", "      unfiltered.put(\"horse\", 5);\n", "      Map<String, Integer> filtered\n", "          = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n", "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5), filtered);\n", "\n", "      filtered.put(\"chicken\", 7);\n", "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5, \"chicken\", 7), filtered);\n", "\n", "      try {\n", "        filtered.put(\"cow\", 7);\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {}\n", "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5, \"chicken\", 7), filtered);\n", "    }\n", "\n", "    public void testFilteredEntriesIllegalPutAll() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      unfiltered.put(\"cat\", 3);\n", "      unfiltered.put(\"dog\", 2);\n", "      unfiltered.put(\"horse\", 5);\n", "      Map<String, Integer> filtered\n", "          = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n", "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5), filtered);\n", "\n", "      filtered.put(\"chicken\", 7);\n", "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5, \"chicken\", 7), filtered);\n", "\n", "      try {\n", "        filtered.putAll(ImmutableMap.of(\"sheep\", 5, \"cow\", 7));\n", "        fail();\n", "      } catch (IllegalArgumentException expected) {}\n", "      assertEquals(ImmutableMap.of(\"cat\", 3, \"horse\", 5, \"chicken\", 7), filtered);\n", "    }\n", "\n", "    public void testFilteredEntriesObjectPredicate() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      unfiltered.put(\"cat\", 3);\n", "      unfiltered.put(\"dog\", 2);\n", "      unfiltered.put(\"horse\", 5);\n", "      Predicate<Object> predicate = Predicates.alwaysFalse();\n", "      Map<String, Integer> filtered\n", "          = Maps.filterEntries(unfiltered, predicate);\n", "      assertTrue(filtered.isEmpty());\n", "    }\n", "\n", "    public void testFilteredEntriesWildCardEntryPredicate() {\n", "      Map<String, Integer> unfiltered = createUnfiltered();\n", "      unfiltered.put(\"cat\", 3);\n", "      unfiltered.put(\"dog\", 2);\n", "      unfiltered.put(\"horse\", 5);\n", "      Predicate<Entry<?, ?>> predicate = new Predicate<Entry<?, ?>>() {\n", "        @Override\n", "        public boolean apply(Entry<?, ?> input) {\n", "          return \"cat\".equals(input.getKey())\n", "              || Integer.valueOf(2) == input.getValue();\n", "        }\n", "      };\n", "      Map<String, Integer> filtered\n", "          = Maps.filterEntries(unfiltered, predicate);\n", "      assertEquals(ImmutableMap.of(\"cat\", 3, \"dog\", 2), filtered);\n", "    }\n", "  }\n", "\n", "  public static class FilteredSortedMapTest extends FilteredMapTest {\n", "    @Override\n", "    SortedMap<String, Integer> createUnfiltered() {\n", "      return Maps.newTreeMap();\n", "    }\n", "\n", "    public void testFilterKeysIdentifiesSortedMap() {\n", "      SortedMap<String, Integer> map = createUnfiltered();\n", "      assertTrue(Maps.filterKeys((Map<String, Integer>) map, NOT_LENGTH_3)\n", "          instanceof SortedMap);\n", "    }\n", "\n", "    public void testFilterValuesIdentifiesSortedMap() {\n", "      SortedMap<String, Integer> map = createUnfiltered();\n", "      assertTrue(Maps.filterValues((Map<String, Integer>) map, EVEN)\n", "          instanceof SortedMap);\n", "    }\n", "\n", "    public void testFilterEntriesIdentifiesSortedMap() {\n", "      SortedMap<String, Integer> map = createUnfiltered();\n", "      assertTrue(Maps.filterEntries((Map<String, Integer>) map, CORRECT_LENGTH)\n", "          instanceof SortedMap);\n", "    }\n", "\n", "    public void testFirstAndLastKeyFilteredMap() {\n", "      SortedMap<String, Integer> unfiltered = createUnfiltered();\n", "      unfiltered.put(\"apple\", 2);\n", "      unfiltered.put(\"banana\", 6);\n", "      unfiltered.put(\"cat\", 3);\n", "      unfiltered.put(\"dog\", 5);\n", "\n", "      SortedMap<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n", "      assertEquals(\"banana\", filtered.firstKey());\n", "      assertEquals(\"cat\", filtered.lastKey());\n", "    }\n", "\n", "    public void testHeadSubTailMap_FilteredMap() {\n", "      SortedMap<String, Integer> unfiltered = createUnfiltered();\n", "      unfiltered.put(\"apple\", 2);\n", "      unfiltered.put(\"banana\", 6);\n", "      unfiltered.put(\"cat\", 4);\n", "      unfiltered.put(\"dog\", 3);\n", "      SortedMap<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);\n", "\n", "      assertEquals(ImmutableMap.of(\"banana\", 6), filtered.headMap(\"dog\"));\n", "      assertEquals(ImmutableMap.of(), filtered.headMap(\"banana\"));\n", "      assertEquals(ImmutableMap.of(\"banana\", 6, \"dog\", 3), filtered.headMap(\"emu\"));\n", "\n", "      assertEquals(ImmutableMap.of(\"banana\", 6), filtered.subMap(\"banana\", \"dog\"));\n", "      assertEquals(ImmutableMap.of(\"dog\", 3), filtered.subMap(\"cat\", \"emu\"));\n", "\n", "      assertEquals(ImmutableMap.of(\"dog\", 3), filtered.tailMap(\"cat\"));\n", "      assertEquals(ImmutableMap.of(\"banana\", 6, \"dog\", 3), filtered.tailMap(\"banana\"));\n", "    }\n", "  }\n", "\n", "  public static class FilteredBiMapTest extends FilteredMapTest {\n", "    @Override\n", "    BiMap<String, Integer> createUnfiltered() {\n", "      return HashBiMap.create();\n", "    }\n", "\n", "    public void testFilterKeysIdentifiesBiMap() {\n", "      BiMap<String, Integer> map = createUnfiltered();\n", "      assertTrue(Maps.filterKeys((Map<String, Integer>) map, NOT_LENGTH_3)\n", "          instanceof BiMap);\n", "    }\n", "\n", "    public void testFilterValuesIdentifiesBiMap() {\n", "      BiMap<String, Integer> map = createUnfiltered();\n", "      assertTrue(Maps.filterValues((Map<String, Integer>) map, EVEN)\n", "          instanceof BiMap);\n", "    }\n", "\n", "    public void testFilterEntriesIdentifiesBiMap() {\n", "      BiMap<String, Integer> map = createUnfiltered();\n", "      assertTrue(Maps.filterEntries((Map<String, Integer>) map, CORRECT_LENGTH)\n", "          instanceof BiMap);\n", "    }\n", "  }\n", "\n", "  public void testTransformValues() {\n", "    Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9);\n", "    Map<String, Double> transformed = transformValues(map, SQRT_FUNCTION);\n", "\n", "    assertEquals(ImmutableMap.of(\"a\", 2.0, \"b\", 3.0), transformed);\n", "  }\n", "\n", "  public void testTransformValuesSecretlySorted() {\n", "    Map<String, Integer> map =\n", "        sortedNotNavigable(ImmutableSortedMap.of(\"a\", 4, \"b\", 9));\n", "    Map<String, Double> transformed = transformValues(map, SQRT_FUNCTION);\n", "\n", "    assertEquals(ImmutableMap.of(\"a\", 2.0, \"b\", 3.0), transformed);\n", "    assertTrue(transformed instanceof SortedMap);\n", "  }\n", "\n", "  public void testTransformEntries() {\n", "    Map<String, String> map = ImmutableMap.of(\"a\", \"4\", \"b\", \"9\");\n", "    EntryTransformer<String, String, String> concat =\n", "        new EntryTransformer<String, String, String>() {\n", "          @Override\n", "          public String transformEntry(String key, String value) {\n", "            return key + value;\n", "          }\n", "        };\n", "    Map<String, String> transformed = transformEntries(map, concat);\n", "\n", "    assertEquals(ImmutableMap.of(\"a\", \"a4\", \"b\", \"b9\"), transformed);\n", "  }\n", "\n", "  public void testTransformEntriesSecretlySorted() {\n", "    Map<String, String> map = ImmutableSortedMap.of(\"a\", \"4\", \"b\", \"9\");\n", "    EntryTransformer<String, String, String> concat =\n", "        new EntryTransformer<String, String, String>() {\n", "          @Override\n", "          public String transformEntry(String key, String value) {\n", "            return key + value;\n", "          }\n", "        };\n", "    Map<String, String> transformed = transformEntries(map, concat);\n", "\n", "    assertEquals(ImmutableMap.of(\"a\", \"a4\", \"b\", \"b9\"), transformed);\n", "    assertTrue(transformed instanceof SortedMap);\n", "  }\n", "\n", "  @SuppressWarnings(\"unused\")\n", "  public void testTransformEntriesGenerics() {\n", "    Map<Object, Object> map1 = ImmutableMap.<Object, Object>of(1, 2);\n", "    Map<Object, Number> map2 = ImmutableMap.<Object, Number>of(1, 2);\n", "    Map<Object, Integer> map3 = ImmutableMap.<Object, Integer>of(1, 2);\n", "    Map<Number, Object> map4 = ImmutableMap.<Number, Object>of(1, 2);\n", "    Map<Number, Number> map5 = ImmutableMap.<Number, Number>of(1, 2);\n", "    Map<Number, Integer> map6 = ImmutableMap.<Number, Integer>of(1, 2);\n", "    Map<Integer, Object> map7 = ImmutableMap.<Integer, Object>of(1, 2);\n", "    Map<Integer, Number> map8 = ImmutableMap.<Integer, Number>of(1, 2);\n", "    Map<Integer, Integer> map9 = ImmutableMap.<Integer, Integer>of(1, 2);\n", "    Map<? extends Number, ? extends Number> map0 = ImmutableMap.of(1, 2);\n", "\n", "    EntryTransformer<Number, Number, Double> transformer =\n", "        new EntryTransformer<Number, Number, Double>() {\n", "          @Override\n", "          public Double transformEntry(Number key, Number value) {\n", "            return key.doubleValue() + value.doubleValue();\n", "          }\n", "        };\n", "\n", "    Map<Object, Double> objectKeyed;\n", "    Map<Number, Double> numberKeyed;\n", "    Map<Integer, Double> integerKeyed;\n", "\n", "    numberKeyed = transformEntries(map5, transformer);\n", "    numberKeyed = transformEntries(map6, transformer);\n", "    integerKeyed = transformEntries(map8, transformer);\n", "    integerKeyed = transformEntries(map9, transformer);\n", "\n", "    Map<? extends Number, Double> wildcarded = transformEntries(map0, transformer);\n", "\n", "    // Can't loosen the key type:\n", "    // objectKeyed = transformEntries(map5, transformer);\n", "    // objectKeyed = transformEntries(map6, transformer);\n", "    // objectKeyed = transformEntries(map8, transformer);\n", "    // objectKeyed = transformEntries(map9, transformer);\n", "    // numberKeyed = transformEntries(map8, transformer);\n", "    // numberKeyed = transformEntries(map9, transformer);\n", "\n", "    // Can't loosen the value type:\n", "    // Map<Number, Number> looseValued1 = transformEntries(map5, transformer);\n", "    // Map<Number, Number> looseValued2 = transformEntries(map6, transformer);\n", "    // Map<Integer, Number> looseValued3 = transformEntries(map8, transformer);\n", "    // Map<Integer, Number> looseValued4 = transformEntries(map9, transformer);\n", "\n", "    // Can't call with too loose a key:\n", "    // transformEntries(map1, transformer);\n", "    // transformEntries(map2, transformer);\n", "    // transformEntries(map3, transformer);\n", "\n", "    // Can't call with too loose a value:\n", "    // transformEntries(map1, transformer);\n", "    // transformEntries(map4, transformer);\n", "    // transformEntries(map7, transformer);\n", "  }\n", "\n", "  public void testTransformEntriesExample() {\n", "    Map<String, Boolean> options =\n", "        ImmutableMap.of(\"verbose\", true, \"sort\", false);\n", "    EntryTransformer<String, Boolean, String> flagPrefixer =\n", "        new EntryTransformer<String, Boolean, String>() {\n", "          @Override\n", "          public String transformEntry(String key, Boolean value) {\n", "            return value ? key : \"no\" + key;\n", "          }\n", "        };\n", "    Map<String, String> transformed = transformEntries(options, flagPrefixer);\n", "    assertEquals(\"{verbose=verbose, sort=nosort}\", transformed.toString());\n", "  }\n", "\n", "  // Logically this would accept a NavigableMap, but that won't work under GWT.\n", "  private static <K, V> SortedMap<K, V> sortedNotNavigable(\n", "      final SortedMap<K, V> map) {\n", "    return new ForwardingSortedMap<K, V>() {\n", "      @Override protected SortedMap<K, V> delegate() {\n", "        return map;\n", "      }\n", "    };\n", "  }\n", "\n", "  public void testSortedMapTransformValues() {\n", "    SortedMap<String, Integer> map =\n", "        sortedNotNavigable(ImmutableSortedMap.of(\"a\", 4, \"b\", 9));\n", "    SortedMap<String, Double> transformed =\n", "        transformValues(map, SQRT_FUNCTION);\n", "\n", "    /*\n", "     * We'd like to sanity check that we didn't get a NavigableMap out, but we\n", "     * can't easily do so while maintaining GWT compatibility.\n", "     */\n", "    assertEquals(ImmutableSortedMap.of(\"a\", 2.0, \"b\", 3.0), transformed);\n", "  }\n", "\n", "  public void testSortedMapTransformEntries() {\n", "    SortedMap<String, String> map =\n", "        sortedNotNavigable(ImmutableSortedMap.of(\"a\", \"4\", \"b\", \"9\"));\n", "    EntryTransformer<String, String, String> concat =\n", "        new EntryTransformer<String, String, String>() {\n", "          @Override\n", "          public String transformEntry(String key, String value) {\n", "            return key + value;\n", "          }\n", "        };\n", "    SortedMap<String, String> transformed = transformEntries(map, concat);\n", "\n", "    /*\n", "     * We'd like to sanity check that we didn't get a NavigableMap out, but we\n", "     * can't easily do so while maintaining GWT compatibility.\n", "     */\n", "    assertEquals(ImmutableSortedMap.of(\"a\", \"a4\", \"b\", \"b9\"), transformed);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455]}}, {"126": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/MultimapBuilderTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.SortedMap;\n", "import java.util.SortedSet;\n", "\n", "/**\n", " * Tests for {@link MultimapBuilder}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MultimapBuilderTest extends TestCase {\n", "\n", "  public void testGenerics_gwtCompatible() {\n", "    ListMultimap<String, Integer> a =\n", "        MultimapBuilder.hashKeys().arrayListValues().<String, Integer>build();\n", "    SortedSetMultimap<String, Integer> b =\n", "        MultimapBuilder.linkedHashKeys().treeSetValues().<String, Integer>build();\n", "    SetMultimap<String, Integer> c = MultimapBuilder.treeKeys(String.CASE_INSENSITIVE_ORDER)\n", "        .hashSetValues().<String, Integer>build();\n", "  }\n", "\n", "  public void testTreeKeys_gwtCompatible() {\n", "    ListMultimap<String, Integer> multimap =\n", "        MultimapBuilder.treeKeys().arrayListValues().<String, Integer>build();\n", "    assertTrue(multimap.keySet() instanceof SortedSet);\n", "    assertTrue(multimap.asMap() instanceof SortedMap);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]}}, {"127": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/MultimapsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.collect.Sets.newHashSet;\n", "import static com.google.common.collect.testing.Helpers.nefariousMapEntry;\n", "import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Functions;\n", "import com.google.common.base.Predicates;\n", "import com.google.common.base.Supplier;\n", "import com.google.common.collect.testing.IteratorTester;\n", "import com.google.common.collect.testing.google.UnmodifiableCollectionTests;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.HashMap;\n", "import java.util.HashSet;\n", "import java.util.Iterator;\n", "import java.util.LinkedList;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Queue;\n", "import java.util.RandomAccess;\n", "import java.util.Set;\n", "import java.util.SortedMap;\n", "import java.util.SortedSet;\n", "import java.util.TreeSet;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Unit test for {@code Multimaps}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MultimapsTest extends TestCase {\n", "\n", "  private static final Comparator<Integer> INT_COMPARATOR =\n", "      Ordering.<Integer>natural().reverse().nullsFirst();\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testUnmodifiableListMultimapShortCircuit() {\n", "    ListMultimap<String, Integer> mod = ArrayListMultimap.create();\n", "    ListMultimap<String, Integer> unmod = Multimaps.unmodifiableListMultimap(mod);\n", "    assertNotSame(mod, unmod);\n", "    assertSame(unmod, Multimaps.unmodifiableListMultimap(unmod));\n", "    ImmutableListMultimap<String, Integer> immutable =\n", "        ImmutableListMultimap.of(\"a\", 1, \"b\", 2, \"a\", 3);\n", "    assertSame(immutable, Multimaps.unmodifiableListMultimap(immutable));\n", "    assertSame(\n", "        immutable, Multimaps.unmodifiableListMultimap((ListMultimap<String, Integer>) immutable));\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testUnmodifiableSetMultimapShortCircuit() {\n", "    SetMultimap<String, Integer> mod = HashMultimap.create();\n", "    SetMultimap<String, Integer> unmod = Multimaps.unmodifiableSetMultimap(mod);\n", "    assertNotSame(mod, unmod);\n", "    assertSame(unmod, Multimaps.unmodifiableSetMultimap(unmod));\n", "    ImmutableSetMultimap<String, Integer> immutable =\n", "        ImmutableSetMultimap.of(\"a\", 1, \"b\", 2, \"a\", 3);\n", "    assertSame(immutable, Multimaps.unmodifiableSetMultimap(immutable));\n", "    assertSame(\n", "        immutable, Multimaps.unmodifiableSetMultimap((SetMultimap<String, Integer>) immutable));\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testUnmodifiableMultimapShortCircuit() {\n", "    Multimap<String, Integer> mod = HashMultimap.create();\n", "    Multimap<String, Integer> unmod = Multimaps.unmodifiableMultimap(mod);\n", "    assertNotSame(mod, unmod);\n", "    assertSame(unmod, Multimaps.unmodifiableMultimap(unmod));\n", "    ImmutableMultimap<String, Integer> immutable = ImmutableMultimap.of(\"a\", 1, \"b\", 2, \"a\", 3);\n", "    assertSame(immutable, Multimaps.unmodifiableMultimap(immutable));\n", "    assertSame(immutable, Multimaps.unmodifiableMultimap((Multimap<String, Integer>) immutable));\n", "  }\n", "\n", "  public void testUnmodifiableArrayListMultimapRandomAccess() {\n", "    ListMultimap<String, Integer> delegate = ArrayListMultimap.create();\n", "    delegate.put(\"foo\", 1);\n", "    delegate.put(\"foo\", 3);\n", "    ListMultimap<String, Integer> multimap\n", "        = Multimaps.unmodifiableListMultimap(delegate);\n", "    assertTrue(multimap.get(\"foo\") instanceof RandomAccess);\n", "    assertTrue(multimap.get(\"bar\") instanceof RandomAccess);\n", "  }\n", "\n", "  public void testUnmodifiableLinkedListMultimapRandomAccess() {\n", "    ListMultimap<String, Integer> delegate = LinkedListMultimap.create();\n", "    delegate.put(\"foo\", 1);\n", "    delegate.put(\"foo\", 3);\n", "    ListMultimap<String, Integer> multimap = Multimaps.unmodifiableListMultimap(delegate);\n", "    assertThat(multimap.get(\"foo\")).isNotInstanceOf(RandomAccess.class);\n", "    assertThat(multimap.get(\"bar\")).isNotInstanceOf(RandomAccess.class);\n", "  }\n", "\n", "  public void testUnmodifiableMultimapIsView() {\n", "    Multimap<String, Integer> mod = HashMultimap.create();\n", "    Multimap<String, Integer> unmod = Multimaps.unmodifiableMultimap(mod);\n", "    assertEquals(mod, unmod);\n", "    mod.put(\"foo\", 1);\n", "    assertTrue(unmod.containsEntry(\"foo\", 1));\n", "    assertEquals(mod, unmod);\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testUnmodifiableMultimapEntries() {\n", "    Multimap<String, Integer> mod = HashMultimap.create();\n", "    Multimap<String, Integer> unmod = Multimaps.unmodifiableMultimap(mod);\n", "    mod.put(\"foo\", 1);\n", "    Entry<String, Integer> entry = unmod.entries().iterator().next();\n", "    try {\n", "      entry.setValue(2);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    entry = (Entry<String, Integer>) unmod.entries().toArray()[0];\n", "    try {\n", "      entry.setValue(2);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    Entry<String, Integer>[] array\n", "        = (Entry<String, Integer>[]) new Entry<?, ?>[2];\n", "    assertSame(array, unmod.entries().toArray(array));\n", "    try {\n", "      array[0].setValue(2);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertFalse(unmod.entries().contains(nefariousMapEntry(\"pwnd\", 2)));\n", "    assertFalse(unmod.keys().contains(\"pwnd\"));\n", "  }\n", "\n", "  /**\n", "   * The supplied multimap will be mutated and an unmodifiable instance used\n", "   * in its stead. The multimap must support null keys and values.\n", "   */\n", "  private static void checkUnmodifiableMultimap(\n", "      Multimap<String, Integer> multimap, boolean permitsDuplicates) {\n", "    checkUnmodifiableMultimap(multimap, permitsDuplicates, null, null);\n", "  }\n", "\n", "  /**\n", "   * The supplied multimap will be mutated and an unmodifiable instance used\n", "   * in its stead. If the multimap does not support null keys or values,\n", "   * alternatives may be specified for tests involving nulls.\n", "   */\n", "  private static void checkUnmodifiableMultimap(\n", "      Multimap<String, Integer> multimap, boolean permitsDuplicates,\n", "      @Nullable String nullKey, @Nullable Integer nullValue) {\n", "    Multimap<String, Integer> unmodifiable =\n", "        prepareUnmodifiableTests(multimap, permitsDuplicates, nullKey, nullValue);\n", "\n", "    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(\n", "        unmodifiable, \"test\", 123);\n", "\n", "    assertUnmodifiableIterableInTandem(\n", "        unmodifiable.keys(), multimap.keys());\n", "\n", "    assertUnmodifiableIterableInTandem(\n", "        unmodifiable.keySet(), multimap.keySet());\n", "\n", "    assertUnmodifiableIterableInTandem(\n", "        unmodifiable.entries(), multimap.entries());\n", "\n", "    assertUnmodifiableIterableInTandem(\n", "        unmodifiable.asMap().entrySet(), multimap.asMap().entrySet());\n", "\n", "    assertEquals(multimap.toString(), unmodifiable.toString());\n", "    assertEquals(multimap.hashCode(), unmodifiable.hashCode());\n", "    assertEquals(multimap, unmodifiable);\n", "\n", "    assertThat(unmodifiable.asMap().get(\"bar\")).containsExactly(5, -1);\n", "    assertNull(unmodifiable.asMap().get(\"missing\"));\n", "\n", "    assertThat(unmodifiable.entries()).isNotInstanceOf(Serializable.class);\n", "  }\n", "\n", "  /**\n", "   * Prepares the multimap for unmodifiable tests, returning an unmodifiable view\n", "   * of the map.\n", "   */\n", "  private static Multimap<String, Integer> prepareUnmodifiableTests(\n", "      Multimap<String, Integer> multimap, boolean permitsDuplicates,\n", "      @Nullable String nullKey, @Nullable Integer nullValue) {\n", "    multimap.clear();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 2);\n", "    multimap.put(\"foo\", 3);\n", "    multimap.put(\"bar\", 5);\n", "    multimap.put(\"bar\", -1);\n", "    multimap.put(nullKey, nullValue);\n", "    multimap.put(\"foo\", nullValue);\n", "    multimap.put(nullKey, 5);\n", "    multimap.put(\"foo\", 2);\n", "\n", "    if (permitsDuplicates) {\n", "      assertEquals(9, multimap.size());\n", "    } else {\n", "      assertEquals(8, multimap.size());\n", "    }\n", "\n", "    Multimap<String, Integer> unmodifiable;\n", "    if (multimap instanceof SortedSetMultimap) {\n", "      unmodifiable = Multimaps.unmodifiableSortedSetMultimap(\n", "          (SortedSetMultimap<String, Integer>) multimap);\n", "    } else if (multimap instanceof SetMultimap) {\n", "      unmodifiable = Multimaps.unmodifiableSetMultimap(\n", "          (SetMultimap<String, Integer>) multimap);\n", "    } else if (multimap instanceof ListMultimap) {\n", "      unmodifiable = Multimaps.unmodifiableListMultimap(\n", "          (ListMultimap<String, Integer>) multimap);\n", "    } else {\n", "      unmodifiable = Multimaps.unmodifiableMultimap(multimap);\n", "    }\n", "    return unmodifiable;\n", "  }\n", "\n", "  private static <T> void assertUnmodifiableIterableInTandem(\n", "      Iterable<T> unmodifiable, Iterable<T> modifiable) {\n", "    UnmodifiableCollectionTests.assertIteratorIsUnmodifiable(\n", "        unmodifiable.iterator());\n", "    UnmodifiableCollectionTests.assertIteratorsInOrder(\n", "        unmodifiable.iterator(), modifiable.iterator());\n", "  }\n", "\n", "  public void testInvertFrom() {\n", "    ImmutableMultimap<Integer, String> empty = ImmutableMultimap.of();\n", "\n", "    // typical usage example - sad that ArrayListMultimap.create() won't work\n", "    Multimap<String, Integer> multimap = Multimaps.invertFrom(empty,\n", "        ArrayListMultimap.<String, Integer>create());\n", "    assertTrue(multimap.isEmpty());\n", "\n", "    ImmutableMultimap<Integer, String> single\n", "        = new ImmutableMultimap.Builder<Integer, String>()\n", "            .put(1, \"one\")\n", "            .put(2, \"two\")\n", "            .build();\n", "\n", "    // copy into existing multimap\n", "    assertSame(multimap, Multimaps.invertFrom(single, multimap));\n", "\n", "    ImmutableMultimap<String, Integer> expected\n", "        = new ImmutableMultimap.Builder<String, Integer>()\n", "        .put(\"one\", 1)\n", "        .put(\"two\", 2)\n", "        .build();\n", "\n", "    assertEquals(expected, multimap);\n", "  }\n", "\n", "  public void testAsMap_multimap() {\n", "    Multimap<String, Integer> multimap = Multimaps.newMultimap(\n", "        new HashMap<String, Collection<Integer>>(), new QueueSupplier());\n", "    Map<String, Collection<Integer>> map = Multimaps.asMap(multimap);\n", "    assertSame(multimap.asMap(), map);\n", "  }\n", "\n", "  public void testAsMap_listMultimap() {\n", "    ListMultimap<String, Integer> listMultimap = ArrayListMultimap.create();\n", "    Map<String, List<Integer>> map = Multimaps.asMap(listMultimap);\n", "    assertSame(listMultimap.asMap(), map);\n", "  }\n", "\n", "  public void testAsMap_setMultimap() {\n", "    SetMultimap<String, Integer> setMultimap = LinkedHashMultimap.create();\n", "    Map<String, Set<Integer>> map = Multimaps.asMap(setMultimap);\n", "    assertSame(setMultimap.asMap(), map);\n", "  }\n", "\n", "  public void testAsMap_sortedSetMultimap() {\n", "    SortedSetMultimap<String, Integer> sortedSetMultimap =\n", "        TreeMultimap.create();\n", "    Map<String, SortedSet<Integer>> map = Multimaps.asMap(sortedSetMultimap);\n", "    assertSame(sortedSetMultimap.asMap(), map);\n", "  }\n", "\n", "  public void testForMap() {\n", "    Map<String, Integer> map = Maps.newHashMap();\n", "    map.put(\"foo\", 1);\n", "    map.put(\"bar\", 2);\n", "    Multimap<String, Integer> multimap = HashMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    Multimap<String, Integer> multimapView = Multimaps.forMap(map);\n", "    assertTrue(multimap.equals(multimapView));\n", "    assertTrue(multimapView.equals(multimap));\n", "    assertTrue(multimapView.equals(multimapView));\n", "    assertFalse(multimapView.equals(map));\n", "    Multimap<String, Integer> multimap2 = HashMultimap.create();\n", "    multimap2.put(\"foo\", 1);\n", "    assertFalse(multimapView.equals(multimap2));\n", "    multimap2.put(\"bar\", 1);\n", "    assertFalse(multimapView.equals(multimap2));\n", "    ListMultimap<String, Integer> listMultimap\n", "        = new ImmutableListMultimap.Builder<String, Integer>()\n", "            .put(\"foo\", 1).put(\"bar\", 2).build();\n", "    assertFalse(\"SetMultimap equals ListMultimap\",\n", "        multimapView.equals(listMultimap));\n", "    assertEquals(multimap.toString(), multimapView.toString());\n", "    assertEquals(multimap.hashCode(), multimapView.hashCode());\n", "    assertEquals(multimap.size(), multimapView.size());\n", "    assertTrue(multimapView.containsKey(\"foo\"));\n", "    assertTrue(multimapView.containsValue(1));\n", "    assertTrue(multimapView.containsEntry(\"bar\", 2));\n", "    assertEquals(Collections.singleton(1), multimapView.get(\"foo\"));\n", "    assertEquals(Collections.singleton(2), multimapView.get(\"bar\"));\n", "    try {\n", "      multimapView.put(\"baz\", 3);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      multimapView.putAll(\"baz\", Collections.singleton(3));\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      multimapView.putAll(multimap);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      multimapView.replaceValues(\"foo\", Collections.<Integer>emptySet());\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    multimapView.remove(\"bar\", 2);\n", "    assertFalse(multimapView.containsKey(\"bar\"));\n", "    assertFalse(map.containsKey(\"bar\"));\n", "    assertEquals(map.keySet(), multimapView.keySet());\n", "    assertEquals(map.keySet(), multimapView.keys().elementSet());\n", "    assertThat(multimapView.keys()).contains(\"foo\");\n", "    assertThat(multimapView.values()).contains(1);\n", "    assertThat(multimapView.entries()).contains(Maps.immutableEntry(\"foo\", 1));\n", "    assertThat(multimapView.asMap().entrySet())\n", "        .contains(Maps.immutableEntry(\"foo\", (Collection<Integer>) Collections.singleton(1)));\n", "    multimapView.clear();\n", "    assertFalse(multimapView.containsKey(\"foo\"));\n", "    assertFalse(map.containsKey(\"foo\"));\n", "    assertTrue(map.isEmpty());\n", "    assertTrue(multimapView.isEmpty());\n", "    multimap.clear();\n", "    assertEquals(multimap.toString(), multimapView.toString());\n", "    assertEquals(multimap.hashCode(), multimapView.hashCode());\n", "    assertEquals(multimap.size(), multimapView.size());\n", "    assertEquals(multimapView, ArrayListMultimap.create());\n", "  }\n", "\n", "  public void testForMapRemoveAll() {\n", "    Map<String, Integer> map = Maps.newHashMap();\n", "    map.put(\"foo\", 1);\n", "    map.put(\"bar\", 2);\n", "    map.put(\"cow\", 3);\n", "    Multimap<String, Integer> multimap = Multimaps.forMap(map);\n", "    assertEquals(3, multimap.size());\n", "    assertEquals(Collections.emptySet(), multimap.removeAll(\"dog\"));\n", "    assertEquals(3, multimap.size());\n", "    assertTrue(multimap.containsKey(\"bar\"));\n", "    assertEquals(Collections.singleton(2), multimap.removeAll(\"bar\"));\n", "    assertEquals(2, multimap.size());\n", "    assertFalse(multimap.containsKey(\"bar\"));\n", "  }\n", "\n", "  public void testForMapAsMap() {\n", "    Map<String, Integer> map = Maps.newHashMap();\n", "    map.put(\"foo\", 1);\n", "    map.put(\"bar\", 2);\n", "    Map<String, Collection<Integer>> asMap = Multimaps.forMap(map).asMap();\n", "    assertEquals(Collections.singleton(1), asMap.get(\"foo\"));\n", "    assertNull(asMap.get(\"cow\"));\n", "    assertTrue(asMap.containsKey(\"foo\"));\n", "    assertFalse(asMap.containsKey(\"cow\"));\n", "\n", "    Set<Entry<String, Collection<Integer>>> entries = asMap.entrySet();\n", "    assertFalse(entries.contains(4.5));\n", "    assertFalse(entries.remove(4.5));\n", "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n", "        Collections.singletonList(1))));\n", "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n", "        Collections.singletonList(1))));\n", "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n", "        Sets.newLinkedHashSet(asList(1, 2)))));\n", "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n", "        Sets.newLinkedHashSet(asList(1, 2)))));\n", "    assertFalse(entries.contains(Maps.immutableEntry(\"foo\",\n", "        Collections.singleton(2))));\n", "    assertFalse(entries.remove(Maps.immutableEntry(\"foo\",\n", "        Collections.singleton(2))));\n", "    assertTrue(map.containsKey(\"foo\"));\n", "    assertTrue(entries.contains(Maps.immutableEntry(\"foo\",\n", "        Collections.singleton(1))));\n", "    assertTrue(entries.remove(Maps.immutableEntry(\"foo\",\n", "        Collections.singleton(1))));\n", "    assertFalse(map.containsKey(\"foo\"));\n", "  }\n", "\n", "  public void testForMapGetIteration() {\n", "    IteratorTester<Integer> tester =\n", "        new IteratorTester<Integer>(4, MODIFIABLE, newHashSet(1),\n", "            IteratorTester.KnownOrder.KNOWN_ORDER) {\n", "          private Multimap<String, Integer> multimap;\n", "\n", "          @Override protected Iterator<Integer> newTargetIterator() {\n", "            Map<String, Integer> map = Maps.newHashMap();\n", "            map.put(\"foo\", 1);\n", "            map.put(\"bar\", 2);\n", "            multimap = Multimaps.forMap(map);\n", "            return multimap.get(\"foo\").iterator();\n", "          }\n", "\n", "          @Override protected void verify(List<Integer> elements) {\n", "            assertEquals(newHashSet(elements), multimap.get(\"foo\"));\n", "          }\n", "        };\n", "\n", "    tester.test();\n", "  }\n", "\n", "  private enum Color {BLUE, RED, YELLOW, GREEN}\n", "\n", "  private abstract static class CountingSupplier<E>\n", "      implements Supplier<E>, Serializable {\n", "    int count;\n", "\n", "    abstract E getImpl();\n", "\n", "    @Override\n", "    public E get() {\n", "      count++;\n", "      return getImpl();\n", "    }\n", "  }\n", "\n", "  private static class QueueSupplier extends CountingSupplier<Queue<Integer>> {\n", "    @Override public Queue<Integer> getImpl() {\n", "      return new LinkedList<Integer>();\n", "    }\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  public void testNewMultimapWithCollectionRejectingNegativeElements() {\n", "    CountingSupplier<Set<Integer>> factory = new SetSupplier() {\n", "      @Override\n", "      public Set<Integer> getImpl() {\n", "        final Set<Integer> backing = super.getImpl();\n", "        return new ForwardingSet<Integer>() {\n", "          @Override\n", "          protected Set<Integer> delegate() {\n", "            return backing;\n", "          }\n", "\n", "          @Override\n", "          public boolean add(Integer element) {\n", "            checkArgument(element >= 0);\n", "            return super.add(element);\n", "          }\n", "\n", "          @Override\n", "          public boolean addAll(Collection<? extends Integer> collection) {\n", "            return standardAddAll(collection);\n", "          }\n", "        };\n", "      }\n", "    };\n", "\n", "    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);\n", "    Multimap<Color, Integer> multimap = Multimaps.newMultimap(map, factory);\n", "    try {\n", "      multimap.put(Color.BLUE, -1);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // expected\n", "    }\n", "    multimap.put(Color.RED, 1);\n", "    multimap.put(Color.BLUE, 2);\n", "    try {\n", "      multimap.put(Color.GREEN, -1);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // expected\n", "    }\n", "    assertThat(multimap.entries()).containsExactly(\n", "        Maps.immutableEntry(Color.RED, 1),\n", "        Maps.immutableEntry(Color.BLUE, 2));\n", "  }\n", "\n", "  public void testNewMultimap() {\n", "    // The ubiquitous EnumArrayBlockingQueueMultimap\n", "    CountingSupplier<Queue<Integer>> factory = new QueueSupplier();\n", "\n", "    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);\n", "    Multimap<Color, Integer> multimap = Multimaps.newMultimap(map, factory);\n", "    assertEquals(0, factory.count);\n", "    multimap.putAll(Color.BLUE, asList(3, 1, 4));\n", "    assertEquals(1, factory.count);\n", "    multimap.putAll(Color.RED, asList(2, 7, 1, 8));\n", "    assertEquals(2, factory.count);\n", "    assertEquals(\"[3, 1, 4]\", multimap.get(Color.BLUE).toString());\n", "\n", "    Multimap<Color, Integer> ummodifiable =\n", "        Multimaps.unmodifiableMultimap(multimap);\n", "    assertEquals(\"[3, 1, 4]\", ummodifiable.get(Color.BLUE).toString());\n", "\n", "    Collection<Integer> collection = multimap.get(Color.BLUE);\n", "    assertEquals(collection, collection);\n", "\n", "    assertThat(multimap.keySet()).isNotInstanceOf(SortedSet.class);\n", "    assertThat(multimap.asMap()).isNotInstanceOf(SortedMap.class);\n", "  }\n", "\n", "  private static class ListSupplier extends\n", "      CountingSupplier<LinkedList<Integer>> {\n", "    @Override public LinkedList<Integer> getImpl() {\n", "      return new LinkedList<Integer>();\n", "    }\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  public void testNewListMultimap() {\n", "    CountingSupplier<LinkedList<Integer>> factory = new ListSupplier();\n", "    Map<Color, Collection<Integer>> map = Maps.newTreeMap();\n", "    ListMultimap<Color, Integer> multimap =\n", "        Multimaps.newListMultimap(map, factory);\n", "    assertEquals(0, factory.count);\n", "    multimap.putAll(Color.BLUE, asList(3, 1, 4, 1));\n", "    assertEquals(1, factory.count);\n", "    multimap.putAll(Color.RED, asList(2, 7, 1, 8));\n", "    assertEquals(2, factory.count);\n", "    assertEquals(\"{BLUE=[3, 1, 4, 1], RED=[2, 7, 1, 8]}\", multimap.toString());\n", "    assertThat(multimap.get(Color.BLUE)).isNotInstanceOf(RandomAccess.class);\n", "\n", "    assertTrue(multimap.keySet() instanceof SortedSet);\n", "    assertTrue(multimap.asMap() instanceof SortedMap);\n", "  }\n", "\n", "  private static class SetSupplier extends CountingSupplier<Set<Integer>> {\n", "    @Override public Set<Integer> getImpl() {\n", "      return new HashSet<Integer>(4);\n", "    }\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  public void testNewSetMultimap() {\n", "    CountingSupplier<Set<Integer>> factory = new SetSupplier();\n", "    Map<Color, Collection<Integer>> map = Maps.newHashMap();\n", "    SetMultimap<Color, Integer> multimap =\n", "        Multimaps.newSetMultimap(map, factory);\n", "    assertEquals(0, factory.count);\n", "    multimap.putAll(Color.BLUE, asList(3, 1, 4));\n", "    assertEquals(1, factory.count);\n", "    multimap.putAll(Color.RED, asList(2, 7, 1, 8));\n", "    assertEquals(2, factory.count);\n", "    assertEquals(Sets.newHashSet(4, 3, 1), multimap.get(Color.BLUE));\n", "  }\n", "\n", "  private static class SortedSetSupplier extends\n", "      CountingSupplier<TreeSet<Integer>> {\n", "    @Override public TreeSet<Integer> getImpl() {\n", "      return Sets.newTreeSet(INT_COMPARATOR);\n", "    }\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  public void testNewSortedSetMultimap() {\n", "    CountingSupplier<TreeSet<Integer>> factory = new SortedSetSupplier();\n", "    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);\n", "    SortedSetMultimap<Color, Integer> multimap =\n", "        Multimaps.newSortedSetMultimap(map, factory);\n", "    // newSortedSetMultimap calls the factory once to determine the comparator.\n", "    assertEquals(1, factory.count);\n", "    multimap.putAll(Color.BLUE, asList(3, 1, 4));\n", "    assertEquals(2, factory.count);\n", "    multimap.putAll(Color.RED, asList(2, 7, 1, 8));\n", "    assertEquals(3, factory.count);\n", "    assertEquals(\"[4, 3, 1]\", multimap.get(Color.BLUE).toString());\n", "    assertEquals(INT_COMPARATOR, multimap.valueComparator());\n", "  }\n", "\n", "  public void testIndex() {\n", "    final Multimap<String, Object> stringToObject =\n", "        new ImmutableMultimap.Builder<String, Object>()\n", "            .put(\"1\", 1)\n", "            .put(\"1\", 1L)\n", "            .put(\"1\", \"1\")\n", "            .put(\"2\", 2)\n", "            .put(\"2\", 2L)\n", "            .build();\n", "\n", "    ImmutableMultimap<String, Object> outputMap =\n", "        Multimaps.index(stringToObject.values(),\n", "            Functions.toStringFunction());\n", "    assertEquals(stringToObject, outputMap);\n", "  }\n", "\n", "  public void testIndexIterator() {\n", "    final Multimap<String, Object> stringToObject =\n", "        new ImmutableMultimap.Builder<String, Object>()\n", "            .put(\"1\", 1)\n", "            .put(\"1\", 1L)\n", "            .put(\"1\", \"1\")\n", "            .put(\"2\", 2)\n", "            .put(\"2\", 2L)\n", "            .build();\n", "\n", "    ImmutableMultimap<String, Object> outputMap =\n", "        Multimaps.index(stringToObject.values().iterator(),\n", "            Functions.toStringFunction());\n", "    assertEquals(stringToObject, outputMap);\n", "  }\n", "\n", "  public void testIndex_ordering() {\n", "    final Multimap<Integer, String> expectedIndex =\n", "        new ImmutableListMultimap.Builder<Integer, String>()\n", "            .put(4, \"Inky\")\n", "            .put(6, \"Blinky\")\n", "            .put(5, \"Pinky\")\n", "            .put(5, \"Pinky\")\n", "            .put(5, \"Clyde\")\n", "            .build();\n", "\n", "    final List<String> badGuys =\n", "        Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n", "    final Function<String, Integer> stringLengthFunction =\n", "        new Function<String, Integer>() {\n", "          @Override\n", "          public Integer apply(String input) {\n", "            return input.length();\n", "          }\n", "        };\n", "\n", "    Multimap<Integer, String> index =\n", "        Multimaps.index(badGuys, stringLengthFunction);\n", "\n", "    assertEquals(expectedIndex, index);\n", "  }\n", "\n", "  public void testIndex_nullValue() {\n", "    List<Integer> values = Arrays.asList(1, null);\n", "    try {\n", "      Multimaps.index(values, Functions.identity());\n", "      fail();\n", "    } catch (NullPointerException e) {}\n", "  }\n", "\n", "  public void testIndex_nullKey() {\n", "    List<Integer> values = Arrays.asList(1, 2);\n", "    try {\n", "      Multimaps.index(values, Functions.constant(null));\n", "      fail();\n", "    } catch (NullPointerException e) {}\n", "  }\n", "\n", "  public <K, V> void testSynchronizedMultimapSampleCodeCompilation() {\n", "    K key = null;\n", "\n", "    Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n", "        HashMultimap.<K, V>create());\n", "    Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n", "    synchronized (multimap) {  // Synchronizing on multimap, not values!\n", "      Iterator<V> i = values.iterator(); // Must be in synchronized block\n", "      while (i.hasNext()) {\n", "        foo(i.next());\n", "      }\n", "    }\n", "  }\n", "\n", "  private static void foo(Object o) {}\n", "  \n", "  public void testFilteredKeysSetMultimapReplaceValues() {\n", "    SetMultimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"baz\", 3);\n", "    multimap.put(\"bar\", 4);\n", "    \n", "    SetMultimap<String, Integer> filtered = Multimaps.filterKeys(\n", "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n", "    \n", "    assertEquals(\n", "        ImmutableSet.of(),\n", "        filtered.replaceValues(\"baz\", ImmutableSet.<Integer>of()));\n", "    \n", "    try {\n", "      filtered.replaceValues(\"baz\", ImmutableSet.of(5));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "  \n", "  public void testFilteredKeysSetMultimapGetBadValue() {\n", "    SetMultimap<String, Integer> multimap = LinkedHashMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"baz\", 3);\n", "    multimap.put(\"bar\", 4);\n", "    \n", "    SetMultimap<String, Integer> filtered = Multimaps.filterKeys(\n", "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n", "    Set<Integer> bazSet = filtered.get(\"baz\");\n", "    assertThat(bazSet).isEmpty();\n", "    try {\n", "      bazSet.add(5);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      bazSet.addAll(ImmutableSet.of(6, 7));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "  \n", "  public void testFilteredKeysListMultimapGetBadValue() {\n", "    ListMultimap<String, Integer> multimap = ArrayListMultimap.create();\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"bar\", 2);\n", "    multimap.put(\"baz\", 3);\n", "    multimap.put(\"bar\", 4);\n", "    \n", "    ListMultimap<String, Integer> filtered = Multimaps.filterKeys(\n", "        multimap, Predicates.in(ImmutableSet.of(\"foo\", \"bar\")));\n", "    List<Integer> bazList = filtered.get(\"baz\");\n", "    assertThat(bazList).isEmpty();\n", "    try {\n", "      bazList.add(5);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      bazList.add(0, 6);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      bazList.addAll(ImmutableList.of(7, 8));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      bazList.addAll(0, ImmutableList.of(9, 10));\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769]}}, {"128": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/MultisetsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.DerivedComparable;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.List;\n", "\n", "/**\n", " * Tests for {@link Multisets}.\n", " *\n", " * @author Mike Bostock\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MultisetsTest extends TestCase {\n", "\n", "  /* See MultisetsImmutableEntryTest for immutableEntry() tests. */\n", "\n", "  public void testNewTreeMultisetDerived() {\n", "    TreeMultiset<DerivedComparable> set = TreeMultiset.create();\n", "    assertTrue(set.isEmpty());\n", "    set.add(new DerivedComparable(\"foo\"), 2);\n", "    set.add(new DerivedComparable(\"bar\"), 3);\n", "    assertThat(set).containsExactly(\n", "        new DerivedComparable(\"bar\"), new DerivedComparable(\"bar\"), new DerivedComparable(\"bar\"),\n", "        new DerivedComparable(\"foo\"), new DerivedComparable(\"foo\")).inOrder();\n", "  }\n", "\n", "  public void testNewTreeMultisetNonGeneric() {\n", "    TreeMultiset<LegacyComparable> set = TreeMultiset.create();\n", "    assertTrue(set.isEmpty());\n", "    set.add(new LegacyComparable(\"foo\"), 2);\n", "    set.add(new LegacyComparable(\"bar\"), 3);\n", "    assertThat(set).containsExactly(new LegacyComparable(\"bar\"),\n", "        new LegacyComparable(\"bar\"), new LegacyComparable(\"bar\"),\n", "        new LegacyComparable(\"foo\"), new LegacyComparable(\"foo\")).inOrder();\n", "  }\n", "\n", "  public void testNewTreeMultisetComparator() {\n", "    TreeMultiset<String> multiset\n", "        = TreeMultiset.create(Collections.reverseOrder());\n", "    multiset.add(\"bar\", 3);\n", "    multiset.add(\"foo\", 2);\n", "    assertThat(multiset).containsExactly(\"foo\", \"foo\", \"bar\", \"bar\", \"bar\").inOrder();\n", "  }\n", "\n", "  public void testRetainOccurrencesEmpty() {\n", "    Multiset<String> multiset = HashMultiset.create();\n", "    Multiset<String> toRetain =\n", "        HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    assertFalse(Multisets.retainOccurrences(multiset, toRetain));\n", "    assertThat(multiset).isEmpty();\n", "  }\n", "\n", "  public void testRemoveOccurrencesIterableEmpty() {\n", "    Multiset<String> multiset = HashMultiset.create();\n", "    Iterable<String> toRemove = Arrays.asList(\"a\", \"b\", \"a\");\n", "    assertFalse(Multisets.removeOccurrences(multiset, toRemove));\n", "    assertTrue(multiset.isEmpty());\n", "  }\n", "\n", "  public void testRemoveOccurrencesMultisetEmpty() {\n", "    Multiset<String> multiset = HashMultiset.create();\n", "    Multiset<String> toRemove =\n", "        HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    assertFalse(Multisets.removeOccurrences(multiset, toRemove));\n", "    assertTrue(multiset.isEmpty());\n", "  }\n", "\n", "  public void testUnion() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create(\n", "        Arrays.asList(\"a\", \"b\", \"b\", \"c\"));\n", "    assertThat(Multisets.union(ms1, ms2)).containsExactly(\"a\", \"a\", \"b\", \"b\", \"c\");\n", "  }\n", "\n", "  public void testUnionEqualMultisets() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    assertEquals(ms1, Multisets.union(ms1, ms2));\n", "  }\n", "\n", "  public void testUnionEmptyNonempty() {\n", "    Multiset<String> ms1 = HashMultiset.create();\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    assertEquals(ms2, Multisets.union(ms1, ms2));\n", "  }\n", "\n", "  public void testUnionNonemptyEmpty() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create();\n", "    assertEquals(ms1, Multisets.union(ms1, ms2));\n", "  }\n", "\n", "  public void testIntersectEmptyNonempty() {\n", "    Multiset<String> ms1 = HashMultiset.create();\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    assertThat(Multisets.intersection(ms1, ms2)).isEmpty();\n", "  }\n", "\n", "  public void testIntersectNonemptyEmpty() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create();\n", "    assertThat(Multisets.intersection(ms1, ms2)).isEmpty();\n", "  }\n", "\n", "  public void testSum() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"b\", \"c\"));\n", "    assertThat(Multisets.sum(ms1, ms2)).containsExactly(\"a\", \"a\", \"b\", \"b\", \"c\");\n", "  }\n", "\n", "  public void testSumEmptyNonempty() {\n", "    Multiset<String> ms1 = HashMultiset.create();\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    assertThat(Multisets.sum(ms1, ms2)).containsExactly(\"a\", \"b\", \"a\");\n", "  }\n", "\n", "  public void testSumNonemptyEmpty() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create();\n", "    assertThat(Multisets.sum(ms1, ms2)).containsExactly(\"a\", \"b\", \"a\");\n", "  }\n", "\n", "  public void testDifferenceWithNoRemovedElements() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"a\"));\n", "    assertThat(Multisets.difference(ms1, ms2)).containsExactly(\"a\", \"b\");\n", "  }\n", "\n", "  public void testDifferenceWithRemovedElement() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"b\"));\n", "    assertThat(Multisets.difference(ms1, ms2)).containsExactly(\"a\", \"a\");\n", "  }\n", "\n", "  public void testDifferenceWithMoreElementsInSecondMultiset() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"b\", \"b\"));\n", "    Multiset<String> diff = Multisets.difference(ms1, ms2);\n", "    assertThat(diff).contains(\"a\");\n", "    assertEquals(0, diff.count(\"b\"));\n", "    assertEquals(1, diff.count(\"a\"));\n", "    assertFalse(diff.contains(\"b\"));\n", "    assertTrue(diff.contains(\"a\"));\n", "  }\n", "\n", "  public void testDifferenceEmptyNonempty() {\n", "    Multiset<String> ms1 = HashMultiset.create();\n", "    Multiset<String> ms2 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    assertEquals(ms1, Multisets.difference(ms1, ms2));\n", "  }\n", "\n", "  public void testDifferenceNonemptyEmpty() {\n", "    Multiset<String> ms1 = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> ms2 = HashMultiset.create();\n", "    assertEquals(ms1, Multisets.difference(ms1, ms2));\n", "  }\n", "\n", "  public void testContainsOccurrencesEmpty() {\n", "    Multiset<String> superMultiset = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> subMultiset = HashMultiset.create();\n", "    assertTrue(Multisets.containsOccurrences(superMultiset, subMultiset));\n", "    assertFalse(Multisets.containsOccurrences(subMultiset, superMultiset));\n", "  }\n", "\n", "  public void testContainsOccurrences() {\n", "    Multiset<String> superMultiset = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> subMultiset = HashMultiset.create(Arrays.asList(\"a\", \"b\"));\n", "    assertTrue(Multisets.containsOccurrences(superMultiset, subMultiset));\n", "    assertFalse(Multisets.containsOccurrences(subMultiset, superMultiset));\n", "    Multiset<String> diffMultiset = HashMultiset.create(Arrays.asList(\"a\", \"b\", \"c\"));\n", "    assertFalse(Multisets.containsOccurrences(superMultiset, diffMultiset));\n", "    assertTrue(Multisets.containsOccurrences(diffMultiset, subMultiset));\n", "  }\n", "\n", "  public void testRetainEmptyOccurrences() {\n", "    Multiset<String> multiset =\n", "        HashMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> toRetain = HashMultiset.create();\n", "    assertTrue(Multisets.retainOccurrences(multiset, toRetain));\n", "    assertTrue(multiset.isEmpty());\n", "  }\n", "\n", "  public void testRetainOccurrences() {\n", "    Multiset<String> multiset =\n", "        TreeMultiset.create(Arrays.asList(\"a\", \"b\", \"a\", \"c\"));\n", "    Multiset<String> toRetain =\n", "        HashMultiset.create(Arrays.asList(\"a\", \"b\", \"b\"));\n", "    assertTrue(Multisets.retainOccurrences(multiset, toRetain));\n", "    assertThat(multiset).containsExactly(\"a\", \"b\").inOrder();\n", "  }\n", "\n", "  public void testRemoveEmptyOccurrencesMultiset() {\n", "    Multiset<String> multiset =\n", "        TreeMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Multiset<String> toRemove = HashMultiset.create();\n", "    assertFalse(Multisets.removeOccurrences(multiset, toRemove));\n", "    assertThat(multiset).containsExactly(\"a\", \"a\", \"b\").inOrder();\n", "  }\n", "\n", "  public void testRemoveOccurrencesMultiset() {\n", "    Multiset<String> multiset =\n", "        TreeMultiset.create(Arrays.asList(\"a\", \"b\", \"a\", \"c\"));\n", "    Multiset<String> toRemove =\n", "        HashMultiset.create(Arrays.asList(\"a\", \"b\", \"b\"));\n", "    assertTrue(Multisets.removeOccurrences(multiset, toRemove));\n", "    assertThat(multiset).containsExactly(\"a\", \"c\").inOrder();\n", "  }\n", "\n", "  public void testRemoveEmptyOccurrencesIterable() {\n", "    Multiset<String> multiset =\n", "        TreeMultiset.create(Arrays.asList(\"a\", \"b\", \"a\"));\n", "    Iterable<String> toRemove = ImmutableList.of();\n", "    assertFalse(Multisets.removeOccurrences(multiset, toRemove));\n", "    assertThat(multiset).containsExactly(\"a\", \"a\", \"b\").inOrder();\n", "  }\n", "\n", "  public void testRemoveOccurrencesMultisetIterable() {\n", "    Multiset<String> multiset =\n", "        TreeMultiset.create(Arrays.asList(\"a\", \"b\", \"a\", \"c\"));\n", "    List<String> toRemove = Arrays.asList(\"a\", \"b\", \"b\");\n", "    assertTrue(Multisets.removeOccurrences(multiset, toRemove));\n", "    assertThat(multiset).containsExactly(\"a\", \"c\").inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"deprecation\")\n", "  public void testUnmodifiableMultisetShortCircuit() {\n", "    Multiset<String> mod = HashMultiset.create();\n", "    Multiset<String> unmod = Multisets.unmodifiableMultiset(mod);\n", "    assertNotSame(mod, unmod);\n", "    assertSame(unmod, Multisets.unmodifiableMultiset(unmod));\n", "    ImmutableMultiset<String> immutable = ImmutableMultiset.of(\"a\", \"a\", \"b\", \"a\");\n", "    assertSame(immutable, Multisets.unmodifiableMultiset(immutable));\n", "    assertSame(immutable, Multisets.unmodifiableMultiset((Multiset<String>) immutable));\n", "  }\n", "\n", "  public void testHighestCountFirst() {\n", "    Multiset<String> multiset = HashMultiset.create(\n", "        Arrays.asList(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\"));\n", "    ImmutableMultiset<String> sortedMultiset =\n", "        Multisets.copyHighestCountFirst(multiset);\n", "\n", "    assertThat(sortedMultiset.entrySet()).containsExactly(\n", "        Multisets.immutableEntry(\"a\", 3), Multisets.immutableEntry(\"c\", 2),\n", "        Multisets.immutableEntry(\"b\", 1)).inOrder();\n", "\n", "    assertThat(sortedMultiset).containsExactly(\n", "        \"a\",\n", "        \"a\",\n", "        \"a\",\n", "        \"c\",\n", "        \"c\",\n", "        \"b\").inOrder();\n", "\n", "    assertThat(Multisets.copyHighestCountFirst(ImmutableMultiset.of())).isEmpty();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282]}}, {"129": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/ObjectArraysTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@code ObjectArrays}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ObjectArraysTest extends TestCase {\n", "\n", "  public void testNewArray_fromArray_Empty() {\n", "    String[] in = new String[0];\n", "    String[] empty = ObjectArrays.newArray(in, 0);\n", "    assertThat(empty).isEmpty();\n", "  }\n", "\n", "  public void testNewArray_fromArray_Nonempty() {\n", "    String[] array = ObjectArrays.newArray(new String[0], 2);\n", "    assertEquals(String[].class, array.getClass());\n", "    assertThat(array).hasLength(2);\n", "    assertNull(array[0]);\n", "  }\n", "\n", "  public void testNewArray_fromArray_OfArray() {\n", "    String[][] array = ObjectArrays.newArray(new String[0][0], 1);\n", "    assertEquals(String[][].class, array.getClass());\n", "    assertThat(array).hasLength(1);\n", "    assertNull(array[0]);\n", "  }\n", "\n", "  public void testToArrayImpl1() {\n", "    doTestToArrayImpl1(Lists.<Integer>newArrayList());\n", "    doTestToArrayImpl1(Lists.newArrayList(1));\n", "    doTestToArrayImpl1(Lists.newArrayList(1, null, 3));\n", "  }\n", "\n", "  private void doTestToArrayImpl1(List<Integer> list) {\n", "    Object[] reference = list.toArray();\n", "    Object[] target = ObjectArrays.toArrayImpl(list);\n", "    assertEquals(reference.getClass(), target.getClass());\n", "    assertTrue(Arrays.equals(reference, target));\n", "  }\n", "\n", "  public void testToArrayImpl2() {\n", "    doTestToArrayImpl2(Lists.<Integer>newArrayList(), new Integer[0], false);\n", "    doTestToArrayImpl2(Lists.<Integer>newArrayList(), new Integer[1], true);\n", "\n", "    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[0], false);\n", "    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[1], true);\n", "    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[] { 2, 3 }, true);\n", "\n", "    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[0], false);\n", "    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[2], false);\n", "    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[3], true);\n", "  }\n", "\n", "  private void doTestToArrayImpl2(List<Integer> list, Integer[] array1,\n", "      boolean expectModify) {\n", "    Integer[] starting = ObjectArrays.arraysCopyOf(array1, array1.length);\n", "    Integer[] array2 = ObjectArrays.arraysCopyOf(array1, array1.length);\n", "    Object[] reference = list.toArray(array1);\n", "\n", "    Object[] target = ObjectArrays.toArrayImpl(list, array2);\n", "\n", "    assertEquals(reference.getClass(), target.getClass());\n", "    assertTrue(Arrays.equals(reference, target));\n", "    assertTrue(Arrays.equals(reference, target));\n", "\n", "    Object[] expectedArray1 = expectModify ? reference : starting;\n", "    Object[] expectedArray2 = expectModify ? target : starting;\n", "    assertTrue(Arrays.equals(expectedArray1, array1));\n", "    assertTrue(Arrays.equals(expectedArray2, array2));\n", "  }\n", "\n", "  public void testPrependZeroElements() {\n", "    String[] result = ObjectArrays.concat(\"foo\", new String[] {});\n", "    assertThat(result).asList().contains(\"foo\");\n", "  }\n", "\n", "  public void testPrependOneElement() {\n", "    String[] result = ObjectArrays.concat(\"foo\", new String[] { \"bar\" });\n", "    assertThat(result).asList().containsExactly(\"foo\", \"bar\").inOrder();\n", "  }\n", "\n", "  public void testPrependTwoElements() {\n", "    String[] result = ObjectArrays.concat(\"foo\", new String[] { \"bar\", \"baz\" });\n", "    assertThat(result).asList().containsExactly(\"foo\", \"bar\", \"baz\").inOrder();\n", "  }\n", "\n", "  public void testAppendZeroElements() {\n", "    String[] result = ObjectArrays.concat(new String[] {}, \"foo\");\n", "    assertThat(result).asList().contains(\"foo\");\n", "  }\n", "\n", "  public void testAppendOneElement() {\n", "    String[] result = ObjectArrays.concat(new String[] { \"foo\" }, \"bar\");\n", "    assertThat(result).asList().containsExactly(\"foo\", \"bar\").inOrder();\n", "  }\n", "\n", "  public void testAppendTwoElements() {\n", "    String[] result = ObjectArrays.concat(new String[] { \"foo\", \"bar\" }, \"baz\");\n", "    assertThat(result).asList().containsExactly(\"foo\", \"bar\", \"baz\").inOrder();\n", "  }\n", "\n", "  public void testEmptyArrayToEmpty() {\n", "    doTestNewArrayEquals(new Object[0], 0);\n", "  }\n", "\n", "  public void testEmptyArrayToNonEmpty() {\n", "    checkArrayEquals(new Long[5], ObjectArrays.newArray(new Long[0], 5));\n", "  }\n", "\n", "  public void testNonEmptyToShorter() {\n", "    checkArrayEquals(new String[9], ObjectArrays.newArray(new String[10], 9));\n", "  }\n", "\n", "  public void testNonEmptyToSameLength() {\n", "    doTestNewArrayEquals(new String[10], 10);\n", "  }\n", "\n", "  public void testNonEmptyToLonger() {\n", "    checkArrayEquals(new String[10],\n", "        ObjectArrays.newArray(new String[] { \"a\", \"b\", \"c\", \"d\", \"e\" }, 10));\n", "  }\n", "\n", "  private static void checkArrayEquals(Object[] expected, Object[] actual) {\n", "    assertTrue(\"expected(\" + expected.getClass() + \"): \" + Arrays.toString(expected)\n", "        + \" actual(\" + actual.getClass() + \"): \" + Arrays.toString(actual),\n", "        arrayEquals(expected, actual));\n", "  }\n", "\n", "  private static boolean arrayEquals(Object[] array1, Object[] array2) {\n", "    assertSame(array1.getClass(), array2.getClass());\n", "    return Arrays.equals(array1, array2);\n", "  }\n", "\n", "  private static void doTestNewArrayEquals(Object[] expected, int length) {\n", "    checkArrayEquals(expected, ObjectArrays.newArray(expected, length));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166]}}, {"130": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/OrderingTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "import static com.google.common.collect.Lists.newArrayList;\n", "import static com.google.common.testing.SerializableTester.reserialize;\n", "import static com.google.common.testing.SerializableTester.reserializeAndAssert;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Functions;\n", "import com.google.common.collect.Ordering.ArbitraryOrdering;\n", "import com.google.common.collect.Ordering.IncomparableValueException;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.primitives.Ints;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.Random;\n", "import java.util.RandomAccess;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Unit tests for {@code Ordering}.\n", " *\n", " * @author Jesse Wilson\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class OrderingTest extends TestCase {\n", "  // TODO(cpovirk): some of these are inexplicably slow (20-30s) under GWT\n", "\n", "  private final Ordering<Number> numberOrdering = new NumberOrdering();\n", "\n", "  public void testAllEqual() {\n", "    Ordering<Object> comparator = Ordering.allEqual();\n", "    assertSame(comparator, comparator.reverse());\n", "\n", "    assertEquals(comparator.compare(null, null), 0);\n", "    assertEquals(comparator.compare(new Object(), new Object()), 0);\n", "    assertEquals(comparator.compare(\"apples\", \"oranges\"), 0);\n", "    assertSame(comparator, reserialize(comparator));\n", "    assertEquals(\"Ordering.allEqual()\", comparator.toString());\n", "\n", "    List<String> strings = ImmutableList.of(\"b\", \"a\", \"d\", \"c\");\n", "    assertEquals(strings, comparator.sortedCopy(strings));\n", "    assertEquals(strings, comparator.immutableSortedCopy(strings));\n", "  }\n", "\n", "  // From https://github.com/google/guava/issues/1342\n", "  public void testComplicatedOrderingExample() {\n", "    Integer nullInt = (Integer) null;\n", "    Ordering<Iterable<Integer>> example =\n", "        Ordering.<Integer>natural().nullsFirst().reverse().lexicographical().reverse().nullsLast();\n", "    List<Integer> list1 = Lists.newArrayList();\n", "    List<Integer> list2 = Lists.newArrayList(1);\n", "    List<Integer> list3 = Lists.newArrayList(1, 1);\n", "    List<Integer> list4 = Lists.newArrayList(1, 2);\n", "    List<Integer> list5 = Lists.newArrayList(1, null, 2);\n", "    List<Integer> list6 = Lists.newArrayList(2);\n", "    List<Integer> list7 = Lists.newArrayList(nullInt);\n", "    List<Integer> list8 = Lists.newArrayList(nullInt, nullInt);\n", "    List<List<Integer>> list =\n", "        Lists.newArrayList(list1, list2, list3, list4, list5, list6, list7, list8, null);\n", "    List<List<Integer>> sorted = example.sortedCopy(list);\n", "\n", "    // [[null, null], [null], [1, null, 2], [1, 1], [1, 2], [1], [2], [], null]\n", "    assertThat(sorted)\n", "        .containsExactly(\n", "            Lists.newArrayList(nullInt, nullInt),\n", "            Lists.newArrayList(nullInt),\n", "            Lists.newArrayList(1, null, 2),\n", "            Lists.newArrayList(1, 1),\n", "            Lists.newArrayList(1, 2),\n", "            Lists.newArrayList(1),\n", "            Lists.newArrayList(2),\n", "            Lists.newArrayList(),\n", "            null)\n", "        .inOrder();\n", "  }\n", "\n", "  public void testNatural() {\n", "    Ordering<Integer> comparator = Ordering.natural();\n", "    Helpers.testComparator(comparator,\n", "        Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE);\n", "    try {\n", "      comparator.compare(1, null);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      comparator.compare(null, 2);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    try {\n", "      comparator.compare(null, null);\n", "      fail();\n", "    } catch (NullPointerException expected) {}\n", "    assertSame(comparator, reserialize(comparator));\n", "    assertEquals(\"Ordering.natural()\", comparator.toString());\n", "  }\n", "\n", "  public void testFrom() {\n", "    Ordering<String> caseInsensitiveOrdering\n", "        = Ordering.from(String.CASE_INSENSITIVE_ORDER);\n", "    assertEquals(0, caseInsensitiveOrdering.compare(\"A\", \"a\"));\n", "    assertTrue(caseInsensitiveOrdering.compare(\"a\", \"B\") < 0);\n", "    assertTrue(caseInsensitiveOrdering.compare(\"B\", \"a\") > 0);\n", "\n", "    @SuppressWarnings(\"deprecation\") // test of deprecated method\n", "    Ordering<String> orderingFromOrdering =\n", "        Ordering.from(Ordering.<String>natural());\n", "    new EqualsTester()\n", "        .addEqualityGroup(caseInsensitiveOrdering, Ordering.from(String.CASE_INSENSITIVE_ORDER))\n", "        .addEqualityGroup(orderingFromOrdering, Ordering.natural())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testExplicit_none() {\n", "    Comparator<Integer> c\n", "        = Ordering.explicit(Collections.<Integer>emptyList());\n", "    try {\n", "      c.compare(0, 0);\n", "      fail();\n", "    } catch (IncomparableValueException expected) {\n", "      assertEquals(0, expected.value);\n", "    }\n", "    reserializeAndAssert(c);\n", "  }\n", "\n", "  public void testExplicit_one() {\n", "    Comparator<Integer> c = Ordering.explicit(0);\n", "    assertEquals(0, c.compare(0, 0));\n", "    try {\n", "      c.compare(0, 1);\n", "      fail();\n", "    } catch (IncomparableValueException expected) {\n", "      assertEquals(1, expected.value);\n", "    }\n", "    reserializeAndAssert(c);\n", "    assertEquals(\"Ordering.explicit([0])\", c.toString());\n", "  }\n", "\n", "  public void testExplicit_two() {\n", "    Comparator<Integer> c = Ordering.explicit(42, 5);\n", "    assertEquals(0, c.compare(5, 5));\n", "    assertTrue(c.compare(5, 42) > 0);\n", "    assertTrue(c.compare(42, 5) < 0);\n", "    try {\n", "      c.compare(5, 666);\n", "      fail();\n", "    } catch (IncomparableValueException expected) {\n", "      assertEquals(666, expected.value);\n", "    }\n", "    new EqualsTester()\n", "        .addEqualityGroup(c, Ordering.explicit(42, 5))\n", "        .addEqualityGroup(Ordering.explicit(5, 42))\n", "        .addEqualityGroup(Ordering.explicit(42))\n", "        .testEquals();\n", "    reserializeAndAssert(c);\n", "  }\n", "\n", "  public void testExplicit_sortingExample() {\n", "    Comparator<Integer> c\n", "        = Ordering.explicit(2, 8, 6, 1, 7, 5, 3, 4, 0, 9);\n", "    List<Integer> list = Arrays.asList(0, 3, 5, 6, 7, 8, 9);\n", "    Collections.sort(list, c);\n", "    assertThat(list).containsExactly(8, 6, 7, 5, 3, 0, 9).inOrder();\n", "    reserializeAndAssert(c);\n", "  }\n", "\n", "  public void testExplicit_withDuplicates() {\n", "    try {\n", "      Ordering.explicit(1, 2, 3, 4, 2);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  // A more limited test than the one that follows, but this one uses the\n", "  // actual public API.\n", "  public void testArbitrary_withoutCollisions() {\n", "    List<Object> list = Lists.newArrayList();\n", "    for (int i = 0; i < 50; i++) {\n", "      list.add(new Object());\n", "    }\n", "\n", "    Ordering<Object> arbitrary = Ordering.arbitrary();\n", "    Collections.sort(list, arbitrary);\n", "\n", "    // Now we don't care what order it's put the list in, only that\n", "    // comparing any pair of elements gives the answer we expect.\n", "    Helpers.testComparator(arbitrary, list);\n", "\n", "    assertEquals(\"Ordering.arbitrary()\", arbitrary.toString());\n", "  }\n", "\n", "  public void testArbitrary_withCollisions() {\n", "    List<Integer> list = Lists.newArrayList();\n", "    for (int i = 0; i < 50; i++) {\n", "      list.add(i);\n", "    }\n", "\n", "    Ordering<Object> arbitrary = new ArbitraryOrdering() {\n", "      @Override int identityHashCode(Object object) {\n", "        return ((Integer) object) % 5; // fake tons of collisions!\n", "      }\n", "    };\n", "\n", "    // Don't let the elements be in such a predictable order\n", "    list = shuffledCopy(list, new Random(1));\n", "\n", "    Collections.sort(list, arbitrary);\n", "\n", "    // Now we don't care what order it's put the list in, only that\n", "    // comparing any pair of elements gives the answer we expect.\n", "    Helpers.testComparator(arbitrary, list);\n", "  }\n", "\n", "  public void testUsingToString() {\n", "    Ordering<Object> ordering = Ordering.usingToString();\n", "    Helpers.testComparator(ordering, 1, 12, 124, 2);\n", "    assertEquals(\"Ordering.usingToString()\", ordering.toString());\n", "    assertSame(ordering, reserialize(ordering));\n", "  }\n", "\n", "  // use an enum to get easy serializability\n", "  private enum CharAtFunction implements Function<String, Character> {\n", "    AT0(0),\n", "    AT1(1),\n", "    AT2(2),\n", "    AT3(3),\n", "    AT4(4),\n", "    AT5(5),\n", "    ;\n", "\n", "    final int index;\n", "    CharAtFunction(int index) {\n", "      this.index = index;\n", "    }\n", "    @Override\n", "    public Character apply(String string) {\n", "      return string.charAt(index);\n", "    }\n", "  }\n", "\n", "  private static Ordering<String> byCharAt(int index) {\n", "    return Ordering.natural().onResultOf(CharAtFunction.values()[index]);\n", "  }\n", "\n", "  public void testCompound_static() {\n", "    Comparator<String> comparator = Ordering.compound(ImmutableList.of(\n", "        byCharAt(0), byCharAt(1), byCharAt(2),\n", "        byCharAt(3), byCharAt(4), byCharAt(5)));\n", "    Helpers.testComparator(comparator, ImmutableList.of(\n", "        \"applesauce\",\n", "        \"apricot\",\n", "        \"artichoke\",\n", "        \"banality\",\n", "        \"banana\",\n", "        \"banquet\",\n", "        \"tangelo\",\n", "        \"tangerine\"));\n", "    reserializeAndAssert(comparator);\n", "  }\n", "\n", "  public void testCompound_instance() {\n", "    Comparator<String> comparator = byCharAt(1).compound(byCharAt(0));\n", "    Helpers.testComparator(comparator, ImmutableList.of(\n", "        \"red\",\n", "        \"yellow\",\n", "        \"violet\",\n", "        \"blue\",\n", "        \"indigo\",\n", "        \"green\",\n", "        \"orange\"));\n", "  }\n", "\n", "  public void testCompound_instance_generics() {\n", "    Ordering<Object> objects = Ordering.explicit((Object) 1);\n", "    Ordering<Number> numbers = Ordering.explicit((Number) 1);\n", "    Ordering<Integer> integers = Ordering.explicit(1);\n", "\n", "    // Like by like equals like\n", "    Ordering<Number> a = numbers.compound(numbers);\n", "\n", "    // The compound takes the more specific type of the two, regardless of order\n", "\n", "    Ordering<Number> b = numbers.compound(objects);\n", "    Ordering<Number> c = objects.compound(numbers);\n", "\n", "    Ordering<Integer> d = numbers.compound(integers);\n", "    Ordering<Integer> e = integers.compound(numbers);\n", "\n", "    // This works with three levels too (IDEA falsely reports errors as noted\n", "    // below. Both javac and eclipse handle these cases correctly.)\n", "\n", "    Ordering<Number> f = numbers.compound(objects).compound(objects); //bad IDEA\n", "    Ordering<Number> g = objects.compound(numbers).compound(objects);\n", "    Ordering<Number> h = objects.compound(objects).compound(numbers);\n", "\n", "    Ordering<Number> i = numbers.compound(objects.compound(objects));\n", "    Ordering<Number> j = objects.compound(numbers.compound(objects)); //bad IDEA\n", "    Ordering<Number> k = objects.compound(objects.compound(numbers));\n", "\n", "    // You can also arbitrarily assign a more restricted type - not an intended\n", "    // feature, exactly, but unavoidable (I think) and harmless\n", "    Ordering<Integer> l = objects.compound(numbers);\n", "\n", "    // This correctly doesn't work:\n", "    // Ordering<Object> m = numbers.compound(objects);\n", "\n", "    // Sadly, the following works in javac 1.6, but at least it fails for\n", "    // eclipse, and is *correctly* highlighted red in IDEA.\n", "    // Ordering<Object> n = objects.compound(numbers);\n", "  }\n", "\n", "  public void testReverse() {\n", "    Ordering<Number> reverseOrder = numberOrdering.reverse();\n", "    Helpers.testComparator(reverseOrder,\n", "        Integer.MAX_VALUE, 1, 0, -1, Integer.MIN_VALUE);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(reverseOrder, numberOrdering.reverse())\n", "        .addEqualityGroup(Ordering.natural().reverse())\n", "        .addEqualityGroup(Collections.reverseOrder())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testReverseOfReverseSameAsForward() {\n", "    // Not guaranteed by spec, but it works, and saves us from testing\n", "    // exhaustively\n", "    assertSame(numberOrdering, numberOrdering.reverse().reverse());\n", "  }\n", "\n", "  private enum StringLengthFunction implements Function<String, Integer> {\n", "    StringLength;\n", "\n", "    @Override\n", "    public Integer apply(String string) {\n", "      return string.length();\n", "    }\n", "  }\n", "\n", "  private static final Ordering<Integer> DECREASING_INTEGER\n", "      = Ordering.natural().reverse();\n", "\n", "  public void testOnResultOf_natural() {\n", "    Comparator<String> comparator\n", "        = Ordering.natural().onResultOf(StringLengthFunction.StringLength);\n", "    assertTrue(comparator.compare(\"to\", \"be\") == 0);\n", "    assertTrue(comparator.compare(\"or\", \"not\") < 0);\n", "    assertTrue(comparator.compare(\"that\", \"to\") > 0);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            comparator,\n", "            Ordering.natural().onResultOf(StringLengthFunction.StringLength))\n", "        .addEqualityGroup(DECREASING_INTEGER)\n", "        .testEquals();\n", "    reserializeAndAssert(comparator);\n", "    assertEquals(\"Ordering.natural().onResultOf(StringLength)\",\n", "        comparator.toString());\n", "  }\n", "\n", "  public void testOnResultOf_chained() {\n", "    Comparator<String> comparator = DECREASING_INTEGER.onResultOf(\n", "        StringLengthFunction.StringLength);\n", "    assertTrue(comparator.compare(\"to\", \"be\") == 0);\n", "    assertTrue(comparator.compare(\"not\", \"or\") < 0);\n", "    assertTrue(comparator.compare(\"to\", \"that\") > 0);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            comparator,\n", "            DECREASING_INTEGER.onResultOf(StringLengthFunction.StringLength))\n", "        .addEqualityGroup(\n", "            DECREASING_INTEGER.onResultOf(Functions.constant(1)))\n", "        .addEqualityGroup(Ordering.natural())\n", "        .testEquals();\n", "    reserializeAndAssert(comparator);\n", "    assertEquals(\"Ordering.natural().reverse().onResultOf(StringLength)\",\n", "        comparator.toString());\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // dang varargs\n", "  public void testLexicographical() {\n", "    Ordering<String> ordering = Ordering.natural();\n", "    Ordering<Iterable<String>> lexy = ordering.lexicographical();\n", "\n", "    ImmutableList<String> empty = ImmutableList.of();\n", "    ImmutableList<String> a = ImmutableList.of(\"a\");\n", "    ImmutableList<String> aa = ImmutableList.of(\"a\", \"a\");\n", "    ImmutableList<String> ab = ImmutableList.of(\"a\", \"b\");\n", "    ImmutableList<String> b = ImmutableList.of(\"b\");\n", "\n", "    Helpers.testComparator(lexy, empty, a, aa, ab, b);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(lexy, ordering.lexicographical())\n", "        .addEqualityGroup(numberOrdering.lexicographical())\n", "        .addEqualityGroup(Ordering.natural())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testNullsFirst() {\n", "    Ordering<Integer> ordering = Ordering.natural().nullsFirst();\n", "    Helpers.testComparator(ordering, null, Integer.MIN_VALUE, 0, 1);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(ordering, Ordering.natural().nullsFirst())\n", "        .addEqualityGroup(numberOrdering.nullsFirst())\n", "        .addEqualityGroup(Ordering.natural())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testNullsLast() {\n", "    Ordering<Integer> ordering = Ordering.natural().nullsLast();\n", "    Helpers.testComparator(ordering, 0, 1, Integer.MAX_VALUE, null);\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(ordering, Ordering.natural().nullsLast())\n", "        .addEqualityGroup(numberOrdering.nullsLast())\n", "        .addEqualityGroup(Ordering.natural())\n", "        .testEquals();\n", "  }\n", "\n", "  public void testBinarySearch() {\n", "    List<Integer> ints = Lists.newArrayList(0, 2, 3, 5, 7, 9);\n", "    assertEquals(4, numberOrdering.binarySearch(ints, 7));\n", "  }\n", "\n", "  public void testSortedCopy() {\n", "    List<Integer> unsortedInts = Collections.unmodifiableList(\n", "        Arrays.asList(5, 0, 3, null, 0, 9));\n", "    List<Integer> sortedInts =\n", "        numberOrdering.nullsLast().sortedCopy(unsortedInts);\n", "    assertEquals(Arrays.asList(0, 0, 3, 5, 9, null), sortedInts);\n", "\n", "    assertEquals(Collections.emptyList(),\n", "        numberOrdering.sortedCopy(Collections.<Integer>emptyList()));\n", "  }\n", "\n", "  public void testImmutableSortedCopy() {\n", "    ImmutableList<Integer> unsortedInts = ImmutableList.of(5, 3, 0, 9, 3);\n", "    ImmutableList<Integer> sortedInts\n", "        = numberOrdering.immutableSortedCopy(unsortedInts);\n", "    assertEquals(Arrays.asList(0, 3, 3, 5, 9), sortedInts);\n", "\n", "    assertEquals(Collections.<Integer>emptyList(),\n", "        numberOrdering.immutableSortedCopy(Collections.<Integer>emptyList()));\n", "\n", "    List<Integer> listWithNull = Arrays.asList(5, 3, null, 9);\n", "    try {\n", "      Ordering.natural().nullsFirst().immutableSortedCopy(listWithNull);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testIsOrdered() {\n", "    assertFalse(numberOrdering.isOrdered(asList(5, 3, 0, 9)));\n", "    assertFalse(numberOrdering.isOrdered(asList(0, 5, 3, 9)));\n", "    assertTrue(numberOrdering.isOrdered(asList(0, 3, 5, 9)));\n", "    assertTrue(numberOrdering.isOrdered(asList(0, 0, 3, 3)));\n", "    assertTrue(numberOrdering.isOrdered(asList(0, 3)));\n", "    assertTrue(numberOrdering.isOrdered(Collections.singleton(1)));\n", "    assertTrue(numberOrdering.isOrdered(Collections.<Integer>emptyList()));\n", "  }\n", "\n", "  public void testIsStrictlyOrdered() {\n", "    assertFalse(numberOrdering.isStrictlyOrdered(asList(5, 3, 0, 9)));\n", "    assertFalse(numberOrdering.isStrictlyOrdered(asList(0, 5, 3, 9)));\n", "    assertTrue(numberOrdering.isStrictlyOrdered(asList(0, 3, 5, 9)));\n", "    assertFalse(numberOrdering.isStrictlyOrdered(asList(0, 0, 3, 3)));\n", "    assertTrue(numberOrdering.isStrictlyOrdered(asList(0, 3)));\n", "    assertTrue(numberOrdering.isStrictlyOrdered(Collections.singleton(1)));\n", "    assertTrue(numberOrdering.isStrictlyOrdered(\n", "        Collections.<Integer>emptyList()));\n", "  }\n", "\n", "  public void testLeastOfIterable_empty_0() {\n", "    List<Integer> result = numberOrdering.leastOf(Arrays.<Integer>asList(), 0);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.<Integer>of(), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_empty_0() {\n", "    List<Integer> result = numberOrdering.leastOf(\n", "        Iterators.<Integer>emptyIterator(), 0);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.<Integer>of(), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_empty_1() {\n", "    List<Integer> result = numberOrdering.leastOf(Arrays.<Integer>asList(), 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.<Integer>of(), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_empty_1() {\n", "    List<Integer> result = numberOrdering.leastOf(\n", "        Iterators.<Integer>emptyIterator(), 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.<Integer>of(), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_simple_negativeOne() {\n", "    try {\n", "      numberOrdering.leastOf(Arrays.asList(3, 4, 5, -1), -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testLeastOfIterator_simple_negativeOne() {\n", "    try {\n", "      numberOrdering.leastOf(Iterators.forArray(3, 4, 5, -1), -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testLeastOfIterable_singleton_0() {\n", "    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3), 0);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.<Integer>of(), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_singleton_0() {\n", "    List<Integer> result = numberOrdering.leastOf(\n", "        Iterators.singletonIterator(3), 0);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.<Integer>of(), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_simple_0() {\n", "    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3, 4, 5, -1), 0);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.<Integer>of(), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_simple_0() {\n", "    List<Integer> result = numberOrdering.leastOf(\n", "        Iterators.forArray(3, 4, 5, -1), 0);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.<Integer>of(), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_simple_1() {\n", "    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3, 4, 5, -1), 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_simple_1() {\n", "    List<Integer> result = numberOrdering.leastOf(\n", "        Iterators.forArray(3, 4, 5, -1), 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_simple_nMinusOne_withNullElement() {\n", "    List<Integer> list = Arrays.asList(3, null, 5, -1);\n", "    List<Integer> result = Ordering.natural().nullsLast().leastOf(list, list.size() - 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1, 3, 5), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_simple_nMinusOne_withNullElement() {\n", "    Iterator<Integer> itr = Iterators.forArray(3, null, 5, -1);\n", "    List<Integer> result = Ordering.natural().nullsLast().leastOf(itr, 3);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1, 3, 5), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_simple_nMinusOne() {\n", "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n", "    List<Integer> result = numberOrdering.leastOf(list, list.size() - 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1, 3, 4), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_simple_nMinusOne() {\n", "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n", "    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size() - 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1, 3, 4), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_simple_n() {\n", "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n", "    List<Integer> result = numberOrdering.leastOf(list, list.size());\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_simple_n() {\n", "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n", "    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size());\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_simple_n_withNullElement() {\n", "    List<Integer> list = Arrays.asList(3, 4, 5, null, -1);\n", "    List<Integer> result = Ordering.natural().nullsLast().leastOf(list, list.size());\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(Arrays.asList(-1, 3, 4, 5, null), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_simple_n_withNullElement() {\n", "    List<Integer> list = Arrays.asList(3, 4, 5, null, -1);\n", "    List<Integer> result = Ordering.natural().nullsLast().leastOf(\n", "        list.iterator(), list.size());\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(Arrays.asList(-1, 3, 4, 5, null), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_simple_nPlusOne() {\n", "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n", "    List<Integer> result = numberOrdering.leastOf(list, list.size() + 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_simple_nPlusOne() {\n", "    List<Integer> list = Arrays.asList(3, 4, 5, -1);\n", "    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size() + 1);\n", "    assertTrue(result instanceof RandomAccess);\n", "    assertListImmutable(result);\n", "    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);\n", "  }\n", "\n", "  public void testLeastOfIterable_ties() {\n", "    Integer foo = new Integer(Integer.MAX_VALUE - 10);\n", "    Integer bar = new Integer(Integer.MAX_VALUE - 10);\n", "\n", "    assertNotSame(foo, bar);\n", "    assertEquals(foo, bar);\n", "\n", "    List<Integer> list = Arrays.asList(3, foo, bar, -1);\n", "    List<Integer> result = numberOrdering.leastOf(list, list.size());\n", "    assertEquals(ImmutableList.of(-1, 3, foo, bar), result);\n", "  }\n", "\n", "  public void testLeastOfIterator_ties() {\n", "    Integer foo = new Integer(Integer.MAX_VALUE - 10);\n", "    Integer bar = new Integer(Integer.MAX_VALUE - 10);\n", "\n", "    assertNotSame(foo, bar);\n", "    assertEquals(foo, bar);\n", "\n", "    List<Integer> list = Arrays.asList(3, foo, bar, -1);\n", "    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size());\n", "    assertEquals(ImmutableList.of(-1, 3, foo, bar), result);\n", "  }\n", "\n", "  public void testLeastOf_reconcileAgainstSortAndSublistSmall() {\n", "    runLeastOfComparison(10, 30, 2);\n", "  }\n", "\n", "  private static void runLeastOfComparison(\n", "      int iterations, int elements, int seeds) {\n", "    Random random = new Random(42);\n", "    Ordering<Integer> ordering = Ordering.natural();\n", "\n", "    for (int i = 0; i < iterations; i++) {\n", "      List<Integer> list = Lists.newArrayList();\n", "      for (int j = 0; j < elements; j++) {\n", "        list.add(random.nextInt(10 * i + j + 1));\n", "      }\n", "\n", "      for (int seed = 1; seed < seeds; seed++) {\n", "        int k = random.nextInt(10 * seed);\n", "        assertEquals(ordering.sortedCopy(list).subList(0, k),\n", "            ordering.leastOf(list, k));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testLeastOfIterableLargeK() {\n", "    List<Integer> list = Arrays.asList(4, 2, 3, 5, 1);\n", "    assertEquals(Arrays.asList(1, 2, 3, 4, 5), Ordering.natural()\n", "        .leastOf(list, Integer.MAX_VALUE));\n", "  }\n", "\n", "  public void testLeastOfIteratorLargeK() {\n", "    List<Integer> list = Arrays.asList(4, 2, 3, 5, 1);\n", "    assertEquals(Arrays.asList(1, 2, 3, 4, 5), Ordering.natural()\n", "        .leastOf(list.iterator(), Integer.MAX_VALUE));\n", "  }\n", "\n", "  public void testGreatestOfIterable_simple() {\n", "    /*\n", "     * If greatestOf() promised to be implemented as reverse().leastOf(), this\n", "     * test would be enough. It doesn't... but we'll cheat and act like it does\n", "     * anyway. There's a comment there to remind us to fix this if we change it.\n", "     */\n", "    List<Integer> list = Arrays.asList(3, 1, 3, 2, 4, 2, 4, 3);\n", "    assertEquals(Arrays.asList(4, 4, 3, 3), numberOrdering.greatestOf(list, 4));\n", "  }\n", "\n", "  public void testGreatestOfIterator_simple() {\n", "    /*\n", "     * If greatestOf() promised to be implemented as reverse().leastOf(), this\n", "     * test would be enough. It doesn't... but we'll cheat and act like it does\n", "     * anyway. There's a comment there to remind us to fix this if we change it.\n", "     */\n", "    List<Integer> list = Arrays.asList(3, 1, 3, 2, 4, 2, 4, 3);\n", "    assertEquals(Arrays.asList(4, 4, 3, 3),\n", "        numberOrdering.greatestOf(list.iterator(), 4));\n", "  }\n", "\n", "  private static void assertListImmutable(List<Integer> result) {\n", "    try {\n", "      result.set(0, 1);\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {\n", "      // pass\n", "    }\n", "  }\n", "\n", "  public void testIteratorMinAndMax() {\n", "    List<Integer> ints = Lists.newArrayList(5, 3, 0, 9);\n", "    assertEquals(9, (int) numberOrdering.max(ints.iterator()));\n", "    assertEquals(0, (int) numberOrdering.min(ints.iterator()));\n", "\n", "    // when the values are the same, the first argument should be returned\n", "    Integer a = new Integer(4);\n", "    Integer b = new Integer(4);\n", "    ints = Lists.newArrayList(a, b, b);\n", "    assertSame(a, numberOrdering.max(ints.iterator()));\n", "    assertSame(a, numberOrdering.min(ints.iterator()));\n", "  }\n", "\n", "  public void testIteratorMinExhaustsIterator() {\n", "    List<Integer> ints = Lists.newArrayList(9, 0, 3, 5);\n", "    Iterator<Integer> iterator = ints.iterator();\n", "    assertEquals(0, (int) numberOrdering.min(iterator));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testIteratorMaxExhaustsIterator() {\n", "    List<Integer> ints = Lists.newArrayList(9, 0, 3, 5);\n", "    Iterator<Integer> iterator = ints.iterator();\n", "    assertEquals(9, (int) numberOrdering.max(iterator));\n", "    assertFalse(iterator.hasNext());\n", "  }\n", "\n", "  public void testIterableMinAndMax() {\n", "    List<Integer> ints = Lists.newArrayList(5, 3, 0, 9);\n", "    assertEquals(9, (int) numberOrdering.max(ints));\n", "    assertEquals(0, (int) numberOrdering.min(ints));\n", "\n", "    // when the values are the same, the first argument should be returned\n", "    Integer a = new Integer(4);\n", "    Integer b = new Integer(4);\n", "    ints = Lists.newArrayList(a, b, b);\n", "    assertSame(a, numberOrdering.max(ints));\n", "    assertSame(a, numberOrdering.min(ints));\n", "  }\n", "\n", "  public void testVarargsMinAndMax() {\n", "    // try the min and max values in all positions, since some values are proper\n", "    // parameters and others are from the varargs array\n", "    assertEquals(9, (int) numberOrdering.max(9, 3, 0, 5, 8));\n", "    assertEquals(9, (int) numberOrdering.max(5, 9, 0, 3, 8));\n", "    assertEquals(9, (int) numberOrdering.max(5, 3, 9, 0, 8));\n", "    assertEquals(9, (int) numberOrdering.max(5, 3, 0, 9, 8));\n", "    assertEquals(9, (int) numberOrdering.max(5, 3, 0, 8, 9));\n", "    assertEquals(0, (int) numberOrdering.min(0, 3, 5, 9, 8));\n", "    assertEquals(0, (int) numberOrdering.min(5, 0, 3, 9, 8));\n", "    assertEquals(0, (int) numberOrdering.min(5, 3, 0, 9, 8));\n", "    assertEquals(0, (int) numberOrdering.min(5, 3, 9, 0, 8));\n", "    assertEquals(0, (int) numberOrdering.min(5, 3, 0, 9, 0));\n", "\n", "    // when the values are the same, the first argument should be returned\n", "    Integer a = new Integer(4);\n", "    Integer b = new Integer(4);\n", "    assertSame(a, numberOrdering.max(a, b, b));\n", "    assertSame(a, numberOrdering.min(a, b, b));\n", "  }\n", "\n", "  public void testParameterMinAndMax() {\n", "    assertEquals(5, (int) numberOrdering.max(3, 5));\n", "    assertEquals(5, (int) numberOrdering.max(5, 3));\n", "    assertEquals(3, (int) numberOrdering.min(3, 5));\n", "    assertEquals(3, (int) numberOrdering.min(5, 3));\n", "\n", "    // when the values are the same, the first argument should be returned\n", "    Integer a = new Integer(4);\n", "    Integer b = new Integer(4);\n", "    assertSame(a, numberOrdering.max(a, b));\n", "    assertSame(a, numberOrdering.min(a, b));\n", "  }\n", "\n", "  private static class NumberOrdering extends Ordering<Number> {\n", "    @Override public int compare(Number a, Number b) {\n", "      return ((Double) a.doubleValue()).compareTo(b.doubleValue());\n", "    }\n", "    @Override public int hashCode() {\n", "      return NumberOrdering.class.hashCode();\n", "    }\n", "    @Override public boolean equals(Object other) {\n", "      return other instanceof NumberOrdering;\n", "    }\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /*\n", "   * Now we have monster tests that create hundreds of Orderings using different\n", "   * combinations of methods, then checks compare(), binarySearch() and so\n", "   * forth on each one.\n", "   */\n", "\n", "  // should periodically try increasing this, but it makes the test run long\n", "  private static final int RECURSE_DEPTH = 2;\n", "  \n", "  public void testCombinationsExhaustively_startingFromNatural() {\n", "    testExhaustively(Ordering.<String>natural(), \"a\", \"b\", \"d\");\n", "  }\n", "\n", "  /**\n", "   * Requires at least 3 elements in {@code strictlyOrderedElements} in order to\n", "   * test the varargs version of min/max.\n", "   */\n", "  private static <T> void testExhaustively(\n", "      Ordering<? super T> ordering, T... strictlyOrderedElements) {\n", "    checkArgument(strictlyOrderedElements.length >= 3, \"strictlyOrderedElements \"\n", "        + \"requires at least 3 elements\");\n", "    List<T> list = Arrays.asList(strictlyOrderedElements);\n", "\n", "    // for use calling Collection.toArray later\n", "    T[] emptyArray = Platform.newArray(strictlyOrderedElements, 0);\n", "\n", "    // shoot me, but I didn't want to deal with wildcards through the whole test\n", "    @SuppressWarnings(\"unchecked\")\n", "    Scenario<T> starter = new Scenario<T>((Ordering) ordering, list, emptyArray);\n", "    verifyScenario(starter, 0);\n", "  }\n", "\n", "  private static <T> void verifyScenario(Scenario<T> scenario, int level) {\n", "    scenario.testCompareTo();\n", "    scenario.testIsOrdered();\n", "    scenario.testMinAndMax();\n", "    scenario.testBinarySearch();\n", "    scenario.testSortedCopy();\n", "\n", "    if (level < RECURSE_DEPTH) {\n", "      for (OrderingMutation alteration : OrderingMutation.values()) {\n", "        verifyScenario(alteration.mutate(scenario), level + 1);\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * An aggregation of an ordering with a list (of size > 1) that should prove\n", "   * to be in strictly increasing order according to that ordering.\n", "   */\n", "  private static class Scenario<T> {\n", "    final Ordering<T> ordering;\n", "    final List<T> strictlyOrderedList;\n", "    final T[] emptyArray;\n", "\n", "    Scenario(Ordering<T> ordering, List<T> strictlyOrderedList, T[] emptyArray) {\n", "      this.ordering = ordering;\n", "      this.strictlyOrderedList = strictlyOrderedList;\n", "      this.emptyArray = emptyArray;\n", "    }\n", "\n", "    void testCompareTo() {\n", "      Helpers.testComparator(ordering, strictlyOrderedList);\n", "    }\n", "\n", "    void testIsOrdered() {\n", "      assertTrue(ordering.isOrdered(strictlyOrderedList));\n", "      assertTrue(ordering.isStrictlyOrdered(strictlyOrderedList));\n", "    }\n", "\n", "    @SuppressWarnings(\"unchecked\") // generic arrays and unchecked cast\n", "    void testMinAndMax() {\n", "      List<T> shuffledList = Lists.newArrayList(strictlyOrderedList);\n", "      shuffledList = shuffledCopy(shuffledList, new Random(5));\n", "\n", "      T min = strictlyOrderedList.get(0);\n", "      T max = strictlyOrderedList.get(strictlyOrderedList.size() - 1);\n", "\n", "      T first = shuffledList.get(0);\n", "      T second = shuffledList.get(1);\n", "      T third = shuffledList.get(2);\n", "      T[] rest = shuffledList.subList(3, shuffledList.size()).toArray(emptyArray);\n", "\n", "      assertEquals(min, ordering.min(shuffledList));\n", "      assertEquals(min, ordering.min(shuffledList.iterator()));\n", "      assertEquals(min, ordering.min(first, second, third, rest));\n", "      assertEquals(min, ordering.min(min, max));\n", "      assertEquals(min, ordering.min(max, min));\n", "\n", "      assertEquals(max, ordering.max(shuffledList));\n", "      assertEquals(max, ordering.max(shuffledList.iterator()));\n", "      assertEquals(max, ordering.max(first, second, third, rest));\n", "      assertEquals(max, ordering.max(min, max));\n", "      assertEquals(max, ordering.max(max, min));\n", "    }\n", "\n", "    void testBinarySearch() {\n", "      for (int i = 0; i < strictlyOrderedList.size(); i++) {\n", "        assertEquals(i, ordering.binarySearch(\n", "            strictlyOrderedList, strictlyOrderedList.get(i)));\n", "      }\n", "      List<T> newList = Lists.newArrayList(strictlyOrderedList);\n", "      T valueNotInList = newList.remove(1);\n", "      assertEquals(-2, ordering.binarySearch(newList, valueNotInList));\n", "    }\n", "\n", "    void testSortedCopy() {\n", "      List<T> shuffledList = Lists.newArrayList(strictlyOrderedList);\n", "      shuffledList = shuffledCopy(shuffledList, new Random(5));\n", "\n", "      assertEquals(strictlyOrderedList, ordering.sortedCopy(shuffledList));\n", "\n", "      if (!strictlyOrderedList.contains(null)) {\n", "        assertEquals(strictlyOrderedList, ordering.immutableSortedCopy(shuffledList));\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * A means for changing an Ordering into another Ordering. Each instance is\n", "   * responsible for creating the alternate Ordering, and providing a List that\n", "   * is known to be ordered, based on an input List known to be ordered\n", "   * according to the input Ordering.\n", "   */\n", "  private enum OrderingMutation {\n", "    REVERSE {\n", "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n", "        List<T> newList = Lists.newArrayList(scenario.strictlyOrderedList);\n", "        Collections.reverse(newList);\n", "        return new Scenario<T>(scenario.ordering.reverse(), newList, scenario.emptyArray);\n", "      }\n", "    },\n", "    NULLS_FIRST {\n", "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n", "        @SuppressWarnings(\"unchecked\")\n", "        List<T> newList = Lists.newArrayList((T) null);\n", "        for (T t : scenario.strictlyOrderedList) {\n", "          if (t != null) {\n", "            newList.add(t);\n", "          }\n", "        }\n", "        return new Scenario<T>(scenario.ordering.nullsFirst(), newList, scenario.emptyArray);\n", "      }\n", "    },\n", "    NULLS_LAST {\n", "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n", "        List<T> newList = Lists.newArrayList();\n", "        for (T t : scenario.strictlyOrderedList) {\n", "          if (t != null) {\n", "            newList.add(t);\n", "          }\n", "        }\n", "        newList.add(null);\n", "        return new Scenario<T>(scenario.ordering.nullsLast(), newList, scenario.emptyArray);\n", "      }\n", "    },\n", "    ON_RESULT_OF {\n", "      @Override <T> Scenario<?> mutate(final Scenario<T> scenario) {\n", "        Ordering<Integer> ordering = scenario.ordering.onResultOf(\n", "            new Function<Integer, T>() {\n", "              @Override\n", "              public T apply(@Nullable Integer from) {\n", "                return scenario.strictlyOrderedList.get(from);\n", "              }\n", "            });\n", "        List<Integer> list = Lists.newArrayList();\n", "        for (int i = 0; i < scenario.strictlyOrderedList.size(); i++) {\n", "          list.add(i);\n", "        }\n", "        return new Scenario<Integer>(ordering, list, new Integer[0]);\n", "      }\n", "    },\n", "    COMPOUND_THIS_WITH_NATURAL {\n", "      @SuppressWarnings(\"unchecked\") // raw array\n", "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n", "        List<Composite<T>> composites = Lists.newArrayList();\n", "        for (T t : scenario.strictlyOrderedList) {\n", "          composites.add(new Composite<T>(t, 1));\n", "          composites.add(new Composite<T>(t, 2));\n", "        }\n", "        Ordering<Composite<T>> ordering =\n", "            scenario.ordering.onResultOf(Composite.<T>getValueFunction())\n", "                .compound(Ordering.natural());\n", "        return new Scenario<Composite<T>>(ordering, composites, new Composite[0]);\n", "      }\n", "    },\n", "    COMPOUND_NATURAL_WITH_THIS {\n", "      @SuppressWarnings(\"unchecked\") // raw array\n", "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n", "        List<Composite<T>> composites = Lists.newArrayList();\n", "        for (T t : scenario.strictlyOrderedList) {\n", "          composites.add(new Composite<T>(t, 1));\n", "        }\n", "        for (T t : scenario.strictlyOrderedList) {\n", "          composites.add(new Composite<T>(t, 2));\n", "        }\n", "        Ordering<Composite<T>> ordering = Ordering.natural().compound(\n", "            scenario.ordering.onResultOf(Composite.<T>getValueFunction()));\n", "        return new Scenario<Composite<T>>(ordering, composites, new Composite[0]);\n", "      }\n", "    },\n", "    LEXICOGRAPHICAL {\n", "      @SuppressWarnings(\"unchecked\") // dang varargs\n", "      @Override <T> Scenario<?> mutate(Scenario<T> scenario) {\n", "        List<Iterable<T>> words = Lists.newArrayList();\n", "        words.add(Collections.<T>emptyList());\n", "        for (T t : scenario.strictlyOrderedList) {\n", "          words.add(Arrays.asList(t));\n", "          for (T s : scenario.strictlyOrderedList) {\n", "            words.add(Arrays.asList(t, s));\n", "          }\n", "        }\n", "        return new Scenario<Iterable<T>>(\n", "            scenario.ordering.lexicographical(), words, new Iterable[0]);\n", "      }\n", "    },\n", "    ;\n", "\n", "    abstract <T> Scenario<?> mutate(Scenario<T> scenario);\n", "  }\n", "\n", "  /**\n", "   * A dummy object we create so that we can have something meaningful to have\n", "   * a compound ordering over.\n", "   */\n", "  private static class Composite<T> implements Comparable<Composite<T>> {\n", "    final T value;\n", "    final int rank;\n", "\n", "    Composite(T value, int rank) {\n", "      this.value = value;\n", "      this.rank = rank;\n", "    }\n", "\n", "    // natural order is by rank only; the test will compound() this with the\n", "    // order of 't'.\n", "    @Override\n", "    public int compareTo(Composite<T> that) {\n", "      return Ints.compare(rank, that.rank);\n", "    }\n", "\n", "    static <T> Function<Composite<T>, T> getValueFunction() {\n", "      return new Function<Composite<T>, T>() {\n", "        @Override\n", "        public T apply(Composite<T> from) {\n", "          return from.value;\n", "        }\n", "      };\n", "    }\n", "  }\n", "\n", "  private static <T> List<T> shuffledCopy(List<T> in, Random random) {\n", "    List<T> mutable = newArrayList(in);\n", "    List<T> out = newArrayList();\n", "    while (!mutable.isEmpty()) {\n", "      out.add(mutable.remove(random.nextInt(mutable.size())));\n", "    }\n", "    return out;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112]}}, {"131": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/PeekingIteratorTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.Iterators.peekingIterator;\n", "import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;\n", "import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;\n", "import static java.util.Collections.emptyList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.IteratorTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.NoSuchElementException;\n", "\n", "/**\n", "  * Unit test for {@link PeekingIterator}.\n", "  *\n", "  * @author Mick Killianey\n", "  */\n", "@SuppressWarnings(\"serial\") // No serialization is used in this test\n", "@GwtCompatible(emulated = true)\n", "public class PeekingIteratorTest extends TestCase {\n", "\n", "  /**\n", "   * Version of {@link IteratorTester} that compares an iterator over\n", "   * a given collection of elements (used as the reference iterator)\n", "   * against a {@code PeekingIterator} that *wraps* such an iterator\n", "   * (used as the target iterator).\n", "   *\n", "   * <p>This IteratorTester makes copies of the master so that it can\n", "   * later verify that {@link PeekingIterator#remove()} removes the\n", "   * same elements as the reference's iterator {@code #remove()}.\n", "   */\n", "  private static class PeekingIteratorTester<T> extends IteratorTester<T> {\n", "    private Iterable<T> master;\n", "    private List<T> targetList;\n", "\n", "    public PeekingIteratorTester(Collection<T> master) {\n", "      super(master.size() + 3, MODIFIABLE, master,\n", "          IteratorTester.KnownOrder.KNOWN_ORDER);\n", "      this.master = master;\n", "    }\n", "    @Override protected Iterator<T> newTargetIterator() {\n", "      // make copy from master to verify later\n", "      targetList = Lists.newArrayList(master);\n", "      Iterator<T> iterator = targetList.iterator();\n", "      return Iterators.peekingIterator(iterator);\n", "    }\n", "    @Override protected void verify(List<T> elements) {\n", "      // verify same objects were removed from reference and target\n", "      assertEquals(elements, targetList);\n", "    }\n", "  }\n", "\n", "  private <T> void actsLikeIteratorHelper(final List<T> list) {\n", "    // Check with modifiable copies of the list\n", "    new PeekingIteratorTester<T>(list).test();\n", "\n", "    // Check with unmodifiable lists\n", "    new IteratorTester<T>(list.size() * 2 + 2, UNMODIFIABLE, list,\n", "        IteratorTester.KnownOrder.KNOWN_ORDER) {\n", "      @Override protected Iterator<T> newTargetIterator() {\n", "        Iterator<T> iterator = Collections.unmodifiableList(list).iterator();\n", "        return Iterators.peekingIterator(iterator);\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  public void testPeekingIteratorBehavesLikeIteratorOnEmptyIterable() {\n", "    actsLikeIteratorHelper(Collections.emptyList());\n", "  }\n", "\n", "  public void testPeekingIteratorBehavesLikeIteratorOnSingletonIterable() {\n", "    actsLikeIteratorHelper(Collections.singletonList(new Object()));\n", "  }\n", "\n", "  // TODO(cpovirk): instead of skipping, use a smaller number of steps\n", "\n", "  public void testPeekOnEmptyList() {\n", "    List<?> list = Collections.emptyList();\n", "    Iterator<?> iterator = list.iterator();\n", "    PeekingIterator<?> peekingIterator = Iterators.peekingIterator(iterator);\n", "\n", "    try {\n", "      peekingIterator.peek();\n", "      fail(\"Should throw NoSuchElementException if nothing to peek()\");\n", "    } catch (NoSuchElementException e) { /* expected */ }\n", "  }\n", "\n", "  public void testPeekDoesntChangeIteration() {\n", "    List<?> list = Lists.newArrayList(\"A\", \"B\", \"C\");\n", "    Iterator<?> iterator = list.iterator();\n", "    PeekingIterator<?> peekingIterator =\n", "        Iterators.peekingIterator(iterator);\n", "\n", "    assertEquals(\"Should be able to peek() at first element\",\n", "        \"A\", peekingIterator.peek());\n", "    assertEquals(\"Should be able to peek() first element multiple times\",\n", "        \"A\", peekingIterator.peek());\n", "    assertEquals(\"next() should still return first element after peeking\",\n", "        \"A\", peekingIterator.next());\n", "\n", "    assertEquals(\"Should be able to peek() at middle element\",\n", "        \"B\", peekingIterator.peek());\n", "    assertEquals(\"Should be able to peek() middle element multiple times\",\n", "        \"B\", peekingIterator.peek());\n", "    assertEquals(\"next() should still return middle element after peeking\",\n", "        \"B\", peekingIterator.next());\n", "\n", "    assertEquals(\"Should be able to peek() at last element\",\n", "        \"C\", peekingIterator.peek());\n", "    assertEquals(\"Should be able to peek() last element multiple times\",\n", "        \"C\", peekingIterator.peek());\n", "    assertEquals(\"next() should still return last element after peeking\",\n", "        \"C\", peekingIterator.next());\n", "\n", "    try {\n", "      peekingIterator.peek();\n", "      fail(\"Should throw exception if no next to peek()\");\n", "    } catch (NoSuchElementException e) { /* expected */ }\n", "    try {\n", "      peekingIterator.peek();\n", "      fail(\"Should continue to throw exception if no next to peek()\");\n", "    } catch (NoSuchElementException e) { /* expected */ }\n", "    try {\n", "      peekingIterator.next();\n", "      fail(\"next() should still throw exception after the end of iteration\");\n", "    } catch (NoSuchElementException e) { /* expected */ }\n", "  }\n", "\n", "  public void testCantRemoveAfterPeek() {\n", "    List<String> list = Lists.newArrayList(\"A\", \"B\", \"C\");\n", "    Iterator<String> iterator = list.iterator();\n", "    PeekingIterator<?> peekingIterator = Iterators.peekingIterator(iterator);\n", "\n", "    assertEquals(\"A\", peekingIterator.next());\n", "    assertEquals(\"B\", peekingIterator.peek());\n", "\n", "    /* Should complain on attempt to remove() after peek(). */\n", "    try {\n", "      peekingIterator.remove();\n", "      fail(\"remove() should throw IllegalStateException after a peek()\");\n", "    } catch (IllegalStateException e) { /* expected */ }\n", "\n", "    assertEquals(\"After remove() throws exception, peek should still be ok\",\n", "        \"B\", peekingIterator.peek());\n", "\n", "    /* Should recover to be able to remove() after next(). */\n", "    assertEquals(\"B\", peekingIterator.next());\n", "    peekingIterator.remove();\n", "    assertEquals(\"Should have removed an element\", 2, list.size());\n", "    assertFalse(\"Second element should be gone\", list.contains(\"B\"));\n", "  }\n", "\n", "  static class ThrowsAtEndException extends RuntimeException { /* nothing */ }\n", "\n", "  /**\n", "    * This Iterator claims to have more elements than the underlying\n", "    * iterable, but when you try to fetch the extra elements, it throws\n", "    * an unchecked exception.\n", "    */\n", "  static class ThrowsAtEndIterator<E> implements Iterator<E> {\n", "    Iterator<E> iterator;\n", "    public ThrowsAtEndIterator(Iterable<E> iterable) {\n", "      this.iterator = iterable.iterator();\n", "    }\n", "    @Override\n", "    public boolean hasNext() {\n", "      return true;  // pretend that you have more...\n", "    }\n", "    @Override\n", "    public E next() {\n", "      // ...but throw an unchecked exception when you ask for it.\n", "      if (!iterator.hasNext()) {\n", "        throw new ThrowsAtEndException();\n", "      }\n", "      return iterator.next();\n", "    }\n", "    @Override\n", "    public void remove() {\n", "      iterator.remove();\n", "    }\n", "  }\n", "\n", "  public void testPeekingIteratorDoesntAdvancePrematurely() throws Exception {\n", "    /*\n", "     * This test will catch problems where the underlying iterator\n", "     * throws a RuntimeException when retrieving the nth element.\n", "     *\n", "     * If the PeekingIterator is caching elements too aggressively,\n", "     * it may throw the exception on the (n-1)th element (oops!).\n", "     */\n", "\n", "    /* Checks the case where the first element throws an exception. */\n", "\n", "    List<Integer> list = emptyList();\n", "    Iterator<Integer> iterator =\n", "        peekingIterator(new ThrowsAtEndIterator<Integer>(list));\n", "    assertNextThrows(iterator);\n", "\n", "    /* Checks the case where a later element throws an exception. */\n", "\n", "    list = Lists.newArrayList(1, 2);\n", "    iterator = peekingIterator(new ThrowsAtEndIterator<Integer>(list));\n", "    assertTrue(iterator.hasNext());\n", "    iterator.next();\n", "    assertTrue(iterator.hasNext());\n", "    iterator.next();\n", "    assertNextThrows(iterator);\n", "  }\n", "\n", "  private void assertNextThrows(Iterator<?> iterator) {\n", "    try {\n", "      iterator.next();\n", "      fail();\n", "    } catch (ThrowsAtEndException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240]}}, {"132": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/SetOperationsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.HashSet;\n", "import java.util.Set;\n", "\n", "/**\n", " * Unit tests for {@link Sets#union}, {@link Sets#intersection} and\n", " * {@link Sets#difference}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SetOperationsTest extends TestCase {\n", "\n", "  public static class MoreTests extends TestCase {\n", "    Set<String> friends;\n", "    Set<String> enemies;\n", "\n", "    @Override public void setUp() {\n", "      friends = Sets.newHashSet(\"Tom\", \"Joe\", \"Dave\");\n", "      enemies = Sets.newHashSet(\"Dick\", \"Harry\", \"Tom\");\n", "    }\n", "\n", "    public void testUnion() {\n", "      Set<String> all = Sets.union(friends, enemies);\n", "      assertEquals(5, all.size());\n", "\n", "      ImmutableSet<String> immut = Sets.union(friends, enemies).immutableCopy();\n", "      HashSet<String> mut\n", "          = Sets.union(friends, enemies).copyInto(new HashSet<String>());\n", "\n", "      enemies.add(\"Buck\");\n", "      assertEquals(6, all.size());\n", "      assertEquals(5, immut.size());\n", "      assertEquals(5, mut.size());\n", "    }\n", "\n", "    public void testIntersection() {\n", "      Set<String> friends = Sets.newHashSet(\"Tom\", \"Joe\", \"Dave\");\n", "      Set<String> enemies = Sets.newHashSet(\"Dick\", \"Harry\", \"Tom\");\n", "\n", "      Set<String> frenemies = Sets.intersection(friends, enemies);\n", "      assertEquals(1, frenemies.size());\n", "\n", "      ImmutableSet<String> immut\n", "          = Sets.intersection(friends, enemies).immutableCopy();\n", "      HashSet<String> mut\n", "          = Sets.intersection(friends, enemies).copyInto(new HashSet<String>());\n", "\n", "      enemies.add(\"Joe\");\n", "      assertEquals(2, frenemies.size());\n", "      assertEquals(1, immut.size());\n", "      assertEquals(1, mut.size());\n", "    }\n", "\n", "    public void testDifference() {\n", "      Set<String> friends = Sets.newHashSet(\"Tom\", \"Joe\", \"Dave\");\n", "      Set<String> enemies = Sets.newHashSet(\"Dick\", \"Harry\", \"Tom\");\n", "\n", "      Set<String> goodFriends = Sets.difference(friends, enemies);\n", "      assertEquals(2, goodFriends.size());\n", "\n", "      ImmutableSet<String> immut\n", "          = Sets.difference(friends, enemies).immutableCopy();\n", "      HashSet<String> mut\n", "          = Sets.difference(friends, enemies).copyInto(new HashSet<String>());\n", "\n", "      enemies.add(\"Dave\");\n", "      assertEquals(1, goodFriends.size());\n", "      assertEquals(2, immut.size());\n", "      assertEquals(2, mut.size());\n", "    }\n", "\n", "    public void testSymmetricDifference() {\n", "      Set<String> friends = Sets.newHashSet(\"Tom\", \"Joe\", \"Dave\");\n", "      Set<String> enemies = Sets.newHashSet(\"Dick\", \"Harry\", \"Tom\");\n", "\n", "      Set<String> symmetricDifferenceFriendsFirst = Sets.symmetricDifference(\n", "          friends, enemies);\n", "      assertEquals(4, symmetricDifferenceFriendsFirst.size());\n", "\n", "      Set<String> symmetricDifferenceEnemiesFirst = Sets.symmetricDifference(\n", "          enemies, friends);\n", "      assertEquals(4, symmetricDifferenceEnemiesFirst.size());\n", "\n", "      assertEquals(symmetricDifferenceFriendsFirst,\n", "          symmetricDifferenceEnemiesFirst);\n", "\n", "      ImmutableSet<String> immut\n", "          = Sets.symmetricDifference(friends, enemies).immutableCopy();\n", "      HashSet<String> mut = Sets.symmetricDifference(friends, enemies)\n", "          .copyInto(new HashSet<String>());\n", "\n", "      enemies.add(\"Dave\");\n", "      assertEquals(3, symmetricDifferenceFriendsFirst.size());\n", "      assertEquals(4, immut.size());\n", "      assertEquals(4, mut.size());\n", "\n", "      immut = Sets.symmetricDifference(enemies, friends).immutableCopy();\n", "      mut = Sets.symmetricDifference(enemies, friends).\n", "          copyInto(new HashSet<String>());\n", "      friends.add(\"Harry\");\n", "      assertEquals(2, symmetricDifferenceEnemiesFirst.size());\n", "      assertEquals(3, immut.size());\n", "      assertEquals(3, mut.size());\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129]}}, {"133": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/SetsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.Iterables.unmodifiableIterable;\n", "import static com.google.common.collect.Sets.newEnumSet;\n", "import static com.google.common.collect.Sets.newHashSet;\n", "import static com.google.common.collect.Sets.newLinkedHashSet;\n", "import static com.google.common.collect.Sets.powerSet;\n", "import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.util.Collections.emptySet;\n", "import static java.util.Collections.singleton;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.IteratorTester;\n", "import com.google.common.collect.testing.MinimalIterable;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.EnumSet;\n", "import java.util.HashMap;\n", "import java.util.HashSet;\n", "import java.util.Iterator;\n", "import java.util.LinkedHashMap;\n", "import java.util.LinkedHashSet;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.NoSuchElementException;\n", "import java.util.Set;\n", "import java.util.SortedSet;\n", "import java.util.TreeSet;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Unit test for {@code Sets}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SetsTest extends TestCase {\n", "\n", "  private static final IteratorTester.KnownOrder KNOWN_ORDER =\n", "      IteratorTester.KnownOrder.KNOWN_ORDER;\n", "\n", "  private static final Collection<Integer> EMPTY_COLLECTION\n", "      = Arrays.<Integer>asList();\n", "\n", "  private static final Collection<Integer> SOME_COLLECTION\n", "      = Arrays.asList(0, 1, 1);\n", "\n", "  private static final Iterable<Integer> SOME_ITERABLE\n", "      = new Iterable<Integer>() {\n", "        @Override\n", "        public Iterator<Integer> iterator() {\n", "          return SOME_COLLECTION.iterator();\n", "        }\n", "      };\n", "\n", "  private static final List<Integer> LONGER_LIST\n", "      = Arrays.asList(8, 6, 7, 5, 3, 0, 9);\n", "\n", "  private static final Comparator<Integer> SOME_COMPARATOR\n", "      = Collections.reverseOrder();\n", "\n", "  private enum SomeEnum { A, B, C, D }\n", "\n", "  public void testImmutableEnumSet() {\n", "    Set<SomeEnum> units = Sets.immutableEnumSet(SomeEnum.D, SomeEnum.B);\n", "\n", "    assertThat(units).containsExactly(SomeEnum.B, SomeEnum.D).inOrder();\n", "    try {\n", "      units.remove(SomeEnum.B);\n", "      fail(\"ImmutableEnumSet should throw an exception on remove()\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    try {\n", "      units.add(SomeEnum.C);\n", "      fail(\"ImmutableEnumSet should throw an exception on add()\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "  }\n", "\n", "  public void testImmutableEnumSet_fromIterable() {\n", "    ImmutableSet<SomeEnum> none\n", "        = Sets.immutableEnumSet(MinimalIterable.<SomeEnum>of());\n", "    assertThat(none).isEmpty();\n", "\n", "    ImmutableSet<SomeEnum> one\n", "        = Sets.immutableEnumSet(MinimalIterable.of(SomeEnum.B));\n", "    assertThat(one).contains(SomeEnum.B);\n", "\n", "    ImmutableSet<SomeEnum> two = Sets.immutableEnumSet(MinimalIterable.of(SomeEnum.D, SomeEnum.B));\n", "    assertThat(two).containsExactly(SomeEnum.B, SomeEnum.D).inOrder();\n", "  }\n", "\n", "  private static byte[] prepended(byte b, byte[] array) {\n", "    byte[] out = new byte[array.length + 1];\n", "    out[0] = b;\n", "    System.arraycopy(array, 0, out, 1, array.length);\n", "    return out;\n", "  }\n", "\n", "  public void testNewEnumSet_empty() {\n", "    EnumSet<SomeEnum> copy =\n", "        newEnumSet(Collections.<SomeEnum>emptySet(), SomeEnum.class);\n", "    assertEquals(EnumSet.noneOf(SomeEnum.class), copy);\n", "  }\n", "\n", "  public void testNewEnumSet_enumSet() {\n", "    EnumSet<SomeEnum> set = EnumSet.of(SomeEnum.A, SomeEnum.D);\n", "    assertEquals(set, newEnumSet(set, SomeEnum.class));\n", "  }\n", "\n", "  public void testNewEnumSet_collection() {\n", "    Set<SomeEnum> set = ImmutableSet.of(SomeEnum.B, SomeEnum.C);\n", "    assertEquals(set, newEnumSet(set, SomeEnum.class));\n", "  }\n", "\n", "  public void testNewEnumSet_iterable() {\n", "    Set<SomeEnum> set = ImmutableSet.of(SomeEnum.A, SomeEnum.B, SomeEnum.C);\n", "    assertEquals(set, newEnumSet(unmodifiableIterable(set), SomeEnum.class));\n", "  }\n", "\n", "  public void testNewHashSetEmpty() {\n", "    HashSet<Integer> set = Sets.newHashSet();\n", "    verifySetContents(set, EMPTY_COLLECTION);\n", "  }\n", "\n", "  public void testNewHashSetVarArgs() {\n", "    HashSet<Integer> set = Sets.newHashSet(0, 1, 1);\n", "    verifySetContents(set, Arrays.asList(0, 1));\n", "  }\n", "\n", "  public void testNewHashSetFromCollection() {\n", "    HashSet<Integer> set = Sets.newHashSet(SOME_COLLECTION);\n", "    verifySetContents(set, SOME_COLLECTION);\n", "  }\n", "\n", "  public void testNewHashSetFromIterable() {\n", "    HashSet<Integer> set = Sets.newHashSet(SOME_ITERABLE);\n", "    verifySetContents(set, SOME_ITERABLE);\n", "  }\n", "\n", "  public void testNewHashSetWithExpectedSizeSmall() {\n", "    HashSet<Integer> set = Sets.newHashSetWithExpectedSize(0);\n", "    verifySetContents(set, EMPTY_COLLECTION);\n", "  }\n", "\n", "  public void testNewHashSetWithExpectedSizeLarge() {\n", "    HashSet<Integer> set = Sets.newHashSetWithExpectedSize(1000);\n", "    verifySetContents(set, EMPTY_COLLECTION);\n", "  }\n", "\n", "  public void testNewHashSetFromIterator() {\n", "    HashSet<Integer> set = Sets.newHashSet(SOME_COLLECTION.iterator());\n", "    verifySetContents(set, SOME_COLLECTION);\n", "  }\n", "\n", "  public void testNewConcurrentHashSetEmpty() {\n", "    Set<Integer> set = Sets.newConcurrentHashSet();\n", "    verifySetContents(set, EMPTY_COLLECTION);\n", "  }\n", "\n", "  public void testNewConcurrentHashSetFromCollection() {\n", "    Set<Integer> set = Sets.newConcurrentHashSet(SOME_COLLECTION);\n", "    verifySetContents(set, SOME_COLLECTION);\n", "  }\n", "\n", "  public void testNewLinkedHashSetEmpty() {\n", "    LinkedHashSet<Integer> set = Sets.newLinkedHashSet();\n", "    verifyLinkedHashSetContents(set, EMPTY_COLLECTION);\n", "  }\n", "\n", "  public void testNewLinkedHashSetFromCollection() {\n", "    LinkedHashSet<Integer> set = Sets.newLinkedHashSet(LONGER_LIST);\n", "    verifyLinkedHashSetContents(set, LONGER_LIST);\n", "  }\n", "\n", "  public void testNewLinkedHashSetFromIterable() {\n", "    LinkedHashSet<Integer> set = Sets.newLinkedHashSet(new Iterable<Integer>()\n", "    {\n", "      @Override\n", "      public Iterator<Integer> iterator() {\n", "        return LONGER_LIST.iterator();\n", "      }\n", "    });\n", "    verifyLinkedHashSetContents(set, LONGER_LIST);\n", "  }\n", "\n", "  public void testNewLinkedHashSetWithExpectedSizeSmall() {\n", "    LinkedHashSet<Integer> set = Sets.newLinkedHashSetWithExpectedSize(0);\n", "    verifySetContents(set, EMPTY_COLLECTION);\n", "  }\n", "\n", "  public void testNewLinkedHashSetWithExpectedSizeLarge() {\n", "    LinkedHashSet<Integer> set = Sets.newLinkedHashSetWithExpectedSize(1000);\n", "    verifySetContents(set, EMPTY_COLLECTION);\n", "  }\n", "\n", "  public void testNewTreeSetEmpty() {\n", "    TreeSet<Integer> set = Sets.newTreeSet();\n", "    verifySortedSetContents(set, EMPTY_COLLECTION, null);\n", "  }\n", "\n", "  public void testNewTreeSetEmptyDerived() {\n", "    TreeSet<Derived> set = Sets.newTreeSet();\n", "    assertTrue(set.isEmpty());\n", "    set.add(new Derived(\"foo\"));\n", "    set.add(new Derived(\"bar\"));\n", "    assertThat(set).containsExactly(new Derived(\"bar\"), new Derived(\"foo\")).inOrder();\n", "  }\n", "\n", "  public void testNewTreeSetEmptyNonGeneric() {\n", "    TreeSet<LegacyComparable> set = Sets.newTreeSet();\n", "    assertTrue(set.isEmpty());\n", "    set.add(new LegacyComparable(\"foo\"));\n", "    set.add(new LegacyComparable(\"bar\"));\n", "    assertThat(set).containsExactly(\n", "        new LegacyComparable(\"bar\"), new LegacyComparable(\"foo\")).inOrder();\n", "  }\n", "\n", "  public void testNewTreeSetFromCollection() {\n", "    TreeSet<Integer> set = Sets.newTreeSet(SOME_COLLECTION);\n", "    verifySortedSetContents(set, SOME_COLLECTION, null);\n", "  }\n", "\n", "  public void testNewTreeSetFromIterable() {\n", "    TreeSet<Integer> set = Sets.newTreeSet(SOME_ITERABLE);\n", "    verifySortedSetContents(set, SOME_ITERABLE, null);\n", "  }\n", "\n", "  public void testNewTreeSetFromIterableDerived() {\n", "    Iterable<Derived> iterable =\n", "        Arrays.asList(new Derived(\"foo\"), new Derived(\"bar\"));\n", "    TreeSet<Derived> set = Sets.newTreeSet(iterable);\n", "    assertThat(set).containsExactly(\n", "        new Derived(\"bar\"), new Derived(\"foo\")).inOrder();\n", "  }\n", "\n", "  public void testNewTreeSetFromIterableNonGeneric() {\n", "    Iterable<LegacyComparable> iterable =\n", "        Arrays.asList(new LegacyComparable(\"foo\"), new LegacyComparable(\"bar\"));\n", "    TreeSet<LegacyComparable> set = Sets.newTreeSet(iterable);\n", "    assertThat(set).containsExactly(\n", "        new LegacyComparable(\"bar\"), new LegacyComparable(\"foo\")).inOrder();\n", "  }\n", "\n", "  public void testNewTreeSetEmptyWithComparator() {\n", "    TreeSet<Integer> set = Sets.newTreeSet(SOME_COMPARATOR);\n", "    verifySortedSetContents(set, EMPTY_COLLECTION, SOME_COMPARATOR);\n", "  }\n", "\n", "  public void testNewIdentityHashSet() {\n", "    Set<Integer> set = Sets.newIdentityHashSet();\n", "    Integer value1 = new Integer(12357);\n", "    Integer value2 = new Integer(12357);\n", "    assertTrue(set.add(value1));\n", "    assertFalse(set.contains(value2));\n", "    assertTrue(set.contains(value1));\n", "    assertTrue(set.add(value2));\n", "    assertEquals(2, set.size());\n", "  }\n", "\n", "  public void testComplementOfEnumSet() {\n", "    Set<SomeEnum> units = EnumSet.of(SomeEnum.B, SomeEnum.D);\n", "    EnumSet<SomeEnum> otherUnits = Sets.complementOf(units);\n", "    verifySetContents(otherUnits, EnumSet.of(SomeEnum.A, SomeEnum.C));\n", "  }\n", "\n", "  public void testComplementOfEnumSetWithType() {\n", "    Set<SomeEnum> units = EnumSet.of(SomeEnum.B, SomeEnum.D);\n", "    EnumSet<SomeEnum> otherUnits = Sets.complementOf(units, SomeEnum.class);\n", "    verifySetContents(otherUnits, EnumSet.of(SomeEnum.A, SomeEnum.C));\n", "  }\n", "\n", "  public void testComplementOfRegularSet() {\n", "    Set<SomeEnum> units = Sets.newHashSet(SomeEnum.B, SomeEnum.D);\n", "    EnumSet<SomeEnum> otherUnits = Sets.complementOf(units);\n", "    verifySetContents(otherUnits, EnumSet.of(SomeEnum.A, SomeEnum.C));\n", "  }\n", "\n", "  public void testComplementOfRegularSetWithType() {\n", "    Set<SomeEnum> units = Sets.newHashSet(SomeEnum.B, SomeEnum.D);\n", "    EnumSet<SomeEnum> otherUnits = Sets.complementOf(units, SomeEnum.class);\n", "    verifySetContents(otherUnits, EnumSet.of(SomeEnum.A, SomeEnum.C));\n", "  }\n", "\n", "  public void testComplementOfEmptySet() {\n", "    Set<SomeEnum> noUnits = Collections.emptySet();\n", "    EnumSet<SomeEnum> allUnits = Sets.complementOf(noUnits, SomeEnum.class);\n", "    verifySetContents(EnumSet.allOf(SomeEnum.class), allUnits);\n", "  }\n", "\n", "  public void testComplementOfFullSet() {\n", "    Set<SomeEnum> allUnits = Sets.newHashSet(SomeEnum.values());\n", "    EnumSet<SomeEnum> noUnits = Sets.complementOf(allUnits, SomeEnum.class);\n", "    verifySetContents(noUnits, EnumSet.noneOf(SomeEnum.class));\n", "  }\n", "\n", "  public void testComplementOfEmptyEnumSetWithoutType() {\n", "    Set<SomeEnum> noUnits = EnumSet.noneOf(SomeEnum.class);\n", "    EnumSet<SomeEnum> allUnits = Sets.complementOf(noUnits);\n", "    verifySetContents(allUnits, EnumSet.allOf(SomeEnum.class));\n", "  }\n", "\n", "  public void testComplementOfEmptySetWithoutTypeDoesntWork() {\n", "    Set<SomeEnum> set = Collections.emptySet();\n", "    try {\n", "      Sets.complementOf(set);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testNewSetFromMap() {\n", "    Set<Integer> set = Sets.newSetFromMap(new HashMap<Integer, Boolean>());\n", "    set.addAll(SOME_COLLECTION);\n", "    verifySetContents(set, SOME_COLLECTION);\n", "  }\n", "\n", "  public void testNewSetFromMapIllegal() {\n", "    Map<Integer, Boolean> map = new LinkedHashMap<Integer, Boolean>();\n", "    map.put(2, true);\n", "    try {\n", "      Sets.newSetFromMap(map);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  // TODO: the overwhelming number of suppressions below suggests that maybe\n", "  // it's not worth having a varargs form of this method at all...\n", "\n", "  /**\n", "   * The 0-ary cartesian product is a single empty list.\n", "   */\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_zeroary() {\n", "    assertThat(Sets.cartesianProduct()).containsExactly(list());\n", "  }\n", "\n", "  /**\n", "   * A unary cartesian product is one list of size 1 for each element in the\n", "   * input set.\n", "   */\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_unary() {\n", "    assertThat(Sets.cartesianProduct(set(1, 2))).containsExactly(list(1), list(2));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary0x0() {\n", "    Set<Integer> mt = emptySet();\n", "    assertEmpty(Sets.cartesianProduct(mt, mt));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary0x1() {\n", "    Set<Integer> mt = emptySet();\n", "    assertEmpty(Sets.cartesianProduct(mt, set(1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary1x0() {\n", "    Set<Integer> mt = emptySet();\n", "    assertEmpty(Sets.cartesianProduct(set(1), mt));\n", "  }\n", "\n", "  private static void assertEmpty(Set<? extends List<?>> set) {\n", "    assertTrue(set.isEmpty());\n", "    assertEquals(0, set.size());\n", "    assertFalse(set.iterator().hasNext());\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary1x1() {\n", "    assertThat(Sets.cartesianProduct(set(1), set(2))).contains(list(1, 2));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary1x2() {\n", "    assertThat(Sets.cartesianProduct(set(1), set(2, 3)))\n", "        .containsExactly(list(1, 2), list(1, 3)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_binary2x2() {\n", "    assertThat(Sets.cartesianProduct(set(1, 2), set(3, 4)))\n", "        .containsExactly(list(1, 3), list(1, 4), list(2, 3), list(2, 4)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_2x2x2() {\n", "    assertThat(Sets.cartesianProduct(set(0, 1), set(0, 1), set(0, 1))).containsExactly(\n", "        list(0, 0, 0), list(0, 0, 1), list(0, 1, 0), list(0, 1, 1),\n", "        list(1, 0, 0), list(1, 0, 1), list(1, 1, 0), list(1, 1, 1)).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_contains() {\n", "    Set<List<Integer>> actual = Sets.cartesianProduct(set(1, 2), set(3, 4));\n", "    assertTrue(actual.contains(list(1, 3)));\n", "    assertTrue(actual.contains(list(1, 4)));\n", "    assertTrue(actual.contains(list(2, 3)));\n", "    assertTrue(actual.contains(list(2, 4)));\n", "    assertFalse(actual.contains(list(3, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_unrelatedTypes() {\n", "    Set<Integer> x = set(1, 2);\n", "    Set<String> y = set(\"3\", \"4\");\n", "\n", "    List<Object> exp1 = list((Object) 1, \"3\");\n", "    List<Object> exp2 = list((Object) 1, \"4\");\n", "    List<Object> exp3 = list((Object) 2, \"3\");\n", "    List<Object> exp4 = list((Object) 2, \"4\");\n", "\n", "    assertThat(Sets.<Object>cartesianProduct(x, y))\n", "        .containsExactly(exp1, exp2, exp3, exp4).inOrder();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProductTooBig() {\n", "    Set<Integer> set = ContiguousSet.create(Range.closed(0, 10000), DiscreteDomain.integers());\n", "    try {\n", "      Sets.cartesianProduct(set, set, set, set, set);\n", "      fail(\"Expected IAE\");\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\") // varargs!\n", "  public void testCartesianProduct_hashCode() {\n", "    // Run through the same cartesian products we tested above\n", "\n", "    Set<List<Integer>> degenerate = Sets.cartesianProduct();\n", "    checkHashCode(degenerate);\n", "\n", "    checkHashCode(Sets.cartesianProduct(set(1, 2)));\n", "\n", "    int num = Integer.MAX_VALUE / 3 * 2; // tickle overflow-related problems\n", "    checkHashCode(Sets.cartesianProduct(set(1, 2, num)));\n", "\n", "    Set<Integer> mt = emptySet();\n", "    checkHashCode(Sets.cartesianProduct(mt, mt));\n", "    checkHashCode(Sets.cartesianProduct(mt, set(num)));\n", "    checkHashCode(Sets.cartesianProduct(set(num), mt));\n", "    checkHashCode(Sets.cartesianProduct(set(num), set(1)));\n", "    checkHashCode(Sets.cartesianProduct(set(1), set(2, num)));\n", "    checkHashCode(Sets.cartesianProduct(set(1, num), set(2, num - 1)));\n", "    checkHashCode(Sets.cartesianProduct(\n", "        set(1, num), set(2, num - 1), set(3, num + 1)));\n", "\n", "    // a bigger one\n", "    checkHashCode(Sets.cartesianProduct(\n", "        set(1, num, num + 1), set(2), set(3, num + 2), set(4, 5, 6, 7, 8)));\n", "  }\n", "\n", "  public void testPowerSetEmpty() {\n", "    ImmutableSet<Integer> elements = ImmutableSet.of();\n", "    Set<Set<Integer>> powerSet = powerSet(elements);\n", "    assertEquals(1, powerSet.size());\n", "    assertEquals(ImmutableSet.of(ImmutableSet.of()), powerSet);\n", "    assertEquals(0, powerSet.hashCode());\n", "  }\n", "\n", "  public void testPowerSetContents() {\n", "    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2, 3);\n", "    Set<Set<Integer>> powerSet = powerSet(elements);\n", "    assertEquals(8, powerSet.size());\n", "    assertEquals(4 * 1 + 4 * 2 + 4 * 3, powerSet.hashCode());\n", "\n", "    Set<Set<Integer>> expected = newHashSet();\n", "    expected.add(ImmutableSet.<Integer>of());\n", "    expected.add(ImmutableSet.of(1));\n", "    expected.add(ImmutableSet.of(2));\n", "    expected.add(ImmutableSet.of(3));\n", "    expected.add(ImmutableSet.of(1, 2));\n", "    expected.add(ImmutableSet.of(1, 3));\n", "    expected.add(ImmutableSet.of(2, 3));\n", "    expected.add(ImmutableSet.of(1, 2, 3));\n", "\n", "    Set<Set<Integer>> almostPowerSet = newHashSet(expected);\n", "    almostPowerSet.remove(ImmutableSet.of(1, 2, 3));\n", "    almostPowerSet.add(ImmutableSet.of(1, 2, 4));\n", "\n", "    new EqualsTester()\n", "        .addEqualityGroup(expected, powerSet)\n", "        .addEqualityGroup(ImmutableSet.of(1, 2, 3))\n", "        .addEqualityGroup(almostPowerSet)\n", "        .testEquals();\n", "\n", "    for (Set<Integer> subset : expected) {\n", "      assertTrue(powerSet.contains(subset));\n", "    }\n", "    assertFalse(powerSet.contains(ImmutableSet.of(1, 2, 4)));\n", "    assertFalse(powerSet.contains(singleton(null)));\n", "    assertFalse(powerSet.contains(null));\n", "    assertFalse(powerSet.contains(\"notASet\"));\n", "  }\n", "\n", "  public void testPowerSetIteration_manual() {\n", "    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2, 3);\n", "    Set<Set<Integer>> powerSet = powerSet(elements);\n", "    // The API doesn't promise this iteration order, but it's convenient here.\n", "    Iterator<Set<Integer>> i = powerSet.iterator();\n", "    assertEquals(ImmutableSet.of(), i.next());\n", "    assertEquals(ImmutableSet.of(1), i.next());\n", "    assertEquals(ImmutableSet.of(2), i.next());\n", "    assertEquals(ImmutableSet.of(2, 1), i.next());\n", "    assertEquals(ImmutableSet.of(3), i.next());\n", "    assertEquals(ImmutableSet.of(3, 1), i.next());\n", "    assertEquals(ImmutableSet.of(3, 2), i.next());\n", "    assertEquals(ImmutableSet.of(3, 2, 1), i.next());\n", "    assertFalse(i.hasNext());\n", "    try {\n", "      i.next();\n", "      fail();\n", "    } catch (NoSuchElementException expected) {\n", "    }\n", "  }\n", "\n", "  public void testPowerSetIteration_iteratorTester_fast() {\n", "    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2);\n", "\n", "    Set<Set<Integer>> expected = newLinkedHashSet();\n", "    expected.add(ImmutableSet.<Integer>of());\n", "    expected.add(ImmutableSet.of(1));\n", "    expected.add(ImmutableSet.of(2));\n", "    expected.add(ImmutableSet.of(1, 2));\n", "\n", "    final Set<Set<Integer>> powerSet = powerSet(elements);\n", "    new IteratorTester<Set<Integer>>(4, UNMODIFIABLE, expected, KNOWN_ORDER) {\n", "      @Override protected Iterator<Set<Integer>> newTargetIterator() {\n", "        return powerSet.iterator();\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  public void testPowerSetSize() {\n", "    assertPowerSetSize(1);\n", "    assertPowerSetSize(2, 'a');\n", "    assertPowerSetSize(4, 'a', 'b');\n", "    assertPowerSetSize(8, 'a', 'b', 'c');\n", "    assertPowerSetSize(16, 'a', 'b', 'd', 'e');\n", "    assertPowerSetSize(1 << 30,\n", "        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n", "        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2',\n", "        '3', '4');\n", "  }\n", "\n", "  public void testPowerSetCreationErrors() {\n", "    try {\n", "      powerSet(newHashSet('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n", "          'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\n", "          'y', 'z', '1', '2', '3', '4', '5'));\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "\n", "    try {\n", "      powerSet(singleton(null));\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testPowerSetEqualsAndHashCode_verifyAgainstHashSet() {\n", "    ImmutableList<Integer> allElements = ImmutableList.of(4233352, 3284593,\n", "        3794208, 3849533, 4013967, 2902658, 1886275, 2131109, 985872, 1843868);\n", "    for (int i = 0; i < allElements.size(); i++) {\n", "      Set<Integer> elements = newHashSet(allElements.subList(0, i));\n", "      Set<Set<Integer>> powerSet1 = powerSet(elements);\n", "      Set<Set<Integer>> powerSet2 = powerSet(elements);\n", "      new EqualsTester()\n", "          .addEqualityGroup(powerSet1, powerSet2, toHashSets(powerSet1))\n", "          .addEqualityGroup(ImmutableSet.of())\n", "          .addEqualityGroup(ImmutableSet.of(9999999))\n", "          .addEqualityGroup(\"notASet\")\n", "          .testEquals();\n", "      assertEquals(toHashSets(powerSet1).hashCode(), powerSet1.hashCode());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Test that a hash code miscomputed by \"input.hashCode() * tooFarValue / 2\"\n", "   * is correct under our {@code hashCode} implementation.\n", "   */\n", "  public void testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero() {\n", "    Set<Object> sumToEighthMaxIntElements =\n", "        newHashSet(objectWithHashCode(1 << 29), objectWithHashCode(0));\n", "    assertPowerSetHashCode(1 << 30, sumToEighthMaxIntElements);\n", "\n", "    Set<Object> sumToQuarterMaxIntElements =\n", "        newHashSet(objectWithHashCode(1 << 30), objectWithHashCode(0));\n", "    assertPowerSetHashCode(1 << 31, sumToQuarterMaxIntElements);\n", "  }\n", "\n", "  public void testPowerSetShowOff() {\n", "    Set<Object> zero = ImmutableSet.of();\n", "    Set<Set<Object>> one = powerSet(zero);\n", "    Set<Set<Set<Object>>> two = powerSet(one);\n", "    Set<Set<Set<Set<Object>>>> four = powerSet(two);\n", "    Set<Set<Set<Set<Set<Object>>>>> sixteen = powerSet(four);\n", "    Set<Set<Set<Set<Set<Set<Object>>>>>> sixtyFiveThousandish =\n", "        powerSet(sixteen);\n", "    assertEquals(1 << 16, sixtyFiveThousandish.size());\n", "\n", "    assertTrue(powerSet(makeSetOfZeroToTwentyNine())\n", "        .contains(makeSetOfZeroToTwentyNine()));\n", "    assertFalse(powerSet(makeSetOfZeroToTwentyNine())\n", "        .contains(ImmutableSet.of(30)));\n", "  }\n", "\n", "  private static Set<Integer> makeSetOfZeroToTwentyNine() {\n", "    // TODO: use Range once it's publicly available\n", "    Set<Integer> zeroToTwentyNine = newHashSet();\n", "    for (int i = 0; i < 30; i++) {\n", "      zeroToTwentyNine.add(i);\n", "    }\n", "    return zeroToTwentyNine;\n", "  }\n", "\n", "  private static <E> Set<Set<E>> toHashSets(Set<Set<E>> powerSet) {\n", "    Set<Set<E>> result = newHashSet();\n", "    for (Set<E> subset : powerSet) {\n", "      result.add(new HashSet<E>(subset));\n", "    }\n", "    return result;\n", "  }\n", "\n", "  private static Object objectWithHashCode(final int hashCode) {\n", "    return new Object() {\n", "      @Override public int hashCode() {\n", "        return hashCode;\n", "      }\n", "    };\n", "  }\n", "\n", "  private static void assertPowerSetHashCode(int expected, Set<?> elements) {\n", "    assertEquals(expected, powerSet(elements).hashCode());\n", "  }\n", "\n", "  private static void assertPowerSetSize(int i, Object... elements) {\n", "    assertEquals(i, powerSet(newHashSet(elements)).size());\n", "  }\n", "\n", "  private static void checkHashCode(Set<?> set) {\n", "    assertEquals(Sets.newHashSet(set).hashCode(), set.hashCode());\n", "  }\n", "\n", "  private static <E> Set<E> set(E... elements) {\n", "    return ImmutableSet.copyOf(elements);\n", "  }\n", "\n", "  private static <E> List<E> list(E... elements) {\n", "    return ImmutableList.copyOf(elements);\n", "  }\n", "\n", "  /**\n", "   * Utility method to verify that the given LinkedHashSet is equal to and\n", "   * hashes identically to a set constructed with the elements in the given\n", "   * collection.  Also verifies that the ordering in the set is the same\n", "   * as the ordering of the given contents.\n", "   */\n", "  private static <E> void verifyLinkedHashSetContents(\n", "      LinkedHashSet<E> set, Collection<E> contents) {\n", "    assertEquals(\"LinkedHashSet should have preserved order for iteration\",\n", "        new ArrayList<E>(set), new ArrayList<E>(contents));\n", "    verifySetContents(set, contents);\n", "  }\n", "\n", "  /**\n", "   * Utility method to verify that the given SortedSet is equal to and\n", "   * hashes identically to a set constructed with the elements in the\n", "   * given iterable.  Also verifies that the comparator is the same as the\n", "   * given comparator.\n", "   */\n", "  private static <E> void verifySortedSetContents(\n", "      SortedSet<E> set, Iterable<E> iterable,\n", "      @Nullable Comparator<E> comparator) {\n", "    assertSame(comparator, set.comparator());\n", "    verifySetContents(set, iterable);\n", "  }\n", "\n", "  /**\n", "   * Utility method that verifies that the given set is equal to and hashes\n", "   * identically to a set constructed with the elements in the given iterable.\n", "   */\n", "  private static <E> void verifySetContents(Set<E> set, Iterable<E> contents) {\n", "    Set<E> expected = null;\n", "    if (contents instanceof Set) {\n", "      expected = (Set<E>) contents;\n", "    } else {\n", "      expected = new HashSet<E>();\n", "      for (E element : contents) {\n", "        expected.add(element);\n", "      }\n", "    }\n", "    assertEquals(expected, set);\n", "  }\n", "\n", "  /**\n", "   * Simple base class to verify that we handle generics correctly.\n", "   */\n", "  static class Base implements Comparable<Base>, Serializable {\n", "    private final String s;\n", "\n", "    public Base(String s) {\n", "      this.s = s;\n", "    }\n", "\n", "    @Override public int hashCode() { // delegate to 's'\n", "      return s.hashCode();\n", "    }\n", "\n", "    @Override public boolean equals(Object other) {\n", "      if (other == null) {\n", "        return false;\n", "      } else if (other instanceof Base) {\n", "        return s.equals(((Base) other).s);\n", "      } else {\n", "        return false;\n", "      }\n", "    }\n", "\n", "    @Override\n", "    public int compareTo(Base o) {\n", "      return s.compareTo(o.s);\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  /**\n", "   * Simple derived class to verify that we handle generics correctly.\n", "   */\n", "  static class Derived extends Base {\n", "    public Derived(String s) {\n", "      super(s);\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "  void ensureNotDirectlyModifiable(SortedSet<Integer> unmod) {\n", "    try {\n", "      unmod.add(4);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      unmod.remove(4);\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      unmod.addAll(Collections.singleton(4));\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    try {\n", "      Iterator<Integer> iterator = unmod.iterator();\n", "      iterator.next();\n", "      iterator.remove();\n", "      fail(\"UnsupportedOperationException expected\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790]}}, {"134": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/SimpleAbstractMultisetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.Serializable;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.concurrent.atomic.AtomicInteger;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Unit test for {@link AbstractMultiset}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Louis Wasserman\n", " */\n", "@SuppressWarnings(\"serial\") // No serialization is used in this test\n", "@GwtCompatible(emulated = true)\n", "public class SimpleAbstractMultisetTest extends TestCase {\n", "\n", "  public void testFastAddAllMultiset() {\n", "    final AtomicInteger addCalls = new AtomicInteger();\n", "    Multiset<String> multiset = new NoRemoveMultiset<String>() {\n", "      @Override\n", "      public int add(String element, int occurrences) {\n", "        addCalls.incrementAndGet();\n", "        return super.add(element, occurrences);\n", "      }\n", "    };\n", "    ImmutableMultiset<String> adds =\n", "        new ImmutableMultiset.Builder<String>().addCopies(\"x\", 10).build();\n", "    multiset.addAll(adds);\n", "    assertEquals(addCalls.get(), 1);\n", "  }\n", "\n", "  public void testRemoveUnsupported() {\n", "    Multiset<String> multiset = new NoRemoveMultiset<String>();\n", "    multiset.add(\"a\");\n", "    try {\n", "      multiset.remove(\"a\");\n", "      fail();\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertTrue(multiset.contains(\"a\"));\n", "  }\n", "\n", "  private static class NoRemoveMultiset<E> extends AbstractMultiset<E>\n", "      implements Serializable {\n", "    final Map<E, Integer> backingMap = Maps.newHashMap();\n", "\n", "    @Override public int add(@Nullable E element, int occurrences) {\n", "      checkArgument(occurrences >= 0);\n", "      Integer frequency = backingMap.get(element);\n", "      if (frequency == null) {\n", "        frequency = 0;\n", "      }\n", "      if (occurrences == 0) {\n", "        return frequency;\n", "      }\n", "      checkArgument(occurrences <= Integer.MAX_VALUE - frequency);\n", "      backingMap.put(element, frequency + occurrences);\n", "      return frequency;\n", "    }\n", "\n", "    @Override\n", "    Iterator<Entry<E>> entryIterator() {\n", "      final Iterator<Map.Entry<E, Integer>> backingEntries = backingMap.entrySet().iterator();\n", "      return new UnmodifiableIterator<Multiset.Entry<E>>() {\n", "        @Override\n", "        public boolean hasNext() {\n", "          return backingEntries.hasNext();\n", "        }\n", "\n", "        @Override\n", "        public Multiset.Entry<E> next() {\n", "          final Map.Entry<E, Integer> mapEntry = backingEntries.next();\n", "          return new Multisets.AbstractEntry<E>() {\n", "            @Override\n", "            public E getElement() {\n", "              return mapEntry.getKey();\n", "            }\n", "\n", "            @Override\n", "            public int getCount() {\n", "              Integer frequency = backingMap.get(getElement());\n", "              return (frequency == null) ? 0 : frequency;\n", "            }\n", "          };\n", "        }\n", "      };\n", "    }\n", "\n", "    @Override\n", "    int distinctElements() {\n", "      return backingMap.size();\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117]}}, {"135": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/SingletonImmutableTableTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Objects;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "/**\n", " * Tests {@link SingletonImmutableTable}.\n", " *\n", " * @author Gregory Kick\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SingletonImmutableTableTest extends AbstractImmutableTableTest {\n", "  private final ImmutableTable<Character, Integer, String> testTable =\n", "      new SingletonImmutableTable<Character, Integer, String>('a', 1, \"blah\");\n", "\n", "  public void testHashCode() {\n", "    assertEquals(Objects.hashCode('a', 1, \"blah\"), testTable.hashCode());\n", "  }\n", "\n", "  public void testCellSet() {\n", "    assertEquals(ImmutableSet.of(Tables.immutableCell('a', 1, \"blah\")), testTable.cellSet());\n", "  }\n", "\n", "  public void testColumn() {\n", "    assertEquals(ImmutableMap.of(), testTable.column(0));\n", "    assertEquals(ImmutableMap.of('a', \"blah\"), testTable.column(1));\n", "  }\n", "\n", "  public void testColumnKeySet() {\n", "    assertEquals(ImmutableSet.of(1), testTable.columnKeySet());\n", "  }\n", "\n", "  public void testColumnMap() {\n", "    assertEquals(ImmutableMap.of(1, ImmutableMap.of('a', \"blah\")), testTable.columnMap());\n", "  }\n", "\n", "  public void testRow() {\n", "    assertEquals(ImmutableMap.of(), testTable.row('A'));\n", "    assertEquals(ImmutableMap.of(1, \"blah\"), testTable.row('a'));\n", "  }\n", "\n", "  public void testRowKeySet() {\n", "    assertEquals(ImmutableSet.of('a'), testTable.rowKeySet());\n", "  }\n", "\n", "  public void testRowMap() {\n", "    assertEquals(ImmutableMap.of('a', ImmutableMap.of(1, \"blah\")),\n", "        testTable.rowMap());\n", "  }\n", "\n", "  public void testEqualsObject() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(testTable, HashBasedTable.create(testTable))\n", "        .addEqualityGroup(ImmutableTable.of(), HashBasedTable.create())\n", "        .addEqualityGroup(HashBasedTable.create(ImmutableTable.of('A', 2, \"\")))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testToString() {\n", "    assertEquals(\"{a={1=blah}}\", testTable.toString());\n", "  }\n", "\n", "  public void testContains() {\n", "    assertTrue(testTable.contains('a', 1));\n", "    assertFalse(testTable.contains('a', 2));\n", "    assertFalse(testTable.contains('A', 1));\n", "    assertFalse(testTable.contains('A', 2));\n", "  }\n", "\n", "  public void testContainsColumn() {\n", "    assertTrue(testTable.containsColumn(1));\n", "    assertFalse(testTable.containsColumn(2));\n", "  }\n", "\n", "  public void testContainsRow() {\n", "    assertTrue(testTable.containsRow('a'));\n", "    assertFalse(testTable.containsRow('A'));\n", "  }\n", "\n", "  public void testContainsValue() {\n", "    assertTrue(testTable.containsValue(\"blah\"));\n", "    assertFalse(testTable.containsValue(\"\"));\n", "  }\n", "\n", "  public void testGet() {\n", "    assertEquals(\"blah\", testTable.get('a', 1));\n", "    assertNull(testTable.get('a', 2));\n", "    assertNull(testTable.get('A', 1));\n", "    assertNull(testTable.get('A', 2));\n", "  }\n", "\n", "  public void testIsEmpty() {\n", "    assertFalse(testTable.isEmpty());\n", "  }\n", "\n", "  public void testSize() {\n", "    assertEquals(1, testTable.size());\n", "  }\n", "\n", "  public void testValues() {\n", "    assertThat(testTable.values()).contains(\"blah\");\n", "  }\n", "\n", "  @Override Iterable<ImmutableTable<Character, Integer, String>> getTestInstances() {\n", "    return ImmutableSet.of(testTable);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"136": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/SortedListsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2010 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the\n", " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n", " * express or implied. See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.SortedLists.KeyAbsentBehavior;\n", "import com.google.common.collect.SortedLists.KeyPresentBehavior;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Tests for SortedLists.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SortedListsTest extends TestCase {\n", "  private static final ImmutableList<Integer> LIST_WITH_DUPS =\n", "      ImmutableList.of(1, 1, 2, 4, 4, 4, 8);\n", "\n", "  private static final ImmutableList<Integer> LIST_WITHOUT_DUPS = ImmutableList.of(1, 2, 4, 8);\n", "\n", "  void assertModelAgrees(List<Integer> list, Integer key, int answer,\n", "      KeyPresentBehavior presentBehavior, KeyAbsentBehavior absentBehavior) {\n", "    switch (presentBehavior) {\n", "      case FIRST_PRESENT:\n", "        if (list.contains(key)) {\n", "          assertEquals(list.indexOf(key), answer);\n", "          return;\n", "        }\n", "        break;\n", "      case LAST_PRESENT:\n", "        if (list.contains(key)) {\n", "          assertEquals(list.lastIndexOf(key), answer);\n", "          return;\n", "        }\n", "        break;\n", "      case ANY_PRESENT:\n", "        if (list.contains(key)) {\n", "          assertEquals(key, list.get(answer));\n", "          return;\n", "        }\n", "        break;\n", "      case FIRST_AFTER:\n", "        if (list.contains(key)) {\n", "          assertEquals(list.lastIndexOf(key) + 1, answer);\n", "          return;\n", "        }\n", "        break;\n", "      case LAST_BEFORE:\n", "        if (list.contains(key)) {\n", "          assertEquals(list.indexOf(key) - 1, answer);\n", "          return;\n", "        }\n", "        break;\n", "      default:\n", "        throw new AssertionError();\n", "    }\n", "    // key is not present\n", "    int nextHigherIndex = list.size();\n", "    for (int i = list.size() - 1; i >= 0 && list.get(i) > key; i--) {\n", "      nextHigherIndex = i;\n", "    }\n", "    switch (absentBehavior) {\n", "      case NEXT_LOWER:\n", "        assertEquals(nextHigherIndex - 1, answer);\n", "        return;\n", "      case NEXT_HIGHER:\n", "        assertEquals(nextHigherIndex, answer);\n", "        return;\n", "      case INVERTED_INSERTION_INDEX:\n", "        assertEquals(-1 - nextHigherIndex, answer);\n", "        return;\n", "      default:\n", "        throw new AssertionError();\n", "    }\n", "  }\n", "\n", "  public void testWithoutDups() {\n", "    for (KeyPresentBehavior presentBehavior : KeyPresentBehavior.values()) {\n", "      for (KeyAbsentBehavior absentBehavior : KeyAbsentBehavior.values()) {\n", "        for (int key = 0; key <= 10; key++) {\n", "          assertModelAgrees(LIST_WITHOUT_DUPS, key,\n", "              SortedLists.binarySearch(LIST_WITHOUT_DUPS, key, presentBehavior, absentBehavior),\n", "              presentBehavior, absentBehavior);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testWithDups() {\n", "    for (KeyPresentBehavior presentBehavior : KeyPresentBehavior.values()) {\n", "      for (KeyAbsentBehavior absentBehavior : KeyAbsentBehavior.values()) {\n", "        for (int key = 0; key <= 10; key++) {\n", "          assertModelAgrees(LIST_WITH_DUPS, key,\n", "              SortedLists.binarySearch(LIST_WITH_DUPS, key, presentBehavior, absentBehavior),\n", "              presentBehavior, absentBehavior);\n", "        }\n", "      }\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117]}}, {"137": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/TableCollectionTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.collect.Table.Cell;\n", "import com.google.common.collect.testing.MapInterfaceTest;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.TestSetGenerator;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.Feature;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Set;\n", "import java.util.SortedMap;\n", "\n", "/**\n", " * Collection tests for {@link Table} implementations.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TableCollectionTest extends TestCase {\n", "\n", "  private static final Feature<?>[] COLLECTION_FEATURES = {\n", "    CollectionSize.ANY,\n", "    CollectionFeature.ALLOWS_NULL_QUERIES\n", "  };\n", "\n", "  private static final Feature<?>[] COLLECTION_FEATURES_ORDER = {\n", "    CollectionSize.ANY,\n", "    CollectionFeature.KNOWN_ORDER,\n", "    CollectionFeature.ALLOWS_NULL_QUERIES\n", "  };\n", "\n", "  private static final Feature<?>[] COLLECTION_FEATURES_REMOVE = {\n", "    CollectionSize.ANY,\n", "    CollectionFeature.SUPPORTS_REMOVE,\n", "    CollectionFeature.ALLOWS_NULL_QUERIES\n", "  };\n", "\n", "  private static final Feature<?>[] COLLECTION_FEATURES_REMOVE_ORDER = {\n", "    CollectionSize.ANY,\n", "    CollectionFeature.KNOWN_ORDER,\n", "    CollectionFeature.SUPPORTS_REMOVE,\n", "    CollectionFeature.ALLOWS_NULL_QUERIES\n", "  };\n", "\n", "  private static void populateForRowKeySet(\n", "      Table<String, Integer, Character> table, String[] elements) {\n", "    for (String row : elements) {\n", "      table.put(row, 1, 'a');\n", "      table.put(row, 2, 'b');\n", "    }\n", "  }\n", "\n", "  private static void populateForColumnKeySet(\n", "      Table<Integer, String, Character> table, String[] elements) {\n", "    for (String column : elements) {\n", "      table.put(1, column, 'a');\n", "      table.put(2, column, 'b');\n", "    }\n", "  }\n", "\n", "  private static void populateForValues(\n", "      Table<Integer, Character, String> table, String[] elements) {\n", "    for (int i = 0; i < elements.length; i++) {\n", "      table.put(i, 'a', elements[i]);\n", "    }\n", "  }\n", "\n", "  private static abstract class TestCellSetGenerator\n", "      implements TestSetGenerator<Cell<String, Integer, Character>> {\n", "    @Override\n", "    public SampleElements<Cell<String, Integer, Character>> samples() {\n", "      return new SampleElements<Cell<String, Integer, Character>>(\n", "          Tables.immutableCell(\"bar\", 1, 'a'),\n", "          Tables.immutableCell(\"bar\", 2, 'b'),\n", "          Tables.immutableCell(\"foo\", 3, 'c'),\n", "          Tables.immutableCell(\"bar\", 1, 'b'),\n", "          Tables.immutableCell(\"cat\", 2, 'b'));\n", "    }\n", "\n", "    @Override\n", "    public Set<Cell<String, Integer, Character>> create(\n", "        Object... elements) {\n", "      Table<String, Integer, Character> table = createTable();\n", "      for (Object element : elements) {\n", "        @SuppressWarnings(\"unchecked\")\n", "        Cell<String, Integer, Character> cell\n", "            = (Cell<String, Integer, Character>) element;\n", "        table.put(cell.getRowKey(), cell.getColumnKey(), cell.getValue());\n", "      }\n", "      return table.cellSet();\n", "    }\n", "\n", "    abstract Table<String, Integer, Character> createTable();\n", "\n", "    @Override\n", "    @SuppressWarnings(\"unchecked\")\n", "    public Cell<String, Integer, Character>[] createArray(int length) {\n", "      return (Cell<String, Integer, Character>[]) new Cell<?, ?, ?>[length];\n", "    }\n", "\n", "    @Override\n", "    public List<Cell<String, Integer, Character>> order(\n", "        List<Cell<String, Integer, Character>> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  private static abstract class MapTests\n", "      extends MapInterfaceTest<String, Integer> {\n", "\n", "    MapTests(boolean allowsNullValues, boolean supportsPut, boolean supportsRemove,\n", "        boolean supportsClear, boolean supportsIteratorRemove) {\n", "      super(false, allowsNullValues, supportsPut, supportsRemove, supportsClear,\n", "          supportsIteratorRemove);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"four\";\n", "    }\n", "\n", "    @Override protected Integer getValueNotInPopulatedMap() {\n", "      return 4;\n", "    }\n", "  }\n", "\n", "  private static abstract class RowTests extends MapTests {\n", "    RowTests(boolean allowsNullValues, boolean supportsPut, boolean supportsRemove,\n", "        boolean supportsClear, boolean supportsIteratorRemove) {\n", "      super(allowsNullValues, supportsPut, supportsRemove, supportsClear,\n", "          supportsIteratorRemove);\n", "    }\n", "\n", "    abstract Table<Character, String, Integer> makeTable();\n", "\n", "    @Override protected Map<String, Integer> makeEmptyMap() {\n", "      return makeTable().row('a');\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      Table<Character, String, Integer> table = makeTable();\n", "      table.put('a', \"one\", 1);\n", "      table.put('a', \"two\", 2);\n", "      table.put('a', \"three\", 3);\n", "      table.put('b', \"four\", 4);\n", "      return table.row('a');\n", "    }\n", "  }\n", "\n", "  public static class HashRowTests extends RowTests {\n", "    public HashRowTests() {\n", "      super(false, true, true, true, true);\n", "    }\n", "\n", "    @Override Table<Character, String, Integer> makeTable() {\n", "      return HashBasedTable.create();\n", "    }\n", "  }\n", "\n", "  public static class TreeRowTests extends RowTests {\n", "    public TreeRowTests() {\n", "      super(false, true, true, true, true);\n", "    }\n", "\n", "    @Override Table<Character, String, Integer> makeTable() {\n", "      return TreeBasedTable.create();\n", "    }\n", "  }\n", "\n", "  public static class TransposeRowTests extends RowTests {\n", "    public TransposeRowTests() {\n", "      super(false, true, true, true, false);\n", "    }\n", "\n", "    @Override Table<Character, String, Integer> makeTable() {\n", "      Table<String, Character, Integer> original = TreeBasedTable.create();\n", "      return Tables.transpose(original);\n", "    }\n", "  }\n", "\n", "  private static final Function<Integer, Integer> DIVIDE_BY_2\n", "      = new Function<Integer, Integer>() {\n", "        @Override public Integer apply(Integer input) {\n", "          return (input == null) ? null : input / 2;\n", "        }\n", "  };\n", "\n", "  public static class TransformValueRowTests extends RowTests {\n", "    public TransformValueRowTests() {\n", "      super(false, false, true, true, true);\n", "    }\n", "\n", "    @Override Table<Character, String, Integer> makeTable() {\n", "      Table<Character, String, Integer> table = HashBasedTable.create();\n", "      return Tables.transformValues(table, DIVIDE_BY_2);\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      Table<Character, String, Integer> table = HashBasedTable.create();\n", "      table.put('a', \"one\", 2);\n", "      table.put('a', \"two\", 4);\n", "      table.put('a', \"three\", 6);\n", "      table.put('b', \"four\", 8);\n", "      return Tables.transformValues(table, DIVIDE_BY_2).row('a');\n", "    }\n", "  }\n", "\n", "  public static class UnmodifiableHashRowTests extends RowTests {\n", "    public UnmodifiableHashRowTests() {\n", "      super(false, false, false, false, false);\n", "    }\n", "\n", "    @Override Table<Character, String, Integer> makeTable() {\n", "      Table<Character, String, Integer> table = HashBasedTable.create();\n", "      return Tables.unmodifiableTable(table);\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      Table<Character, String, Integer> table = HashBasedTable.create();\n", "      table.put('a', \"one\", 1);\n", "      table.put('a', \"two\", 2);\n", "      table.put('a', \"three\", 3);\n", "      table.put('b', \"four\", 4);\n", "      return Tables.unmodifiableTable(table).row('a');\n", "    }\n", "  }\n", "\n", "  public static class UnmodifiableTreeRowTests extends RowTests {\n", "    public UnmodifiableTreeRowTests() {\n", "      super(false, false, false, false, false);\n", "    }\n", "\n", "    @Override Table<Character, String, Integer> makeTable() {\n", "      RowSortedTable<Character, String, Integer> table = TreeBasedTable.create();\n", "      return Tables.unmodifiableRowSortedTable(table);\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      RowSortedTable<Character, String, Integer> table = TreeBasedTable.create();\n", "      table.put('a', \"one\", 1);\n", "      table.put('a', \"two\", 2);\n", "      table.put('a', \"three\", 3);\n", "      table.put('b', \"four\", 4);\n", "      return Tables.unmodifiableRowSortedTable(table).row('a');\n", "    }\n", "  }\n", "\n", "  private static abstract class ColumnTests extends MapTests {\n", "    ColumnTests(boolean allowsNullValues, boolean supportsPut, boolean supportsRemove,\n", "        boolean supportsClear, boolean supportsIteratorRemove) {\n", "      super(allowsNullValues, supportsPut, supportsRemove, supportsClear,\n", "          supportsIteratorRemove);\n", "    }\n", "\n", "    abstract Table<String, Character, Integer> makeTable();\n", "\n", "    @Override protected Map<String, Integer> makeEmptyMap() {\n", "      return makeTable().column('a');\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      Table<String, Character, Integer> table = makeTable();\n", "      table.put(\"one\", 'a', 1);\n", "      table.put(\"two\", 'a', 2);\n", "      table.put(\"three\", 'a', 3);\n", "      table.put(\"four\", 'b', 4);\n", "      return table.column('a');\n", "    }\n", "  }\n", "\n", "  public static class HashColumnTests extends ColumnTests {\n", "    public HashColumnTests() {\n", "      super(false, true, true, true, false);\n", "    }\n", "\n", "    @Override Table<String, Character, Integer> makeTable() {\n", "      return HashBasedTable.create();\n", "    }\n", "  }\n", "\n", "  public static class TreeColumnTests extends ColumnTests {\n", "    public TreeColumnTests() {\n", "      super(false, true, true, true, false);\n", "    }\n", "\n", "    @Override Table<String, Character, Integer> makeTable() {\n", "      return TreeBasedTable.create();\n", "    }\n", "  }\n", "\n", "  public static class TransposeColumnTests extends ColumnTests {\n", "    public TransposeColumnTests() {\n", "      super(false, true, true, true, true);\n", "    }\n", "\n", "    @Override Table<String, Character, Integer> makeTable() {\n", "      Table<Character, String, Integer> original = TreeBasedTable.create();\n", "      return Tables.transpose(original);\n", "    }\n", "  }\n", "\n", "  public static class TransformValueColumnTests extends ColumnTests {\n", "    public TransformValueColumnTests() {\n", "      super(false, false, true, true, false);\n", "    }\n", "\n", "    @Override Table<String, Character, Integer> makeTable() {\n", "      Table<String, Character, Integer> table = HashBasedTable.create();\n", "      return Tables.transformValues(table, DIVIDE_BY_2);\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      Table<String, Character, Integer> table = HashBasedTable.create();\n", "      table.put(\"one\", 'a', 1);\n", "      table.put(\"two\", 'a', 2);\n", "      table.put(\"three\", 'a', 3);\n", "      table.put(\"four\", 'b', 4);\n", "      return Tables.transformValues(table, DIVIDE_BY_2).column('a');\n", "    }\n", "  }\n", "\n", "  public static class UnmodifiableHashColumnTests extends ColumnTests {\n", "    public UnmodifiableHashColumnTests() {\n", "      super(false, false, false, false, false);\n", "    }\n", "\n", "    @Override Table<String, Character, Integer> makeTable() {\n", "      Table<String, Character, Integer> table = HashBasedTable.create();\n", "      return Tables.unmodifiableTable(table);\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      Table<String, Character, Integer> table = HashBasedTable.create();\n", "      table.put(\"one\", 'a', 1);\n", "      table.put(\"two\", 'a', 2);\n", "      table.put(\"three\", 'a', 3);\n", "      table.put(\"four\", 'b', 4);\n", "      return Tables.unmodifiableTable(table).column('a');\n", "    }\n", "  }\n", "\n", "  public static class UnmodifiableTreeColumnTests extends ColumnTests {\n", "    public UnmodifiableTreeColumnTests() {\n", "      super(false, false, false, false, false);\n", "    }\n", "\n", "    @Override Table<String, Character, Integer> makeTable() {\n", "      RowSortedTable<String, Character, Integer> table = TreeBasedTable.create();\n", "      return Tables.unmodifiableRowSortedTable(table);\n", "    }\n", "\n", "    @Override protected Map<String, Integer> makePopulatedMap() {\n", "      RowSortedTable<String, Character, Integer> table = TreeBasedTable.create();\n", "      table.put(\"one\", 'a', 1);\n", "      table.put(\"two\", 'a', 2);\n", "      table.put(\"three\", 'a', 3);\n", "      table.put(\"four\", 'b', 4);\n", "      return Tables.unmodifiableRowSortedTable(table).column('a');\n", "    }\n", "  }\n", "\n", "  private static abstract class MapMapTests\n", "      extends MapInterfaceTest<String, Map<Integer, Character>> {\n", "\n", "    MapMapTests(boolean allowsNullValues, boolean supportsRemove,\n", "        boolean supportsClear, boolean supportsIteratorRemove) {\n", "      super(false, allowsNullValues, false, supportsRemove, supportsClear,\n", "          supportsIteratorRemove);\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"cat\";\n", "    }\n", "\n", "    @Override protected Map<Integer, Character> getValueNotInPopulatedMap() {\n", "      return ImmutableMap.of();\n", "    }\n", "\n", "    /**\n", "     * The version of this test supplied by {@link MapInterfaceTest} fails for\n", "     * this particular map implementation, because {@code map.get()} returns a\n", "     * view collection that changes in the course of a call to {@code remove()}.\n", "     * Thus, the expectation doesn't hold that {@code map.remove(x)} returns the\n", "     * same value which {@code map.get(x)} did immediately beforehand.\n", "     */\n", "    @Override public void testRemove() {\n", "      final Map<String, Map<Integer, Character>> map;\n", "      final String keyToRemove;\n", "      try {\n", "        map = makePopulatedMap();\n", "      } catch (UnsupportedOperationException e) {\n", "        return;\n", "      }\n", "      keyToRemove = map.keySet().iterator().next();\n", "      if (supportsRemove) {\n", "        int initialSize = map.size();\n", "        map.get(keyToRemove);\n", "        map.remove(keyToRemove);\n", "        // This line doesn't hold - see the Javadoc comments above.\n", "        // assertEquals(expectedValue, oldValue);\n", "        assertFalse(map.containsKey(keyToRemove));\n", "        assertEquals(initialSize - 1, map.size());\n", "      } else {\n", "        try {\n", "          map.remove(keyToRemove);\n", "          fail(\"Expected UnsupportedOperationException.\");\n", "        } catch (UnsupportedOperationException e) {\n", "          // Expected.\n", "        }\n", "      }\n", "      assertInvariants(map);\n", "    }\n", "  }\n", "\n", "  private static abstract class RowMapTests extends MapMapTests {\n", "    RowMapTests(boolean allowsNullValues, boolean supportsRemove,\n", "        boolean supportsClear, boolean supportsIteratorRemove) {\n", "      super(allowsNullValues, supportsRemove, supportsClear,\n", "          supportsIteratorRemove);\n", "    }\n", "\n", "    abstract Table<String, Integer, Character> makeTable();\n", "\n", "    @Override protected Map<String, Map<Integer, Character>>\n", "        makePopulatedMap() {\n", "      Table<String, Integer, Character> table = makeTable();\n", "      populateTable(table);\n", "      return table.rowMap();\n", "    }\n", "\n", "    void populateTable(Table<String, Integer, Character> table) {\n", "      table.put(\"foo\", 1, 'a');\n", "      table.put(\"bar\", 1, 'b');\n", "      table.put(\"foo\", 3, 'c');\n", "    }\n", "\n", "    @Override protected Map<String, Map<Integer, Character>> makeEmptyMap() {\n", "      return makeTable().rowMap();\n", "    }\n", "  }\n", "\n", "  public static class HashRowMapTests extends RowMapTests {\n", "    public HashRowMapTests() {\n", "      super(false, true, true, true);\n", "    }\n", "\n", "    @Override Table<String, Integer, Character> makeTable() {\n", "      return HashBasedTable.create();\n", "    }\n", "  }\n", "\n", "  public static class TreeRowMapTests extends RowMapTests {\n", "    public TreeRowMapTests() {\n", "      super(false, true, true, true);\n", "    }\n", "\n", "    @Override Table<String, Integer, Character> makeTable() {\n", "      return TreeBasedTable.create();\n", "    }\n", "  }\n", "\n", "  public static class TreeRowMapHeadMapTests extends RowMapTests {\n", "    public TreeRowMapHeadMapTests() {\n", "      super(false, true, true, true);\n", "    }\n", "\n", "    @Override TreeBasedTable<String, Integer, Character> makeTable() {\n", "      TreeBasedTable<String, Integer, Character> table =\n", "          TreeBasedTable.create();\n", "      table.put(\"z\", 1, 'a');\n", "      return table;\n", "    }\n", "\n", "    @Override protected Map<String, Map<Integer, Character>>\n", "        makePopulatedMap() {\n", "      TreeBasedTable<String, Integer, Character> table = makeTable();\n", "      populateTable(table);\n", "      return table.rowMap().headMap(\"x\");\n", "    }\n", "\n", "    @Override protected Map<String, Map<Integer, Character>> makeEmptyMap() {\n", "      return makeTable().rowMap().headMap(\"x\");\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"z\";\n", "    }\n", "  }\n", "\n", "  public static class TreeRowMapTailMapTests extends RowMapTests {\n", "    public TreeRowMapTailMapTests() {\n", "      super(false, true, true, true);\n", "    }\n", "\n", "    @Override TreeBasedTable<String, Integer, Character> makeTable() {\n", "      TreeBasedTable<String, Integer, Character> table =\n", "          TreeBasedTable.create();\n", "      table.put(\"a\", 1, 'a');\n", "      return table;\n", "    }\n", "\n", "    @Override protected Map<String, Map<Integer, Character>>\n", "        makePopulatedMap() {\n", "      TreeBasedTable<String, Integer, Character> table = makeTable();\n", "      populateTable(table);\n", "      return table.rowMap().tailMap(\"b\");\n", "    }\n", "\n", "    @Override protected Map<String, Map<Integer, Character>> makeEmptyMap() {\n", "      return makeTable().rowMap().tailMap(\"b\");\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"a\";\n", "    }\n", "  }\n", "\n", "  public static class TreeRowMapSubMapTests extends RowMapTests {\n", "    public TreeRowMapSubMapTests() {\n", "      super(false, true, true, true);\n", "    }\n", "\n", "    @Override TreeBasedTable<String, Integer, Character> makeTable() {\n", "      TreeBasedTable<String, Integer, Character> table =\n", "          TreeBasedTable.create();\n", "      table.put(\"a\", 1, 'a');\n", "      table.put(\"z\", 1, 'a');\n", "      return table;\n", "    }\n", "\n", "    @Override protected Map<String, Map<Integer, Character>>\n", "        makePopulatedMap() {\n", "      TreeBasedTable<String, Integer, Character> table = makeTable();\n", "      populateTable(table);\n", "      return table.rowMap().subMap(\"b\", \"x\");\n", "    }\n", "\n", "    @Override protected Map<String, Map<Integer, Character>> makeEmptyMap() {\n", "      return makeTable().rowMap().subMap(\"b\", \"x\");\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"z\";\n", "    }\n", "  }\n", "\n", "  private static final Function<String, Character> FIRST_CHARACTER =\n", "      new Function<String, Character>() {\n", "        @Override\n", "        public Character apply(String input) {\n", "          return input == null ? null : input.charAt(0);\n", "        }\n", "      };\n", "\n", "  public static class TransformValueRowMapTests extends RowMapTests {\n", "    public TransformValueRowMapTests() {\n", "      super(false, true, true, true);\n", "    }\n", "\n", "    @Override Table<String, Integer, Character> makeTable() {\n", "      Table<String, Integer, String> original = HashBasedTable.create();\n", "      return Tables.transformValues(original, FIRST_CHARACTER);\n", "    }\n", "\n", "    @Override\n", "    protected Map<String, Map<Integer, Character>> makePopulatedMap() {\n", "      Table<String, Integer, String> table = HashBasedTable.create();\n", "      table.put(\"foo\", 1, \"apple\");\n", "      table.put(\"bar\", 1, \"banana\");\n", "      table.put(\"foo\", 3, \"cat\");\n", "      return Tables.transformValues(table, FIRST_CHARACTER).rowMap();\n", "    }\n", "  }\n", "\n", "  public static class UnmodifiableHashRowMapTests extends RowMapTests {\n", "    public UnmodifiableHashRowMapTests() {\n", "      super(false, false, false, false);\n", "    }\n", "\n", "    @Override Table<String, Integer, Character> makeTable() {\n", "      Table<String, Integer, Character> original = HashBasedTable.create();\n", "      return Tables.unmodifiableTable(original);\n", "    }\n", "\n", "    @Override\n", "    protected Map<String, Map<Integer, Character>> makePopulatedMap() {\n", "      Table<String, Integer, Character> table = HashBasedTable.create();\n", "      table.put(\"foo\", 1, 'a');\n", "      table.put(\"bar\", 1, 'b');\n", "      table.put(\"foo\", 3, 'c');\n", "      return Tables.unmodifiableTable(table).rowMap();\n", "    }\n", "  }\n", "\n", "  public static class UnmodifiableTreeRowMapTests extends RowMapTests {\n", "    public UnmodifiableTreeRowMapTests() {\n", "      super(false, false, false, false);\n", "    }\n", "\n", "    @Override RowSortedTable<String, Integer, Character> makeTable() {\n", "      RowSortedTable<String, Integer, Character> original = TreeBasedTable.create();\n", "      return Tables.unmodifiableRowSortedTable(original);\n", "    }\n", "\n", "    @Override\n", "    protected SortedMap<String, Map<Integer, Character>> makePopulatedMap() {\n", "      RowSortedTable<String, Integer, Character> table = TreeBasedTable.create();\n", "      table.put(\"foo\", 1, 'a');\n", "      table.put(\"bar\", 1, 'b');\n", "      table.put(\"foo\", 3, 'c');\n", "      return Tables.unmodifiableRowSortedTable(table).rowMap();\n", "    }\n", "  }\n", "\n", "  private static abstract class ColumnMapTests extends MapMapTests {\n", "    ColumnMapTests(boolean allowsNullValues, boolean supportsRemove,\n", "        boolean supportsClear, boolean supportsIteratorRemove) {\n", "      super(allowsNullValues, supportsRemove, supportsClear,\n", "          supportsIteratorRemove);\n", "    }\n", "\n", "    abstract Table<Integer, String, Character> makeTable();\n", "\n", "    @Override protected Map<String, Map<Integer, Character>>\n", "        makePopulatedMap() {\n", "      Table<Integer, String, Character> table = makeTable();\n", "      table.put(1, \"foo\", 'a');\n", "      table.put(1, \"bar\", 'b');\n", "      table.put(3, \"foo\", 'c');\n", "      return table.columnMap();\n", "    }\n", "\n", "    @Override protected Map<String, Map<Integer, Character>> makeEmptyMap() {\n", "      return makeTable().columnMap();\n", "    }\n", "  }\n", "\n", "  public static class HashColumnMapTests extends ColumnMapTests {\n", "    public HashColumnMapTests() {\n", "      super(false, true, true, false);\n", "    }\n", "\n", "    @Override Table<Integer, String, Character> makeTable() {\n", "      return HashBasedTable.create();\n", "    }\n", "  }\n", "\n", "  public static class TreeColumnMapTests extends ColumnMapTests {\n", "    public TreeColumnMapTests() {\n", "      super(false, true, true, false);\n", "    }\n", "\n", "    @Override Table<Integer, String, Character> makeTable() {\n", "      return TreeBasedTable.create();\n", "    }\n", "  }\n", "\n", "  public static class TransformValueColumnMapTests extends ColumnMapTests {\n", "    public TransformValueColumnMapTests() {\n", "      super(false, true, true, false);\n", "    }\n", "\n", "    @Override Table<Integer, String, Character> makeTable() {\n", "      Table<Integer, String, String> original = HashBasedTable.create();\n", "      return Tables.transformValues(original, FIRST_CHARACTER);\n", "    }\n", "\n", "    @Override\n", "    protected Map<String, Map<Integer, Character>> makePopulatedMap() {\n", "      Table<Integer, String, String> table = HashBasedTable.create();\n", "      table.put(1, \"foo\", \"apple\");\n", "      table.put(1, \"bar\", \"banana\");\n", "      table.put(3, \"foo\", \"cat\");\n", "      return Tables.transformValues(table, FIRST_CHARACTER).columnMap();\n", "    }\n", "  }\n", "\n", "  public static class UnmodifiableHashColumnMapTests extends ColumnMapTests {\n", "    public UnmodifiableHashColumnMapTests() {\n", "      super(false, false, false, false);\n", "    }\n", "\n", "    @Override Table<Integer, String, Character> makeTable() {\n", "      Table<Integer, String, Character> original = HashBasedTable.create();\n", "      return Tables.unmodifiableTable(original);\n", "    }\n", "\n", "    @Override\n", "    protected Map<String, Map<Integer, Character>> makePopulatedMap() {\n", "      Table<Integer, String, Character> table = HashBasedTable.create();\n", "      table.put(1, \"foo\", 'a');\n", "      table.put(1, \"bar\", 'b');\n", "      table.put(3, \"foo\", 'c');\n", "      return Tables.unmodifiableTable(table).columnMap();\n", "    }\n", "  }\n", "\n", "  public static class UnmodifiableTreeColumnMapTests extends ColumnMapTests {\n", "    public UnmodifiableTreeColumnMapTests() {\n", "      super(false, false, false, false);\n", "    }\n", "\n", "    @Override Table<Integer, String, Character> makeTable() {\n", "      RowSortedTable<Integer, String, Character> original = TreeBasedTable.create();\n", "      return Tables.unmodifiableRowSortedTable(original);\n", "    }\n", "\n", "    @Override\n", "    protected Map<String, Map<Integer, Character>> makePopulatedMap() {\n", "      RowSortedTable<Integer, String, Character> table = TreeBasedTable.create();\n", "      table.put(1, \"foo\", 'a');\n", "      table.put(1, \"bar\", 'b');\n", "      table.put(3, \"foo\", 'c');\n", "      return Tables.unmodifiableRowSortedTable(table).columnMap();\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741]}}, {"138": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/TablesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Table.Cell;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * Tests for {@link Tables}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TablesTest extends TestCase {\n", "  \n", "  public void testImmutableEntryToString() {\n", "    Cell<String, Integer, Character> entry\n", "        = Tables.immutableCell(\"foo\", 1, 'a');\n", "    assertEquals(\"(foo,1)=a\", entry.toString());\n", "    \n", "    Cell<String, Integer, Character> nullEntry\n", "        = Tables.immutableCell(null, null, null);\n", "    assertEquals(\"(null,null)=null\", nullEntry.toString());\n", "  }\n", "  \n", "  public void testEntryEquals() {\n", "    Cell<String, Integer, Character> entry\n", "        = Tables.immutableCell(\"foo\", 1, 'a');\n", "    \n", "    new EqualsTester()\n", "        .addEqualityGroup(entry, Tables.immutableCell(\"foo\", 1, 'a'))\n", "        .addEqualityGroup(Tables.immutableCell(\"bar\", 1, 'a'))\n", "        .addEqualityGroup(Tables.immutableCell(\"foo\", 2, 'a'))\n", "        .addEqualityGroup(Tables.immutableCell(\"foo\", 1, 'b'))\n", "        .addEqualityGroup(Tables.immutableCell(null, null, null))\n", "        .testEquals();\n", "  }\n", "  \n", "  public void testEntryEqualsNull() {\n", "    Cell<String, Integer, Character> entry\n", "        = Tables.immutableCell(null, null, null);\n", "    \n", "    new EqualsTester()\n", "        .addEqualityGroup(entry, Tables.immutableCell(null, null, null))\n", "        .addEqualityGroup(Tables.immutableCell(\"bar\", null, null))\n", "        .addEqualityGroup(Tables.immutableCell(null, 2, null))\n", "        .addEqualityGroup(Tables.immutableCell(null, null, 'b'))\n", "        .addEqualityGroup(Tables.immutableCell(\"foo\", 1, 'a'))\n", "        .testEquals();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69]}}, {"139": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/TablesTransformValuesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.base.Preconditions.checkArgument;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "\n", "/**\n", " * Test cases for {@link Tables#transformValues}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TablesTransformValuesTest extends AbstractTableTest {\n", "\n", "  private static final Function<String, Character> FIRST_CHARACTER\n", "    = new Function<String, Character>() {\n", "      @Override public Character apply(String input) {\n", "        return input == null ? null : input.charAt(0);\n", "      }\n", "  };\n", "\n", "  @Override protected Table<String, Integer, Character> create(\n", "      Object... data) {\n", "    Table<String, Integer, String> table = HashBasedTable.create();\n", "    checkArgument(data.length % 3 == 0);\n", "    for (int i = 0; i < data.length; i += 3) {\n", "      String value =\n", "          (data[i + 2] == null) ? null : (data[i + 2] + \"transformed\");\n", "      table.put((String) data[i], (Integer) data[i + 1], value);\n", "    }\n", "    return Tables.transformValues(table, FIRST_CHARACTER);\n", "  }\n", "\n", "  // Null support depends on the underlying table and function.\n", "\n", "  // put() and putAll() aren't supported.\n", "  @Override public void testPut() {\n", "    try {\n", "      table.put(\"foo\", 1, 'a');\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertSize(0);\n", "  }\n", "\n", "  @Override public void testPutAllTable() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Table<String, Integer, Character> other = HashBasedTable.create();\n", "    other.put(\"foo\", 1, 'd');\n", "    other.put(\"bar\", 2, 'e');\n", "    other.put(\"cat\", 2, 'f');\n", "    try {\n", "      table.putAll(other);\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "    assertEquals((Character) 'a', table.get(\"foo\", 1));\n", "    assertEquals((Character) 'b', table.get(\"bar\", 1));\n", "    assertEquals((Character) 'c', table.get(\"foo\", 3));\n", "    assertSize(3);\n", "  }\n", "\n", "  @Override public void testPutNull() {}\n", "  @Override public void testPutNullReplace() {}\n", "  @Override public void testRowClearAndPut() {}\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82]}}, {"140": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/TreeBasedTableTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SortedMapInterfaceTest;\n", "\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.Map;\n", "import java.util.Set;\n", "import java.util.SortedMap;\n", "\n", "/**\n", " * Test cases for {@link TreeBasedTable}.\n", " *\n", " * @author Jared Levy\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TreeBasedTableTest extends AbstractTableTest {\n", "\n", "  public static class TreeRowTest extends\n", "      SortedMapInterfaceTest<String, String> {\n", "    public TreeRowTest() {\n", "      super(false, false, true, true, true);\n", "    }\n", "\n", "    @Override protected SortedMap<String, String> makeEmptyMap() {\n", "      TreeBasedTable<String, String, String> table = TreeBasedTable.create();\n", "      table.put(\"a\", \"b\", \"c\");\n", "      table.put(\"c\", \"b\", \"a\");\n", "      table.put(\"a\", \"a\", \"d\");\n", "      return table.row(\"b\");\n", "    }\n", "\n", "    @Override protected SortedMap<String, String> makePopulatedMap() {\n", "      TreeBasedTable<String, String, String> table = TreeBasedTable.create();\n", "      table.put(\"a\", \"b\", \"c\");\n", "      table.put(\"c\", \"b\", \"a\");\n", "      table.put(\"b\", \"b\", \"x\");\n", "      table.put(\"b\", \"c\", \"y\");\n", "      table.put(\"b\", \"x\", \"n\");\n", "      table.put(\"a\", \"a\", \"d\");\n", "      return table.row(\"b\");\n", "    }\n", "\n", "    @Override protected String getKeyNotInPopulatedMap() {\n", "      return \"q\";\n", "    }\n", "\n", "    @Override protected String getValueNotInPopulatedMap() {\n", "      return \"p\";\n", "    }\n", "\n", "    public void testClearSubMapOfRowMap() {\n", "      TreeBasedTable<String, String, String> table = TreeBasedTable.create();\n", "      table.put(\"a\", \"b\", \"c\");\n", "      table.put(\"c\", \"b\", \"a\");\n", "      table.put(\"b\", \"b\", \"x\");\n", "      table.put(\"b\", \"c\", \"y\");\n", "      table.put(\"b\", \"x\", \"n\");\n", "      table.put(\"a\", \"a\", \"d\");\n", "      table.row(\"b\").subMap(\"c\", \"x\").clear();\n", "      assertEquals(table.row(\"b\"), ImmutableMap.of(\"b\", \"x\", \"x\", \"n\"));\n", "      table.row(\"b\").subMap(\"b\", \"y\").clear();\n", "      assertEquals(table.row(\"b\"), ImmutableMap.of());\n", "      assertFalse(table.backingMap.containsKey(\"b\"));\n", "    }\n", "  }\n", "\n", "  private TreeBasedTable<String, Integer, Character> sortedTable;\n", "\n", "  protected TreeBasedTable<String, Integer, Character> create(\n", "    Comparator<? super String> rowComparator,\n", "    Comparator<? super Integer> columnComparator,\n", "    Object... data) {\n", "    TreeBasedTable<String, Integer, Character> table =\n", "        TreeBasedTable.create(rowComparator, columnComparator);\n", "    table.put(\"foo\", 4, 'a');\n", "    table.put(\"cat\", 1, 'b');\n", "    table.clear();\n", "    populate(table, data);\n", "    return table;\n", "  }\n", "\n", "  @Override protected TreeBasedTable<String, Integer, Character> create(\n", "      Object... data) {\n", "    TreeBasedTable<String, Integer, Character> table = TreeBasedTable.create();\n", "    table.put(\"foo\", 4, 'a');\n", "    table.put(\"cat\", 1, 'b');\n", "    table.clear();\n", "    populate(table, data);\n", "    return table;\n", "  }\n", "\n", "  public void testCreateExplicitComparators() {\n", "    table = TreeBasedTable.create(\n", "        Collections.reverseOrder(), Ordering.usingToString());\n", "    table.put(\"foo\", 3, 'a');\n", "    table.put(\"foo\", 12, 'b');\n", "    table.put(\"bar\", 5, 'c');\n", "    table.put(\"cat\", 8, 'd');\n", "    assertThat(table.rowKeySet()).containsExactly(\"foo\", \"cat\", \"bar\").inOrder();\n", "    assertThat(table.row(\"foo\").keySet()).containsExactly(12, 3).inOrder();\n", "  }\n", "\n", "  public void testCreateCopy() {\n", "    TreeBasedTable<String, Integer, Character> original = TreeBasedTable.create(\n", "        Collections.reverseOrder(), Ordering.usingToString());\n", "    original.put(\"foo\", 3, 'a');\n", "    original.put(\"foo\", 12, 'b');\n", "    original.put(\"bar\", 5, 'c');\n", "    original.put(\"cat\", 8, 'd');\n", "    table = TreeBasedTable.create(original);\n", "    assertThat(table.rowKeySet()).containsExactly(\"foo\", \"cat\", \"bar\").inOrder();\n", "    assertThat(table.row(\"foo\").keySet()).containsExactly(12, 3).inOrder();\n", "    assertEquals(original, table);\n", "  }\n", "\n", "  public void testToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"{bar={1=b}, foo={1=a, 3=c}}\", table.toString());\n", "    assertEquals(\"{bar={1=b}, foo={1=a, 3=c}}\", table.rowMap().toString());\n", "  }\n", "\n", "  public void testCellSetToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"[(bar,1)=b, (foo,1)=a, (foo,3)=c]\",\n", "        table.cellSet().toString());\n", "  }\n", "\n", "  public void testRowKeySetToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"[bar, foo]\", table.rowKeySet().toString());\n", "  }\n", "\n", "  public void testValuesToString_ordered() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertEquals(\"[b, a, c]\", table.values().toString());\n", "  }\n", "\n", "  public void testRowComparator() {\n", "    sortedTable = TreeBasedTable.create();\n", "    assertSame(Ordering.natural(), sortedTable.rowComparator());\n", "\n", "    sortedTable = TreeBasedTable.create(\n", "        Collections.reverseOrder(), Ordering.usingToString());\n", "    assertSame(Collections.reverseOrder(), sortedTable.rowComparator());\n", "  }\n", "\n", "  public void testColumnComparator() {\n", "    sortedTable = TreeBasedTable.create();\n", "    assertSame(Ordering.natural(), sortedTable.columnComparator());\n", "\n", "    sortedTable = TreeBasedTable.create(\n", "        Collections.reverseOrder(), Ordering.usingToString());\n", "    assertSame(Ordering.usingToString(), sortedTable.columnComparator());\n", "  }\n", "\n", "  public void testRowKeySetComparator() {\n", "    sortedTable = TreeBasedTable.create();\n", "    assertSame(Ordering.natural(),\n", "        sortedTable.rowKeySet().comparator());\n", "\n", "    sortedTable = TreeBasedTable.create(\n", "        Collections.reverseOrder(), Ordering.usingToString());\n", "    assertSame(Collections.reverseOrder(),\n", "        sortedTable.rowKeySet().comparator());\n", "  }\n", "\n", "  public void testRowKeySetFirst() {\n", "    sortedTable = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertSame(\"bar\", sortedTable.rowKeySet().first());\n", "  }\n", "\n", "  public void testRowKeySetLast() {\n", "    sortedTable = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertSame(\"foo\", sortedTable.rowKeySet().last());\n", "  }\n", "\n", "  public void testRowKeySetHeadSet() {\n", "    sortedTable = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Set<String> set = sortedTable.rowKeySet().headSet(\"cat\");\n", "    assertEquals(Collections.singleton(\"bar\"), set);\n", "    set.clear();\n", "    assertTrue(set.isEmpty());\n", "    assertEquals(Collections.singleton(\"foo\"), sortedTable.rowKeySet());\n", "  }\n", "\n", "  public void testRowKeySetTailSet() {\n", "    sortedTable = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Set<String> set = sortedTable.rowKeySet().tailSet(\"cat\");\n", "    assertEquals(Collections.singleton(\"foo\"), set);\n", "    set.clear();\n", "    assertTrue(set.isEmpty());\n", "    assertEquals(Collections.singleton(\"bar\"), sortedTable.rowKeySet());\n", "  }\n", "\n", "  public void testRowKeySetSubSet() {\n", "    sortedTable = create(\n", "        \"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c', \"dog\", 2, 'd');\n", "    Set<String> set = sortedTable.rowKeySet().subSet(\"cat\", \"egg\");\n", "    assertEquals(Collections.singleton(\"dog\"), set);\n", "    set.clear();\n", "    assertTrue(set.isEmpty());\n", "    assertEquals(ImmutableSet.of(\"bar\", \"foo\"), sortedTable.rowKeySet());\n", "  }\n", "\n", "  public void testRowMapComparator() {\n", "    sortedTable = TreeBasedTable.create();\n", "    assertSame(Ordering.natural(), sortedTable.rowMap().comparator());\n", "\n", "    sortedTable = TreeBasedTable.create(\n", "        Collections.reverseOrder(), Ordering.usingToString());\n", "    assertSame(Collections.reverseOrder(), sortedTable.rowMap().comparator());\n", "  }\n", "\n", "  public void testRowMapFirstKey() {\n", "    sortedTable = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertSame(\"bar\", sortedTable.rowMap().firstKey());\n", "  }\n", "\n", "  public void testRowMapLastKey() {\n", "    sortedTable = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    assertSame(\"foo\", sortedTable.rowMap().lastKey());\n", "  }\n", "\n", "  public void testRowKeyMapHeadMap() {\n", "    sortedTable = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Map<String, Map<Integer, Character>> map\n", "        = sortedTable.rowMap().headMap(\"cat\");\n", "    assertEquals(1, map.size());\n", "    assertEquals(ImmutableMap.of(1, 'b'), map.get(\"bar\"));\n", "    map.clear();\n", "    assertTrue(map.isEmpty());\n", "    assertEquals(Collections.singleton(\"foo\"), sortedTable.rowKeySet());\n", "  }\n", "\n", "  public void testRowKeyMapTailMap() {\n", "    sortedTable = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    Map<String, Map<Integer, Character>> map\n", "        = sortedTable.rowMap().tailMap(\"cat\");\n", "    assertEquals(1, map.size());\n", "    assertEquals(ImmutableMap.of(1, 'a', 3, 'c'), map.get(\"foo\"));\n", "    map.clear();\n", "    assertTrue(map.isEmpty());\n", "    assertEquals(Collections.singleton(\"bar\"), sortedTable.rowKeySet());\n", "  }\n", "\n", "  public void testRowKeyMapSubMap() {\n", "    sortedTable = create(\n", "        \"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c', \"dog\", 2, 'd');\n", "    Map<String, Map<Integer, Character>> map\n", "        = sortedTable.rowMap().subMap(\"cat\", \"egg\");\n", "    assertEquals(ImmutableMap.of(2, 'd'), map.get(\"dog\"));\n", "    map.clear();\n", "    assertTrue(map.isEmpty());\n", "    assertEquals(ImmutableSet.of(\"bar\", \"foo\"), sortedTable.rowKeySet());\n", "  }\n", "\n", "  public void testRowMapValuesAreSorted() {\n", "    sortedTable = create(\n", "        \"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c', \"dog\", 2, 'd');\n", "    assertTrue(sortedTable.rowMap().get(\"foo\") instanceof SortedMap);\n", "  }\n", "\n", "  public void testColumnKeySet_isSorted() {\n", "    table = create(\"a\", 2,  'X',\n", "                   \"a\", 2,  'X',\n", "                   \"b\", 3,  'X',\n", "                   \"b\", 2,  'X',\n", "                   \"c\", 10, 'X',\n", "                   \"c\", 10, 'X',\n", "                   \"c\", 20, 'X',\n", "                   \"d\", 15, 'X',\n", "                   \"d\", 20, 'X',\n", "                   \"d\", 1,  'X',\n", "                   \"e\", 5,  'X'\n", "                  );\n", "    assertEquals(\"[1, 2, 3, 5, 10, 15, 20]\", table.columnKeySet().toString());\n", "  }\n", "\n", "  public void testColumnKeySet_isSortedWithRealComparator() {\n", "    table = create(String.CASE_INSENSITIVE_ORDER,\n", "                   Ordering.natural().reverse(),\n", "                   \"a\", 2,  'X',\n", "                   \"a\", 2,  'X',\n", "                   \"b\", 3,  'X',\n", "                   \"b\", 2,  'X',\n", "                   \"c\", 10, 'X',\n", "                   \"c\", 10, 'X',\n", "                   \"c\", 20, 'X',\n", "                   \"d\", 15, 'X',\n", "                   \"d\", 20, 'X',\n", "                   \"d\", 1,  'X',\n", "                   \"e\", 5,  'X'\n", "                  );\n", "    assertEquals(\"[20, 15, 10, 5, 3, 2, 1]\", table.columnKeySet().toString());\n", "  }\n", "\n", "  public void testColumnKeySet_empty() {\n", "    table = create();\n", "    assertEquals(\"[]\", table.columnKeySet().toString());\n", "  }\n", "\n", "  public void testColumnKeySet_oneRow() {\n", "    table = create(\"a\", 2,  'X',\n", "                   \"a\", 1,  'X'\n", "                  );\n", "    assertEquals(\"[1, 2]\", table.columnKeySet().toString());\n", "  }\n", "\n", "  public void testColumnKeySet_oneColumn() {\n", "    table = create(\"a\", 1,  'X',\n", "                   \"b\", 1,  'X'\n", "                  );\n", "    assertEquals(\"[1]\", table.columnKeySet().toString());\n", "  }\n", "\n", "  public void testColumnKeySet_oneEntry() {\n", "    table = create(\"a\", 1,  'X');\n", "    assertEquals(\"[1]\", table.columnKeySet().toString());\n", "  }\n", "\n", "  public void testRowEntrySetContains() {\n", "    table =\n", "        sortedTable =\n", "            create(\"a\", 2, 'X', \"a\", 2, 'X', \"b\", 3, 'X', \"b\", 2, 'X', \"c\", 10,\n", "                'X', \"c\", 10, 'X', \"c\", 20, 'X', \"d\", 15, 'X', \"d\", 20, 'X',\n", "                \"d\", 1, 'X', \"e\", 5, 'X');\n", "    SortedMap<Integer, Character> row = sortedTable.row(\"c\");\n", "    Set<Map.Entry<Integer, Character>> entrySet = row.entrySet();\n", "    assertTrue(entrySet.contains(Maps.immutableEntry(10, 'X')));\n", "    assertTrue(entrySet.contains(Maps.immutableEntry(20, 'X')));\n", "    assertFalse(entrySet.contains(Maps.immutableEntry(15, 'X')));\n", "    entrySet = row.tailMap(15).entrySet();\n", "    assertFalse(entrySet.contains(Maps.immutableEntry(10, 'X')));\n", "    assertTrue(entrySet.contains(Maps.immutableEntry(20, 'X')));\n", "    assertFalse(entrySet.contains(Maps.immutableEntry(15, 'X')));\n", "  }\n", "\n", "  public void testRowEntrySetRemove() {\n", "    table =\n", "        sortedTable =\n", "            create(\"a\", 2, 'X', \"a\", 2, 'X', \"b\", 3, 'X', \"b\", 2, 'X', \"c\", 10,\n", "                'X', \"c\", 10, 'X', \"c\", 20, 'X', \"d\", 15, 'X', \"d\", 20, 'X',\n", "                \"d\", 1, 'X', \"e\", 5, 'X');\n", "    SortedMap<Integer, Character> row = sortedTable.row(\"c\");\n", "    Set<Map.Entry<Integer, Character>> entrySet = row.tailMap(15).entrySet();\n", "    assertFalse(entrySet.remove(Maps.immutableEntry(10, 'X')));\n", "    assertTrue(entrySet.remove(Maps.immutableEntry(20, 'X')));\n", "    assertFalse(entrySet.remove(Maps.immutableEntry(15, 'X')));\n", "    entrySet = row.entrySet();\n", "    assertTrue(entrySet.remove(Maps.immutableEntry(10, 'X')));\n", "    assertFalse(entrySet.remove(Maps.immutableEntry(20, 'X')));\n", "    assertFalse(entrySet.remove(Maps.immutableEntry(15, 'X')));\n", "  }\n", "\n", "  public void testRowSize() {\n", "    table =\n", "        sortedTable =\n", "            create(\"a\", 2, 'X', \"a\", 2, 'X', \"b\", 3, 'X', \"b\", 2, 'X', \"c\", 10,\n", "                'X', \"c\", 10, 'X', \"c\", 20, 'X', \"d\", 15, 'X', \"d\", 20, 'X',\n", "                \"d\", 1, 'X', \"e\", 5, 'X');\n", "    SortedMap<Integer, Character> row = sortedTable.row(\"c\");\n", "    assertEquals(row.size(), 2);\n", "    assertEquals(row.tailMap(15).size(), 1);\n", "  }\n", "\n", "  public void testSubRowClearAndPut() {\n", "    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\n", "    SortedMap<Integer, Character> row = (SortedMap<Integer, Character>) table.row(\"foo\");\n", "    SortedMap<Integer, Character> subRow = row.tailMap(2);\n", "    assertEquals(ImmutableMap.of(1, 'a', 3, 'c'), row);\n", "    assertEquals(ImmutableMap.of(3, 'c'), subRow);\n", "    table.remove(\"foo\", 3);\n", "    assertEquals(ImmutableMap.of(1, 'a'), row);\n", "    assertEquals(ImmutableMap.of(), subRow);\n", "    table.remove(\"foo\", 1);\n", "    assertEquals(ImmutableMap.of(), row);\n", "    assertEquals(ImmutableMap.of(), subRow);\n", "    table.put(\"foo\", 2, 'b');\n", "    assertEquals(ImmutableMap.of(2, 'b'), row);\n", "    assertEquals(ImmutableMap.of(2, 'b'), subRow);\n", "    row.clear();\n", "    assertEquals(ImmutableMap.of(), row);\n", "    assertEquals(ImmutableMap.of(), subRow);\n", "    table.put(\"foo\", 5, 'x');\n", "    assertEquals(ImmutableMap.of(5, 'x'), row);\n", "    assertEquals(ImmutableMap.of(5, 'x'), subRow);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410]}}, {"141": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/TreeMultimapExplicitTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.SortedSet;\n", "\n", "/**\n", " * Unit tests for {@code TreeMultimap} with explicit comparators.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TreeMultimapExplicitTest extends TestCase {\n", "\n", "  /**\n", "   * Compare strings lengths, and if the lengths are equal compare the strings.\n", "   * A {@code null} is less than any non-null value.\n", "   */\n", "  private enum StringLength implements Comparator<String> {\n", "    COMPARATOR;\n", "\n", "    @Override\n", "    public int compare(String first, String second) {\n", "      if (first == second) {\n", "        return 0;\n", "      } else if (first == null) {\n", "        return -1;\n", "      } else if (second == null) {\n", "        return 1;\n", "      } else if (first.length() != second.length()) {\n", "        return first.length() - second.length();\n", "      } else {\n", "        return first.compareTo(second);\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Decreasing integer values. A {@code null} comes before any non-null value.\n", "   */\n", "  private static final Comparator<Integer> DECREASING_INT_COMPARATOR =\n", "      Ordering.<Integer>natural().reverse().nullsFirst();\n", "\n", "  private SetMultimap<String, Integer> create() {\n", "    return TreeMultimap.create(\n", "        StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\n", "  }\n", "\n", "  /**\n", "   * Create and populate a {@code TreeMultimap} with explicit comparators.\n", "   */\n", "  private TreeMultimap<String, Integer> createPopulate() {\n", "    TreeMultimap<String, Integer> multimap = TreeMultimap.create(\n", "        StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\n", "    multimap.put(\"google\", 2);\n", "    multimap.put(\"google\", 6);\n", "    multimap.put(null, 3);\n", "    multimap.put(null, 1);\n", "    multimap.put(null, 7);\n", "    multimap.put(\"tree\", 0);\n", "    multimap.put(\"tree\", null);\n", "    return multimap;\n", "  }\n", "\n", "  /**\n", "   * Test that a TreeMultimap created from another uses the natural ordering.\n", "   */\n", "  public void testMultimapCreateFromTreeMultimap() {\n", "    TreeMultimap<String, Integer> tree = TreeMultimap.create(\n", "        StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\n", "    tree.put(\"google\", 2);\n", "    tree.put(\"google\", 6);\n", "    tree.put(\"tree\", 0);\n", "    tree.put(\"tree\", 3);\n", "    assertThat(tree.keySet()).containsExactly(\"tree\", \"google\").inOrder();\n", "    assertThat(tree.get(\"google\")).containsExactly(6, 2).inOrder();\n", "\n", "    TreeMultimap<String, Integer> copy = TreeMultimap.create(tree);\n", "    assertEquals(tree, copy);\n", "    assertThat(copy.keySet()).containsExactly(\"google\", \"tree\").inOrder();\n", "    assertThat(copy.get(\"google\")).containsExactly(2, 6).inOrder();\n", "    assertEquals(Ordering.natural(), copy.keyComparator());\n", "    assertEquals(Ordering.natural(), copy.valueComparator());\n", "    assertEquals(Ordering.natural(), copy.get(\"google\").comparator());\n", "  }\n", "\n", "  public void testToString() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 3);\n", "    multimap.put(\"bar\", 1);\n", "    multimap.putAll(\"foo\", Arrays.asList(-1, 2, 4));\n", "    multimap.putAll(\"bar\", Arrays.asList(2, 3));\n", "    multimap.put(\"foo\", 1);\n", "    assertEquals(\"{bar=[3, 2, 1], foo=[4, 3, 2, 1, -1]}\",\n", "        multimap.toString());\n", "  }\n", "\n", "  public void testGetComparator() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertEquals(StringLength.COMPARATOR, multimap.keyComparator());\n", "    assertEquals(DECREASING_INT_COMPARATOR, multimap.valueComparator());\n", "  }\n", "\n", "  public void testOrderedGet() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertThat(multimap.get(null)).containsExactly(7, 3, 1).inOrder();\n", "    assertThat(multimap.get(\"google\")).containsExactly(6, 2).inOrder();\n", "    assertThat(multimap.get(\"tree\")).containsExactly(null, 0).inOrder();\n", "  }\n", "\n", "  public void testOrderedKeySet() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertThat(multimap.keySet()).containsExactly(null, \"tree\", \"google\").inOrder();\n", "  }\n", "\n", "  public void testOrderedAsMapEntries() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    Iterator<Map.Entry<String, Collection<Integer>>> iterator =\n", "        multimap.asMap().entrySet().iterator();\n", "    Map.Entry<String, Collection<Integer>> entry = iterator.next();\n", "    assertEquals(null, entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(7, 3, 1);\n", "    entry = iterator.next();\n", "    assertEquals(\"tree\", entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(null, 0);\n", "    entry = iterator.next();\n", "    assertEquals(\"google\", entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(6, 2);\n", "  }\n", "\n", "  public void testOrderedEntries() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertThat(multimap.entries()).containsExactly(\n", "        Maps.immutableEntry((String) null, 7),\n", "        Maps.immutableEntry((String) null, 3),\n", "        Maps.immutableEntry((String) null, 1),\n", "        Maps.immutableEntry(\"tree\", (Integer) null),\n", "        Maps.immutableEntry(\"tree\", 0),\n", "        Maps.immutableEntry(\"google\", 6), \n", "        Maps.immutableEntry(\"google\", 2)).inOrder();\n", "  }\n", "\n", "  public void testOrderedValues() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertThat(multimap.values()).containsExactly(7, 3, 1, null, 0, 6, 2).inOrder();\n", "  }\n", "\n", "  public void testComparator() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertEquals(DECREASING_INT_COMPARATOR, multimap.get(\"foo\").comparator());\n", "    assertEquals(DECREASING_INT_COMPARATOR,\n", "        multimap.get(\"missing\").comparator());\n", "  }\n", "\n", "  public void testMultimapComparators() {\n", "    Multimap<String, Integer> multimap = create();\n", "    multimap.put(\"foo\", 3);\n", "    multimap.put(\"bar\", 1);\n", "    multimap.putAll(\"foo\", Arrays.asList(-1, 2, 4));\n", "    multimap.putAll(\"bar\", Arrays.asList(2, 3));\n", "    multimap.put(\"foo\", 1);\n", "    TreeMultimap<String, Integer> copy =\n", "        TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\n", "    copy.putAll(multimap);\n", "    assertEquals(multimap, copy);\n", "    assertEquals(StringLength.COMPARATOR, copy.keyComparator());\n", "    assertEquals(DECREASING_INT_COMPARATOR, copy.valueComparator());\n", "  }\n", "\n", "  public void testSortedKeySet() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    SortedSet<String> keySet = multimap.keySet();\n", "\n", "    assertEquals(null, keySet.first());\n", "    assertEquals(\"google\", keySet.last());\n", "    assertEquals(StringLength.COMPARATOR, keySet.comparator());\n", "    assertEquals(Sets.newHashSet(null, \"tree\"), keySet.headSet(\"yahoo\"));\n", "    assertEquals(Sets.newHashSet(\"google\"), keySet.tailSet(\"yahoo\"));\n", "    assertEquals(Sets.newHashSet(\"tree\"), keySet.subSet(\"ask\", \"yahoo\"));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207]}}, {"142": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/TreeMultimapNaturalTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.Set;\n", "import java.util.SortedMap;\n", "\n", "/**\n", " * Unit tests for {@code TreeMultimap} with natural ordering.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TreeMultimapNaturalTest extends TestCase {\n", "\n", "  protected SetMultimap<String, Integer> create() {\n", "    return TreeMultimap.create();\n", "  }\n", "\n", "  /**\n", "   * Create and populate a {@code TreeMultimap} with the natural ordering of\n", "   * keys and values.\n", "   */\n", "  private TreeMultimap<String, Integer> createPopulate() {\n", "    TreeMultimap<String, Integer> multimap = TreeMultimap.create();\n", "    multimap.put(\"google\", 2);\n", "    multimap.put(\"google\", 6);\n", "    multimap.put(\"foo\", 3);\n", "    multimap.put(\"foo\", 1);\n", "    multimap.put(\"foo\", 7);\n", "    multimap.put(\"tree\", 4);\n", "    multimap.put(\"tree\", 0);\n", "    return multimap;\n", "  }\n", "\n", "  public void testToString() {\n", "    SetMultimap<String, Integer> multimap = create();\n", "    multimap.putAll(\"bar\", Arrays.asList(3, 1, 2));\n", "    multimap.putAll(\"foo\", Arrays.asList(2, 3, 1, -1, 4));\n", "    assertEquals(\"{bar=[1, 2, 3], foo=[-1, 1, 2, 3, 4]}\",\n", "        multimap.toString());\n", "  }\n", "\n", "  public void testOrderedGet() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertThat(multimap.get(\"foo\")).containsExactly(1, 3, 7).inOrder();\n", "    assertThat(multimap.get(\"google\")).containsExactly(2, 6).inOrder();\n", "    assertThat(multimap.get(\"tree\")).containsExactly(0, 4).inOrder();\n", "  }\n", "\n", "  public void testOrderedKeySet() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertThat(multimap.keySet()).containsExactly(\"foo\", \"google\", \"tree\").inOrder();\n", "  }\n", "\n", "  public void testOrderedAsMapEntries() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    Iterator<Map.Entry<String, Collection<Integer>>> iterator =\n", "        multimap.asMap().entrySet().iterator();\n", "    Map.Entry<String, Collection<Integer>> entry = iterator.next();\n", "    assertEquals(\"foo\", entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(1, 3, 7);\n", "    entry = iterator.next();\n", "    assertEquals(\"google\", entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(2, 6);\n", "    entry = iterator.next();\n", "    assertEquals(\"tree\", entry.getKey());\n", "    assertThat(entry.getValue()).containsExactly(0, 4);\n", "  }\n", "\n", "  public void testOrderedEntries() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertThat(multimap.entries()).containsExactly(\n", "        Maps.immutableEntry(\"foo\", 1),\n", "        Maps.immutableEntry(\"foo\", 3),\n", "        Maps.immutableEntry(\"foo\", 7),\n", "        Maps.immutableEntry(\"google\", 2),\n", "        Maps.immutableEntry(\"google\", 6),\n", "        Maps.immutableEntry(\"tree\", 0),\n", "        Maps.immutableEntry(\"tree\", 4)).inOrder();\n", "  }\n", "\n", "  public void testOrderedValues() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    assertThat(multimap.values()).containsExactly(\n", "        1, 3, 7, 2, 6, 0, 4).inOrder();\n", "  }\n", "\n", "  public void testMultimapConstructor() {\n", "    SetMultimap<String, Integer> multimap = create();\n", "    multimap.putAll(\"bar\", Arrays.asList(3, 1, 2));\n", "    multimap.putAll(\"foo\", Arrays.asList(2, 3, 1, -1, 4));\n", "    TreeMultimap<String, Integer> copy = TreeMultimap.create(multimap);\n", "    assertEquals(multimap, copy);\n", "  }\n", "\n", "  private static final Comparator<Double> KEY_COMPARATOR =\n", "      Ordering.natural();\n", "\n", "  private static final Comparator<Double> VALUE_COMPARATOR =\n", "      Ordering.natural().reverse().nullsFirst();\n", "\n", "  /**\n", "   * Test that creating one TreeMultimap from another does not copy the\n", "   * comparators from the source TreeMultimap.\n", "   */\n", "  public void testCreateFromTreeMultimap() {\n", "    Multimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);\n", "    tree.put(1.0, 2.0);\n", "    tree.put(2.0, 3.0);\n", "    tree.put(3.0, 4.0);\n", "    tree.put(4.0, 5.0);\n", "\n", "    TreeMultimap<Double, Double> copyFromTree = TreeMultimap.create(tree);\n", "    assertEquals(tree, copyFromTree);\n", "    assertSame(Ordering.natural(), copyFromTree.keyComparator());\n", "    assertSame(Ordering.natural(), copyFromTree.valueComparator());\n", "    assertSame(Ordering.natural(), copyFromTree.get(1.0).comparator());\n", "  }\n", "\n", "  /**\n", "   * Test that creating one TreeMultimap from a non-TreeMultimap\n", "   * results in natural ordering.\n", "   */\n", "  public void testCreateFromHashMultimap() {\n", "    Multimap<Double, Double> hash = HashMultimap.create();\n", "    hash.put(1.0, 2.0);\n", "    hash.put(2.0, 3.0);\n", "    hash.put(3.0, 4.0);\n", "    hash.put(4.0, 5.0);\n", "\n", "    TreeMultimap<Double, Double> copyFromHash = TreeMultimap.create(hash);\n", "    assertEquals(hash, copyFromHash);\n", "    assertEquals(Ordering.natural(), copyFromHash.keyComparator());\n", "    assertEquals(Ordering.natural(), copyFromHash.valueComparator());\n", "  }\n", "\n", "  /**\n", "   * Test that creating one TreeMultimap from a SortedSetMultimap uses natural\n", "   * ordering.\n", "   */\n", "  public void testCreateFromSortedSetMultimap() {\n", "    SortedSetMultimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);\n", "    tree.put(1.0, 2.0);\n", "    tree.put(2.0, 3.0);\n", "    tree.put(3.0, 4.0);\n", "    tree.put(4.0, 5.0);\n", "\n", "    SortedSetMultimap<Double, Double> sorted = Multimaps.unmodifiableSortedSetMultimap(tree);\n", "    TreeMultimap<Double, Double> copyFromSorted = TreeMultimap.create(sorted);\n", "    assertEquals(tree, copyFromSorted);\n", "    assertSame(Ordering.natural(), copyFromSorted.keyComparator());\n", "    assertSame(Ordering.natural(), copyFromSorted.valueComparator());\n", "    assertSame(Ordering.natural(), copyFromSorted.get(1.0).comparator());\n", "  }\n", "\n", "  public void testComparators() {\n", "    TreeMultimap<String, Integer> multimap = TreeMultimap.create();\n", "    assertEquals(Ordering.natural(), multimap.keyComparator());\n", "    assertEquals(Ordering.natural(), multimap.valueComparator());\n", "  }\n", "\n", "  public void testTreeMultimapAsMapSorted() {\n", "    TreeMultimap<String, Integer> multimap = createPopulate();\n", "    SortedMap<String, Collection<Integer>> asMap = multimap.asMap();\n", "    assertEquals(Ordering.natural(), asMap.comparator());\n", "    assertEquals(\"foo\", asMap.firstKey());\n", "    assertEquals(\"tree\", asMap.lastKey());\n", "    Set<Integer> fooValues = ImmutableSet.of(1, 3, 7);\n", "    Set<Integer> googleValues = ImmutableSet.of(2, 6);\n", "    Set<Integer> treeValues = ImmutableSet.of(4, 0);\n", "    assertEquals(ImmutableMap.of(\"google\", googleValues, \"tree\", treeValues),\n", "        asMap.tailMap(\"g\"));\n", "    assertEquals(ImmutableMap.of(\"google\", googleValues, \"foo\", fooValues),\n", "        asMap.headMap(\"h\"));\n", "    assertEquals(ImmutableMap.of(\"google\", googleValues),\n", "        asMap.subMap(\"g\", \"h\"));\n", "  }\n", "\n", "  public void testTailSetClear() {\n", "    TreeMultimap<String, Integer> multimap = TreeMultimap.create();\n", "    multimap.put(\"a\", 1);\n", "    multimap.put(\"a\", 11);\n", "    multimap.put(\"b\", 2);\n", "    multimap.put(\"c\", 3);\n", "    multimap.put(\"d\", 4);\n", "    multimap.put(\"e\", 5);\n", "    multimap.put(\"e\", 55);\n", "\n", "    multimap.keySet().tailSet(\"d\").clear();\n", "    assertEquals(ImmutableSet.of(\"a\", \"b\", \"c\"), multimap.keySet());\n", "    assertEquals(4, multimap.size());\n", "    assertEquals(4, multimap.values().size());\n", "    assertEquals(4, multimap.keys().size());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222]}}, {"143": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/TreeMultisetTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.collect.BoundType.CLOSED;\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.SortedSet;\n", "\n", "/**\n", " * Unit test for {@link TreeMultiset}.\n", " *\n", " * @author Neal Kanodia\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TreeMultisetTest extends TestCase {\n", "\n", "  public void testCreate() {\n", "    TreeMultiset<String> multiset = TreeMultiset.create();\n", "    multiset.add(\"foo\", 2);\n", "    multiset.add(\"bar\");\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "    assertEquals(Ordering.natural(), multiset.comparator());\n", "    assertEquals(\"[bar, foo x 2]\", multiset.toString());\n", "  }\n", "\n", "  public void testCreateWithComparator() {\n", "    Multiset<String> multiset = TreeMultiset.create(Collections.reverseOrder());\n", "    multiset.add(\"foo\", 2);\n", "    multiset.add(\"bar\");\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "    assertEquals(\"[foo x 2, bar]\", multiset.toString());\n", "  }\n", "\n", "  public void testCreateFromIterable() {\n", "    Multiset<String> multiset\n", "        = TreeMultiset.create(Arrays.asList(\"foo\", \"bar\", \"foo\"));\n", "    assertEquals(3, multiset.size());\n", "    assertEquals(2, multiset.count(\"foo\"));\n", "    assertEquals(\"[bar, foo x 2]\", multiset.toString());\n", "  }\n", "\n", "  public void testToString() {\n", "    Multiset<String> ms = TreeMultiset.create();\n", "    ms.add(\"a\", 3);\n", "    ms.add(\"c\", 1);\n", "    ms.add(\"b\", 2);\n", "\n", "    assertEquals(\"[a x 3, b x 2, c]\", ms.toString());\n", "  }\n", "\n", "  public void testElementSetSortedSetMethods() {\n", "    TreeMultiset<String> ms = TreeMultiset.create();\n", "    ms.add(\"c\", 1);\n", "    ms.add(\"a\", 3);\n", "    ms.add(\"b\", 2);\n", "    SortedSet<String> elementSet = ms.elementSet();\n", "\n", "    assertEquals(\"a\", elementSet.first());\n", "    assertEquals(\"c\", elementSet.last());\n", "    assertEquals(Ordering.natural(), elementSet.comparator());\n", "\n", "    assertThat(elementSet.headSet(\"b\")).containsExactly(\"a\");\n", "    assertThat(elementSet.tailSet(\"b\")).containsExactly(\"b\", \"c\").inOrder();\n", "    assertThat(elementSet.subSet(\"a\", \"c\")).containsExactly(\"a\", \"b\").inOrder();\n", "  }\n", "\n", "  public void testElementSetSubsetRemove() {\n", "    TreeMultiset<String> ms = TreeMultiset.create();\n", "    ms.add(\"a\", 1);\n", "    ms.add(\"b\", 3);\n", "    ms.add(\"c\", 2);\n", "    ms.add(\"d\", 1);\n", "    ms.add(\"e\", 3);\n", "    ms.add(\"f\", 2);\n", "\n", "    SortedSet<String> elementSet = ms.elementSet();\n", "    assertThat(elementSet).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "    SortedSet<String> subset = elementSet.subSet(\"b\", \"f\");\n", "    assertThat(subset).containsExactly(\"b\", \"c\", \"d\", \"e\").inOrder();\n", "\n", "    assertTrue(subset.remove(\"c\"));\n", "    assertThat(elementSet).containsExactly(\"a\", \"b\", \"d\", \"e\", \"f\").inOrder();\n", "    assertThat(subset).containsExactly(\"b\", \"d\", \"e\").inOrder();\n", "    assertEquals(10, ms.size());\n", "\n", "    assertFalse(subset.remove(\"a\"));\n", "    assertThat(elementSet).containsExactly(\"a\", \"b\", \"d\", \"e\", \"f\").inOrder();\n", "    assertThat(subset).containsExactly(\"b\", \"d\", \"e\").inOrder();\n", "    assertEquals(10, ms.size());\n", "  }\n", "\n", "  public void testElementSetSubsetRemoveAll() {\n", "    TreeMultiset<String> ms = TreeMultiset.create();\n", "    ms.add(\"a\", 1);\n", "    ms.add(\"b\", 3);\n", "    ms.add(\"c\", 2);\n", "    ms.add(\"d\", 1);\n", "    ms.add(\"e\", 3);\n", "    ms.add(\"f\", 2);\n", "\n", "    SortedSet<String> elementSet = ms.elementSet();\n", "    assertThat(elementSet).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "    SortedSet<String> subset = elementSet.subSet(\"b\", \"f\");\n", "    assertThat(subset).containsExactly(\"b\", \"c\", \"d\", \"e\").inOrder();\n", "\n", "    assertTrue(subset.removeAll(Arrays.asList(\"a\", \"c\")));\n", "    assertThat(elementSet).containsExactly(\"a\", \"b\", \"d\", \"e\", \"f\").inOrder();\n", "    assertThat(subset).containsExactly(\"b\", \"d\", \"e\").inOrder();\n", "    assertEquals(10, ms.size());\n", "  }\n", "\n", "  public void testElementSetSubsetRetainAll() {\n", "    TreeMultiset<String> ms = TreeMultiset.create();\n", "    ms.add(\"a\", 1);\n", "    ms.add(\"b\", 3);\n", "    ms.add(\"c\", 2);\n", "    ms.add(\"d\", 1);\n", "    ms.add(\"e\", 3);\n", "    ms.add(\"f\", 2);\n", "\n", "    SortedSet<String> elementSet = ms.elementSet();\n", "    assertThat(elementSet).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "    SortedSet<String> subset = elementSet.subSet(\"b\", \"f\");\n", "    assertThat(subset).containsExactly(\"b\", \"c\", \"d\", \"e\").inOrder();\n", "\n", "    assertTrue(subset.retainAll(Arrays.asList(\"a\", \"c\")));\n", "    assertThat(elementSet).containsExactly(\"a\", \"c\", \"f\").inOrder();\n", "    assertThat(subset).containsExactly(\"c\");\n", "    assertEquals(5, ms.size());\n", "  }\n", "\n", "  public void testElementSetSubsetClear() {\n", "    TreeMultiset<String> ms = TreeMultiset.create();\n", "    ms.add(\"a\", 1);\n", "    ms.add(\"b\", 3);\n", "    ms.add(\"c\", 2);\n", "    ms.add(\"d\", 1);\n", "    ms.add(\"e\", 3);\n", "    ms.add(\"f\", 2);\n", "\n", "    SortedSet<String> elementSet = ms.elementSet();\n", "    assertThat(elementSet).containsExactly(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\").inOrder();\n", "    SortedSet<String> subset = elementSet.subSet(\"b\", \"f\");\n", "    assertThat(subset).containsExactly(\"b\", \"c\", \"d\", \"e\").inOrder();\n", "\n", "    subset.clear();\n", "    assertThat(elementSet).containsExactly(\"a\", \"f\").inOrder();\n", "    assertThat(subset).isEmpty();\n", "    assertEquals(3, ms.size());\n", "  }\n", "\n", "  public void testCustomComparator() throws Exception {\n", "    Comparator<String> comparator = new Comparator<String>() {\n", "      @Override\n", "      public int compare(String o1, String o2) {\n", "        return o2.compareTo(o1);\n", "      }\n", "    };\n", "    TreeMultiset<String> ms = TreeMultiset.create(comparator);\n", "\n", "    ms.add(\"b\");\n", "    ms.add(\"c\");\n", "    ms.add(\"a\");\n", "    ms.add(\"b\");\n", "    ms.add(\"d\");\n", "\n", "    assertThat(ms).containsExactly(\"d\", \"c\", \"b\", \"b\", \"a\").inOrder();\n", "\n", "    SortedSet<String> elementSet = ms.elementSet();\n", "    assertEquals(\"d\", elementSet.first());\n", "    assertEquals(\"a\", elementSet.last());\n", "    assertEquals(comparator, elementSet.comparator());\n", "  }\n", "\n", "  public void testNullAcceptingComparator() throws Exception {\n", "    Comparator<String> comparator = Ordering.<String>natural().nullsFirst();\n", "    TreeMultiset<String> ms = TreeMultiset.create(comparator);\n", "\n", "    ms.add(\"b\");\n", "    ms.add(null);\n", "    ms.add(\"a\");\n", "    ms.add(\"b\");\n", "    ms.add(null, 2);\n", "\n", "    assertThat(ms).containsExactly(null, null, null, \"a\", \"b\", \"b\").inOrder();\n", "    assertEquals(3, ms.count(null));\n", "\n", "    SortedSet<String> elementSet = ms.elementSet();\n", "    assertEquals(null, elementSet.first());\n", "    assertEquals(\"b\", elementSet.last());\n", "    assertEquals(comparator, elementSet.comparator());\n", "  }\n", "\n", "  private static final Comparator<String> DEGENERATE_COMPARATOR =\n", "      new Comparator<String>() {\n", "        @Override\n", "        public int compare(String o1, String o2) {\n", "          return o1.length() - o2.length();\n", "        }\n", "      };\n", "\n", "  /**\n", "   * Test a TreeMultiset with a comparator that can return 0 when comparing\n", "   * unequal values.\n", "   */\n", "  public void testDegenerateComparator() throws Exception {\n", "    TreeMultiset<String> ms = TreeMultiset.create(DEGENERATE_COMPARATOR);\n", "\n", "    ms.add(\"foo\");\n", "    ms.add(\"a\");\n", "    ms.add(\"bar\");\n", "    ms.add(\"b\");\n", "    ms.add(\"c\");\n", "\n", "    assertEquals(2, ms.count(\"bar\"));\n", "    assertEquals(3, ms.count(\"b\"));\n", "\n", "    Multiset<String> ms2 = TreeMultiset.create(DEGENERATE_COMPARATOR);\n", "\n", "    ms2.add(\"cat\", 2);\n", "    ms2.add(\"x\", 3);\n", "\n", "    assertEquals(ms, ms2);\n", "    assertEquals(ms2, ms);\n", "\n", "    SortedSet<String> elementSet = ms.elementSet();\n", "    assertEquals(\"a\", elementSet.first());\n", "    assertEquals(\"foo\", elementSet.last());\n", "    assertEquals(DEGENERATE_COMPARATOR, elementSet.comparator());\n", "  }\n", "\n", "  public void testSubMultisetSize() {\n", "    TreeMultiset<String> ms = TreeMultiset.create();\n", "    ms.add(\"a\", Integer.MAX_VALUE);\n", "    ms.add(\"b\", Integer.MAX_VALUE);\n", "    ms.add(\"c\", 3);\n", "\n", "    assertEquals(Integer.MAX_VALUE, ms.count(\"a\"));\n", "    assertEquals(Integer.MAX_VALUE, ms.count(\"b\"));\n", "    assertEquals(3, ms.count(\"c\"));\n", "\n", "    assertEquals(Integer.MAX_VALUE, ms.headMultiset(\"c\", CLOSED).size());\n", "    assertEquals(Integer.MAX_VALUE, ms.headMultiset(\"b\", CLOSED).size());\n", "    assertEquals(Integer.MAX_VALUE, ms.headMultiset(\"a\", CLOSED).size());\n", "\n", "    assertEquals(3, ms.tailMultiset(\"c\", CLOSED).size());\n", "    assertEquals(Integer.MAX_VALUE, ms.tailMultiset(\"b\", CLOSED).size());\n", "    assertEquals(Integer.MAX_VALUE, ms.tailMultiset(\"a\", CLOSED).size());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275]}}, {"144": "guava-gwt/test-super/com/google/common/collect/super/com/google/common/collect/TreeTraverserTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License.  You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied.  See the License for the specific language governing permissions and limitations\n", " * under the License.\n", " */\n", "\n", "package com.google.common.collect;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Optional;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.List;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Tests for {@code TreeTraverser}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TreeTraverserTest extends TestCase {\n", "  private static final class Tree {\n", "    final char value;\n", "    final List<Tree> children;\n", "\n", "    public Tree(char value, Tree... children) {\n", "      this.value = value;\n", "      this.children = Arrays.asList(children);\n", "    }\n", "  }\n", "\n", "  private static final class BinaryTree {\n", "    final char value;\n", "    @Nullable\n", "    final BinaryTree left;\n", "    @Nullable\n", "    final BinaryTree right;\n", "\n", "    private BinaryTree(char value, BinaryTree left, BinaryTree right) {\n", "      this.value = value;\n", "      this.left = left;\n", "      this.right = right;\n", "    }\n", "  }\n", "\n", "  private static final TreeTraverser<Tree> ADAPTER = new TreeTraverser<Tree>() {\n", "    @Override\n", "    public Iterable<Tree> children(Tree node) {\n", "      return node.children;\n", "    }\n", "  };\n", "\n", "  private static final BinaryTreeTraverser<BinaryTree> BIN_ADAPTER =\n", "      new BinaryTreeTraverser<BinaryTree>() {\n", "\n", "    @Override\n", "    public Optional<BinaryTree> leftChild(BinaryTree node) {\n", "      return Optional.fromNullable(node.left);\n", "    }\n", "\n", "    @Override\n", "    public Optional<BinaryTree> rightChild(BinaryTree node) {\n", "      return Optional.fromNullable(node.right);\n", "    }\n", "  };\n", "\n", "  //        h\n", "  //      / | \\\n", "  //     /  e  \\\n", "  //    d       g\n", "  //   /|\\      |\n", "  //  / | \\     f\n", "  // a  b  c\n", "  static final Tree a = new Tree('a');\n", "  static final Tree b = new Tree('b');\n", "  static final Tree c = new Tree('c');\n", "  static final Tree d = new Tree('d', a, b, c);\n", "  static final Tree e = new Tree('e');\n", "  static final Tree f = new Tree('f');\n", "  static final Tree g = new Tree('g', f);\n", "  static final Tree h = new Tree('h', d, e, g);\n", "\n", "  //      d\n", "  //     / \\\n", "  //    b   e\n", "  //   / \\   \\\n", "  //  a   c   f\n", "  //         /\n", "  //        g\n", "  static final BinaryTree ba = new BinaryTree('a', null, null);\n", "  static final BinaryTree bc = new BinaryTree('c', null, null);\n", "  static final BinaryTree bb = new BinaryTree('b', ba, bc);\n", "  static final BinaryTree bg = new BinaryTree('g', null, null);\n", "  static final BinaryTree bf = new BinaryTree('f', bg, null);\n", "  static final BinaryTree be = new BinaryTree('e', null, bf);\n", "  static final BinaryTree bd = new BinaryTree('d', bb, be);\n", "\n", "  static String iterationOrder(Iterable<Tree> iterable) {\n", "    StringBuilder builder = new StringBuilder();\n", "    for (Tree t : iterable) {\n", "      builder.append(t.value);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  static String binaryIterationOrder(Iterable<BinaryTree> iterable) {\n", "    StringBuilder builder = new StringBuilder();\n", "    for (BinaryTree t : iterable) {\n", "      builder.append(t.value);\n", "    }\n", "    return builder.toString();\n", "  }\n", "\n", "  public void testPreOrder() {\n", "    assertThat(iterationOrder(ADAPTER.preOrderTraversal(h))).isEqualTo(\"hdabcegf\");\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.preOrderTraversal(bd))).isEqualTo(\"dbacefg\");\n", "  }\n", "\n", "  public void testPostOrder() {\n", "    assertThat(iterationOrder(ADAPTER.postOrderTraversal(h))).isEqualTo(\"abcdefgh\");\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.postOrderTraversal(bd))).isEqualTo(\"acbgfed\");\n", "  }\n", "\n", "  public void testBreadthOrder() {\n", "    assertThat(iterationOrder(ADAPTER.breadthFirstTraversal(h))).isEqualTo(\"hdegabcf\");\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.breadthFirstTraversal(bd))).isEqualTo(\"dbeacfg\");\n", "  }\n", "\n", "  public void testInOrder() {\n", "    assertThat(binaryIterationOrder(BIN_ADAPTER.inOrderTraversal(bd))).isEqualTo(\"abcdegf\");\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147]}}, {"145": "guava-gwt/test-super/com/google/common/collect/testing/google/super/com/google/common/collect/testing/google/AbstractMultisetSetCountTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.google;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION;\n", "import static com.google.common.collect.testing.features.CollectionFeature.RESTRICTS_ELEMENTS;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ADD;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_REMOVE;\n", "import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.Multiset;\n", "import com.google.common.collect.Multiset.Entry;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "\n", "/**\n", " * Common superclass for {@link MultisetSetCountUnconditionallyTester} and\n", " * {@link MultisetSetCountConditionallyTester}. It is used by those testers to\n", " * test calls to the unconditional {@code setCount()} method and calls to the\n", " * conditional {@code setCount()} method when the expected present count is\n", " * correct.\n", " *\n", " * @author Chris Povirk\n", " */\n", "@GwtCompatible(emulated = true)\n", "public abstract class AbstractMultisetSetCountTester<E>\n", "    extends AbstractMultisetTester<E> {\n", "  /*\n", "   * TODO: consider adding MultisetFeatures.SUPPORTS_SET_COUNT. Currently we\n", "   * assume that using setCount() to increase the count is permitted iff add()\n", "   * is permitted and similarly for decrease/remove(). We assume that a\n", "   * setCount() no-op is permitted if either add() or remove() is permitted,\n", "   * though we also allow it to \"succeed\" if neither is permitted.\n", "   */\n", "\n", "  private void assertSetCount(E element, int count) {\n", "    setCountCheckReturnValue(element, count);\n", "\n", "    assertEquals(\n", "        \"multiset.count() should return the value passed to setCount()\",\n", "        count, getMultiset().count(element));\n", "\n", "    int size = 0;\n", "    for (Multiset.Entry<E> entry : getMultiset().entrySet()) {\n", "      size += entry.getCount();\n", "    }\n", "    assertEquals(\n", "        \"multiset.size() should be the sum of the counts of all entries\",\n", "        size, getMultiset().size());\n", "  }\n", "\n", "  /**\n", "   * Call the {@code setCount()} method under test, and check its return value.\n", "   */\n", "  abstract void setCountCheckReturnValue(E element, int count);\n", "\n", "  /**\n", "   * Call the {@code setCount()} method under test, but do not check its return\n", "   * value. Callers should use this method over\n", "   * {@link #setCountCheckReturnValue(Object, int)} when they expect\n", "   * {@code setCount()} to throw an exception, as checking the return value\n", "   * could produce an incorrect error message like\n", "   * \"setCount() should return the original count\" instead of the message passed\n", "   * to a later invocation of {@code fail()}, like \"setCount should throw\n", "   * UnsupportedOperationException.\"\n", "   */\n", "  abstract void setCountNoCheckReturnValue(E element, int count);\n", "\n", "  private void assertSetCountIncreasingFailure(E element, int count) {\n", "    try {\n", "      setCountNoCheckReturnValue(element, count);\n", "      fail(\"a call to multiset.setCount() to increase an element's count \"\n", "          + \"should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  private void assertSetCountDecreasingFailure(E element, int count) {\n", "    try {\n", "      setCountNoCheckReturnValue(element, count);\n", "      fail(\"a call to multiset.setCount() to decrease an element's count \"\n", "          + \"should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  // Unconditional setCount no-ops.\n", "\n", "  private void assertZeroToZero() {\n", "    assertSetCount(e3(), 0);\n", "  }\n", "\n", "  private void assertOneToOne() {\n", "    assertSetCount(e0(), 1);\n", "  }\n", "\n", "  private void assertThreeToThree() {\n", "    initThreeCopies();\n", "    assertSetCount(e0(), 3);\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testSetCount_zeroToZero_addSupported() {\n", "    assertZeroToZero();\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testSetCount_zeroToZero_removeSupported() {\n", "    assertZeroToZero();\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = {SUPPORTS_ADD, SUPPORTS_REMOVE})\n", "  public void testSetCount_zeroToZero_unsupported() {\n", "    try {\n", "      assertZeroToZero();\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testSetCount_oneToOne_addSupported() {\n", "    assertOneToOne();\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testSetCount_oneToOne_removeSupported() {\n", "    assertOneToOne();\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(absent = {SUPPORTS_ADD, SUPPORTS_REMOVE})\n", "  public void testSetCount_oneToOne_unsupported() {\n", "    try {\n", "      assertOneToOne();\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testSetCount_threeToThree_addSupported() {\n", "    assertThreeToThree();\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testSetCount_threeToThree_removeSupported() {\n", "    assertThreeToThree();\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(absent = {SUPPORTS_ADD, SUPPORTS_REMOVE})\n", "  public void testSetCount_threeToThree_unsupported() {\n", "    try {\n", "      assertThreeToThree();\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "  }\n", "\n", "  // Unconditional setCount size increases:\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testSetCount_zeroToOne_supported() {\n", "    assertSetCount(e3(), 1);\n", "  }\n", "\n", "  @CollectionFeature.Require({SUPPORTS_ADD,\n", "      FAILS_FAST_ON_CONCURRENT_MODIFICATION})\n", "  public void testSetCountZeroToOneConcurrentWithIteration() {\n", "    try {\n", "      Iterator<E> iterator = collection.iterator();\n", "      assertSetCount(e3(), 1);\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require({SUPPORTS_ADD,\n", "      FAILS_FAST_ON_CONCURRENT_MODIFICATION})\n", "  public void testSetCountZeroToOneConcurrentWithEntrySetIteration() {\n", "    try {\n", "      Iterator<Entry<E>> iterator = getMultiset().entrySet().iterator();\n", "      assertSetCount(e3(), 1);\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testSetCount_zeroToThree_supported() {\n", "    assertSetCount(e3(), 3);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testSetCount_oneToThree_supported() {\n", "    assertSetCount(e0(), 3);\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  public void testSetCount_zeroToOne_unsupported() {\n", "    assertSetCountIncreasingFailure(e3(), 1);\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  public void testSetCount_zeroToThree_unsupported() {\n", "    assertSetCountIncreasingFailure(e3(), 3);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  public void testSetCount_oneToThree_unsupported() {\n", "    assertSetCountIncreasingFailure(e3(), 3);\n", "  }\n", "\n", "  // Unconditional setCount size decreases:\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testSetCount_oneToZero_supported() {\n", "    assertSetCount(e0(), 0);\n", "  }\n", "\n", "  @CollectionFeature.Require({SUPPORTS_REMOVE,\n", "      FAILS_FAST_ON_CONCURRENT_MODIFICATION})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testSetCountOneToZeroConcurrentWithIteration() {\n", "    try {\n", "      Iterator<E> iterator = collection.iterator();\n", "      assertSetCount(e0(), 0);\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require({SUPPORTS_REMOVE,\n", "      FAILS_FAST_ON_CONCURRENT_MODIFICATION})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testSetCountOneToZeroConcurrentWithEntrySetIteration() {\n", "    try {\n", "      Iterator<Entry<E>> iterator = getMultiset().entrySet().iterator();\n", "      assertSetCount(e0(), 0);\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testSetCount_threeToZero_supported() {\n", "    initThreeCopies();\n", "    assertSetCount(e0(), 0);\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testSetCount_threeToOne_supported() {\n", "    initThreeCopies();\n", "    assertSetCount(e0(), 1);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  public void testSetCount_oneToZero_unsupported() {\n", "    assertSetCountDecreasingFailure(e0(), 0);\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  public void testSetCount_threeToZero_unsupported() {\n", "    initThreeCopies();\n", "    assertSetCountDecreasingFailure(e0(), 0);\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  public void testSetCount_threeToOne_unsupported() {\n", "    initThreeCopies();\n", "    assertSetCountDecreasingFailure(e0(), 1);\n", "  }\n", "\n", "  // setCount with nulls:\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})\n", "  public void testSetCount_removeNull_nullSupported() {\n", "    initCollectionWithNullElement();\n", "    assertSetCount(null, 0);\n", "  }\n", "\n", "  @CollectionFeature.Require(value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES},\n", "      absent = RESTRICTS_ELEMENTS)\n", "  public void testSetCount_addNull_nullSupported() {\n", "    assertSetCount(null, 1);\n", "  }\n", "\n", "  @CollectionFeature.Require(value = SUPPORTS_ADD, absent = ALLOWS_NULL_VALUES)\n", "  public void testSetCount_addNull_nullUnsupported() {\n", "    try {\n", "      setCountNoCheckReturnValue(null, 1);\n", "      fail(\"adding null with setCount() should throw NullPointerException\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  public void testSetCount_noOpNull_nullSupported() {\n", "    try {\n", "      assertSetCount(null, 0);\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = ALLOWS_NULL_VALUES)\n", "  public void testSetCount_noOpNull_nullUnsupported() {\n", "    try {\n", "      assertSetCount(null, 0);\n", "    } catch (NullPointerException tolerated) {\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  public void testSetCount_existingNoNopNull_nullSupported() {\n", "    initCollectionWithNullElement();\n", "    try {\n", "      assertSetCount(null, 1);\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "  }\n", "\n", "  // Negative count.\n", "\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testSetCount_negative_removeSupported() {\n", "    try {\n", "      setCountNoCheckReturnValue(e3(), -1);\n", "      fail(\"calling setCount() with a negative count should throw \"\n", "          + \"IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  public void testSetCount_negative_removeUnsupported() {\n", "    try {\n", "      setCountNoCheckReturnValue(e3(), -1);\n", "      fail(\"calling setCount() with a negative count should throw \"\n", "          + \"IllegalArgumentException or UnsupportedOperationException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  // TODO: test adding element of wrong type\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388]}}, {"146": "guava-gwt/test-super/com/google/common/collect/testing/google/super/com/google/common/collect/testing/google/BiMapInverseTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.google;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.SERIALIZABLE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.BiMap;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.testing.SerializableTester;\n", "\n", "import java.io.Serializable;\n", "\n", "/**\n", " * Tests for the {@code inverse} view of a BiMap.\n", " * \n", " * <p>This assumes that {@code bimap.inverse().inverse() == bimap}, which is not technically\n", " * required but is fulfilled by all current implementations.\n", " * \n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class BiMapInverseTester<K, V> extends AbstractBiMapTester<K, V> {\n", "\n", "  public void testInverseSame() {\n", "    assertSame(getMap(), getMap().inverse().inverse());\n", "  }\n", "\n", "  @CollectionFeature.Require(SERIALIZABLE)\n", "  public void testInverseSerialization() {\n", "    BiMapPair<K, V> pair = new BiMapPair<K, V>(getMap());\n", "    BiMapPair<K, V> copy = SerializableTester.reserialize(pair);\n", "    assertEquals(pair.forward, copy.forward);\n", "    assertEquals(pair.backward, copy.backward);\n", "    assertSame(copy.backward, copy.forward.inverse());\n", "    assertSame(copy.forward, copy.backward.inverse());\n", "  }\n", "\n", "  private static class BiMapPair<K, V> implements Serializable {\n", "    final BiMap<K, V> forward;\n", "    final BiMap<V, K> backward;\n", "\n", "    BiMapPair(BiMap<K, V> original) {\n", "      this.forward = original;\n", "      this.backward = original.inverse();\n", "    }\n", "\n", "    private static final long serialVersionUID = 0;\n", "  }\n", "\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66]}}, {"147": "guava-gwt/test-super/com/google/common/collect/testing/google/super/com/google/common/collect/testing/google/MultisetCountTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.google;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_QUERIES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.WrongType;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "/**\n", " * Tests for {@code Multiset#count}.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MultisetCountTester<E> extends AbstractMultisetTester<E> {\n", "\n", "  public void testCount_0() {\n", "    assertEquals(\"multiset.count(missing) didn't return 0\",\n", "        0, getMultiset().count(e3()));\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCount_1() {\n", "    assertEquals(\"multiset.count(present) didn't return 1\",\n", "        1, getMultiset().count(e0()));\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  public void testCount_3() {\n", "    initThreeCopies();\n", "    assertEquals(\"multiset.count(thriceContained) didn't return 3\",\n", "        3, getMultiset().count(e0()));\n", "  }\n", "\n", "  @CollectionFeature.Require(ALLOWS_NULL_QUERIES)\n", "  public void testCount_nullAbsent() {\n", "    assertEquals(\"multiset.count(null) didn't return 0\",\n", "        0, getMultiset().count(null));\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = ALLOWS_NULL_QUERIES)\n", "  public void testCount_null_forbidden() {\n", "    try {\n", "      getMultiset().count(null);\n", "      fail(\"Expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "  \n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  public void testCount_nullPresent() {\n", "    initCollectionWithNullElement();\n", "    assertEquals(1, getMultiset().count(null));\n", "  }\n", "\n", "  public void testCount_wrongType() {\n", "    assertEquals(\"multiset.count(wrongType) didn't return 0\",\n", "        0, getMultiset().count(WrongType.VALUE));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81]}}, {"148": "guava-gwt/test-super/com/google/common/collect/testing/google/super/com/google/common/collect/testing/google/MultisetIteratorTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " * \n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " * \n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " * \n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.collect.testing.google;\n", "\n", "import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;\n", "import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ITERATOR_REMOVE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.IteratorTester;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "\n", "import java.util.Arrays;\n", "import java.util.Iterator;\n", "\n", "/**\n", " * Tester to make sure the {@code iterator().remove()} implementation of {@code Multiset} works when\n", " * there are multiple occurrences of elements.\n", " * \n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MultisetIteratorTester<E> extends AbstractMultisetTester<E> {\n", "  @SuppressWarnings(\"unchecked\")\n", "  @CollectionFeature.Require({SUPPORTS_ITERATOR_REMOVE, KNOWN_ORDER})\n", "  public void testRemovingIteratorKnownOrder() {\n", "    new IteratorTester<E>(4, MODIFIABLE, getSubjectGenerator().order(\n", "        Arrays.asList(e0(), e1(), e1(), e2())),\n", "        IteratorTester.KnownOrder.KNOWN_ORDER) {\n", "      @Override\n", "      protected Iterator<E> newTargetIterator() {\n", "        return getSubjectGenerator().create(e0(), e1(), e1(), e2())\n", "            .iterator();\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  @CollectionFeature.Require(value = SUPPORTS_ITERATOR_REMOVE, absent = KNOWN_ORDER)\n", "  public void testRemovingIteratorUnknownOrder() {\n", "    new IteratorTester<E>(4, MODIFIABLE, Arrays.asList(e0(), e1(),\n", "        e1(), e2()), IteratorTester.KnownOrder.UNKNOWN_ORDER) {\n", "      @Override\n", "      protected Iterator<E> newTargetIterator() {\n", "        return getSubjectGenerator().create(e0(), e1(), e1(), e2())\n", "            .iterator();\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  @CollectionFeature.Require(value = KNOWN_ORDER, absent = SUPPORTS_ITERATOR_REMOVE)\n", "  public void testIteratorKnownOrder() {\n", "    new IteratorTester<E>(4, UNMODIFIABLE, getSubjectGenerator().order(\n", "        Arrays.asList(e0(), e1(), e1(), e2())),\n", "        IteratorTester.KnownOrder.KNOWN_ORDER) {\n", "      @Override\n", "      protected Iterator<E> newTargetIterator() {\n", "        return getSubjectGenerator().create(e0(), e1(), e1(), e2())\n", "            .iterator();\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  @SuppressWarnings(\"unchecked\")\n", "  @CollectionFeature.Require(absent = {SUPPORTS_ITERATOR_REMOVE, KNOWN_ORDER})\n", "  public void testIteratorUnknownOrder() {\n", "    new IteratorTester<E>(4, UNMODIFIABLE, Arrays.asList(e0(), e1(),\n", "        e1(), e2()), IteratorTester.KnownOrder.UNKNOWN_ORDER) {\n", "      @Override\n", "      protected Iterator<E> newTargetIterator() {\n", "        return getSubjectGenerator().create(e0(), e1(), e1(), e2())\n", "            .iterator();\n", "      }\n", "    }.test();\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91]}}, {"149": "guava-gwt/test-super/com/google/common/collect/testing/google/super/com/google/common/collect/testing/google/MultisetRemoveTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2013 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.google;\n", "\n", "import static com.google.common.collect.testing.Helpers.assertEmpty;\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_QUERIES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_REMOVE;\n", "import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.WrongType;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "import java.util.Collections;\n", "import java.util.List;\n", "\n", "/**\n", " * Tests for {@code Multiset#remove}, {@code Multiset.removeAll}, and {@code Multiset.retainAll}\n", " * not already covered by the corresponding Collection testers.\n", " *\n", " * @author Jared Levy\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MultisetRemoveTester<E> extends AbstractMultisetTester<E> {\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemoveNegative() {\n", "    try {\n", "      getMultiset().remove(e0(), -1);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {}\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  public void testRemoveUnsupported() {\n", "    try {\n", "      getMultiset().remove(e0(), 2);\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemoveZeroNoOp() {\n", "    int originalCount = getMultiset().count(e0());\n", "    assertEquals(\"old count\", originalCount, getMultiset().remove(e0(), 0));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_occurrences_present() {\n", "    assertEquals(\"multiset.remove(present, 2) didn't return the old count\",\n", "        1, getMultiset().remove(e0(), 2));\n", "    assertFalse(\"multiset contains present after multiset.remove(present, 2)\",\n", "        getMultiset().contains(e0()));\n", "    assertEquals(0, getMultiset().count(e0()));\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_some_occurrences_present() {\n", "    initThreeCopies();\n", "    assertEquals(\"multiset.remove(present, 2) didn't return the old count\",\n", "        3, getMultiset().remove(e0(), 2));\n", "    assertTrue(\"multiset contains present after multiset.remove(present, 2)\",\n", "        getMultiset().contains(e0()));\n", "    assertEquals(1, getMultiset().count(e0()));\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_occurrences_absent() {\n", "    assertEquals(\"multiset.remove(absent, 0) didn't return 0\",\n", "        0, getMultiset().remove(e3(), 2));\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  public void testRemove_occurrences_unsupported_absent() {\n", "    // notice: we don't care whether it succeeds, or fails with UOE\n", "    try {\n", "      assertEquals(\n", "          \"multiset.remove(absent, 2) didn't return 0 or throw an exception\",\n", "          0, getMultiset().remove(e3(), 2));\n", "    } catch (UnsupportedOperationException ok) {}\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_occurrences_0() {\n", "    int oldCount = getMultiset().count(e0());\n", "    assertEquals(\"multiset.remove(E, 0) didn't return the old count\",\n", "        oldCount, getMultiset().remove(e0(), 0));\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_occurrences_negative() {\n", "    try {\n", "      getMultiset().remove(e0(), -1);\n", "      fail(\"multiset.remove(E, -1) didn't throw an exception\");\n", "    } catch (IllegalArgumentException required) {}\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemove_occurrences_wrongType() {\n", "    assertEquals(\"multiset.remove(wrongType, 1) didn't return 0\",\n", "        0, getMultiset().remove(WrongType.VALUE, 1));\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})\n", "  public void testRemove_nullPresent() {\n", "    initCollectionWithNullElement();\n", "    assertEquals(1, getMultiset().remove(null, 2));\n", "    assertFalse(\"multiset contains present after multiset.remove(present, 2)\",\n", "        getMultiset().contains(null));\n", "    assertEquals(0, getMultiset().count(null));\n", "  }\n", "\n", "  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_QUERIES})\n", "  public void testRemove_nullAbsent() {\n", "    assertEquals(0, getMultiset().remove(null, 2));\n", "  }\n", "\n", "  @CollectionFeature.Require(value = SUPPORTS_REMOVE, absent = ALLOWS_NULL_QUERIES)\n", "  public void testRemove_nullForbidden() {\n", "    try {\n", "      getMultiset().remove(null, 2);\n", "      fail(\"Expected NullPointerException\");\n", "    } catch (NullPointerException expected) {}\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRemoveAllIgnoresCount() {\n", "    initThreeCopies();\n", "    assertTrue(getMultiset().removeAll(Collections.singleton(e0())));\n", "    assertEmpty(getMultiset());\n", "  }\n", "\n", "  @CollectionSize.Require(SEVERAL)\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  public void testRetainAllIgnoresCount() {\n", "    initThreeCopies();\n", "    List<E> contents = Helpers.copyToList(getMultiset());\n", "    assertFalse(getMultiset().retainAll(Collections.singleton(e0())));\n", "    expectContents(contents);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165]}}, {"150": "guava-gwt/test-super/com/google/common/collect/testing/google/super/com/google/common/collect/testing/google/SetGenerators.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.google;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "import static com.google.common.collect.Lists.newArrayList;\n", "import static com.google.common.collect.Sets.newTreeSet;\n", "import static com.google.common.collect.testing.SampleElements.Strings.AFTER_LAST;\n", "import static com.google.common.collect.testing.SampleElements.Strings.AFTER_LAST_2;\n", "import static com.google.common.collect.testing.SampleElements.Strings.BEFORE_FIRST;\n", "import static com.google.common.collect.testing.SampleElements.Strings.BEFORE_FIRST_2;\n", "import static junit.framework.Assert.assertEquals;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ContiguousSet;\n", "import com.google.common.collect.DiscreteDomain;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.ImmutableSortedSet;\n", "import com.google.common.collect.Lists;\n", "import com.google.common.collect.Ordering;\n", "import com.google.common.collect.Range;\n", "import com.google.common.collect.Sets;\n", "import com.google.common.collect.testing.TestCollectionGenerator;\n", "import com.google.common.collect.testing.TestCollidingSetGenerator;\n", "import com.google.common.collect.testing.TestIntegerSortedSetGenerator;\n", "import com.google.common.collect.testing.TestSetGenerator;\n", "import com.google.common.collect.testing.TestStringListGenerator;\n", "import com.google.common.collect.testing.TestStringSetGenerator;\n", "import com.google.common.collect.testing.TestStringSortedSetGenerator;\n", "import com.google.common.collect.testing.TestUnhashableCollectionGenerator;\n", "import com.google.common.collect.testing.UnhashableObject;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "import java.util.Set;\n", "import java.util.SortedSet;\n", "\n", "/**\n", " * Generators of different types of sets and derived collections from sets.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Jared Levy\n", " * @author Hayward Chan\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SetGenerators {\n", "\n", "  public static class ImmutableSetCopyOfGenerator extends TestStringSetGenerator {\n", "    @Override protected Set<String> create(String[] elements) {\n", "      return ImmutableSet.copyOf(elements);\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSetWithBadHashesGenerator\n", "      extends TestCollidingSetGenerator\n", "      // Work around a GWT compiler bug.  Not explicitly listing this will\n", "      // cause the createArray() method missing in the generated javascript.\n", "      // TODO: Remove this once the GWT bug is fixed.\n", "      implements TestCollectionGenerator<Object> {\n", "    @Override\n", "    public Set<Object> create(Object... elements) {\n", "      return ImmutableSet.copyOf(elements);\n", "    }\n", "  }\n", "\n", "  public static class DegeneratedImmutableSetGenerator\n", "      extends TestStringSetGenerator {\n", "    // Make sure we get what we think we're getting, or else this test\n", "    // is pointless\n", "    @SuppressWarnings(\"cast\")\n", "    @Override protected Set<String> create(String[] elements) {\n", "      return (ImmutableSet<String>)\n", "          ImmutableSet.of(elements[0], elements[0]);\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetCopyOfGenerator\n", "      extends TestStringSortedSetGenerator {\n", "    @Override protected SortedSet<String> create(String[] elements) {\n", "      return ImmutableSortedSet.copyOf(elements);\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetHeadsetGenerator\n", "      extends TestStringSortedSetGenerator {\n", "    @Override protected SortedSet<String> create(String[] elements) {\n", "      List<String> list = Lists.newArrayList(elements);\n", "      list.add(\"zzz\");\n", "      return ImmutableSortedSet.copyOf(list)\n", "          .headSet(\"zzy\");\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetTailsetGenerator\n", "      extends TestStringSortedSetGenerator {\n", "    @Override protected SortedSet<String> create(String[] elements) {\n", "      List<String> list = Lists.newArrayList(elements);\n", "      list.add(\"\\0\");\n", "      return ImmutableSortedSet.copyOf(list)\n", "          .tailSet(\"\\0\\0\");\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetSubsetGenerator\n", "      extends TestStringSortedSetGenerator {\n", "    @Override protected SortedSet<String> create(String[] elements) {\n", "      List<String> list = Lists.newArrayList(elements);\n", "      list.add(\"\\0\");\n", "      list.add(\"zzz\");\n", "      return ImmutableSortedSet.copyOf(list)\n", "          .subSet(\"\\0\\0\", \"zzy\");\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetExplicitComparator\n", "      extends TestStringSetGenerator {\n", "\n", "    private static final Comparator<String> STRING_REVERSED\n", "        = Collections.reverseOrder();\n", "\n", "    @Override protected SortedSet<String> create(String[] elements) {\n", "      return ImmutableSortedSet.orderedBy(STRING_REVERSED)\n", "          .add(elements)\n", "          .build();\n", "    }\n", "\n", "    @Override public List<String> order(List<String> insertionOrder) {\n", "      Collections.sort(insertionOrder, Collections.reverseOrder());\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetExplicitSuperclassComparatorGenerator\n", "      extends TestStringSetGenerator {\n", "\n", "    private static final Comparator<Comparable<?>> COMPARABLE_REVERSED\n", "        = Collections.reverseOrder();\n", "\n", "    @Override protected SortedSet<String> create(String[] elements) {\n", "      return new ImmutableSortedSet.Builder<String>(COMPARABLE_REVERSED)\n", "          .add(elements)\n", "          .build();\n", "    }\n", "\n", "    @Override public List<String> order(List<String> insertionOrder) {\n", "      Collections.sort(insertionOrder, Collections.reverseOrder());\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetReversedOrderGenerator\n", "      extends TestStringSetGenerator {\n", "\n", "    @Override protected SortedSet<String> create(String[] elements) {\n", "      return ImmutableSortedSet.<String>reverseOrder()\n", "          .addAll(Arrays.asList(elements).iterator())\n", "          .build();\n", "    }\n", "\n", "    @Override public List<String> order(List<String> insertionOrder) {\n", "      Collections.sort(insertionOrder, Collections.reverseOrder());\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetUnhashableGenerator\n", "      extends TestUnhashableSetGenerator {\n", "    @Override public Set<UnhashableObject> create(\n", "        UnhashableObject[] elements) {\n", "      return ImmutableSortedSet.copyOf(elements);\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSetAsListGenerator\n", "      extends TestStringListGenerator {\n", "    @Override protected List<String> create(String[] elements) {\n", "      return ImmutableSet.copyOf(elements).asList();\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetAsListGenerator\n", "      extends TestStringListGenerator {\n", "    @Override protected List<String> create(String[] elements) {\n", "      Comparator<String> comparator = createExplicitComparator(elements);\n", "      ImmutableSet<String> set = ImmutableSortedSet.copyOf(\n", "          comparator, Arrays.asList(elements));\n", "      return set.asList();\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetSubsetAsListGenerator\n", "      extends TestStringListGenerator {\n", "    @Override protected List<String> create(String[] elements) {\n", "      Comparator<String> comparator = createExplicitComparator(elements);\n", "      ImmutableSortedSet.Builder<String> builder\n", "          = ImmutableSortedSet.orderedBy(comparator);\n", "      builder.add(BEFORE_FIRST);\n", "      builder.add(elements);\n", "      builder.add(AFTER_LAST);\n", "      return builder.build().subSet(BEFORE_FIRST_2,\n", "          AFTER_LAST).asList();\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetAsListSubListGenerator\n", "      extends TestStringListGenerator {\n", "    @Override protected List<String> create(String[] elements) {\n", "      Comparator<String> comparator = createExplicitComparator(elements);\n", "      ImmutableSortedSet.Builder<String> builder\n", "          = ImmutableSortedSet.orderedBy(comparator);\n", "      builder.add(BEFORE_FIRST);\n", "      builder.add(elements);\n", "      builder.add(AFTER_LAST);\n", "      return builder.build().asList().subList(1, elements.length + 1);\n", "    }\n", "  }\n", "\n", "  public static class ImmutableSortedSetSubsetAsListSubListGenerator\n", "      extends TestStringListGenerator {\n", "    @Override protected List<String> create(String[] elements) {\n", "      Comparator<String> comparator = createExplicitComparator(elements);\n", "      ImmutableSortedSet.Builder<String> builder\n", "          = ImmutableSortedSet.orderedBy(comparator);\n", "      builder.add(BEFORE_FIRST);\n", "      builder.add(BEFORE_FIRST_2);\n", "      builder.add(elements);\n", "      builder.add(AFTER_LAST);\n", "      builder.add(AFTER_LAST_2);\n", "      return builder.build().subSet(BEFORE_FIRST_2,\n", "          AFTER_LAST_2)\n", "              .asList().subList(1, elements.length + 1);\n", "    }\n", "  }\n", "\n", "  public abstract static class TestUnhashableSetGenerator\n", "      extends TestUnhashableCollectionGenerator<Set<UnhashableObject>>\n", "      implements TestSetGenerator<UnhashableObject> {\n", "  }\n", "\n", "  private static Ordering<String> createExplicitComparator(\n", "      String[] elements) {\n", "    // Collapse equal elements, which Ordering.explicit() doesn't support, while\n", "    // maintaining the ordering by first occurrence.\n", "    Set<String> elementsPlus = Sets.newLinkedHashSet();\n", "    elementsPlus.add(BEFORE_FIRST);\n", "    elementsPlus.add(BEFORE_FIRST_2);\n", "    elementsPlus.addAll(Arrays.asList(elements));\n", "    elementsPlus.add(AFTER_LAST);\n", "    elementsPlus.add(AFTER_LAST_2);\n", "    return Ordering.explicit(Lists.newArrayList(elementsPlus));\n", "  }\n", "\n", "  /*\n", "   * All the ContiguousSet generators below manually reject nulls here. In principle, we'd like to\n", "   * defer that to Range, since it's ContiguousSet.create() that's used to create the sets. However,\n", "   * that gets messy here, and we already have null tests for Range.\n", "   */\n", "\n", "  /*\n", "   * These generators also rely on consecutive integer inputs (not necessarily in order, but no\n", "   * holes).\n", "   */\n", "\n", "  // SetCreationTester has some tests that pass in duplicates. Dedup them.\n", "  private static <E extends Comparable<? super E>> SortedSet<E> nullCheckedTreeSet(E[] elements) {\n", "    SortedSet<E> set = newTreeSet();\n", "    for (E element : elements) {\n", "      // Explicit null check because TreeSet wrongly accepts add(null) when empty.\n", "      set.add(checkNotNull(element));\n", "    }\n", "    return set;\n", "  }\n", "\n", "  public static class ContiguousSetGenerator extends AbstractContiguousSetGenerator {\n", "    @Override protected SortedSet<Integer> create(Integer[] elements) {\n", "      return checkedCreate(nullCheckedTreeSet(elements));\n", "    }\n", "  }\n", "\n", "  public static class ContiguousSetHeadsetGenerator extends AbstractContiguousSetGenerator {\n", "    @Override protected SortedSet<Integer> create(Integer[] elements) {\n", "      SortedSet<Integer> set = nullCheckedTreeSet(elements);\n", "      int tooHigh = (set.isEmpty()) ? 0 : set.last() + 1;\n", "      set.add(tooHigh);\n", "      return checkedCreate(set).headSet(tooHigh);\n", "    }\n", "  }\n", "\n", "  public static class ContiguousSetTailsetGenerator extends AbstractContiguousSetGenerator {\n", "    @Override protected SortedSet<Integer> create(Integer[] elements) {\n", "      SortedSet<Integer> set = nullCheckedTreeSet(elements);\n", "      int tooLow = (set.isEmpty()) ? 0 : set.first() - 1;\n", "      set.add(tooLow);\n", "      return checkedCreate(set).tailSet(tooLow + 1);\n", "    }\n", "  }\n", "\n", "  public static class ContiguousSetSubsetGenerator extends AbstractContiguousSetGenerator {\n", "    @Override protected SortedSet<Integer> create(Integer[] elements) {\n", "      SortedSet<Integer> set = nullCheckedTreeSet(elements);\n", "      if (set.isEmpty()) {\n", "        /*\n", "         * The (tooLow + 1, tooHigh) arguments below would be invalid because tooLow would be\n", "         * greater than tooHigh.\n", "         */\n", "        return ContiguousSet.create(Range.openClosed(0, 1), DiscreteDomain.integers()).subSet(0, 1);\n", "      }\n", "      int tooHigh = set.last() + 1;\n", "      int tooLow = set.first() - 1;\n", "      set.add(tooHigh);\n", "      set.add(tooLow);\n", "      return checkedCreate(set).subSet(tooLow + 1, tooHigh);\n", "    }\n", "  }\n", "\n", "  private abstract static class AbstractContiguousSetGenerator\n", "      extends TestIntegerSortedSetGenerator {\n", "    protected final ContiguousSet<Integer> checkedCreate(SortedSet<Integer> elementsSet) {\n", "      List<Integer> elements = newArrayList(elementsSet);\n", "      /*\n", "       * A ContiguousSet can't have holes. If a test demands a hole, it should be changed so that it\n", "       * doesn't need one, or it should be suppressed for ContiguousSet.\n", "       */\n", "      for (int i = 0; i < elements.size() - 1; i++) {\n", "        assertEquals(elements.get(i) + 1, (int) elements.get(i + 1));\n", "      }\n", "      Range<Integer> range =\n", "          (elements.isEmpty()) ? Range.closedOpen(0, 0) : Range.encloseAll(elements);\n", "      return ContiguousSet.create(range, DiscreteDomain.integers());\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349]}}, {"151": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/Helpers.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing;\n", "\n", "import static java.util.Collections.sort;\n", "import static junit.framework.Assert.assertEquals;\n", "import static junit.framework.Assert.assertFalse;\n", "import static junit.framework.Assert.assertTrue;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.Assert;\n", "import junit.framework.AssertionFailedError;\n", "\n", "import java.io.Serializable;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.Iterator;\n", "import java.util.LinkedHashSet;\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "import java.util.Set;\n", "\n", "@GwtCompatible(emulated = true)\n", "public class Helpers {\n", "  // Clone of Objects.equal\n", "  static boolean equal(Object a, Object b) {\n", "    return a == b || (a != null && a.equals(b));\n", "  }\n", "\n", "  // Clone of Lists.newArrayList\n", "  public static <E> List<E> copyToList(Iterable<? extends E> elements) {\n", "    List<E> list = new ArrayList<E>();\n", "    addAll(list, elements);\n", "    return list;\n", "  }\n", "\n", "  public static <E> List<E> copyToList(E[] elements) {\n", "    return copyToList(Arrays.asList(elements));\n", "  }\n", "\n", "  // Clone of Sets.newLinkedHashSet\n", "  public static <E> Set<E> copyToSet(Iterable<? extends E> elements) {\n", "    Set<E> set = new LinkedHashSet<E>();\n", "    addAll(set, elements);\n", "    return set;\n", "  }\n", "\n", "  public static <E> Set<E> copyToSet(E[] elements) {\n", "    return copyToSet(Arrays.asList(elements));\n", "  }\n", "\n", "  // Would use Maps.immutableEntry\n", "  public static <K, V> Entry<K, V> mapEntry(K key, V value) {\n", "    return Collections.singletonMap(key, value).entrySet().iterator().next();\n", "  }\n", "\n", "  private static boolean isEmpty(Iterable<?> iterable) {\n", "    return iterable instanceof Collection\n", "        ? ((Collection<?>) iterable).isEmpty()\n", "        : iterable.iterator().hasNext();\n", "  }\n", "\n", "  public static void assertEmpty(Iterable<?> iterable) {\n", "    if (!isEmpty(iterable)) {\n", "      Assert.fail(\"Not true that \" + iterable + \" is empty\");\n", "    }\n", "  }\n", "\n", "  public static void assertEmpty(Map<?, ?> map) {\n", "    if (!map.isEmpty()) {\n", "      Assert.fail(\"Not true that \" + map + \" is empty\");\n", "    }\n", "  }\n", "\n", "  public static void assertEqualInOrder(\n", "      Iterable<?> expected, Iterable<?> actual) {\n", "    Iterator<?> expectedIter = expected.iterator();\n", "    Iterator<?> actualIter = actual.iterator();\n", "\n", "    while (expectedIter.hasNext() && actualIter.hasNext()) {\n", "      if (!equal(expectedIter.next(), actualIter.next())) {\n", "        Assert.fail(\n", "            \"contents were not equal and in the same order: \"\n", "                + \"expected = \" + expected + \", actual = \" + actual);\n", "      }\n", "    }\n", "\n", "    if (expectedIter.hasNext() || actualIter.hasNext()) {\n", "      // actual either had too few or too many elements\n", "      Assert.fail(\n", "          \"contents were not equal and in the same order: \"\n", "              + \"expected = \" + expected + \", actual = \" + actual);\n", "    }\n", "  }\n", "\n", "  public static void assertContentsInOrder(Iterable<?> actual, Object... expected) {\n", "    assertEqualInOrder(Arrays.asList(expected), actual);\n", "  }\n", "\n", "  public static void assertEqualIgnoringOrder(\n", "      Iterable<?> expected, Iterable<?> actual) {\n", "    List<?> exp = copyToList(expected);\n", "    List<?> act = copyToList(actual);\n", "    String actString = act.toString();\n", "\n", "    // Of course we could take pains to give the complete description of the\n", "    // problem on any failure.\n", "\n", "    // Yeah it's n^2.\n", "    for (Object object : exp) {\n", "      if (!act.remove(object)) {\n", "        Assert.fail(\"did not contain expected element \" + object + \", \"\n", "            + \"expected = \" + exp + \", actual = \" + actString);\n", "      }\n", "    }\n", "    assertTrue(\"unexpected elements: \" + act, act.isEmpty());\n", "  }\n", "\n", "  public static void assertContentsAnyOrder(\n", "      Iterable<?> actual, Object... expected) {\n", "    assertEqualIgnoringOrder(Arrays.asList(expected), actual);\n", "  }\n", "\n", "  public static void assertContains(Iterable<?> actual, Object expected) {\n", "    boolean contained = false;\n", "    if (actual instanceof Collection) {\n", "      contained = ((Collection<?>) actual).contains(expected);\n", "    } else {\n", "      for (Object o : actual) {\n", "        if (equal(o, expected)) {\n", "          contained = true;\n", "          break;\n", "        }\n", "      }\n", "    }\n", "\n", "    if (!contained) {\n", "      Assert.fail(\"Not true that \" + actual + \" contains \" + expected);\n", "    }\n", "  }\n", "\n", "  public static void assertContainsAllOf(\n", "      Iterable<?> actual, Object... expected) {\n", "    List<Object> expectedList = new ArrayList<Object>();\n", "    expectedList.addAll(Arrays.asList(expected));\n", "\n", "    for (Object o : actual) {\n", "      expectedList.remove(o);\n", "    }\n", "\n", "    if (!expectedList.isEmpty()) {\n", "      Assert.fail(\n", "          \"Not true that \" + actual + \" contains all of \" + Arrays.asList(expected));\n", "    }\n", "  }\n", "\n", "  public static <E> boolean addAll(\n", "      Collection<E> addTo, Iterable<? extends E> elementsToAdd) {\n", "    boolean modified = false;\n", "    for (E e : elementsToAdd) {\n", "      modified |= addTo.add(e);\n", "    }\n", "    return modified;\n", "  }\n", "\n", "  static <T> Iterable<T> reverse(final List<T> list) {\n", "    return new Iterable<T>() {\n", "      @Override\n", "      public Iterator<T> iterator() {\n", "        final ListIterator<T> listIter = list.listIterator(list.size());\n", "        return new Iterator<T>() {\n", "          @Override\n", "          public boolean hasNext() {\n", "            return listIter.hasPrevious();\n", "          }\n", "          @Override\n", "          public T next() {\n", "            return listIter.previous();\n", "          }\n", "          @Override\n", "          public void remove() {\n", "            listIter.remove();\n", "          }\n", "        };\n", "      }\n", "    };\n", "  }\n", "\n", "  static <T> Iterator<T> cycle(final Iterable<T> iterable) {\n", "    return new Iterator<T>() {\n", "      Iterator<T> iterator = Collections.<T>emptySet().iterator();\n", "      @Override\n", "      public boolean hasNext() {\n", "        return true;\n", "      }\n", "      @Override\n", "      public T next() {\n", "        if (!iterator.hasNext()) {\n", "          iterator = iterable.iterator();\n", "        }\n", "        return iterator.next();\n", "      }\n", "      @Override\n", "      public void remove() {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "    };\n", "  }\n", "\n", "  static <T> T get(Iterator<T> iterator, int position) {\n", "    for (int i = 0; i < position; i++) {\n", "      iterator.next();\n", "    }\n", "    return iterator.next();\n", "  }\n", "\n", "  static void fail(Throwable cause, Object message) {\n", "    AssertionFailedError assertionFailedError =\n", "        new AssertionFailedError(String.valueOf(message));\n", "    assertionFailedError.initCause(cause);\n", "    throw assertionFailedError;\n", "  }\n", "\n", "  public static <K, V> Comparator<Entry<K, V>> entryComparator(\n", "      final Comparator<? super K> keyComparator) {\n", "    return new Comparator<Entry<K, V>>() {\n", "      @Override\n", "      @SuppressWarnings(\"unchecked\") // no less safe than putting it in the map!\n", "      public int compare(Entry<K, V> a, Entry<K, V> b) {\n", "        return (keyComparator == null)\n", "            ? ((Comparable) a.getKey()).compareTo(b.getKey())\n", "            : keyComparator.compare(a.getKey(), b.getKey());\n", "      }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Asserts that all pairs of {@code T} values within {@code valuesInExpectedOrder} are ordered\n", "   * consistently between their order within {@code valuesInExpectedOrder} and the order implied by\n", "   * the given {@code comparator}.\n", "   *\n", "   * @see #testComparator(Comparator, List)\n", "   */\n", "  public static <T> void testComparator(\n", "      Comparator<? super T> comparator, T... valuesInExpectedOrder) {\n", "    testComparator(comparator, Arrays.asList(valuesInExpectedOrder));\n", "  }\n", "\n", "  /**\n", "   * Asserts that all pairs of {@code T} values within {@code valuesInExpectedOrder} are ordered\n", "   * consistently between their order within {@code valuesInExpectedOrder} and the order implied by\n", "   * the given {@code comparator}.\n", "   *\n", "   * <p>In detail, this method asserts\n", "   * <ul>\n", "   * <li><i>reflexivity</i>: {@code comparator.compare(t, t) = 0} for all {@code t} in\n", "   * {@code valuesInExpectedOrder}; and\n", "   * <li><i>consistency</i>: {@code comparator.compare(ti, tj) < 0} and\n", "   * {@code comparator.compare(tj, ti) > 0} for {@code i < j}, where\n", "   * {@code ti = valuesInExpectedOrder.get(i)} and {@code tj = valuesInExpectedOrder.get(j)}.\n", "   */\n", "  public static <T> void testComparator(\n", "      Comparator<? super T> comparator, List<T> valuesInExpectedOrder) {\n", "    // This does an O(n^2) test of all pairs of values in both orders\n", "    for (int i = 0; i < valuesInExpectedOrder.size(); i++) {\n", "      T t = valuesInExpectedOrder.get(i);\n", "\n", "      for (int j = 0; j < i; j++) {\n", "        T lesser = valuesInExpectedOrder.get(j);\n", "        assertTrue(comparator + \".compare(\" + lesser + \", \" + t + \")\",\n", "            comparator.compare(lesser, t) < 0);\n", "      }\n", "\n", "      assertEquals(comparator + \".compare(\" + t + \", \" + t + \")\",\n", "          0, comparator.compare(t, t));\n", "\n", "      for (int j = i + 1; j < valuesInExpectedOrder.size(); j++) {\n", "        T greater = valuesInExpectedOrder.get(j);\n", "        assertTrue(comparator + \".compare(\" + greater + \", \" + t + \")\",\n", "            comparator.compare(greater, t) > 0);\n", "      }\n", "    }\n", "  }\n", "\n", "  public static <T extends Comparable<? super T>> void testCompareToAndEquals(\n", "      List<T> valuesInExpectedOrder) {\n", "    // This does an O(n^2) test of all pairs of values in both orders\n", "    for (int i = 0; i < valuesInExpectedOrder.size(); i++) {\n", "      T t = valuesInExpectedOrder.get(i);\n", "\n", "      for (int j = 0; j < i; j++) {\n", "        T lesser = valuesInExpectedOrder.get(j);\n", "        assertTrue(lesser + \".compareTo(\" + t + ')', lesser.compareTo(t) < 0);\n", "        assertFalse(lesser.equals(t));\n", "      }\n", "\n", "      assertEquals(t + \".compareTo(\" + t + ')', 0, t.compareTo(t));\n", "      assertTrue(t.equals(t));\n", "\n", "      for (int j = i + 1; j < valuesInExpectedOrder.size(); j++) {\n", "        T greater = valuesInExpectedOrder.get(j);\n", "        assertTrue(greater + \".compareTo(\" + t + ')', greater.compareTo(t) > 0);\n", "        assertFalse(greater.equals(t));\n", "      }\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Returns a collection that simulates concurrent modification by\n", "   * having its size method return incorrect values.  This is useful\n", "   * for testing methods that must treat the return value from size()\n", "   * as a hint only.\n", "   *\n", "   * @param delta the difference between the true size of the\n", "   * collection and the values returned by the size method\n", "   */\n", "  public static <T> Collection<T> misleadingSizeCollection(final int delta) {\n", "    // It would be nice to be able to return a real concurrent\n", "    // collection like ConcurrentLinkedQueue, so that e.g. concurrent\n", "    // iteration would work, but that would not be GWT-compatible.\n", "    return new ArrayList<T>() {\n", "      @Override public int size() { return Math.max(0, super.size() + delta); }\n", "    };\n", "  }\n", "\n", "  /**\n", "   * Returns a \"nefarious\" map entry with the specified key and value,\n", "   * meaning an entry that is suitable for testing that map entries cannot be\n", "   * modified via a nefarious implementation of equals. This is used for testing\n", "   * unmodifiable collections of map entries; for example, it should not be\n", "   * possible to access the raw (modifiable) map entry via a nefarious equals\n", "   * method.\n", "   */\n", "  public static <K, V> Map.Entry<K, V> nefariousMapEntry(final K key,\n", "      final V value) {\n", "    return new Map.Entry<K, V>() {\n", "      @Override public K getKey() {\n", "        return key;\n", "      }\n", "      @Override public V getValue() {\n", "        return value;\n", "      }\n", "      @Override public V setValue(V value) {\n", "        throw new UnsupportedOperationException();\n", "      }\n", "      @SuppressWarnings(\"unchecked\")\n", "      @Override public boolean equals(Object o) {\n", "        if (o instanceof Map.Entry) {\n", "          Map.Entry<K, V> e = (Map.Entry<K, V>) o;\n", "          e.setValue(value); // muhahaha!\n", "\n", "          return equal(this.getKey(), e.getKey())\n", "              && equal(this.getValue(), e.getValue());\n", "        }\n", "        return false;\n", "      }\n", "\n", "      @Override public int hashCode() {\n", "        K k = getKey();\n", "        V v = getValue();\n", "        return ((k == null) ?\n", "            0 : k.hashCode()) ^ ((v == null) ? 0 : v.hashCode());\n", "      }\n", "\n", "      /**\n", "       * Returns a string representation of the form <code>{key}={value}</code>.\n", "       */\n", "      @Override public String toString() {\n", "        return getKey() + \"=\" + getValue();\n", "      }\n", "    };\n", "  }\n", "\n", "  static <E> List<E> castOrCopyToList(Iterable<E> iterable) {\n", "    if (iterable instanceof List) {\n", "      return (List<E>) iterable;\n", "    }\n", "    List<E> list = new ArrayList<E>();\n", "    for (E e : iterable) {\n", "      list.add(e);\n", "    }\n", "    return list;\n", "  }\n", "\n", "  private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\n", "    @SuppressWarnings(\"unchecked\") // assume any Comparable is Comparable<Self>\n", "    @Override public int compare(Comparable left, Comparable right) {\n", "      return left.compareTo(right);\n", "    }\n", "  };\n", "\n", "  public static <K extends Comparable, V> Iterable<Entry<K, V>> orderEntriesByKey(\n", "      List<Entry<K, V>> insertionOrder) {\n", "    sort(insertionOrder, Helpers.<K, V>entryComparator(NATURAL_ORDER));\n", "    return insertionOrder;\n", "  }\n", "\n", "  /**\n", "   * Private replacement for {@link com.google.gwt.user.client.rpc.GwtTransient} to work around\n", "   * build-system quirks.\n", "   */\n", "  private @interface GwtTransient {}\n", "\n", "  /**\n", "   * Compares strings in natural order except that null comes immediately before a given value. This\n", "   * works better than Ordering.natural().nullsFirst() because, if null comes before all other\n", "   * values, it lies outside the submap/submultiset ranges we test, and the variety of tests that\n", "   * exercise null handling fail on those subcollections.\n", "   */\n", "  public abstract static class NullsBefore implements Comparator<String>, Serializable {\n", "    /*\n", "     * We don't serialize this class in GWT, so we don't care about whether GWT will serialize this\n", "     * field.\n", "     */\n", "    @GwtTransient private final String justAfterNull;\n", "\n", "    protected NullsBefore(String justAfterNull) {\n", "      if (justAfterNull == null) {\n", "        throw new NullPointerException();\n", "      }\n", "\n", "      this.justAfterNull = justAfterNull;\n", "    }\n", "\n", "    @Override\n", "    public int compare(String lhs, String rhs) {\n", "      if (lhs == rhs) {\n", "        return 0;\n", "      }\n", "      if (lhs == null) {\n", "        // lhs (null) comes just before justAfterNull.\n", "        // If rhs is b, lhs comes first.\n", "        if (rhs.equals(justAfterNull)) {\n", "          return -1;\n", "        }\n", "        return justAfterNull.compareTo(rhs);\n", "      }\n", "      if (rhs == null) {\n", "        // rhs (null) comes just before justAfterNull.\n", "        // If lhs is b, rhs comes first.\n", "        if (lhs.equals(justAfterNull)) {\n", "          return 1;\n", "        }\n", "        return lhs.compareTo(justAfterNull);\n", "      }\n", "      return lhs.compareTo(rhs);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "      if (obj instanceof NullsBefore) {\n", "        NullsBefore other = (NullsBefore) obj;\n", "        return justAfterNull.equals(other.justAfterNull);\n", "      }\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "      return justAfterNull.hashCode();\n", "    }\n", "  }\n", "\n", "  public static final class NullsBeforeB extends NullsBefore {\n", "    public static final NullsBeforeB INSTANCE = new NullsBeforeB();\n", "\n", "    private NullsBeforeB() {\n", "      super(\"b\");\n", "    }\n", "  }\n", "\n", "  public static final class NullsBeforeTwo extends NullsBefore {\n", "    public static final NullsBeforeTwo INSTANCE = new NullsBeforeTwo();\n", "\n", "    private NullsBeforeTwo() {\n", "      super(\"two\"); // from TestStringSortedMapGenerator's sample keys\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500]}}, {"152": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/CollectionAddAllTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION;\n", "import static com.google.common.collect.testing.features.CollectionFeature.RESTRICTS_ELEMENTS;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ADD;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static java.util.Collections.singletonList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.MinimalCollection;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "\n", "/**\n", " * A generic JUnit test which tests addAll operations on a collection. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " * @author Kevin Bourrillion\n", " */\n", "@SuppressWarnings(\"unchecked\") // too many \"unchecked generic array creations\"\n", "@GwtCompatible(emulated = true)\n", "public class CollectionAddAllTester<E> extends AbstractCollectionTester<E> {\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testAddAll_supportedNothing() {\n", "    assertFalse(\"addAll(nothing) should return false\",\n", "        collection.addAll(emptyCollection()));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  public void testAddAll_unsupportedNothing() {\n", "    try {\n", "      assertFalse(\"addAll(nothing) should return false or throw\",\n", "          collection.addAll(emptyCollection()));\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testAddAll_supportedNonePresent() {\n", "    assertTrue(\"addAll(nonePresent) should return true\",\n", "        collection.addAll(createDisjointCollection()));\n", "    expectAdded(e3(), e4());\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  public void testAddAll_unsupportedNonePresent() {\n", "    try {\n", "      collection.addAll(createDisjointCollection());\n", "      fail(\"addAll(nonePresent) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectMissing(e3(), e4());\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAddAll_supportedSomePresent() {\n", "    assertTrue(\"addAll(somePresent) should return true\",\n", "        collection.addAll(MinimalCollection.of(e3(), e0())));\n", "    assertTrue(\"should contain \" + e3(), collection.contains(e3()));\n", "    assertTrue(\"should contain \" + e0(), collection.contains(e0()));\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAddAll_unsupportedSomePresent() {\n", "    try {\n", "      collection.addAll(MinimalCollection.of(e3(), e0()));\n", "      fail(\"addAll(somePresent) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require({SUPPORTS_ADD,\n", "      FAILS_FAST_ON_CONCURRENT_MODIFICATION})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAddAllConcurrentWithIteration() {\n", "    try {\n", "      Iterator<E> iterator = collection.iterator();\n", "      assertTrue(collection.addAll(MinimalCollection.of(e3(), e0())));\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAddAll_unsupportedAllPresent() {\n", "    try {\n", "      assertFalse(\"addAll(allPresent) should return false or throw\",\n", "          collection.addAll(MinimalCollection.of(e0())));\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require(value = {SUPPORTS_ADD,\n", "      ALLOWS_NULL_VALUES}, absent = RESTRICTS_ELEMENTS)\n", "  public void testAddAll_nullSupported() {\n", "    List<E> containsNull = singletonList(null);\n", "    assertTrue(\"addAll(containsNull) should return true\", collection\n", "        .addAll(containsNull));\n", "    /*\n", "     * We need (E) to force interpretation of null as the single element of a\n", "     * varargs array, not the array itself\n", "     */\n", "    expectAdded((E) null);\n", "  }\n", "\n", "  @CollectionFeature.Require(value = SUPPORTS_ADD,\n", "      absent = ALLOWS_NULL_VALUES)\n", "  public void testAddAll_nullUnsupported() {\n", "    List<E> containsNull = singletonList(null);\n", "    try {\n", "      collection.addAll(containsNull);\n", "      fail(\"addAll(containsNull) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullMissingWhenNullUnsupported(\n", "        \"Should not contain null after unsupported addAll(containsNull)\");\n", "  }\n", "\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testAddAll_nullCollectionReference() {\n", "    try {\n", "      collection.addAll(null);\n", "      fail(\"addAll(null) should throw NullPointerException\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163]}}, {"153": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/CollectionAddTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION;\n", "import static com.google.common.collect.testing.features.CollectionFeature.RESTRICTS_ELEMENTS;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ADD;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code add} operations on a collection.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " * @author Kevin Bourrillion\n", " */\n", "@SuppressWarnings(\"unchecked\") // too many \"unchecked generic array creations\"\n", "@GwtCompatible(emulated = true)\n", "public class CollectionAddTester<E> extends AbstractCollectionTester<E> {\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  public void testAdd_supportedNotPresent() {\n", "    assertTrue(\"add(notPresent) should return true\",\n", "        collection.add(e3()));\n", "    expectAdded(e3());\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  public void testAdd_unsupportedNotPresent() {\n", "    try {\n", "      collection.add(e3());\n", "      fail(\"add(notPresent) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectMissing(e3());\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAdd_unsupportedPresent() {\n", "    try {\n", "      assertFalse(\"add(present) should return false or throw\",\n", "          collection.add(e0()));\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require(\n", "      value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES},\n", "      absent = RESTRICTS_ELEMENTS)\n", "  public void testAdd_nullSupported() {\n", "    assertTrue(\"add(null) should return true\", collection.add(null));\n", "    expectAdded((E) null);\n", "  }\n", "\n", "  @CollectionFeature.Require(value = SUPPORTS_ADD,\n", "      absent = ALLOWS_NULL_VALUES)\n", "  public void testAdd_nullUnsupported() {\n", "    try {\n", "      collection.add(null);\n", "      fail(\"add(null) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullMissingWhenNullUnsupported(\n", "        \"Should not contain null after unsupported add(null)\");\n", "  }\n", "\n", "  @CollectionFeature.Require({SUPPORTS_ADD,\n", "      FAILS_FAST_ON_CONCURRENT_MODIFICATION})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAddConcurrentWithIteration() {\n", "    try {\n", "      Iterator<E> iterator = collection.iterator();\n", "      assertTrue(collection.add(e3()));\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108]}}, {"154": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/CollectionCreationTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "/**\n", " * A generic JUnit test which tests creation (typically through a constructor or\n", " * static factory method) of a collection. Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CollectionCreationTester<E> extends AbstractCollectionTester<E> {\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCreateWithNull_supported() {\n", "    E[] array = createArrayWithNullElement();\n", "    collection = getSubjectGenerator().create(array);\n", "    expectContents(array);\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCreateWithNull_unsupported() {\n", "    E[] array = createArrayWithNullElement();\n", "\n", "    try {\n", "      getSubjectGenerator().create(array);\n", "      fail(\"Creating a collection containing null should fail\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56]}}, {"155": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/CollectionIteratorTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;\n", "import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ITERATOR_REMOVE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.IteratorFeature;\n", "import com.google.common.collect.testing.IteratorTester;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "import java.util.NoSuchElementException;\n", "import java.util.Set;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code iterator} operations on a collection.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CollectionIteratorTester<E> extends AbstractCollectionTester<E> {\n", "  public void testIterator() {\n", "    List<E> iteratorElements = new ArrayList<E>();\n", "    for (E element : collection) { // uses iterator()\n", "      iteratorElements.add(element);\n", "    }\n", "    Helpers.assertEqualIgnoringOrder(\n", "        Arrays.asList(createSamplesArray()), iteratorElements);\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testIterationOrdering() {\n", "    List<E> iteratorElements = new ArrayList<E>();\n", "    for (E element : collection) { // uses iterator()\n", "      iteratorElements.add(element);\n", "    }\n", "    List<E> expected = Helpers.copyToList(getOrderedElements());\n", "    assertEquals(\"Different ordered iteration\", expected, iteratorElements);\n", "  }\n", "\n", "  // TODO: switch to DerivedIteratorTestSuiteBuilder\n", "\n", "  @CollectionFeature.Require({KNOWN_ORDER, SUPPORTS_ITERATOR_REMOVE})\n", "  public void testIterator_knownOrderRemoveSupported() {\n", "    runIteratorTest(MODIFIABLE, IteratorTester.KnownOrder.KNOWN_ORDER,\n", "        getOrderedElements());\n", "  }\n", "\n", "  @CollectionFeature.Require(value = KNOWN_ORDER, absent = SUPPORTS_ITERATOR_REMOVE)\n", "  public void testIterator_knownOrderRemoveUnsupported() {\n", "    runIteratorTest(UNMODIFIABLE, IteratorTester.KnownOrder.KNOWN_ORDER,\n", "        getOrderedElements());\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = KNOWN_ORDER, value = SUPPORTS_ITERATOR_REMOVE)\n", "  public void testIterator_unknownOrderRemoveSupported() {\n", "    runIteratorTest(MODIFIABLE, IteratorTester.KnownOrder.UNKNOWN_ORDER,\n", "        getSampleElements());\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = {KNOWN_ORDER, SUPPORTS_ITERATOR_REMOVE})\n", "  public void testIterator_unknownOrderRemoveUnsupported() {\n", "    runIteratorTest(UNMODIFIABLE, IteratorTester.KnownOrder.UNKNOWN_ORDER,\n", "        getSampleElements());\n", "  }\n", "\n", "  private void runIteratorTest(Set<IteratorFeature> features,\n", "      IteratorTester.KnownOrder knownOrder, Iterable<E> elements) {\n", "    new IteratorTester<E>(Platform.collectionIteratorTesterNumIterations(), features, elements,\n", "        knownOrder) {\n", "      @Override protected Iterator<E> newTargetIterator() {\n", "        resetCollection();\n", "        return collection.iterator();\n", "      }\n", "\n", "      @Override protected void verify(List<E> elements) {\n", "        expectContents(elements);\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  public void testIteratorNoSuchElementException() {\n", "    Iterator<E> iterator = collection.iterator();\n", "    while (iterator.hasNext()) {\n", "      iterator.next();\n", "    }\n", "\n", "    try {\n", "      iterator.next();\n", "      fail(\"iterator.next() should throw NoSuchElementException\");\n", "    } catch (NoSuchElementException expected) {}\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]}}, {"156": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/CollectionToArrayTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractCollectionTester;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.WrongType;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "import java.util.Arrays;\n", "import java.util.List;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code toArray()} operations on a\n", " * collection. Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.\n", " *\n", " * @author Kevin Bourrillion\n", " * @author Chris Povirk\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CollectionToArrayTester<E> extends AbstractCollectionTester<E> {\n", "  public void testToArray_noArgs() {\n", "    Object[] array = collection.toArray();\n", "    expectArrayContentsAnyOrder(createSamplesArray(), array);\n", "  }\n", "\n", "  /**\n", "   * {@link Collection#toArray(Object[])} says: \"Note that\n", "   * <tt>toArray(new Object[0])</tt> is identical in function to\n", "   * <tt>toArray()</tt>.\"\n", "   *\n", "   * <p>For maximum effect, the collection under test should be created from an\n", "   * element array of a type other than {@code Object[]}.\n", "   */\n", "  public void testToArray_isPlainObjectArray() {\n", "    Object[] array = collection.toArray();\n", "    assertEquals(Object[].class, array.getClass());\n", "  }\n", "\n", "  public void testToArray_emptyArray() {\n", "    E[] empty = getSubjectGenerator().createArray(0);\n", "    E[] array = collection.toArray(empty);\n", "    assertEquals(\"toArray(emptyT[]) should return an array of type T\",\n", "        empty.getClass(), array.getClass());\n", "    assertEquals(\"toArray(emptyT[]).length:\", getNumElements(), array.length);\n", "    expectArrayContentsAnyOrder(createSamplesArray(), array);\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testToArray_emptyArray_ordered() {\n", "    E[] empty = getSubjectGenerator().createArray(0);\n", "    E[] array = collection.toArray(empty);\n", "    assertEquals(\"toArray(emptyT[]) should return an array of type T\",\n", "        empty.getClass(), array.getClass());\n", "    assertEquals(\"toArray(emptyT[]).length:\", getNumElements(), array.length);\n", "    expectArrayContentsInOrder(getOrderedElements(), array);\n", "  }\n", "\n", "  public void testToArray_emptyArrayOfObject() {\n", "    Object[] in = new Object[0];\n", "    Object[] array = collection.toArray(in);\n", "    assertEquals(\"toArray(emptyObject[]) should return an array of type Object\",\n", "        Object[].class, array.getClass());\n", "    assertEquals(\"toArray(emptyObject[]).length\",\n", "        getNumElements(), array.length);\n", "    expectArrayContentsAnyOrder(createSamplesArray(), array);\n", "  }\n", "\n", "  public void testToArray_rightSizedArray() {\n", "    E[] array = getSubjectGenerator().createArray(getNumElements());\n", "    assertSame(\"toArray(sameSizeE[]) should return the given array\",\n", "        array, collection.toArray(array));\n", "    expectArrayContentsAnyOrder(createSamplesArray(), array);\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testToArray_rightSizedArray_ordered() {\n", "    E[] array = getSubjectGenerator().createArray(getNumElements());\n", "    assertSame(\"toArray(sameSizeE[]) should return the given array\",\n", "        array, collection.toArray(array));\n", "    expectArrayContentsInOrder(getOrderedElements(), array);\n", "  }\n", "\n", "  public void testToArray_rightSizedArrayOfObject() {\n", "    Object[] array = new Object[getNumElements()];\n", "    assertSame(\"toArray(sameSizeObject[]) should return the given array\",\n", "        array, collection.toArray(array));\n", "    expectArrayContentsAnyOrder(createSamplesArray(), array);\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testToArray_rightSizedArrayOfObject_ordered() {\n", "    Object[] array = new Object[getNumElements()];\n", "    assertSame(\"toArray(sameSizeObject[]) should return the given array\",\n", "        array, collection.toArray(array));\n", "    expectArrayContentsInOrder(getOrderedElements(), array);\n", "  }\n", "\n", "  public void testToArray_oversizedArray() {\n", "    E[] array = getSubjectGenerator().createArray(getNumElements() + 2);\n", "    array[getNumElements()] = e3();\n", "    array[getNumElements() + 1] = e3();\n", "    assertSame(\"toArray(overSizedE[]) should return the given array\",\n", "        array, collection.toArray(array));\n", "\n", "    List<E> subArray = Arrays.asList(array).subList(0, getNumElements());\n", "    E[] expectedSubArray = createSamplesArray();\n", "    for (int i = 0; i < getNumElements(); i++) {\n", "      assertTrue(\n", "          \"toArray(overSizedE[]) should contain element \" + expectedSubArray[i],\n", "          subArray.contains(expectedSubArray[i]));\n", "    }\n", "    assertNull(\"The array element \"\n", "        + \"immediately following the end of the collection should be nulled\",\n", "        array[getNumElements()]);\n", "    // array[getNumElements() + 1] might or might not have been nulled\n", "  }\n", "\n", "  @CollectionFeature.Require(KNOWN_ORDER)\n", "  public void testToArray_oversizedArray_ordered() {\n", "    E[] array = getSubjectGenerator().createArray(getNumElements() + 2);\n", "    array[getNumElements()] = e3();\n", "    array[getNumElements() + 1] = e3();\n", "    assertSame(\"toArray(overSizedE[]) should return the given array\",\n", "        array, collection.toArray(array));\n", "\n", "    List<E> expected = getOrderedElements();\n", "    for (int i = 0; i < getNumElements(); i++) {\n", "      assertEquals(expected.get(i), array[i]);\n", "    }\n", "    assertNull(\"The array element \"\n", "        + \"immediately following the end of the collection should be nulled\",\n", "        array[getNumElements()]);\n", "    // array[getNumElements() + 1] might or might not have been nulled\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testToArray_emptyArrayOfWrongTypeForNonEmptyCollection() {\n", "    try {\n", "      WrongType[] array = new WrongType[0];\n", "      collection.toArray(array);\n", "      fail(\"toArray(notAssignableTo[]) should throw\");\n", "    } catch (ArrayStoreException expected) {\n", "    }\n", "  }\n", "\n", "  @CollectionSize.Require(ZERO)\n", "  public void testToArray_emptyArrayOfWrongTypeForEmptyCollection() {\n", "    WrongType[] array = new WrongType[0];\n", "    assertSame(\n", "        \"toArray(sameSizeNotAssignableTo[]) should return the given array\",\n", "        array, collection.toArray(array));\n", "  }\n", "\n", "  private void expectArrayContentsAnyOrder(Object[] expected, Object[] actual) {\n", "    Helpers.assertEqualIgnoringOrder(\n", "        Arrays.asList(expected), Arrays.asList(actual));\n", "  }\n", "\n", "  private void expectArrayContentsInOrder(List<E> expected, Object[] actual) {\n", "    assertEquals(\"toArray() ordered contents: \",\n", "        expected, Arrays.asList(actual));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185]}}, {"157": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/ListAddAtIndexTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION;\n", "import static com.google.common.collect.testing.features.CollectionSize.ONE;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_ADD_WITH_INDEX;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.ListFeature;\n", "\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code add(int, Object)} operations on a\n", " * list. Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.ListTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " */\n", "@SuppressWarnings(\"unchecked\") // too many \"unchecked generic array creations\"\n", "@GwtCompatible(emulated = true)\n", "public class ListAddAtIndexTester<E> extends AbstractListTester<E> {\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAddAtIndex_supportedPresent() {\n", "    getList().add(0, e0());\n", "    expectAdded(0, e0());\n", "  }\n", "\n", "  @ListFeature.Require(absent = SUPPORTS_ADD_WITH_INDEX)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  /*\n", "   * absent = ZERO isn't required, since unmodList.add() must\n", "   * throw regardless, but it keeps the method name accurate.\n", "   */\n", "  public void testAddAtIndex_unsupportedPresent() {\n", "    try {\n", "      getList().add(0, e0());\n", "      fail(\"add(n, present) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  public void testAddAtIndex_supportedNotPresent() {\n", "    getList().add(0, e3());\n", "    expectAdded(0, e3());\n", "  }\n", "\n", "  @CollectionFeature.Require(FAILS_FAST_ON_CONCURRENT_MODIFICATION)\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  public void testAddAtIndexConcurrentWithIteration() {\n", "    try {\n", "      Iterator<E> iterator = collection.iterator();\n", "      getList().add(0, e3());\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @ListFeature.Require(absent = SUPPORTS_ADD_WITH_INDEX)\n", "  public void testAddAtIndex_unsupportedNotPresent() {\n", "    try {\n", "      getList().add(0, e3());\n", "      fail(\"add(n, notPresent) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectMissing(e3());\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testAddAtIndex_middle() {\n", "    getList().add(getNumElements() / 2, e3());\n", "    expectAdded(getNumElements() / 2, e3());\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAddAtIndex_end() {\n", "    getList().add(getNumElements(), e3());\n", "    expectAdded(getNumElements(), e3());\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  public void testAddAtIndex_nullSupported() {\n", "    getList().add(0, null);\n", "    expectAdded(0, (E) null);\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  @CollectionFeature.Require(absent = ALLOWS_NULL_VALUES)\n", "  public void testAddAtIndex_nullUnsupported() {\n", "    try {\n", "      getList().add(0, null);\n", "      fail(\"add(n, null) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullMissingWhenNullUnsupported(\n", "        \"Should not contain null after unsupported add(n, null)\");\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  public void testAddAtIndex_negative() {\n", "    try {\n", "      getList().add(-1, e3());\n", "      fail(\"add(-1, e) should throw\");\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectMissing(e3());\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  public void testAddAtIndex_tooLarge() {\n", "    try {\n", "      getList().add(getNumElements() + 1, e3());\n", "      fail(\"add(size + 1, e) should throw\");\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectMissing(e3());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151]}}, {"158": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/ListAddTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ADD;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code add(Object)} operations on a list.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.ListTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " */\n", "@SuppressWarnings(\"unchecked\") // too many \"unchecked generic array creations\"\n", "@GwtCompatible(emulated = true)\n", "public class ListAddTester<E> extends AbstractListTester<E> {\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAdd_supportedPresent() {\n", "    assertTrue(\"add(present) should return true\", getList().add(e0()));\n", "    expectAdded(e0());\n", "  }\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_ADD)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  /*\n", "   * absent = ZERO isn't required, since unmodList.add() must\n", "   * throw regardless, but it keeps the method name accurate.\n", "   */\n", "  public void testAdd_unsupportedPresent() {\n", "    try {\n", "      getList().add(e0());\n", "      fail(\"add(present) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "  }\n", "\n", "  @CollectionFeature.Require(value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAdd_supportedNullPresent() {\n", "    E[] array = createArrayWithNullElement();\n", "    collection = getSubjectGenerator().create(array);\n", "    assertTrue(\"add(nullPresent) should return true\", getList().add(null));\n", "\n", "    List<E> expected = Helpers.copyToList(array);\n", "    expected.add(null);\n", "    expectContents(expected);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73]}}, {"159": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/ListHashCodeTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "/**\n", " * Tests {@link java.util.List#hashCode}.\n", " *\n", " * @author George van den Driessche\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ListHashCodeTester<E> extends AbstractListTester<E> {\n", "  public void testHashCode() {\n", "    int expectedHashCode = 1;\n", "    for (E element : getOrderedElements()) {\n", "      expectedHashCode = 31 * expectedHashCode +\n", "          ((element == null) ? 0 : element.hashCode());\n", "    }\n", "    assertEquals(\n", "        \"A List's hashCode() should be computed from those of its elements.\",\n", "        expectedHashCode, getList().hashCode());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]}}, {"160": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/ListListIteratorTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;\n", "import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_REMOVE;\n", "import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_ADD_WITH_INDEX;\n", "import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_SET;\n", "import static com.google.common.collect.testing.testers.Platform.listListIteratorTesterNumIterations;\n", "import static java.util.Collections.singleton;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.IteratorFeature;\n", "import com.google.common.collect.testing.ListIteratorTester;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.ListFeature;\n", "\n", "import java.util.List;\n", "import java.util.ListIterator;\n", "import java.util.Set;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code listIterator} operations on a list.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.ListTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ListListIteratorTester<E> extends AbstractListTester<E> {\n", "  // TODO: switch to DerivedIteratorTestSuiteBuilder\n", "\n", "  @CollectionFeature.Require(absent = SUPPORTS_REMOVE)\n", "  @ListFeature.Require(absent = {SUPPORTS_SET, SUPPORTS_ADD_WITH_INDEX})\n", "  public void testListIterator_unmodifiable() {\n", "    runListIteratorTest(UNMODIFIABLE);\n", "  }\n", "\n", "  /*\n", "   * For now, we don't cope with testing this when the list supports only some\n", "   * modification operations.\n", "   */\n", "  @CollectionFeature.Require(SUPPORTS_REMOVE)\n", "  @ListFeature.Require({SUPPORTS_SET, SUPPORTS_ADD_WITH_INDEX})\n", "  public void testListIterator_fullyModifiable() {\n", "    runListIteratorTest(MODIFIABLE);\n", "  }\n", "\n", "  private void runListIteratorTest(Set<IteratorFeature> features) {\n", "    new ListIteratorTester<E>(\n", "        listListIteratorTesterNumIterations(), singleton(e4()), features,\n", "        Helpers.copyToList(getOrderedElements()), 0) {\n", "      {\n", "        // TODO: don't set this universally\n", "        stopTestingWhenAddThrowsException();\n", "      }\n", "\n", "      @Override protected ListIterator<E> newTargetIterator() {\n", "        resetCollection();\n", "        return getList().listIterator();\n", "      }\n", "\n", "      @Override protected void verify(List<E> elements) {\n", "        expectContents(elements);\n", "      }\n", "    }.test();\n", "  }\n", "\n", "  public void testListIterator_tooLow() {\n", "    try {\n", "      getList().listIterator(-1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "  }\n", "\n", "  public void testListIterator_tooHigh() {\n", "    try {\n", "      getList().listIterator(getNumElements() + 1);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "  }\n", "\n", "  public void testListIterator_atSize() {\n", "    getList().listIterator(getNumElements());\n", "    // TODO: run the iterator through ListIteratorTester\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107]}}, {"161": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/ListSetTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_SET;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.ListFeature;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code set()} operations on a list. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.ListTestSuiteBuilder}.\n", " *\n", " * @author George van den Driessche\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ListSetTester<E> extends AbstractListTester<E> {\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testSet() {\n", "    doTestSet(e3());\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  public void testSet_null() {\n", "    doTestSet(null);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  public void testSet_replacingNull() {\n", "    E[] elements = createSamplesArray();\n", "    int i = aValidIndex();\n", "    elements[i] = null;\n", "    collection = getSubjectGenerator().create(elements);\n", "\n", "    doTestSet(e3());\n", "  }\n", "\n", "  private void doTestSet(E newValue) {\n", "    int index = aValidIndex();\n", "    E initialValue = getList().get(index);\n", "    assertEquals(\"set(i, x) should return the old element at position i.\",\n", "        initialValue, getList().set(index, newValue));\n", "    assertEquals(\"After set(i, x), get(i) should return x\",\n", "        newValue, getList().get(index));\n", "    assertEquals(\"set() should not change the size of a list.\",\n", "        getNumElements(), getList().size());\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  public void testSet_indexTooLow() {\n", "    try {\n", "      getList().set(-1, e3());\n", "      fail(\"set(-1) should throw IndexOutOfBoundsException\");\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  public void testSet_indexTooHigh() {\n", "    int index = getNumElements();\n", "    try {\n", "      getList().set(index, e3());\n", "      fail(\"set(size) should throw IndexOutOfBoundsException\");\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @ListFeature.Require(absent = SUPPORTS_SET)\n", "  public void testSet_unsupported() {\n", "    try {\n", "      getList().set(aValidIndex(), e3());\n", "      fail(\"set() should throw UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionSize.Require(ZERO)\n", "  @ListFeature.Require(absent = SUPPORTS_SET)\n", "  public void testSet_unsupportedByEmptyList() {\n", "    try {\n", "      getList().set(0, e3());\n", "      fail(\"set() should throw UnsupportedOperationException \"\n", "          + \"or IndexOutOfBoundsException\");\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    } catch (IndexOutOfBoundsException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionSize.Require(absent = ZERO)\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  @CollectionFeature.Require(absent = ALLOWS_NULL_VALUES)\n", "  public void testSet_nullUnsupported() {\n", "    try {\n", "      getList().set(aValidIndex(), null);\n", "      fail(\"set(null) should throw NullPointerException\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  private int aValidIndex() {\n", "    return getList().size() / 2;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134]}}, {"162": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/ListSubListTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS;\n", "import static com.google.common.collect.testing.features.CollectionSize.ONE;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_ADD_WITH_INDEX;\n", "import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_REMOVE_WITH_INDEX;\n", "import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_SET;\n", "import static java.util.Collections.emptyList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.ListFeature;\n", "import com.google.common.testing.SerializableTester;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.List;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code subList()} operations on a list.\n", " * Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.ListTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " */\n", "@SuppressWarnings(\"unchecked\") // too many \"unchecked generic array creations\"\n", "@GwtCompatible(emulated = true)\n", "public class ListSubListTester<E> extends AbstractListTester<E> {\n", "  public void testSubList_startNegative() {\n", "    try {\n", "      getList().subList(-1, 0);\n", "      fail(\"subList(-1, 0) should throw\");\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "  }\n", "\n", "  public void testSubList_endTooLarge() {\n", "    try {\n", "      getList().subList(0, getNumElements() + 1);\n", "      fail(\"subList(0, size + 1) should throw\");\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "  }\n", "\n", "  public void testSubList_startGreaterThanEnd() {\n", "    try {\n", "      getList().subList(1, 0);\n", "      fail(\"subList(1, 0) should throw\");\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    } catch (IllegalArgumentException expected) {\n", "      /*\n", "       * The subList() docs claim that this should be an\n", "       * IndexOutOfBoundsException, but many JDK implementations throw\n", "       * IllegalArgumentException:\n", "       * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4506427\n", "       */\n", "    }\n", "  }\n", "\n", "  public void testSubList_empty() {\n", "    assertEquals(\"subList(0, 0) should be empty\",\n", "        emptyList(), getList().subList(0, 0));\n", "  }\n", "\n", "  public void testSubList_entireList() {\n", "    assertEquals(\"subList(0, size) should be equal to the original list\",\n", "        getList(), getList().subList(0, getNumElements()));\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testSubList_subListRemoveAffectsOriginal() {\n", "    List<E> subList = getList().subList(0, 1);\n", "    subList.remove(0);\n", "    List<E> expected =\n", "        Arrays.asList(createSamplesArray()).subList(1, getNumElements());\n", "    expectContents(expected);\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testSubList_subListClearAffectsOriginal() {\n", "    List<E> subList = getList().subList(0, 1);\n", "    subList.clear();\n", "    List<E> expected =\n", "        Arrays.asList(createSamplesArray()).subList(1, getNumElements());\n", "    expectContents(expected);\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  public void testSubList_subListAddAffectsOriginal() {\n", "    List<E> subList = getList().subList(0, 0);\n", "    subList.add(e3());\n", "    expectAdded(0, e3());\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testSubList_subListSetAffectsOriginal() {\n", "    List<E> subList = getList().subList(0, 1);\n", "    subList.set(0, e3());\n", "    List<E> expected = Helpers.copyToList(createSamplesArray());\n", "    expected.set(0, e3());\n", "    expectContents(expected);\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testSubList_originalListSetAffectsSubList() {\n", "    List<E> subList = getList().subList(0, 1);\n", "    getList().set(0, e3());\n", "    assertEquals(\"A set() call to a list after a sublist has been created \"\n", "        + \"should be reflected in the sublist\",\n", "        Collections.singletonList(e3()), subList);\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_subListRemoveAffectsOriginalLargeList() {\n", "    List<E> subList = getList().subList(1, 3);\n", "    subList.remove(e2());\n", "    List<E> expected = Helpers.copyToList(createSamplesArray());\n", "    expected.remove(2);\n", "    expectContents(expected);\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_subListAddAtIndexAffectsOriginalLargeList() {\n", "    List<E> subList = getList().subList(2, 3);\n", "    subList.add(0, e3());\n", "    expectAdded(2, e3());\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_subListSetAffectsOriginalLargeList() {\n", "    List<E> subList = getList().subList(1, 2);\n", "    subList.set(0, e3());\n", "    List<E> expected = Helpers.copyToList(createSamplesArray());\n", "    expected.set(1, e3());\n", "    expectContents(expected);\n", "  }\n", "\n", "  @ListFeature.Require(SUPPORTS_SET)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_originalListSetAffectsSubListLargeList() {\n", "    List<E> subList = getList().subList(1, 3);\n", "    getList().set(1, e3());\n", "    assertEquals(\"A set() call to a list after a sublist has been created \"\n", "        + \"should be reflected in the sublist\",\n", "        Arrays.asList(e3(), e2()), subList);\n", "  }\n", "\n", "  public void testSubList_ofSubListEmpty() {\n", "    List<E> subList = getList().subList(0, 0).subList(0, 0);\n", "    assertEquals(\"subList(0, 0).subList(0, 0) should be an empty list\",\n", "        emptyList(), subList);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_ofSubListNonEmpty() {\n", "    List<E> subList = getList().subList(0, 2).subList(1, 2);\n", "    assertEquals(\"subList(0, 2).subList(1, 2) \"\n", "        + \"should be a single-element list of the element at index 1\",\n", "        Collections.singletonList(getOrderedElements().get(1)), subList);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = {ZERO})\n", "  public void testSubList_size() {\n", "    List<E> list = getList();\n", "    int size = getNumElements();\n", "    assertEquals(list.subList(0, size).size(),\n", "                 size);\n", "    assertEquals(list.subList(0, size - 1).size(),\n", "                 size - 1);\n", "    assertEquals(list.subList(1, size).size(),\n", "                 size - 1);\n", "    assertEquals(list.subList(size, size).size(),\n", "                 0);\n", "    assertEquals(list.subList(0, 0).size(),\n", "                 0);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = {ZERO})\n", "  public void testSubList_isEmpty() {\n", "    List<E> list = getList();\n", "    int size = getNumElements();\n", "    for (List<E> subList : Arrays.asList(\n", "        list.subList(0, size),\n", "        list.subList(0, size - 1),\n", "        list.subList(1, size),\n", "        list.subList(0, 0),\n", "        list.subList(size, size))) {\n", "      assertEquals(subList.isEmpty(), subList.size() == 0);\n", "    }\n", "  }\n", "\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_get() {\n", "    List<E> list = getList();\n", "    int size = getNumElements();\n", "    List<E> copy = list.subList(0, size);\n", "    List<E> head = list.subList(0, size - 1);\n", "    List<E> tail = list.subList(1, size);\n", "    assertEquals(list.get(0), copy.get(0));\n", "    assertEquals(list.get(size - 1), copy.get(size - 1));\n", "    assertEquals(list.get(1), tail.get(0));\n", "    assertEquals(list.get(size - 1), tail.get(size - 2));\n", "    assertEquals(list.get(0), head.get(0));\n", "    assertEquals(list.get(size - 2), head.get(size - 2));\n", "    for (List<E> subList : Arrays.asList(copy, head, tail)) {\n", "      for (int index : Arrays.asList(-1, subList.size())) {\n", "        try {\n", "          subList.get(index);\n", "          fail(\"expected IndexOutOfBoundsException\");\n", "        } catch (IndexOutOfBoundsException expected) {\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_contains() {\n", "    List<E> list = getList();\n", "    int size = getNumElements();\n", "    List<E> copy = list.subList(0, size);\n", "    List<E> head = list.subList(0, size - 1);\n", "    List<E> tail = list.subList(1, size);\n", "    assertTrue(copy.contains(list.get(0)));\n", "    assertTrue(head.contains(list.get(0)));\n", "    assertTrue(tail.contains(list.get(1)));\n", "    // The following assumes all elements are distinct.\n", "    assertTrue(copy.contains(list.get(size - 1)));\n", "    assertTrue(head.contains(list.get(size - 2)));\n", "    assertTrue(tail.contains(list.get(size - 1)));\n", "    assertFalse(head.contains(list.get(size - 1)));\n", "    assertFalse(tail.contains(list.get(0)));\n", "  }\n", "\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_indexOf() {\n", "    List<E> list = getList();\n", "    int size = getNumElements();\n", "    List<E> copy = list.subList(0, size);\n", "    List<E> head = list.subList(0, size - 1);\n", "    List<E> tail = list.subList(1, size);\n", "    assertEquals(copy.indexOf(list.get(0)),\n", "                 0);\n", "    assertEquals(head.indexOf(list.get(0)),\n", "                 0);\n", "    assertEquals(tail.indexOf(list.get(1)),\n", "                 0);\n", "    // The following assumes all elements are distinct.\n", "    assertEquals(copy.indexOf(list.get(size - 1)),\n", "                 size - 1);\n", "    assertEquals(head.indexOf(list.get(size - 2)),\n", "                 size - 2);\n", "    assertEquals(tail.indexOf(list.get(size - 1)),\n", "                 size - 2);\n", "    assertEquals(head.indexOf(list.get(size - 1)),\n", "                 -1);\n", "    assertEquals(tail.indexOf(list.get(0)),\n", "                 -1);\n", "  }\n", "\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testSubList_lastIndexOf() {\n", "    List<E> list = getList();\n", "    int size = list.size();\n", "    List<E> copy = list.subList(0, size);\n", "    List<E> head = list.subList(0, size - 1);\n", "    List<E> tail = list.subList(1, size);\n", "    assertEquals(copy.lastIndexOf(list.get(size - 1)),\n", "                 size - 1);\n", "    assertEquals(head.lastIndexOf(list.get(size - 2)),\n", "                 size - 2);\n", "    assertEquals(tail.lastIndexOf(list.get(size - 1)),\n", "                 size - 2);\n", "    // The following assumes all elements are distinct.\n", "    assertEquals(copy.lastIndexOf(list.get(0)),\n", "                 0);\n", "    assertEquals(head.lastIndexOf(list.get(0)),\n", "                 0);\n", "    assertEquals(tail.lastIndexOf(list.get(1)),\n", "                 0);\n", "    assertEquals(head.lastIndexOf(list.get(size - 1)),\n", "                 -1);\n", "    assertEquals(tail.lastIndexOf(list.get(0)),\n", "                 -1);\n", "  }\n", "\n", "  @CollectionFeature.Require(SERIALIZABLE_INCLUDING_VIEWS)\n", "  public void testReserializeWholeSubList() {\n", "    SerializableTester.reserializeAndAssert(getList().subList(0, getNumElements()));\n", "  }\n", "\n", "  @CollectionFeature.Require(SERIALIZABLE_INCLUDING_VIEWS)\n", "  public void testReserializeEmptySubList() {\n", "    SerializableTester.reserializeAndAssert(getList().subList(0, 0));\n", "  }\n", "\n", "  @CollectionFeature.Require(SERIALIZABLE_INCLUDING_VIEWS)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testReserializeSubList() {\n", "    SerializableTester.reserializeAndAssert(getList().subList(0, 2));\n", "  }\n", "\n", "  /*\n", "   * TODO: perform all List tests on subList(), but beware infinite recursion\n", "   */\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332]}}, {"163": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/MapCreationTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ONE;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.REJECTS_DUPLICATES_AT_CREATION;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * A generic JUnit test which tests creation (typically through a constructor or\n", " * static factory method) of a map. Can't be invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MapCreationTester<K, V> extends AbstractMapTester<K, V> {\n", "  @MapFeature.Require(ALLOWS_NULL_KEYS)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCreateWithNullKeySupported() {\n", "    initMapWithNullKey();\n", "    expectContents(createArrayWithNullKey());\n", "  }\n", "\n", "  @MapFeature.Require(absent = ALLOWS_NULL_KEYS)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCreateWithNullKeyUnsupported() {\n", "    try {\n", "      initMapWithNullKey();\n", "      fail(\"Creating a map containing a null key should fail\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require(ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCreateWithNullValueSupported() {\n", "    initMapWithNullValue();\n", "    expectContents(createArrayWithNullValue());\n", "  }\n", "\n", "  @MapFeature.Require(absent = ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCreateWithNullValueUnsupported() {\n", "    try {\n", "      initMapWithNullValue();\n", "      fail(\"Creating a map containing a null value should fail\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require({ALLOWS_NULL_KEYS, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testCreateWithNullKeyAndValueSupported() {\n", "    Entry<K, V>[] entries = createSamplesArray();\n", "    entries[getNullLocation()] = entry(null, null);\n", "    resetMap(entries);\n", "    expectContents(entries);\n", "  }\n", "\n", "  @MapFeature.Require(value = ALLOWS_NULL_KEYS,\n", "      absent = REJECTS_DUPLICATES_AT_CREATION)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testCreateWithDuplicates_nullDuplicatesNotRejected() {\n", "    expectFirstRemoved(getEntriesMultipleNullKeys());\n", "  }\n", "\n", "  @MapFeature.Require(absent = REJECTS_DUPLICATES_AT_CREATION)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testCreateWithDuplicates_nonNullDuplicatesNotRejected() {\n", "    expectFirstRemoved(getEntriesMultipleNonNullKeys());\n", "  }\n", "\n", "  @MapFeature.Require({ALLOWS_NULL_KEYS, REJECTS_DUPLICATES_AT_CREATION})\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testCreateWithDuplicates_nullDuplicatesRejected() {\n", "    Entry<K, V>[] entries = getEntriesMultipleNullKeys();\n", "    try {\n", "      resetMap(entries);\n", "      fail(\"Should reject duplicate null elements at creation\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require(REJECTS_DUPLICATES_AT_CREATION)\n", "  @CollectionSize.Require(absent = {ZERO, ONE})\n", "  public void testCreateWithDuplicates_nonNullDuplicatesRejected() {\n", "    Entry<K, V>[] entries = getEntriesMultipleNonNullKeys();\n", "    try {\n", "      resetMap(entries);\n", "      fail(\"Should reject duplicate non-null elements at creation\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  private Entry<K, V>[] getEntriesMultipleNullKeys() {\n", "    Entry<K, V>[] entries = createArrayWithNullKey();\n", "    entries[0] = entry(null, entries[0].getValue());\n", "    return entries;\n", "  }\n", "\n", "  private Entry<K, V>[] getEntriesMultipleNonNullKeys() {\n", "    Entry<K, V>[] entries = createSamplesArray();\n", "    entries[0] = entry(k1(), v0());\n", "    return entries;\n", "  }\n", "\n", "  private void expectFirstRemoved(Entry<K, V>[] entries) {\n", "    resetMap(entries);\n", "\n", "    List<Entry<K, V>> expectedWithDuplicateRemoved =\n", "        Arrays.asList(entries).subList(1, getNumElements());\n", "    expectContents(expectedWithDuplicateRemoved);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142]}}, {"164": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/MapPutAllTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "import static java.util.Collections.singletonList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.MinimalCollection;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "\n", "import java.util.Collections;\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "import java.util.LinkedHashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code putAll} operations on a map. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " * @author Kevin Bourrillion\n", " */\n", "@SuppressWarnings(\"unchecked\") // too many \"unchecked generic array creations\"\n", "@GwtCompatible(emulated = true)\n", "public class MapPutAllTester<K, V> extends AbstractMapTester<K, V> {\n", "  private List<Entry<K, V>> containsNullKey;\n", "  private List<Entry<K, V>> containsNullValue;\n", "\n", "  @Override public void setUp() throws Exception {\n", "    super.setUp();\n", "    containsNullKey = singletonList(entry(null, v3()));\n", "    containsNullValue = singletonList(entry(k3(), null));\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testPutAll_supportedNothing() {\n", "    getMap().putAll(emptyMap());\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testPutAll_unsupportedNothing() {\n", "    try {\n", "      getMap().putAll(emptyMap());\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testPutAll_supportedNonePresent() {\n", "    putAll(createDisjointCollection());\n", "    expectAdded(e3(), e4());\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testPutAll_unsupportedNonePresent() {\n", "    try {\n", "      putAll(createDisjointCollection());\n", "      fail(\"putAll(nonePresent) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectMissing(e3(), e4());\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutAll_supportedSomePresent() {\n", "    putAll(MinimalCollection.of(e3(), e0()));\n", "    expectAdded(e3());\n", "  }\n", "\n", "  @MapFeature.Require({ FAILS_FAST_ON_CONCURRENT_MODIFICATION,\n", "      SUPPORTS_PUT })\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutAllSomePresentConcurrentWithEntrySetIteration() {\n", "    try {\n", "      Iterator<Entry<K, V>> iterator = getMap().entrySet().iterator();\n", "      putAll(MinimalCollection.of(e3(), e0()));\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutAll_unsupportedSomePresent() {\n", "    try {\n", "      putAll(MinimalCollection.of(e3(), e0()));\n", "      fail(\"putAll(somePresent) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutAll_unsupportedAllPresent() {\n", "    try {\n", "      putAll(MinimalCollection.of(e0()));\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT,\n", "      ALLOWS_NULL_KEYS})\n", "  public void testPutAll_nullKeySupported() {\n", "    putAll(containsNullKey);\n", "    expectAdded(containsNullKey.get(0));\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT,\n", "      absent = ALLOWS_NULL_KEYS)\n", "  public void testPutAll_nullKeyUnsupported() {\n", "    try {\n", "      putAll(containsNullKey);\n", "      fail(\"putAll(containsNullKey) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullKeyMissingWhenNullKeysUnsupported(\n", "        \"Should not contain null key after unsupported \" +\n", "        \"putAll(containsNullKey)\");\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT,\n", "      ALLOWS_NULL_VALUES})\n", "  public void testPutAll_nullValueSupported() {\n", "    putAll(containsNullValue);\n", "    expectAdded(containsNullValue.get(0));\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT,\n", "      absent = ALLOWS_NULL_VALUES)\n", "  public void testPutAll_nullValueUnsupported() {\n", "    try {\n", "      putAll(containsNullValue);\n", "      fail(\"putAll(containsNullValue) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullValueMissingWhenNullValuesUnsupported(\n", "        \"Should not contain null value after unsupported \" +\n", "        \"putAll(containsNullValue)\");\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testPutAll_nullCollectionReference() {\n", "    try {\n", "      getMap().putAll(null);\n", "      fail(\"putAll(null) should throw NullPointerException\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  private Map<K, V> emptyMap() {\n", "    return Collections.emptyMap();\n", "  }\n", "\n", "  private void putAll(Iterable<Entry<K, V>> entries) {\n", "    Map<K, V> map = new LinkedHashMap<K, V>();\n", "    for (Entry<K, V> entry : entries) {\n", "      map.put(entry.getKey(), entry.getValue());\n", "    }\n", "    getMap().putAll(map);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197]}}, {"165": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/MapPutTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;\n", "import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.MapFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION;\n", "import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.AbstractMapTester;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "import com.google.common.collect.testing.features.MapFeature;\n", "\n", "import java.util.ConcurrentModificationException;\n", "import java.util.Iterator;\n", "import java.util.Map;\n", "import java.util.Map.Entry;\n", "\n", "/**\n", " * A generic JUnit test which tests {@code put} operations on a map. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.MapTestSuiteBuilder}.\n", " *\n", " * @author Chris Povirk\n", " * @author Kevin Bourrillion\n", " */\n", "@SuppressWarnings(\"unchecked\") // too many \"unchecked generic array creations\"\n", "@GwtCompatible(emulated = true)\n", "public class MapPutTester<K, V> extends AbstractMapTester<K, V> {\n", "  private Entry<K, V> nullKeyEntry;\n", "  private Entry<K, V> nullValueEntry;\n", "  private Entry<K, V> nullKeyValueEntry;\n", "  private Entry<K, V> presentKeyNullValueEntry;\n", "\n", "  @Override public void setUp() throws Exception {\n", "    super.setUp();\n", "    nullKeyEntry = entry(null, v3());\n", "    nullValueEntry = entry(k3(), null);\n", "    nullKeyValueEntry = entry(null, null);\n", "    presentKeyNullValueEntry = entry(k0(), null);\n", "  }\n", "\n", "  @MapFeature.Require(SUPPORTS_PUT)\n", "  public void testPut_supportedNotPresent() {\n", "    assertNull(\"put(notPresent, value) should return null\", put(e3()));\n", "    expectAdded(e3());\n", "  }\n", "\n", "  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutAbsentConcurrentWithEntrySetIteration() {\n", "    try {\n", "      Iterator<Entry<K, V>> iterator = getMap().entrySet().iterator();\n", "      put(e3());\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutAbsentConcurrentWithKeySetIteration() {\n", "    try {\n", "      Iterator<K> iterator = getMap().keySet().iterator();\n", "      put(e3());\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPutAbsentConcurrentWithValueIteration() {\n", "    try {\n", "      Iterator<V> iterator = getMap().values().iterator();\n", "      put(e3());\n", "      iterator.next();\n", "      fail(\"Expected ConcurrentModificationException\");\n", "    } catch (ConcurrentModificationException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  public void testPut_unsupportedNotPresent() {\n", "    try {\n", "      put(e3());\n", "      fail(\"put(notPresent, value) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectMissing(e3());\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPut_unsupportedPresentExistingValue() {\n", "    try {\n", "      assertEquals(\"put(present, existingValue) should return present or throw\",\n", "          v0(), put(e0()));\n", "    } catch (UnsupportedOperationException tolerated) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require(absent = SUPPORTS_PUT)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPut_unsupportedPresentDifferentValue() {\n", "    try {\n", "      getMap().put(k0(), v3());\n", "      fail(\"put(present, differentValue) should throw\");\n", "    } catch (UnsupportedOperationException expected) {\n", "    }\n", "    expectUnchanged();\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})\n", "  public void testPut_nullKeySupportedNotPresent() {\n", "    assertNull(\"put(null, value) should return null\", put(nullKeyEntry));\n", "    expectAdded(nullKeyEntry);\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPut_nullKeySupportedPresent() {\n", "    Entry<K, V> newEntry = entry(null, v3());\n", "    initMapWithNullKey();\n", "    assertEquals(\"put(present, value) should return the associated value\",\n", "        getValueForNullKey(), put(newEntry));\n", "\n", "    Entry<K, V>[] expected = createArrayWithNullKey();\n", "    expected[getNullLocation()] = newEntry;\n", "    expectContents(expected);\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_KEYS)\n", "  public void testPut_nullKeyUnsupported() {\n", "    try {\n", "      put(nullKeyEntry);\n", "      fail(\"put(null, value) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullKeyMissingWhenNullKeysUnsupported(\n", "        \"Should not contain null key after unsupported put(null, value)\");\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})\n", "  public void testPut_nullValueSupported() {\n", "    assertNull(\"put(key, null) should return null\", put(nullValueEntry));\n", "    expectAdded(nullValueEntry);\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)\n", "  public void testPut_nullValueUnsupported() {\n", "    try {\n", "      put(nullValueEntry);\n", "      fail(\"put(key, null) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullValueMissingWhenNullValuesUnsupported(\n", "        \"Should not contain null value after unsupported put(key, null)\");\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPut_replaceWithNullValueSupported() {\n", "    assertEquals(\"put(present, null) should return the associated value\",\n", "        v0(), put(presentKeyNullValueEntry));\n", "    expectReplacement(presentKeyNullValueEntry);\n", "  }\n", "\n", "  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPut_replaceWithNullValueUnsupported() {\n", "    try {\n", "      put(presentKeyNullValueEntry);\n", "      fail(\"put(present, null) should throw\");\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    expectUnchanged();\n", "    expectNullValueMissingWhenNullValuesUnsupported(\n", "        \"Should not contain null after unsupported put(present, null)\");\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPut_replaceNullValueWithNullSupported() {\n", "    initMapWithNullValue();\n", "    assertNull(\"put(present, null) should return the associated value (null)\",\n", "        getMap().put(getKeyForNullValue(), null));\n", "    expectContents(createArrayWithNullValue());\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testPut_replaceNullValueWithNonNullSupported() {\n", "    Entry<K, V> newEntry = entry(getKeyForNullValue(), v3());\n", "    initMapWithNullValue();\n", "    assertNull(\"put(present, value) should return the associated value (null)\",\n", "        put(newEntry));\n", "\n", "    Entry<K, V>[] expected = createArrayWithNullValue();\n", "    expected[getNullLocation()] = newEntry;\n", "    expectContents(expected);\n", "  }\n", "\n", "  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS, ALLOWS_NULL_VALUES})\n", "  public void testPut_nullKeyAndValueSupported() {\n", "    assertNull(\"put(null, null) should return null\", put(nullKeyValueEntry));\n", "    expectAdded(nullKeyValueEntry);\n", "  }\n", "\n", "  private V put(Map.Entry<K, V> entry) {\n", "    return getMap().put(entry.getKey(), entry.getValue());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239]}}, {"166": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/SetAddTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2007 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ADD;\n", "import static com.google.common.collect.testing.features.CollectionSize.ZERO;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "/**\n", " * A generic JUnit test which tests add operations on a set. Can't be\n", " * invoked directly; please see\n", " * {@link com.google.common.collect.testing.SetTestSuiteBuilder}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SetAddTester<E> extends AbstractSetTester<E> {\n", "  @CollectionFeature.Require(SUPPORTS_ADD)\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAdd_supportedPresent() {\n", "    assertFalse(\"add(present) should return false\", getSet().add(e0()));\n", "    expectUnchanged();\n", "  }\n", "\n", "  @CollectionFeature.Require(value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES})\n", "  @CollectionSize.Require(absent = ZERO)\n", "  public void testAdd_supportedNullPresent() {\n", "    E[] array = createArrayWithNullElement();\n", "    collection = getSubjectGenerator().create(array);\n", "    assertFalse(\"add(nullPresent) should return false\", getSet().add(null));\n", "    expectContents(array);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52]}}, {"167": "guava-gwt/test-super/com/google/common/collect/testing/super/com/google/common/collect/testing/testers/SetHashCodeTester.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.collect.testing.testers;\n", "\n", "import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.features.CollectionFeature;\n", "import com.google.common.collect.testing.features.CollectionSize;\n", "\n", "import java.util.Collection;\n", "\n", "/**\n", " * Tests {@link java.util.Set#hashCode}.\n", " *\n", " * @author George van den Driessche\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class SetHashCodeTester<E> extends AbstractSetTester<E> {\n", "  public void testHashCode() {\n", "    int expectedHashCode = 0;\n", "    for (E element : getSampleElements()) {\n", "      expectedHashCode += ((element == null) ? 0 : element.hashCode());\n", "    }\n", "    assertEquals(\n", "        \"A Set's hashCode() should be the sum of those of its elements.\",\n", "        expectedHashCode, getSet().hashCode());\n", "  }\n", "\n", "  @CollectionSize.Require(absent = CollectionSize.ZERO)\n", "  @CollectionFeature.Require(ALLOWS_NULL_VALUES)\n", "  public void testHashCode_containingNull() {\n", "    Collection<E> elements = getSampleElements(getNumElements() - 1);\n", "    int expectedHashCode = 0;\n", "    for (E element : elements) {\n", "      expectedHashCode += ((element == null) ? 0 : element.hashCode());\n", "    }\n", "\n", "    elements.add(null);\n", "    collection = getSubjectGenerator().create(elements.toArray());\n", "    assertEquals(\n", "        \"A Set's hashCode() should be the sum of those of its elements (with \"\n", "            + \"a null element counting as having a hash of zero).\",\n", "        expectedHashCode, getSet().hashCode());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61]}}, {"168": "guava-gwt/test-super/com/google/common/io/super/com/google/common/io/BaseEncodingTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2012 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the License\n", " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n", " * or implied. See the License for the specific language governing permissions and limitations under\n", " * the License.\n", " */\n", "\n", "package com.google.common.io;\n", "\n", "import static com.google.common.io.BaseEncoding.base16;\n", "import static com.google.common.io.BaseEncoding.base32;\n", "import static com.google.common.io.BaseEncoding.base32Hex;\n", "import static com.google.common.io.BaseEncoding.base64;\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Ascii;\n", "import com.google.common.base.Joiner;\n", "import com.google.common.base.Splitter;\n", "import com.google.common.collect.ImmutableList;\n", "import com.google.common.io.BaseEncoding.DecodingException;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.io.UnsupportedEncodingException;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Tests for {@code BaseEncoding}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class BaseEncodingTest extends TestCase {\n", "  public static void assertEquals(byte[] expected, byte[] actual) {\n", "    assertEquals(expected.length, actual.length);\n", "    for (int i = 0; i < expected.length; i++) {\n", "      assertEquals(expected[i], actual[i]);\n", "    }\n", "  }\n", "\n", "  public void testSeparatorsExplicitly() {\n", "    testEncodes(base64().withSeparator(\"\\n\", 3), \"foobar\", \"Zm9\\nvYm\\nFy\");\n", "    testEncodes(base64().withSeparator(\"$\", 4), \"foobar\", \"Zm9v$YmFy\");\n", "    testEncodes(base32().withSeparator(\"*\", 4), \"foobar\", \"MZXW*6YTB*OI==*====\");\n", "  }\n", "\n", "  @SuppressWarnings(\"ReturnValueIgnored\")\n", "  public void testSeparatorSameAsPadChar() {\n", "    try {\n", "      base64().withSeparator(\"=\", 3);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {}\n", "\n", "    try {\n", "      base64().withPadChar('#').withSeparator(\"!#!\", 3);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  @SuppressWarnings(\"ReturnValueIgnored\")\n", "  public void testAtMostOneSeparator() {\n", "    BaseEncoding separated = base64().withSeparator(\"\\n\", 3);\n", "    try {\n", "      separated.withSeparator(\"$\", 4);\n", "      fail(\"Expected UnsupportedOperationException\");\n", "    } catch (UnsupportedOperationException expected) {}\n", "  }\n", "\n", "  public void testBase64() {\n", "    // The following test vectors are specified in RFC 4648 itself\n", "    testEncodingWithSeparators(base64(), \"\", \"\");\n", "    testEncodingWithSeparators(base64(), \"f\", \"Zg==\");\n", "    testEncodingWithSeparators(base64(), \"fo\", \"Zm8=\");\n", "    testEncodingWithSeparators(base64(), \"foo\", \"Zm9v\");\n", "    testEncodingWithSeparators(base64(), \"foob\", \"Zm9vYg==\");\n", "    testEncodingWithSeparators(base64(), \"fooba\", \"Zm9vYmE=\");\n", "    testEncodingWithSeparators(base64(), \"foobar\", \"Zm9vYmFy\");\n", "  }\n", "\n", "  public void testBase64LenientPadding() {\n", "    testDecodes(base64(), \"Zg\", \"f\");\n", "    testDecodes(base64(), \"Zg=\", \"f\");\n", "    testDecodes(base64(), \"Zg==\", \"f\"); // proper padding length\n", "    testDecodes(base64(), \"Zg===\", \"f\");\n", "    testDecodes(base64(), \"Zg====\", \"f\");\n", "  }\n", "\n", "  public void testBase64InvalidDecodings() {\n", "    // These contain bytes not in the decodabet.\n", "    assertFailsToDecode(base64(), \"A\\u007f\", \"Unrecognized character: 0x7f\");\n", "    assertFailsToDecode(base64(), \"Wf2!\", \"Unrecognized character: !\");\n", "    // This sentence just isn't base64() encoded.\n", "    assertFailsToDecode(base64(), \"let's not talk of love or chains!\");\n", "    // A 4n+1 length string is never legal base64().\n", "    assertFailsToDecode(base64(), \"12345\", \"Invalid input length 5\");\n", "    // These have a combination of invalid length, unrecognized characters and wrong padding.\n", "    assertFailsToDecode(base64(), \"AB=C\", \"Unrecognized character: =\");\n", "    assertFailsToDecode(base64(), \"A=BCD\", \"Invalid input length 5\");\n", "    assertFailsToDecode(base64(), \"?\", \"Invalid input length 1\");\n", "  }\n", "\n", "  @SuppressWarnings(\"ReturnValueIgnored\")\n", "  public void testBase64CannotUpperCase() {\n", "    try {\n", "      base64().upperCase();\n", "      fail();\n", "    } catch (IllegalStateException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"ReturnValueIgnored\")\n", "  public void testBase64CannotLowerCase() {\n", "    try {\n", "      base64().lowerCase();\n", "      fail();\n", "    } catch (IllegalStateException expected) {\n", "      // success\n", "    }\n", "  }\n", "\n", "  public void testBase64AlternatePadding() {\n", "    BaseEncoding enc = base64().withPadChar('~');\n", "    testEncodingWithSeparators(enc, \"\", \"\");\n", "    testEncodingWithSeparators(enc, \"f\", \"Zg~~\");\n", "    testEncodingWithSeparators(enc, \"fo\", \"Zm8~\");\n", "    testEncodingWithSeparators(enc, \"foo\", \"Zm9v\");\n", "    testEncodingWithSeparators(enc, \"foob\", \"Zm9vYg~~\");\n", "    testEncodingWithSeparators(enc, \"fooba\", \"Zm9vYmE~\");\n", "    testEncodingWithSeparators(enc, \"foobar\", \"Zm9vYmFy\");\n", "  }\n", "\n", "  public void testBase64OmitPadding() {\n", "    BaseEncoding enc = base64().omitPadding();\n", "    testEncodingWithSeparators(enc, \"\", \"\");\n", "    testEncodingWithSeparators(enc, \"f\", \"Zg\");\n", "    testEncodingWithSeparators(enc, \"fo\", \"Zm8\");\n", "    testEncodingWithSeparators(enc, \"foo\", \"Zm9v\");\n", "    testEncodingWithSeparators(enc, \"foob\", \"Zm9vYg\");\n", "    testEncodingWithSeparators(enc, \"fooba\", \"Zm9vYmE\");\n", "    testEncodingWithSeparators(enc, \"foobar\", \"Zm9vYmFy\");\n", "  }\n", "\n", "  public void testBase64Offset() {\n", "    testEncodesWithOffset(base64(), \"foobar\", 0, 6, \"Zm9vYmFy\");\n", "    testEncodesWithOffset(base64(), \"foobar\", 1, 5, \"b29iYXI=\");\n", "    testEncodesWithOffset(base64(), \"foobar\", 2, 3, \"b2Jh\");\n", "    testEncodesWithOffset(base64(), \"foobar\", 3, 1, \"Yg==\");\n", "    testEncodesWithOffset(base64(), \"foobar\", 4, 0, \"\");\n", "  }\n", "\n", "  public void testBase32() {\n", "    // The following test vectors are specified in RFC 4648 itself\n", "    testEncodingWithCasing(base32(), \"\", \"\");\n", "    testEncodingWithCasing(base32(), \"f\", \"MY======\");\n", "    testEncodingWithCasing(base32(), \"fo\", \"MZXQ====\");\n", "    testEncodingWithCasing(base32(), \"foo\", \"MZXW6===\");\n", "    testEncodingWithCasing(base32(), \"foob\", \"MZXW6YQ=\");\n", "    testEncodingWithCasing(base32(), \"fooba\", \"MZXW6YTB\");\n", "    testEncodingWithCasing(base32(), \"foobar\", \"MZXW6YTBOI======\");\n", "  }\n", "\n", "  public void testBase32LenientPadding() {\n", "    testDecodes(base32(), \"MZXW6\", \"foo\");\n", "    testDecodes(base32(), \"MZXW6=\", \"foo\");\n", "    testDecodes(base32(), \"MZXW6==\", \"foo\");\n", "    testDecodes(base32(), \"MZXW6===\", \"foo\"); // proper padding length\n", "    testDecodes(base32(), \"MZXW6====\", \"foo\");\n", "    testDecodes(base32(), \"MZXW6=====\", \"foo\");\n", "  }\n", "\n", "  public void testBase32AlternatePadding() {\n", "    BaseEncoding enc = base32().withPadChar('~');\n", "    testEncodingWithCasing(enc, \"\", \"\");\n", "    testEncodingWithCasing(enc, \"f\", \"MY~~~~~~\");\n", "    testEncodingWithCasing(enc, \"fo\", \"MZXQ~~~~\");\n", "    testEncodingWithCasing(enc, \"foo\", \"MZXW6~~~\");\n", "    testEncodingWithCasing(enc, \"foob\", \"MZXW6YQ~\");\n", "    testEncodingWithCasing(enc, \"fooba\", \"MZXW6YTB\");\n", "    testEncodingWithCasing(enc, \"foobar\", \"MZXW6YTBOI~~~~~~\");\n", "  }\n", "\n", "  public void testBase32InvalidDecodings() {\n", "    // These contain bytes not in the decodabet.\n", "    assertFailsToDecode(base32(), \"A \", \"Unrecognized character: 0x20\");\n", "    assertFailsToDecode(base32(), \"Wf2!\", \"Unrecognized character: f\");\n", "    // This sentence just isn't base32() encoded.\n", "    assertFailsToDecode(base32(), \"let's not talk of love or chains!\");\n", "    // An 8n+{1,3,6} length string is never legal base32.\n", "    assertFailsToDecode(base32(), \"A\", \"Invalid input length 1\");\n", "    assertFailsToDecode(base32(), \"ABC\");\n", "    assertFailsToDecode(base32(), \"ABCDEF\");\n", "    // These have a combination of invalid length, unrecognized characters and wrong padding.\n", "    assertFailsToDecode(base32(), \"AB=C\", \"Unrecognized character: =\");\n", "    assertFailsToDecode(base32(), \"A=BCDE\", \"Invalid input length 6\");\n", "    assertFailsToDecode(base32(), \"?\", \"Invalid input length 1\");\n", "  }\n", "\n", "  public void testBase32UpperCaseIsNoOp() {\n", "    assertSame(base32(), base32().upperCase());\n", "  }\n", "\n", "  public void testBase32Offset() {\n", "    testEncodesWithOffset(base32(), \"foobar\", 0, 6, \"MZXW6YTBOI======\");\n", "    testEncodesWithOffset(base32(), \"foobar\", 1, 5, \"N5XWEYLS\");\n", "    testEncodesWithOffset(base32(), \"foobar\", 2, 3, \"N5RGC===\");\n", "    testEncodesWithOffset(base32(), \"foobar\", 3, 1, \"MI======\");\n", "    testEncodesWithOffset(base32(), \"foobar\", 4, 0, \"\");\n", "  }\n", "\n", "  public void testBase32Hex() {\n", "    // The following test vectors are specified in RFC 4648 itself\n", "    testEncodingWithCasing(base32Hex(), \"\", \"\");\n", "    testEncodingWithCasing(base32Hex(), \"f\", \"CO======\");\n", "    testEncodingWithCasing(base32Hex(), \"fo\", \"CPNG====\");\n", "    testEncodingWithCasing(base32Hex(), \"foo\", \"CPNMU===\");\n", "    testEncodingWithCasing(base32Hex(), \"foob\", \"CPNMUOG=\");\n", "    testEncodingWithCasing(base32Hex(), \"fooba\", \"CPNMUOJ1\");\n", "    testEncodingWithCasing(base32Hex(), \"foobar\", \"CPNMUOJ1E8======\");\n", "  }\n", "\n", "  public void testBase32HexLenientPadding() {\n", "    testDecodes(base32Hex(), \"CPNMU\", \"foo\");\n", "    testDecodes(base32Hex(), \"CPNMU=\", \"foo\");\n", "    testDecodes(base32Hex(), \"CPNMU==\", \"foo\");\n", "    testDecodes(base32Hex(), \"CPNMU===\", \"foo\"); // proper padding length\n", "    testDecodes(base32Hex(), \"CPNMU====\", \"foo\");\n", "    testDecodes(base32Hex(), \"CPNMU=====\", \"foo\");\n", "  }\n", "\n", "  public void testBase32HexInvalidDecodings() {\n", "    // These contain bytes not in the decodabet.\n", "    assertFailsToDecode(base32Hex(), \"A\\u007f\", \"Unrecognized character: 0x7f\");\n", "    assertFailsToDecode(base32Hex(), \"Wf2!\", \"Unrecognized character: W\");\n", "    // This sentence just isn't base32 encoded.\n", "    assertFailsToDecode(base32Hex(), \"let's not talk of love or chains!\");\n", "    // An 8n+{1,3,6} length string is never legal base32.\n", "    assertFailsToDecode(base32Hex(), \"A\");\n", "    assertFailsToDecode(base32Hex(), \"ABC\");\n", "    assertFailsToDecode(base32Hex(), \"ABCDEF\");\n", "  }\n", "\n", "  public void testBase32HexUpperCaseIsNoOp() {\n", "    assertSame(base32Hex(), base32Hex().upperCase());\n", "  }\n", "\n", "  public void testBase16() {\n", "    testEncodingWithCasing(base16(), \"\", \"\");\n", "    testEncodingWithCasing(base16(), \"f\", \"66\");\n", "    testEncodingWithCasing(base16(), \"fo\", \"666F\");\n", "    testEncodingWithCasing(base16(), \"foo\", \"666F6F\");\n", "    testEncodingWithCasing(base16(), \"foob\", \"666F6F62\");\n", "    testEncodingWithCasing(base16(), \"fooba\", \"666F6F6261\");\n", "    testEncodingWithCasing(base16(), \"foobar\", \"666F6F626172\");\n", "  }\n", "\n", "  public void testBase16UpperCaseIsNoOp() {\n", "    assertSame(base16(), base16().upperCase());\n", "  }\n", "\n", "  public void testBase16InvalidDecodings() {\n", "    // These contain bytes not in the decodabet.\n", "    assertFailsToDecode(base16(), \"\\n\\n\", \"Unrecognized character: 0xa\");\n", "    assertFailsToDecode(base16(), \"EFGH\", \"Unrecognized character: G\");\n", "    // Valid base16 strings always have an even length.\n", "    assertFailsToDecode(base16(), \"A\", \"Invalid input length 1\");\n", "    assertFailsToDecode(base16(), \"ABC\");\n", "    // These have a combination of invalid length and unrecognized characters.\n", "    assertFailsToDecode(base16(), \"?\", \"Invalid input length 1\");\n", "  }\n", "\n", "  public void testBase16Offset() {\n", "    testEncodesWithOffset(base16(), \"foobar\", 0, 6, \"666F6F626172\");\n", "    testEncodesWithOffset(base16(), \"foobar\", 1, 5, \"6F6F626172\");\n", "    testEncodesWithOffset(base16(), \"foobar\", 2, 3, \"6F6261\");\n", "    testEncodesWithOffset(base16(), \"foobar\", 3, 1, \"62\");\n", "    testEncodesWithOffset(base16(), \"foobar\", 4, 0, \"\");\n", "  }\n", "\n", "  private static void testEncodingWithCasing(\n", "      BaseEncoding encoding, String decoded, String encoded) {\n", "    testEncodingWithSeparators(encoding, decoded, encoded);\n", "    testEncodingWithSeparators(encoding.upperCase(), decoded, Ascii.toUpperCase(encoded));\n", "    testEncodingWithSeparators(encoding.lowerCase(), decoded, Ascii.toLowerCase(encoded));\n", "  }\n", "\n", "  private static void testEncodingWithSeparators(\n", "      BaseEncoding encoding, String decoded, String encoded) {\n", "    testEncoding(encoding, decoded, encoded);\n", "\n", "    // test separators work\n", "    for (int sepLength = 3; sepLength <= 5; sepLength++) {\n", "      for (String separator : ImmutableList.of(\",\", \"\\n\", \";;\", \"\")) {\n", "        testEncoding(encoding.withSeparator(separator, sepLength), decoded,\n", "            Joiner.on(separator).join(Splitter.fixedLength(sepLength).split(encoded)));\n", "      }\n", "    }\n", "  }\n", "\n", "  private static void testEncoding(BaseEncoding encoding, String decoded, String encoded) {\n", "    testEncodes(encoding, decoded, encoded);\n", "    testDecodes(encoding, encoded, decoded);\n", "  }\n", "\n", "  private static void testEncodes(BaseEncoding encoding, String decoded, String encoded) {\n", "    assertEquals(encoded, encoding.encode(getBytes(decoded)));\n", "  }\n", "\n", "  private static void testEncodesWithOffset(\n", "      BaseEncoding encoding, String decoded, int offset, int len, String encoded) {\n", "    assertEquals(encoded, encoding.encode(getBytes(decoded), offset, len));\n", "  }\n", "\n", "  private static void testDecodes(BaseEncoding encoding, String encoded, String decoded) {\n", "    assertEquals(getBytes(decoded), encoding.decode(encoded));\n", "  }\n", "\n", "  private static void assertFailsToDecode(BaseEncoding encoding, String cannotDecode) {\n", "    assertFailsToDecode(encoding, cannotDecode, null);\n", "  }\n", "\n", "  private static void assertFailsToDecode(\n", "      BaseEncoding encoding, String cannotDecode, @Nullable String expectedMessage) {\n", "    try {\n", "      encoding.decode(cannotDecode);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "      if (expectedMessage != null) {\n", "        assertThat(expected.getCause()).hasMessage(expectedMessage);\n", "      }\n", "    }\n", "    try {\n", "      encoding.decodeChecked(cannotDecode);\n", "      fail(\"Expected DecodingException\");\n", "    } catch (DecodingException expected) {\n", "      if (expectedMessage != null) {\n", "        assertThat(expected).hasMessage(expectedMessage);\n", "      }\n", "    }\n", "  }\n", "\n", "  private static byte[] getBytes(String decoded) {\n", "    try {\n", "      // GWT does not support String.getBytes(Charset)\n", "      return decoded.getBytes(\"UTF-8\");\n", "    } catch (UnsupportedEncodingException e) {\n", "      throw new AssertionError();\n", "    }\n", "  }\n", "\n", "  public void testToString() {\n", "    assertEquals(\"BaseEncoding.base64().withPadChar(=)\", BaseEncoding.base64().toString());\n", "    assertEquals(\"BaseEncoding.base32Hex().omitPadding()\",\n", "        BaseEncoding.base32Hex().omitPadding().toString());\n", "    assertEquals(\"BaseEncoding.base32().lowerCase().withPadChar($)\",\n", "        BaseEncoding.base32().lowerCase().withPadChar('$').toString());\n", "    assertEquals(\"BaseEncoding.base16().withSeparator(\\\"\\n\\\", 10)\",\n", "        BaseEncoding.base16().withSeparator(\"\\n\", 10).toString());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370]}}, {"169": "guava-gwt/test-super/com/google/common/math/super/com/google/common/math/BigIntegerMathTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.math;\n", "\n", "import static com.google.common.math.MathTesting.ALL_BIGINTEGER_CANDIDATES;\n", "import static com.google.common.math.MathTesting.ALL_ROUNDING_MODES;\n", "import static com.google.common.math.MathTesting.POSITIVE_BIGINTEGER_CANDIDATES;\n", "import static java.math.BigInteger.ONE;\n", "import static java.math.BigInteger.ZERO;\n", "import static java.math.RoundingMode.CEILING;\n", "import static java.math.RoundingMode.DOWN;\n", "import static java.math.RoundingMode.FLOOR;\n", "import static java.math.RoundingMode.HALF_DOWN;\n", "import static java.math.RoundingMode.HALF_EVEN;\n", "import static java.math.RoundingMode.HALF_UP;\n", "import static java.math.RoundingMode.UNNECESSARY;\n", "import static java.math.RoundingMode.UP;\n", "import static java.util.Arrays.asList;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.math.BigInteger;\n", "import java.math.RoundingMode;\n", "\n", "/**\n", " * Tests for BigIntegerMath.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class BigIntegerMathTest extends TestCase {\n", "\n", "  public void testIsPowerOfTwo() {\n", "    for (BigInteger x : ALL_BIGINTEGER_CANDIDATES) {\n", "      // Checks for a single bit set.\n", "      boolean expected = x.signum() > 0 & x.and(x.subtract(ONE)).equals(ZERO);\n", "      assertEquals(expected, BigIntegerMath.isPowerOfTwo(x));\n", "    }\n", "  }\n", "\n", "  public void testLog2ZeroAlwaysThrows() {\n", "    for (RoundingMode mode : ALL_ROUNDING_MODES) {\n", "      try {\n", "        BigIntegerMath.log2(ZERO, mode);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testLog2NegativeAlwaysThrows() {\n", "    for (RoundingMode mode : ALL_ROUNDING_MODES) {\n", "      try {\n", "        BigIntegerMath.log2(BigInteger.valueOf(-1), mode);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testLog2Floor() {\n", "    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n", "      for (RoundingMode mode : asList(FLOOR, DOWN)) {\n", "        int result = BigIntegerMath.log2(x, mode);\n", "        assertTrue(ZERO.setBit(result).compareTo(x) <= 0);\n", "        assertTrue(ZERO.setBit(result + 1).compareTo(x) > 0);\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testLog2Ceiling() {\n", "    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n", "      for (RoundingMode mode : asList(CEILING, UP)) {\n", "        int result = BigIntegerMath.log2(x, mode);\n", "        assertTrue(ZERO.setBit(result).compareTo(x) >= 0);\n", "        assertTrue(result == 0 || ZERO.setBit(result - 1).compareTo(x) < 0);\n", "      }\n", "    }\n", "  }\n", "\n", "  // Relies on the correctness of isPowerOfTwo(BigInteger).\n", "  public void testLog2Exact() {\n", "    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n", "      // We only expect an exception if x was not a power of 2.\n", "      boolean isPowerOf2 = BigIntegerMath.isPowerOfTwo(x);\n", "      try {\n", "        assertEquals(x, ZERO.setBit(BigIntegerMath.log2(x, UNNECESSARY)));\n", "        assertTrue(isPowerOf2);\n", "      } catch (ArithmeticException e) {\n", "        assertFalse(isPowerOf2);\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testLog2HalfUp() {\n", "    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n", "      int result = BigIntegerMath.log2(x, HALF_UP);\n", "      BigInteger x2 = x.pow(2);\n", "      // x^2 < 2^(2 * result + 1), or else we would have rounded up\n", "      assertTrue(ZERO.setBit(2 * result + 1).compareTo(x2) > 0);\n", "      // x^2 >= 2^(2 * result - 1), or else we would have rounded down\n", "      assertTrue(result == 0 || ZERO.setBit(2 * result - 1).compareTo(x2) <= 0);\n", "    }\n", "  }\n", "\n", "  public void testLog2HalfDown() {\n", "    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n", "      int result = BigIntegerMath.log2(x, HALF_DOWN);\n", "      BigInteger x2 = x.pow(2);\n", "      // x^2 <= 2^(2 * result + 1), or else we would have rounded up\n", "      assertTrue(ZERO.setBit(2 * result + 1).compareTo(x2) >= 0);\n", "      // x^2 > 2^(2 * result - 1), or else we would have rounded down\n", "      assertTrue(result == 0 || ZERO.setBit(2 * result - 1).compareTo(x2) < 0);\n", "    }\n", "  }\n", "\n", "  // Relies on the correctness of log2(BigInteger, {HALF_UP,HALF_DOWN}).\n", "  public void testLog2HalfEven() {\n", "    for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {\n", "      int halfEven = BigIntegerMath.log2(x, HALF_EVEN);\n", "      // Now figure out what rounding mode we should behave like (it depends if FLOOR was\n", "      // odd/even).\n", "      boolean floorWasEven = (BigIntegerMath.log2(x, FLOOR) & 1) == 0;\n", "      assertEquals(BigIntegerMath.log2(x, floorWasEven ? HALF_DOWN : HALF_UP), halfEven);\n", "    }\n", "  }\n", "\n", "  // Relies on the correctness of log10(BigInteger, FLOOR).\n", "\n", "  // Relies on the correctness of log10(BigInteger, {HALF_UP,HALF_DOWN}).\n", "\n", "  // Relies on the correctness of sqrt(BigInteger, FLOOR).\n", "\n", "  // Relies on the correctness of sqrt(BigInteger, {HALF_UP,HALF_DOWN}).\n", "\n", "  public void testFactorial() {\n", "    BigInteger expected = BigInteger.ONE;\n", "    for (int i = 1; i <= 200; i++) {\n", "      expected = expected.multiply(BigInteger.valueOf(i));\n", "      assertEquals(expected, BigIntegerMath.factorial(i));\n", "    }\n", "  }\n", "\n", "  public void testFactorial0() {\n", "    assertEquals(BigInteger.ONE, BigIntegerMath.factorial(0));\n", "  }\n", "\n", "  public void testFactorialNegative() {\n", "    try {\n", "      BigIntegerMath.factorial(-1);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testBinomialSmall() {\n", "    runBinomialTest(0, 30);\n", "  }\n", "\n", "  // Depends on the correctness of BigIntegerMath.factorial\n", "  private static void runBinomialTest(int firstN, int lastN) {\n", "    for (int n = firstN; n <= lastN; n++) {\n", "      for (int k = 0; k <= n; k++) {\n", "        BigInteger expected = BigIntegerMath\n", "            .factorial(n)\n", "            .divide(BigIntegerMath.factorial(k))\n", "            .divide(BigIntegerMath.factorial(n - k));\n", "        assertEquals(expected, BigIntegerMath.binomial(n, k));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testBinomialOutside() {\n", "    for (int n = 0; n <= 50; n++) {\n", "      try {\n", "        BigIntegerMath.binomial(n, -1);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "      try {\n", "        BigIntegerMath.binomial(n, n + 1);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]}}, {"170": "guava-gwt/test-super/com/google/common/math/super/com/google/common/math/IntMathTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.math;\n", "\n", "import static com.google.common.math.MathTesting.ALL_INTEGER_CANDIDATES;\n", "import static com.google.common.math.MathTesting.ALL_ROUNDING_MODES;\n", "import static com.google.common.math.MathTesting.ALL_SAFE_ROUNDING_MODES;\n", "import static com.google.common.math.MathTesting.EXPONENTS;\n", "import static com.google.common.math.MathTesting.NEGATIVE_INTEGER_CANDIDATES;\n", "import static com.google.common.math.MathTesting.NONZERO_INTEGER_CANDIDATES;\n", "import static com.google.common.math.MathTesting.POSITIVE_INTEGER_CANDIDATES;\n", "import static com.google.common.math.TestPlatform.intsCanGoOutOfRange;\n", "import static java.math.BigInteger.valueOf;\n", "import static java.math.RoundingMode.UNNECESSARY;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.math.BigDecimal;\n", "import java.math.BigInteger;\n", "import java.math.RoundingMode;\n", "\n", "/**\n", " * Tests for {@link IntMath}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class IntMathTest extends TestCase {\n", "  \n", "  public void testLessThanBranchFree() {\n", "    for (int x : ALL_INTEGER_CANDIDATES) {\n", "      for (int y : ALL_INTEGER_CANDIDATES) {\n", "        if (LongMath.fitsInInt((long) x - y)) {\n", "          int expected = (x < y) ? 1 : 0;\n", "          int actual = IntMath.lessThanBranchFree(x, y);\n", "          assertEquals(expected, actual);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testLog2ZeroAlwaysThrows() {\n", "    for (RoundingMode mode : ALL_ROUNDING_MODES) {\n", "      try {\n", "        IntMath.log2(0, mode);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testLog2NegativeAlwaysThrows() {\n", "    for (int x : NEGATIVE_INTEGER_CANDIDATES) {\n", "      for (RoundingMode mode : ALL_ROUNDING_MODES) {\n", "        try {\n", "          IntMath.log2(x, mode);\n", "          fail(\"Expected IllegalArgumentException\");\n", "        } catch (IllegalArgumentException expected) {}\n", "      }\n", "    }\n", "  }\n", "\n", "  // Relies on the correctness of BigIntegrerMath.log2 for all modes except UNNECESSARY.\n", "  public void testLog2MatchesBigInteger() {\n", "    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n", "      for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n", "        assertEquals(BigIntegerMath.log2(valueOf(x), mode), IntMath.log2(x, mode));\n", "      }\n", "    }\n", "  }\n", "\n", "  // Relies on the correctness of isPowerOfTwo(int).\n", "  public void testLog2Exact() {\n", "    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n", "      // We only expect an exception if x was not a power of 2.\n", "      boolean isPowerOf2 = IntMath.isPowerOfTwo(x);\n", "      try {\n", "        assertEquals(x, 1 << IntMath.log2(x, UNNECESSARY));\n", "        assertTrue(isPowerOf2);\n", "      } catch (ArithmeticException e) {\n", "        assertFalse(isPowerOf2);\n", "      }\n", "    }\n", "  }\n", "\n", "  // Relies on the correctness of BigIntegerMath.log10 for all modes except UNNECESSARY.\n", "\n", "  // Relies on the correctness of log10(int, FLOOR) and of pow(int, int).\n", "\n", "  // Simple test to cover sqrt(0) for all types and all modes.\n", "\n", "  /* Relies on the correctness of BigIntegerMath.sqrt for all modes except UNNECESSARY. */\n", "\n", "  /* Relies on the correctness of sqrt(int, FLOOR). */\n", "\n", "  public void testDivNonZero() {\n", "    for (int p : NONZERO_INTEGER_CANDIDATES) {\n", "      for (int q : NONZERO_INTEGER_CANDIDATES) {\n", "        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n", "          // Skip some tests that fail due to GWT's non-compliant int implementation.\n", "          // TODO(cpovirk): does this test fail for only some rounding modes or for all?\n", "          if (p == -2147483648 && q == -1 && intsCanGoOutOfRange()) {\n", "            continue;\n", "          }\n", "          int expected =\n", "              new BigDecimal(valueOf(p)).divide(new BigDecimal(valueOf(q)), 0, mode).intValue();\n", "          assertEquals(p + \"/\" + q, force32(expected), IntMath.divide(p, q, mode));\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDivNonZeroExact() {\n", "    for (int p : NONZERO_INTEGER_CANDIDATES) {\n", "      for (int q : NONZERO_INTEGER_CANDIDATES) {\n", "        // Skip some tests that fail due to GWT's non-compliant int implementation.\n", "        if (p == -2147483648 && q == -1 && intsCanGoOutOfRange()) {\n", "          continue;\n", "        }\n", "        boolean dividesEvenly = (p % q) == 0;\n", "        try {\n", "          assertEquals(p + \"/\" + q, p, IntMath.divide(p, q, UNNECESSARY) * q);\n", "          assertTrue(p + \"/\" + q + \" not expected to divide evenly\", dividesEvenly);\n", "        } catch (ArithmeticException e) {\n", "          assertFalse(p + \"/\" + q + \" expected to divide evenly\", dividesEvenly);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testZeroDivIsAlwaysZero() {\n", "    for (int q : NONZERO_INTEGER_CANDIDATES) {\n", "      for (RoundingMode mode : ALL_ROUNDING_MODES) {\n", "        assertEquals(0, IntMath.divide(0, q, mode));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDivByZeroAlwaysFails() {\n", "    for (int p : ALL_INTEGER_CANDIDATES) {\n", "      for (RoundingMode mode : ALL_ROUNDING_MODES) {\n", "        try {\n", "          IntMath.divide(p, 0, mode);\n", "          fail(\"Expected ArithmeticException\");\n", "        } catch (ArithmeticException expected) {}\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testMod() {\n", "    for (int x : ALL_INTEGER_CANDIDATES) {\n", "      for (int m : POSITIVE_INTEGER_CANDIDATES) {\n", "        assertEquals(valueOf(x).mod(valueOf(m)).intValue(), IntMath.mod(x, m));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testModNegativeModulusFails() {\n", "    for (int x : POSITIVE_INTEGER_CANDIDATES) {\n", "      for (int m : NEGATIVE_INTEGER_CANDIDATES) {\n", "        try {\n", "          IntMath.mod(x, m);\n", "          fail(\"Expected ArithmeticException\");\n", "        } catch (ArithmeticException expected) {}\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testModZeroModulusFails() {\n", "    for (int x : ALL_INTEGER_CANDIDATES) {\n", "      try {\n", "        IntMath.mod(x, 0);\n", "        fail(\"Expected ArithmeticException\");\n", "      } catch (ArithmeticException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testGCD() {\n", "    for (int a : POSITIVE_INTEGER_CANDIDATES) {\n", "      for (int b : POSITIVE_INTEGER_CANDIDATES) {\n", "        assertEquals(valueOf(a).gcd(valueOf(b)), valueOf(IntMath.gcd(a, b)));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testGCDZero() {\n", "    for (int a : POSITIVE_INTEGER_CANDIDATES) {\n", "      assertEquals(a, IntMath.gcd(a, 0));\n", "      assertEquals(a, IntMath.gcd(0, a));\n", "    }\n", "    assertEquals(0, IntMath.gcd(0, 0));\n", "  }\n", "\n", "  public void testGCDNegativePositiveThrows() {\n", "    for (int a : NEGATIVE_INTEGER_CANDIDATES) {\n", "      try {\n", "        IntMath.gcd(a, 3);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "      try {\n", "        IntMath.gcd(3, a);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testGCDNegativeZeroThrows() {\n", "    for (int a : NEGATIVE_INTEGER_CANDIDATES) {\n", "      try {\n", "        IntMath.gcd(a, 0);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "      try {\n", "        IntMath.gcd(0, a);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testCheckedAdd() {\n", "    for (int a : ALL_INTEGER_CANDIDATES) {\n", "      for (int b : ALL_INTEGER_CANDIDATES) {\n", "        BigInteger expectedResult = valueOf(a).add(valueOf(b));\n", "        boolean expectedSuccess = fitsInInt(expectedResult);\n", "        try {\n", "          assertEquals(a + b, IntMath.checkedAdd(a, b));\n", "          assertTrue(expectedSuccess);\n", "        } catch (ArithmeticException e) {\n", "          assertFalse(expectedSuccess);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testCheckedSubtract() {\n", "    for (int a : ALL_INTEGER_CANDIDATES) {\n", "      for (int b : ALL_INTEGER_CANDIDATES) {\n", "        BigInteger expectedResult = valueOf(a).subtract(valueOf(b));\n", "        boolean expectedSuccess = fitsInInt(expectedResult);\n", "        try {\n", "          assertEquals(a - b, IntMath.checkedSubtract(a, b));\n", "          assertTrue(expectedSuccess);\n", "        } catch (ArithmeticException e) {\n", "          assertFalse(expectedSuccess);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testCheckedMultiply() {\n", "    for (int a : ALL_INTEGER_CANDIDATES) {\n", "      for (int b : ALL_INTEGER_CANDIDATES) {\n", "        BigInteger expectedResult = valueOf(a).multiply(valueOf(b));\n", "        boolean expectedSuccess = fitsInInt(expectedResult);\n", "        try {\n", "          assertEquals(a * b, IntMath.checkedMultiply(a, b));\n", "          assertTrue(expectedSuccess);\n", "        } catch (ArithmeticException e) {\n", "          assertFalse(expectedSuccess);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testCheckedPow() {\n", "    for (int b : ALL_INTEGER_CANDIDATES) {\n", "      for (int k : EXPONENTS) {\n", "        BigInteger expectedResult = valueOf(b).pow(k);\n", "        boolean expectedSuccess = fitsInInt(expectedResult);\n", "        try {\n", "          assertEquals(b + \"^\" + k, force32(expectedResult.intValue()), IntMath.checkedPow(b, k));\n", "          assertTrue(b + \"^\" + k + \" should have succeeded\", expectedSuccess);\n", "        } catch (ArithmeticException e) {\n", "          assertFalse(b + \"^\" + k + \" should have failed\", expectedSuccess);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  // Depends on the correctness of BigIntegerMath.factorial.\n", "  public void testFactorial() {\n", "    for (int n = 0; n <= 50; n++) {\n", "      BigInteger expectedBig = BigIntegerMath.factorial(n);\n", "      int expectedInt = fitsInInt(expectedBig) ? expectedBig.intValue() : Integer.MAX_VALUE;\n", "      assertEquals(expectedInt, IntMath.factorial(n));\n", "    }\n", "  }\n", "\n", "  public void testFactorialNegative() {\n", "    for (int n : NEGATIVE_INTEGER_CANDIDATES) {\n", "      try {\n", "        IntMath.factorial(n);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  // Depends on the correctness of BigIntegerMath.binomial.\n", "\n", "  /**\n", "   * Helper method that asserts the arithmetic mean of x and y is equal\n", "   * to the expectedMean.\n", "   */\n", "  private static void assertMean(int expectedMean, int x, int y) {\n", "    assertEquals(\"The expectedMean should be the same as computeMeanSafely\",\n", "        expectedMean, computeMeanSafely(x, y));\n", "    assertMean(x, y);\n", "  }\n", "\n", "  /**\n", "   * Helper method that asserts the arithmetic mean of x and y is equal\n", "   * to the result of computeMeanSafely.\n", "   */\n", "  private static void assertMean(int x, int y) {\n", "    int expectedMean = computeMeanSafely(x, y);\n", "    assertEquals(expectedMean, IntMath.mean(x, y));\n", "    assertEquals(\"The mean of x and y should equal the mean of y and x\",\n", "        expectedMean, IntMath.mean(y, x));\n", "  }\n", "\n", "  /**\n", "   * Computes the mean in a way that is obvious and resilient to\n", "   * overflow by using BigInteger arithmetic.\n", "   */\n", "  private static int computeMeanSafely(int x, int y) {\n", "    BigInteger bigX = BigInteger.valueOf(x);\n", "    BigInteger bigY = BigInteger.valueOf(y);\n", "    BigDecimal bigMean = new BigDecimal(bigX.add(bigY))\n", "        .divide(BigDecimal.valueOf(2), BigDecimal.ROUND_FLOOR);\n", "    // parseInt blows up on overflow as opposed to intValue() which does not.\n", "    return Integer.parseInt(bigMean.toString());\n", "  }\n", "\n", "  private static boolean fitsInInt(BigInteger big) {\n", "    return big.bitLength() <= 31;\n", "  }\n", "\n", "  private static int force32(int value) {\n", "    // GWT doesn't consistently overflow values to make them 32-bit, so we need to force it.\n", "    return value & 0xffffffff;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358]}}, {"171": "guava-gwt/test-super/com/google/common/math/super/com/google/common/math/LongMathTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.math;\n", "\n", "import static com.google.common.math.MathTesting.ALL_LONG_CANDIDATES;\n", "import static com.google.common.math.MathTesting.ALL_ROUNDING_MODES;\n", "import static com.google.common.math.MathTesting.ALL_SAFE_ROUNDING_MODES;\n", "import static com.google.common.math.MathTesting.NEGATIVE_INTEGER_CANDIDATES;\n", "import static com.google.common.math.MathTesting.NEGATIVE_LONG_CANDIDATES;\n", "import static com.google.common.math.MathTesting.POSITIVE_LONG_CANDIDATES;\n", "import static java.math.BigInteger.valueOf;\n", "import static java.math.RoundingMode.UNNECESSARY;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.math.BigDecimal;\n", "import java.math.BigInteger;\n", "import java.math.RoundingMode;\n", "\n", "/**\n", " * Tests for LongMath.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class LongMathTest extends TestCase {\n", "  \n", "  public void testLessThanBranchFree() {\n", "    for (long x : ALL_LONG_CANDIDATES) {\n", "      for (long y : ALL_LONG_CANDIDATES) {\n", "        BigInteger difference = BigInteger.valueOf(x).subtract(BigInteger.valueOf(y));\n", "        if (fitsInLong(difference)) {\n", "          int expected = (x < y) ? 1 : 0;\n", "          int actual = LongMath.lessThanBranchFree(x, y);\n", "          assertEquals(expected, actual);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  // Throws an ArithmeticException if \"the simple implementation\" of binomial coefficients overflows\n", "\n", "  public void testLog2ZeroAlwaysThrows() {\n", "    for (RoundingMode mode : ALL_ROUNDING_MODES) {\n", "      try {\n", "        LongMath.log2(0L, mode);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testLog2NegativeAlwaysThrows() {\n", "    for (long x : NEGATIVE_LONG_CANDIDATES) {\n", "      for (RoundingMode mode : ALL_ROUNDING_MODES) {\n", "        try {\n", "          LongMath.log2(x, mode);\n", "          fail(\"Expected IllegalArgumentException\");\n", "        } catch (IllegalArgumentException expected) {}\n", "      }\n", "    }\n", "  }\n", "\n", "  /* Relies on the correctness of BigIntegerMath.log2 for all modes except UNNECESSARY. */\n", "  public void testLog2MatchesBigInteger() {\n", "    for (long x : POSITIVE_LONG_CANDIDATES) {\n", "      for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\n", "        // The BigInteger implementation is tested separately, use it as the reference.\n", "        assertEquals(BigIntegerMath.log2(valueOf(x), mode), LongMath.log2(x, mode));\n", "      }\n", "    }\n", "  }\n", "\n", "  /* Relies on the correctness of isPowerOfTwo(long). */\n", "  public void testLog2Exact() {\n", "    for (long x : POSITIVE_LONG_CANDIDATES) {\n", "      // We only expect an exception if x was not a power of 2.\n", "      boolean isPowerOf2 = LongMath.isPowerOfTwo(x);\n", "      try {\n", "        assertEquals(x, 1L << LongMath.log2(x, UNNECESSARY));\n", "        assertTrue(isPowerOf2);\n", "      } catch (ArithmeticException e) {\n", "        assertFalse(isPowerOf2);\n", "      }\n", "    }\n", "  }\n", "\n", "  // Relies on the correctness of BigIntegerMath.log10 for all modes except UNNECESSARY.\n", "\n", "  // Relies on the correctness of log10(long, FLOOR) and of pow(long, int).\n", "\n", "  // Relies on the correctness of BigIntegerMath.sqrt for all modes except UNNECESSARY.\n", "\n", "  /* Relies on the correctness of sqrt(long, FLOOR). */\n", "\n", "  public void testGCDExhaustive() {\n", "    for (long a : POSITIVE_LONG_CANDIDATES) {\n", "      for (long b : POSITIVE_LONG_CANDIDATES) {\n", "        assertEquals(valueOf(a).gcd(valueOf(b)), valueOf(LongMath.gcd(a, b)));\n", "      }\n", "    }\n", "  }\n", "\n", "  // Depends on the correctness of BigIntegerMath.factorial.\n", "\n", "  // Depends on the correctness of BigIntegerMath.binomial.\n", "  public void testBinomial() {\n", "    for (int n = 0; n <= 70; n++) {\n", "      for (int k = 0; k <= n; k++) {\n", "        BigInteger expectedBig = BigIntegerMath.binomial(n, k);\n", "        long expectedLong = fitsInLong(expectedBig) ? expectedBig.longValue() : Long.MAX_VALUE;\n", "        assertEquals(expectedLong, LongMath.binomial(n, k));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testBinomialOutside() {\n", "    for (int n = 0; n <= 50; n++) {\n", "      try {\n", "        LongMath.binomial(n, -1);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "      try {\n", "        LongMath.binomial(n, n + 1);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testBinomialNegative() {\n", "    for (int n : NEGATIVE_INTEGER_CANDIDATES) {\n", "      try {\n", "        LongMath.binomial(n, 0);\n", "        fail(\"Expected IllegalArgumentException\");\n", "      } catch (IllegalArgumentException expected) {}\n", "    }\n", "  }\n", "  \n", "  public void testSqrtOfLongIsAtMostFloorSqrtMaxLong() {\n", "    long sqrtMaxLong = (long) Math.sqrt(Long.MAX_VALUE);\n", "    assertTrue(sqrtMaxLong <= LongMath.FLOOR_SQRT_MAX_LONG);\n", "  }\n", "\n", "  /**\n", "   * Helper method that asserts the arithmetic mean of x and y is equal\n", "   * to the expectedMean.\n", "   */\n", "  private static void assertMean(long expectedMean, long x, long y) {\n", "    assertEquals(\"The expectedMean should be the same as computeMeanSafely\",\n", "        expectedMean, computeMeanSafely(x, y));\n", "    assertMean(x, y);\n", "  }\n", "\n", "  /**\n", "   * Helper method that asserts the arithmetic mean of x and y is equal\n", "   *to the result of computeMeanSafely.\n", "   */\n", "  private static void assertMean(long x, long y) {\n", "    long expectedMean = computeMeanSafely(x, y);\n", "    assertEquals(expectedMean, LongMath.mean(x, y));\n", "    assertEquals(\"The mean of x and y should equal the mean of y and x\",\n", "        expectedMean, LongMath.mean(y, x));\n", "  }\n", "\n", "  /**\n", "   * Computes the mean in a way that is obvious and resilient to\n", "   * overflow by using BigInteger arithmetic.\n", "   */\n", "  private static long computeMeanSafely(long x, long y) {\n", "    BigInteger bigX = BigInteger.valueOf(x);\n", "    BigInteger bigY = BigInteger.valueOf(y);\n", "    BigDecimal bigMean = new BigDecimal(bigX.add(bigY))\n", "        .divide(BigDecimal.valueOf(2), BigDecimal.ROUND_FLOOR);\n", "    // parseInt blows up on overflow as opposed to intValue() which does not.\n", "    return Long.parseLong(bigMean.toString());\n", "  }\n", "\n", "  private static boolean fitsInLong(BigInteger big) {\n", "    return big.bitLength() <= 63;\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197]}}, {"172": "guava-gwt/test-super/com/google/common/net/super/com/google/common/net/InternetDomainNameTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.net;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Ascii;\n", "import com.google.common.base.Strings;\n", "import com.google.common.collect.ImmutableSet;\n", "import com.google.common.collect.Iterables;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "/**\n", " * {@link TestCase} for {@link InternetDomainName}.\n", " *\n", " * @author Craig Berry\n", " */\n", "@GwtCompatible(emulated = true)\n", "public final class InternetDomainNameTest extends TestCase {\n", "  private static final InternetDomainName UNICODE_EXAMPLE =\n", "      InternetDomainName.from(\"j\\u00f8rpeland.no\");\n", "  private static final InternetDomainName PUNYCODE_EXAMPLE =\n", "      InternetDomainName.from(\"xn--jrpeland-54a.no\");\n", "\n", "  /**\n", "   * The Greek letter delta, used in unicode testing.\n", "   */\n", "  private static final String DELTA = \"\\u0394\";\n", "\n", "  /**\n", "   * A domain part which is valid under lenient validation, but invalid under\n", "   * strict validation.\n", "   */\n", "  static final String LOTS_OF_DELTAS = Strings.repeat(DELTA, 62);\n", "\n", "  private static final String ALMOST_TOO_MANY_LEVELS =\n", "      Strings.repeat(\"a.\", 127);\n", "\n", "  private static final String ALMOST_TOO_LONG =\n", "      Strings.repeat(\"aaaaa.\", 40) + \"1234567890.c\";\n", "\n", "  private static final ImmutableSet<String> VALID_NAME = ImmutableSet.of(\n", "      \"foo.com\",\n", "      \"f-_-o.cOM\",\n", "      \"f--1.com\",\n", "      \"f11-1.com\",\n", "      \"www\",\n", "      \"abc.a23\",\n", "      \"biz.com.ua\",\n", "      \"x\",\n", "      \"fOo\",\n", "      \"f--o\",\n", "      \"f_a\",\n", "      \"foo.net.us\\uFF61ocm\",\n", "      \"woo.com.\",\n", "      \"a\" + DELTA + \"b.com\",\n", "      ALMOST_TOO_MANY_LEVELS,\n", "      ALMOST_TOO_LONG);\n", "\n", "  private static final ImmutableSet<String> INVALID_NAME = ImmutableSet.of(\n", "      \"\",\n", "      \" \",\n", "      \"127.0.0.1\",\n", "      \"::1\", \"13\",\n", "      \"abc.12c\",\n", "      \"foo-.com\",\n", "      \"_bar.quux\",\n", "      \"foo+bar.com\",\n", "      \"foo!bar.com\",\n", "      \".foo.com\",\n", "      \"..bar.com\",\n", "      \"baz..com\",\n", "      \"..quiffle.com\",\n", "      \"fleeb.com..\",\n", "      \".\",\n", "      \"..\",\n", "      \"...\",\n", "      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.com\",\n", "      \"a\" + DELTA + \" .com\",\n", "      ALMOST_TOO_MANY_LEVELS + \"com\",\n", "      ALMOST_TOO_LONG + \".c\");\n", "\n", "  private static final ImmutableSet<String> PS = ImmutableSet.of(\n", "      \"com\",\n", "      \"co.uk\",\n", "      \"foo.bd\",\n", "      \"xxxxxx.bd\",\n", "      \"org.mK\",\n", "      \"us\",\n", "      \"uk\\uFF61com.\",  // Alternate dot character\n", "      \"\\u7f51\\u7edc.Cn\",  // \"\u7f51\u7edc.Cn\"\n", "      \"j\\u00f8rpeland.no\",  // \"jorpeland.no\" (first o slashed)\n", "      \"xn--jrpeland-54a.no\"  // IDNA (punycode) encoding of above\n", "  );\n", "\n", "  private static final ImmutableSet<String> NO_PS = ImmutableSet.of(\n", "      \"www\", \"foo.ihopethiswillneverbeapublicsuffix\", \"x.y.z\");\n", "\n", "  private static final ImmutableSet<String> NON_PS = ImmutableSet.of(\n", "      \"foo.bar.com\", \"foo.ca\", \"foo.bar.ca\",\n", "      \"foo.bar.co.il\", \"state.CA.us\", \"www.state.pa.us\", \"pvt.k12.ca.us\",\n", "      \"www.google.com\", \"www4.yahoo.co.uk\", \"home.netscape.com\",\n", "      \"web.MIT.edu\", \"foo.eDu.au\", \"utenti.blah.IT\", \"dominio.com.co\");\n", "\n", "  private static final ImmutableSet<String> TOP_PRIVATE_DOMAIN =\n", "      ImmutableSet.of(\"google.com\", \"foo.Co.uk\", \"foo.ca.us.\");\n", "\n", "  private static final ImmutableSet<String> UNDER_PRIVATE_DOMAIN =\n", "      ImmutableSet.of(\"foo.bar.google.com\", \"a.b.co.uk\", \"x.y.ca.us\");\n", "\n", "  private static final ImmutableSet<String> VALID_IP_ADDRS = ImmutableSet.of(\n", "      \"1.2.3.4\", \"127.0.0.1\", \"::1\", \"2001:db8::1\");\n", "\n", "  private static final ImmutableSet<String> INVALID_IP_ADDRS = ImmutableSet.of(\n", "      \"\", \"1\", \"1.2.3\", \"...\", \"1.2.3.4.5\", \"400.500.600.700\",\n", "      \":\", \":::1\", \"2001:db8:\");\n", "\n", "  private static final ImmutableSet<String> SOMEWHERE_UNDER_PS =\n", "      ImmutableSet.of(\n", "          \"foo.bar.google.com\",\n", "          \"a.b.c.1.2.3.ca.us\",\n", "          \"site.jp\",\n", "          \"uomi-online.kir.jp\",\n", "          \"jprs.co.jp\",\n", "          \"site.quick.jp\",\n", "          \"site.tenki.jp\",\n", "          \"site.or.jp\",\n", "          \"site.gr.jp\",\n", "          \"site.ne.jp\",\n", "          \"site.ac.jp\",\n", "          \"site.ad.jp\",\n", "          \"site.ed.jp\",\n", "          \"site.geo.jp\",\n", "          \"site.go.jp\",\n", "          \"site.lg.jp\",\n", "          \"1.fm\",\n", "          \"site.cc\",\n", "          \"site.ee\",\n", "          \"site.fi\",\n", "          \"site.fm\",\n", "          \"site.gr\",\n", "          \"www.leguide.ma\",\n", "          \"site.ma\",\n", "          \"some.org.mk\",\n", "          \"site.mk\",\n", "          \"site.tv\",\n", "          \"site.us\",\n", "          \"www.odev.us\",\n", "          \"www.GOOGLE.com\",\n", "          \"www.com\",\n", "          \"google.com\",\n", "          \"www7.google.co.uk\",\n", "          \"google.Co.uK\",\n", "          \"jobs.kt.com.\",\n", "          \"home.netscape.com\",\n", "          \"web.stanford.edu\",\n", "          \"stanford.edu\",\n", "          \"state.ca.us\",\n", "          \"www.state.ca.us\",\n", "          \"state.ca.us\",\n", "          \"pvt.k12.ca.us\",\n", "          \"www.rave.ca.\",\n", "          \"cnn.ca\",\n", "          \"ledger-enquirer.com\",\n", "          \"it-trace.ch\",\n", "          \"cool.dk\",\n", "          \"cool.co.uk\",\n", "          \"cool.de\",\n", "          \"cool.es\",\n", "          \"cool\\uFF61fr\", // Alternate dot character\n", "          \"cool.nl\",\n", "          \"members.blah.nl.\",\n", "          \"cool.se\",\n", "          \"utenti.blah.it\",\n", "          \"kt.co\",\n", "          \"a\\u7f51\\u7edcA.\\u7f51\\u7edc.Cn\"  // \"a\u7f51\u7edcA.\u7f51\u7edc.Cn\"\n", "      );\n", "\n", "  public void testValid() {\n", "    for (String name : VALID_NAME) {\n", "      InternetDomainName.from(name);\n", "    }\n", "  }\n", "\n", "  public void testInvalid() {\n", "    for (String name : INVALID_NAME) {\n", "      try {\n", "        InternetDomainName.from(name);\n", "        fail(\"Should have been invalid: '\" + name + \"'\");\n", "      } catch (IllegalArgumentException expected) {\n", "        // Expected case\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testPublicSuffix() {\n", "    for (String name : PS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertTrue(name, domain.isPublicSuffix());\n", "      assertTrue(name, domain.hasPublicSuffix());\n", "      assertFalse(name, domain.isUnderPublicSuffix());\n", "      assertFalse(name, domain.isTopPrivateDomain());\n", "      assertEquals(domain, domain.publicSuffix());\n", "    }\n", "\n", "    for (String name : NO_PS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isPublicSuffix());\n", "      assertFalse(name, domain.hasPublicSuffix());\n", "      assertFalse(name, domain.isUnderPublicSuffix());\n", "      assertFalse(name, domain.isTopPrivateDomain());\n", "      assertNull(domain.publicSuffix());\n", "    }\n", "\n", "    for (String name : NON_PS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isPublicSuffix());\n", "      assertTrue(name, domain.hasPublicSuffix());\n", "      assertTrue(name, domain.isUnderPublicSuffix());\n", "    }\n", "  }\n", "\n", "  public void testUnderPublicSuffix() {\n", "    for (String name : SOMEWHERE_UNDER_PS) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isPublicSuffix());\n", "      assertTrue(name, domain.hasPublicSuffix());\n", "      assertTrue(name, domain.isUnderPublicSuffix());\n", "    }\n", "  }\n", "\n", "  public void testTopPrivateDomain() {\n", "    for (String name : TOP_PRIVATE_DOMAIN) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isPublicSuffix());\n", "      assertTrue(name, domain.hasPublicSuffix());\n", "      assertTrue(name, domain.isUnderPublicSuffix());\n", "      assertTrue(name, domain.isTopPrivateDomain());\n", "      assertEquals(domain.parent(), domain.publicSuffix());\n", "    }\n", "  }\n", "\n", "  public void testUnderPrivateDomain() {\n", "    for (String name : UNDER_PRIVATE_DOMAIN) {\n", "      final InternetDomainName domain = InternetDomainName.from(name);\n", "      assertFalse(name, domain.isPublicSuffix());\n", "      assertTrue(name, domain.hasPublicSuffix());\n", "      assertTrue(name, domain.isUnderPublicSuffix());\n", "      assertFalse(name, domain.isTopPrivateDomain());\n", "    }\n", "  }\n", "\n", "  public void testParent() {\n", "    assertEquals(\n", "        \"com\",\n", "        InternetDomainName.from(\"google.com\").parent().toString());\n", "    assertEquals(\n", "        \"uk\",\n", "        InternetDomainName.from(\"co.uk\").parent().toString());\n", "    assertEquals(\n", "        \"google.com\",\n", "        InternetDomainName.from(\"www.google.com\").parent().toString());\n", "\n", "    try {\n", "      InternetDomainName.from(\"com\").parent();\n", "      fail(\"'com' should throw ISE on .parent() call\");\n", "    } catch (IllegalStateException expected) {\n", "    }\n", "  }\n", "\n", "  public void testChild() {\n", "    InternetDomainName domain = InternetDomainName.from(\"foo.com\");\n", "\n", "    assertEquals(\"www.foo.com\", domain.child(\"www\").toString());\n", "\n", "    try {\n", "      domain.child(\"www.\");\n", "      fail(\"www..google.com should have been invalid\");\n", "    } catch (IllegalArgumentException expected) {\n", "      // Expected outcome\n", "    }\n", "  }\n", "\n", "  public void testParentChild() {\n", "    InternetDomainName origin = InternetDomainName.from(\"foo.com\");\n", "    InternetDomainName parent = origin.parent();\n", "    assertEquals(\"com\", parent.toString());\n", "\n", "    // These would throw an exception if leniency were not preserved during parent() and child()\n", "    // calls.\n", "    InternetDomainName child = parent.child(LOTS_OF_DELTAS);\n", "    child.child(LOTS_OF_DELTAS);\n", "  }\n", "\n", "  public void testValidTopPrivateDomain() {\n", "    InternetDomainName googleDomain = InternetDomainName.from(\"google.com\");\n", "\n", "    assertEquals(googleDomain, googleDomain.topPrivateDomain());\n", "    assertEquals(googleDomain, googleDomain.child(\"mail\").topPrivateDomain());\n", "    assertEquals(googleDomain, googleDomain.child(\"foo.bar\").topPrivateDomain());\n", "  }\n", "\n", "  public void testInvalidTopPrivateDomain() {\n", "    ImmutableSet<String> badCookieDomains =\n", "        ImmutableSet.of(\"co.uk\", \"foo\", \"com\");\n", "\n", "    for (String domain : badCookieDomains) {\n", "      try {\n", "        InternetDomainName.from(domain).topPrivateDomain();\n", "        fail(domain);\n", "      } catch (IllegalStateException expected) {\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testIsValid() {\n", "    final Iterable<String> validCases = Iterables.concat(\n", "        VALID_NAME, PS, NO_PS, NON_PS);\n", "    final Iterable<String> invalidCases = Iterables.concat(\n", "        INVALID_NAME, VALID_IP_ADDRS, INVALID_IP_ADDRS);\n", "\n", "    for (String valid : validCases) {\n", "      assertTrue(valid, InternetDomainName.isValid(valid));\n", "    }\n", "\n", "    for (String invalid : invalidCases) {\n", "      assertFalse(invalid, InternetDomainName.isValid(invalid));\n", "    }\n", "  }\n", "\n", "  public void testToString() {\n", "    for (String inputName : SOMEWHERE_UNDER_PS) {\n", "      InternetDomainName domain = InternetDomainName.from(inputName);\n", "\n", "      /*\n", "       * We would ordinarily use constants for the expected results, but\n", "       * doing it by derivation allows us to reuse the test case definitions\n", "       * used in other tests.\n", "       */\n", "\n", "      String expectedName = Ascii.toLowerCase(inputName);\n", "      expectedName = expectedName.replaceAll(\"[\\u3002\\uFF0E\\uFF61]\", \".\");\n", "\n", "      if (expectedName.endsWith(\".\")) {\n", "        expectedName = expectedName.substring(0, expectedName.length() - 1);\n", "      }\n", "\n", "      assertEquals(expectedName, domain.toString());\n", "    }\n", "  }\n", "\n", "  public void testExclusion() {\n", "    InternetDomainName domain = InternetDomainName.from(\"foo.teledata.mz\");\n", "    assertTrue(domain.hasPublicSuffix());\n", "    assertEquals(\"mz\", domain.publicSuffix().toString());\n", "\n", "    // Behold the weirdness!\n", "    assertFalse(domain.publicSuffix().isPublicSuffix());\n", "  }\n", "\n", "  public void testMultipleUnders() {\n", "    // PSL has both *.uk and *.sch.uk; the latter should win.\n", "    // See http://code.google.com/p/guava-libraries/issues/detail?id=1176\n", "\n", "    InternetDomainName domain = InternetDomainName.from(\"www.essex.sch.uk\");\n", "    assertTrue(domain.hasPublicSuffix());\n", "    assertEquals(\"essex.sch.uk\", domain.publicSuffix().toString());\n", "    assertEquals(\"www.essex.sch.uk\", domain.topPrivateDomain().toString());\n", "  }\n", "\n", "  public void testEquality() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(\n", "            idn(\"google.com\"), idn(\"google.com\"), idn(\"GOOGLE.COM\"))\n", "        .addEqualityGroup(idn(\"www.google.com\"))\n", "        .addEqualityGroup(UNICODE_EXAMPLE)\n", "        .addEqualityGroup(PUNYCODE_EXAMPLE)\n", "        .testEquals();\n", "  }\n", "\n", "  private static InternetDomainName idn(String domain) {\n", "    return InternetDomainName.from(domain);\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399]}}, {"173": "guava-gwt/test-super/com/google/common/net/super/com/google/common/net/MediaTypeTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.net;\n", "\n", "import static com.google.common.base.Charsets.UTF_8;\n", "import static com.google.common.net.MediaType.ANY_APPLICATION_TYPE;\n", "import static com.google.common.net.MediaType.ANY_AUDIO_TYPE;\n", "import static com.google.common.net.MediaType.ANY_IMAGE_TYPE;\n", "import static com.google.common.net.MediaType.ANY_TEXT_TYPE;\n", "import static com.google.common.net.MediaType.ANY_TYPE;\n", "import static com.google.common.net.MediaType.ANY_VIDEO_TYPE;\n", "import static com.google.common.net.MediaType.HTML_UTF_8;\n", "import static com.google.common.net.MediaType.JPEG;\n", "import static com.google.common.net.MediaType.PLAIN_TEXT_UTF_8;\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableListMultimap;\n", "import com.google.common.collect.ImmutableMultimap;\n", "import com.google.common.testing.EqualsTester;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.nio.charset.IllegalCharsetNameException;\n", "import java.nio.charset.UnsupportedCharsetException;\n", "\n", "/**\n", " * Tests for {@link MediaType}.\n", " *\n", " * @author Gregory Kick\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class MediaTypeTest extends TestCase {\n", "\n", "  public void testCreate_invalidType() {\n", "    try {\n", "      MediaType.create(\"te><t\", \"plaintext\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreate_invalidSubtype() {\n", "    try {\n", "      MediaType.create(\"text\", \"pl@intext\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreate_wildcardTypeDeclaredSubtype() {\n", "    try {\n", "      MediaType.create(\"*\", \"text\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testCreateApplicationType() {\n", "    MediaType newType = MediaType.createApplicationType(\"yams\");\n", "    assertEquals(\"application\", newType.type());\n", "    assertEquals(\"yams\", newType.subtype());\n", "  }\n", "\n", "  public void testCreateAudioType() {\n", "    MediaType newType = MediaType.createAudioType(\"yams\");\n", "    assertEquals(\"audio\", newType.type());\n", "    assertEquals(\"yams\", newType.subtype());\n", "  }\n", "\n", "  public void testCreateImageType() {\n", "    MediaType newType = MediaType.createImageType(\"yams\");\n", "    assertEquals(\"image\", newType.type());\n", "    assertEquals(\"yams\", newType.subtype());\n", "  }\n", "\n", "  public void testCreateTextType() {\n", "    MediaType newType = MediaType.createTextType(\"yams\");\n", "    assertEquals(\"text\", newType.type());\n", "    assertEquals(\"yams\", newType.subtype());\n", "  }\n", "\n", "  public void testCreateVideoType() {\n", "    MediaType newType = MediaType.createVideoType(\"yams\");\n", "    assertEquals(\"video\", newType.type());\n", "    assertEquals(\"yams\", newType.subtype());\n", "  }\n", "\n", "  public void testGetType() {\n", "    assertEquals(\"text\", MediaType.parse(\"text/plain\").type());\n", "    assertEquals(\"application\",\n", "        MediaType.parse(\"application/atom+xml; charset=utf-8\").type());\n", "  }\n", "\n", "  public void testGetSubtype() {\n", "    assertEquals(\"plain\", MediaType.parse(\"text/plain\").subtype());\n", "    assertEquals(\"atom+xml\",\n", "        MediaType.parse(\"application/atom+xml; charset=utf-8\").subtype());\n", "  }\n", "\n", "  private static final ImmutableListMultimap<String, String> PARAMETERS =\n", "      ImmutableListMultimap.of(\"a\", \"1\", \"a\", \"2\", \"b\", \"3\");\n", "\n", "  public void testGetParameters() {\n", "    assertEquals(ImmutableListMultimap.of(), MediaType.parse(\"text/plain\").parameters());\n", "    assertEquals(ImmutableListMultimap.of(\"charset\", \"utf-8\"),\n", "        MediaType.parse(\"application/atom+xml; charset=utf-8\").parameters());\n", "    assertEquals(PARAMETERS,\n", "        MediaType.parse(\"application/atom+xml; a=1; a=2; b=3\").parameters());\n", "  }\n", "\n", "  public void testWithoutParameters() {\n", "    assertSame(MediaType.parse(\"image/gif\"),\n", "        MediaType.parse(\"image/gif\").withoutParameters());\n", "    assertEquals(MediaType.parse(\"image/gif\"),\n", "        MediaType.parse(\"image/gif; foo=bar\").withoutParameters());\n", "  }\n", "\n", "  public void testWithParameters() {\n", "    assertEquals(MediaType.parse(\"text/plain; a=1; a=2; b=3\"),\n", "        MediaType.parse(\"text/plain\").withParameters(PARAMETERS));\n", "    assertEquals(MediaType.parse(\"text/plain; a=1; a=2; b=3\"),\n", "        MediaType.parse(\"text/plain; a=1; a=2; b=3\").withParameters(PARAMETERS));\n", "  }\n", "\n", "  public void testWithParameters_invalidAttribute() {\n", "    MediaType mediaType = MediaType.parse(\"text/plain\");\n", "    ImmutableListMultimap<String, String> parameters =\n", "        ImmutableListMultimap.of(\"a\", \"1\", \"@\", \"2\", \"b\", \"3\");\n", "    try {\n", "      mediaType.withParameters(parameters);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testWithParameter() {\n", "    assertEquals(MediaType.parse(\"text/plain; a=1\"),\n", "        MediaType.parse(\"text/plain\").withParameter(\"a\", \"1\"));\n", "    assertEquals(MediaType.parse(\"text/plain; a=1\"),\n", "        MediaType.parse(\"text/plain; a=1; a=2\").withParameter(\"a\", \"1\"));\n", "    assertEquals(MediaType.parse(\"text/plain; a=3\"),\n", "        MediaType.parse(\"text/plain; a=1; a=2\").withParameter(\"a\", \"3\"));\n", "    assertEquals(MediaType.parse(\"text/plain; a=1; a=2; b=3\"),\n", "        MediaType.parse(\"text/plain; a=1; a=2\").withParameter(\"b\", \"3\"));\n", "  }\n", "\n", "  public void testWithParameter_invalidAttribute() {\n", "    MediaType mediaType = MediaType.parse(\"text/plain\");\n", "    try {\n", "      mediaType.withParameter(\"@\", \"2\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testWithCharset() {\n", "    assertEquals(MediaType.parse(\"text/plain; charset=utf-8\"),\n", "        MediaType.parse(\"text/plain\").withCharset(UTF_8));\n", "    assertEquals(MediaType.parse(\"text/plain; charset=utf-8\"),\n", "        MediaType.parse(\"text/plain; charset=utf-16\").withCharset(UTF_8));\n", "  }\n", "\n", "  public void testHasWildcard() {\n", "    assertFalse(PLAIN_TEXT_UTF_8.hasWildcard());\n", "    assertFalse(JPEG.hasWildcard());\n", "    assertTrue(ANY_TYPE.hasWildcard());\n", "    assertTrue(ANY_APPLICATION_TYPE.hasWildcard());\n", "    assertTrue(ANY_AUDIO_TYPE.hasWildcard());\n", "    assertTrue(ANY_IMAGE_TYPE.hasWildcard());\n", "    assertTrue(ANY_TEXT_TYPE.hasWildcard());\n", "    assertTrue(ANY_VIDEO_TYPE.hasWildcard());\n", "  }\n", "\n", "  public void testIs() {\n", "    assertTrue(PLAIN_TEXT_UTF_8.is(ANY_TYPE));\n", "    assertTrue(JPEG.is(ANY_TYPE));\n", "    assertTrue(ANY_TEXT_TYPE.is(ANY_TYPE));\n", "    assertTrue(PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE));\n", "    assertTrue(PLAIN_TEXT_UTF_8.withoutParameters().is(ANY_TEXT_TYPE));\n", "    assertFalse(JPEG.is(ANY_TEXT_TYPE));\n", "    assertTrue(PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8));\n", "    assertTrue(PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8.withoutParameters()));\n", "    assertFalse(PLAIN_TEXT_UTF_8.withoutParameters().is(PLAIN_TEXT_UTF_8));\n", "    assertFalse(PLAIN_TEXT_UTF_8.is(HTML_UTF_8));\n", "    assertFalse(PLAIN_TEXT_UTF_8.withParameter(\"charset\", \"UTF-16\").is(PLAIN_TEXT_UTF_8));\n", "    assertFalse(PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8.withParameter(\"charset\", \"UTF-16\")));\n", "  }\n", "\n", "  public void testParse_empty() {\n", "    try {\n", "      MediaType.parse(\"\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testParse_badInput() {\n", "    try {\n", "      MediaType.parse(\"/\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"te<t/plain\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/pl@in\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain;\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; \");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a=\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a=@\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a=\\\"@\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a=1;\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a=1; \");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a=1; b\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a=1; b=\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "    try {\n", "      MediaType.parse(\"text/plain; a=\\u2025\");\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {}\n", "  }\n", "\n", "  public void testGetCharset() {\n", "    assertThat(MediaType.parse(\"text/plain\").charset()).isAbsent();\n", "    assertThat(MediaType.parse(\"text/plain; charset=utf-8\").charset()).hasValue(UTF_8);\n", "  }\n", "\n", "  public void testGetCharset_tooMany() {\n", "    MediaType mediaType = MediaType.parse(\"text/plain; charset=utf-8; charset=utf-16\");\n", "    try {\n", "      mediaType.charset();\n", "      fail();\n", "    } catch (IllegalStateException expected) {}\n", "  }\n", "\n", "  public void testGetCharset_illegalCharset() {\n", "    MediaType mediaType = MediaType.parse(\n", "        \"text/plain; charset=\\\"!@#$%^&*()\\\"\");\n", "    try {\n", "      mediaType.charset();\n", "      fail();\n", "    } catch (IllegalCharsetNameException expected) {}\n", "  }\n", "\n", "  public void testGetCharset_unsupportedCharset() {\n", "    MediaType mediaType = MediaType.parse(\n", "        \"text/plain; charset=utf-wtf\");\n", "    try {\n", "      mediaType.charset();\n", "      fail();\n", "    } catch (UnsupportedCharsetException expected) {}\n", "  }\n", "\n", "  public void testEquals() {\n", "    new EqualsTester()\n", "        .addEqualityGroup(MediaType.create(\"text\", \"plain\"),\n", "            MediaType.create(\"TEXT\", \"PLAIN\"),\n", "            MediaType.parse(\"text/plain\"),\n", "            MediaType.parse(\"TEXT/PLAIN\"),\n", "            MediaType.create(\"text\", \"plain\").withParameter(\"a\", \"1\").withoutParameters())\n", "        .addEqualityGroup(\n", "            MediaType.create(\"text\", \"plain\").withCharset(UTF_8),\n", "            MediaType.create(\"text\", \"plain\").withParameter(\"CHARSET\", \"UTF-8\"),\n", "            MediaType.create(\"text\", \"plain\").withParameters(\n", "                ImmutableMultimap.of(\"charset\", \"utf-8\")),\n", "            MediaType.parse(\"text/plain;charset=utf-8\"),\n", "            MediaType.parse(\"text/plain; charset=utf-8\"),\n", "            MediaType.parse(\"text/plain;  charset=utf-8\"),\n", "            MediaType.parse(\"text/plain; \\tcharset=utf-8\"),\n", "            MediaType.parse(\"text/plain; \\r\\n\\tcharset=utf-8\"),\n", "            MediaType.parse(\"text/plain; CHARSET=utf-8\"),\n", "            MediaType.parse(\"text/plain; charset=\\\"utf-8\\\"\"),\n", "            MediaType.parse(\"text/plain; charset=\\\"\\\\u\\\\tf-\\\\8\\\"\"),\n", "            MediaType.parse(\"text/plain; charset=UTF-8\"))\n", "        .addEqualityGroup(MediaType.parse(\"text/plain; charset=utf-8; charset=utf-8\"))\n", "        .addEqualityGroup(MediaType.create(\"text\", \"plain\").withParameter(\"a\", \"value\"),\n", "            MediaType.create(\"text\", \"plain\").withParameter(\"A\", \"value\"))\n", "        .addEqualityGroup(MediaType.create(\"text\", \"plain\").withParameter(\"a\", \"VALUE\"),\n", "            MediaType.create(\"text\", \"plain\").withParameter(\"A\", \"VALUE\"))\n", "        .addEqualityGroup(\n", "            MediaType.create(\"text\", \"plain\")\n", "                .withParameters(ImmutableListMultimap.of(\"a\", \"1\", \"a\", \"2\")),\n", "            MediaType.create(\"text\", \"plain\")\n", "                .withParameters(ImmutableListMultimap.of(\"a\", \"2\", \"a\", \"1\")))\n", "        .addEqualityGroup(MediaType.create(\"text\", \"csv\"))\n", "        .addEqualityGroup(MediaType.create(\"application\", \"atom+xml\"))\n", "        .testEquals();\n", "  }\n", "\n", "  public void testToString() {\n", "    assertEquals(\"text/plain\", MediaType.create(\"text\", \"plain\").toString());\n", "    assertEquals(\"text/plain; something=\\\"cr@zy\\\"; something-else=\\\"crazy with spaces\\\"\",\n", "        MediaType.create(\"text\", \"plain\")\n", "            .withParameter(\"something\", \"cr@zy\")\n", "            .withParameter(\"something-else\", \"crazy with spaces\")\n", "            .toString());\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349]}}, {"174": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/BooleansTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link Booleans}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class BooleansTest extends TestCase {\n", "  private static final boolean[] EMPTY = {};\n", "  private static final boolean[] ARRAY_FALSE = {false};\n", "  private static final boolean[] ARRAY_TRUE = {true};\n", "  private static final boolean[] ARRAY_FALSE_FALSE = {false, false};\n", "  private static final boolean[] ARRAY_FALSE_TRUE = {false, true};\n", "\n", "  private static final boolean[] VALUES = {false, true};\n", "\n", "  public void testHashCode() {\n", "    assertEquals(Boolean.TRUE.hashCode(), Booleans.hashCode(true));\n", "    assertEquals(Boolean.FALSE.hashCode(), Booleans.hashCode(false));\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (boolean x : VALUES) {\n", "      for (boolean y : VALUES) {\n", "        // note: spec requires only that the sign is the same\n", "        assertEquals(x + \", \" + y,\n", "                     Boolean.valueOf(x).compareTo(y),\n", "                     Booleans.compare(x, y));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(Booleans.contains(EMPTY, false));\n", "    assertFalse(Booleans.contains(ARRAY_FALSE, true));\n", "    assertTrue(Booleans.contains(ARRAY_FALSE, false));\n", "    assertTrue(Booleans.contains(ARRAY_FALSE_TRUE, false));\n", "    assertTrue(Booleans.contains(ARRAY_FALSE_TRUE, true));\n", "  }\n", "\n", "  public void testIndexOf() {\n", "    assertEquals(-1, Booleans.indexOf(EMPTY, ARRAY_FALSE));\n", "    assertEquals(-1, Booleans.indexOf(ARRAY_FALSE, ARRAY_FALSE_TRUE));\n", "    assertEquals(0, Booleans.indexOf(ARRAY_FALSE_FALSE, ARRAY_FALSE));\n", "    assertEquals(0, Booleans.indexOf(ARRAY_FALSE, ARRAY_FALSE));\n", "    assertEquals(0, Booleans.indexOf(ARRAY_FALSE_TRUE, ARRAY_FALSE));\n", "    assertEquals(1, Booleans.indexOf(ARRAY_FALSE_TRUE, ARRAY_TRUE));\n", "    assertEquals(0, Booleans.indexOf(ARRAY_TRUE, new boolean[0]));\n", "  }\n", "\n", "  public void testIndexOf_arrays() {\n", "    assertEquals(-1, Booleans.indexOf(EMPTY, false));\n", "    assertEquals(-1, Booleans.indexOf(ARRAY_FALSE, true));\n", "    assertEquals(-1, Booleans.indexOf(ARRAY_FALSE_FALSE, true));\n", "    assertEquals(0, Booleans.indexOf(ARRAY_FALSE, false));\n", "    assertEquals(0, Booleans.indexOf(ARRAY_FALSE_TRUE, false));\n", "    assertEquals(1, Booleans.indexOf(ARRAY_FALSE_TRUE, true));\n", "    assertEquals(2, Booleans.indexOf(new boolean[] {false, false, true}, true));\n", "  }\n", "\n", "  public void testLastIndexOf() {\n", "    assertEquals(-1, Booleans.lastIndexOf(EMPTY, false));\n", "    assertEquals(-1, Booleans.lastIndexOf(ARRAY_FALSE, true));\n", "    assertEquals(-1, Booleans.lastIndexOf(ARRAY_FALSE_FALSE, true));\n", "    assertEquals(0, Booleans.lastIndexOf(ARRAY_FALSE, false));\n", "    assertEquals(0, Booleans.lastIndexOf(ARRAY_FALSE_TRUE, false));\n", "    assertEquals(1, Booleans.lastIndexOf(ARRAY_FALSE_TRUE, true));\n", "    assertEquals(2, Booleans.lastIndexOf(new boolean[] {false, true, true}, true));\n", "  }\n", "\n", "  public void testConcat() {\n", "    assertTrue(Arrays.equals(EMPTY, Booleans.concat()));\n", "    assertTrue(Arrays.equals(EMPTY, Booleans.concat(EMPTY)));\n", "    assertTrue(Arrays.equals(EMPTY, Booleans.concat(EMPTY, EMPTY, EMPTY)));\n", "    assertTrue(Arrays.equals(ARRAY_FALSE, Booleans.concat(ARRAY_FALSE)));\n", "    assertNotSame(ARRAY_FALSE, Booleans.concat(ARRAY_FALSE));\n", "    assertTrue(Arrays.equals(ARRAY_FALSE, Booleans.concat(EMPTY, ARRAY_FALSE, EMPTY)));\n", "    assertTrue(Arrays.equals(\n", "        new boolean[] {false, false, false},\n", "        Booleans.concat(ARRAY_FALSE, ARRAY_FALSE, ARRAY_FALSE)));\n", "    assertTrue(Arrays.equals(\n", "        new boolean[] {false, false, true},\n", "        Booleans.concat(ARRAY_FALSE, ARRAY_FALSE_TRUE)));\n", "  }\n", "\n", "  public void testEnsureCapacity() {\n", "    assertSame(EMPTY, Booleans.ensureCapacity(EMPTY, 0, 1));\n", "    assertSame(ARRAY_FALSE, Booleans.ensureCapacity(ARRAY_FALSE, 0, 1));\n", "    assertSame(ARRAY_FALSE, Booleans.ensureCapacity(ARRAY_FALSE, 1, 1));\n", "    assertTrue(Arrays.equals(\n", "        new boolean[] {true, false, false},\n", "        Booleans.ensureCapacity(new boolean[] {true}, 2, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEnsureCapacity_fail() {\n", "    try {\n", "      Booleans.ensureCapacity(ARRAY_FALSE, -1, 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // notice that this should even fail when no growth was needed\n", "      Booleans.ensureCapacity(ARRAY_FALSE, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testJoin() {\n", "    assertEquals(\"\", Booleans.join(\",\", EMPTY));\n", "    assertEquals(\"false\", Booleans.join(\",\", ARRAY_FALSE));\n", "    assertEquals(\"false,true\", Booleans.join(\",\", false, true));\n", "    assertEquals(\"falsetruefalse\",\n", "        Booleans.join(\"\", false, true, false));\n", "  }\n", "\n", "  public void testLexicographicalComparator() {\n", "    List<boolean[]> ordered = Arrays.asList(\n", "        new boolean[] {},\n", "        new boolean[] {false},\n", "        new boolean[] {false, false},\n", "        new boolean[] {false, true},\n", "        new boolean[] {true},\n", "        new boolean[] {true, false},\n", "        new boolean[] {true, true},\n", "        new boolean[] {true, true, true});\n", "\n", "    Comparator<boolean[]> comparator = Booleans.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testToArray() {\n", "    // need explicit type parameter to avoid javac warning!?\n", "    List<Boolean> none = Arrays.<Boolean>asList();\n", "    assertTrue(Arrays.equals(EMPTY, Booleans.toArray(none)));\n", "\n", "    List<Boolean> one = Arrays.asList(false);\n", "    assertTrue(Arrays.equals(ARRAY_FALSE, Booleans.toArray(one)));\n", "\n", "    boolean[] array = {false, false, true};\n", "\n", "    List<Boolean> three = Arrays.asList(false, false, true);\n", "    assertTrue(Arrays.equals(array, Booleans.toArray(three)));\n", "\n", "    assertTrue(Arrays.equals(array, Booleans.toArray(Booleans.asList(array))));\n", "  }\n", "\n", "  public void testToArray_threadSafe() {\n", "    // Only for booleans, we lengthen VALUES\n", "    boolean[] VALUES = BooleansTest.VALUES;\n", "    VALUES = Booleans.concat(VALUES, VALUES);\n", "\n", "    for (int delta : new int[] { +1, 0, -1 }) {\n", "      for (int i = 0; i < VALUES.length; i++) {\n", "        List<Boolean> list = Booleans.asList(VALUES).subList(0, i);\n", "        Collection<Boolean> misleadingSize =\n", "            Helpers.misleadingSizeCollection(delta);\n", "        misleadingSize.addAll(list);\n", "        boolean[] arr = Booleans.toArray(misleadingSize);\n", "        assertEquals(i, arr.length);\n", "        for (int j = 0; j < i; j++) {\n", "          assertEquals(VALUES[j], arr[j]);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testToArray_withNull() {\n", "    List<Boolean> list = Arrays.asList(false, true, null);\n", "    try {\n", "      Booleans.toArray(list);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsListIsEmpty() {\n", "    assertTrue(Booleans.asList(EMPTY).isEmpty());\n", "    assertFalse(Booleans.asList(ARRAY_FALSE).isEmpty());\n", "  }\n", "\n", "  public void testAsListSize() {\n", "    assertEquals(0, Booleans.asList(EMPTY).size());\n", "    assertEquals(1, Booleans.asList(ARRAY_FALSE).size());\n", "    assertEquals(2, Booleans.asList(ARRAY_FALSE_TRUE).size());\n", "  }\n", "\n", "  public void testAsListIndexOf() {\n", "    assertEquals(-1, Booleans.asList(EMPTY).indexOf(\"wrong type\"));\n", "    assertEquals(-1, Booleans.asList(EMPTY).indexOf(true));\n", "    assertEquals(-1, Booleans.asList(ARRAY_FALSE).indexOf(true));\n", "    assertEquals(0, Booleans.asList(ARRAY_FALSE).indexOf(false));\n", "    assertEquals(1, Booleans.asList(ARRAY_FALSE_TRUE).indexOf(true));\n", "  }\n", "\n", "  public void testAsListLastIndexOf() {\n", "    assertEquals(-1, Booleans.asList(EMPTY).indexOf(\"wrong type\"));\n", "    assertEquals(-1, Booleans.asList(EMPTY).indexOf(true));\n", "    assertEquals(-1, Booleans.asList(ARRAY_FALSE).lastIndexOf(true));\n", "    assertEquals(1, Booleans.asList(ARRAY_FALSE_TRUE).lastIndexOf(true));\n", "    assertEquals(1, Booleans.asList(ARRAY_FALSE_FALSE).lastIndexOf(false));\n", "  }\n", "\n", "  public void testAsListContains() {\n", "    assertFalse(Booleans.asList(EMPTY).contains(\"wrong type\"));\n", "    assertFalse(Booleans.asList(EMPTY).contains(true));\n", "    assertFalse(Booleans.asList(ARRAY_FALSE).contains(true));\n", "    assertTrue(Booleans.asList(ARRAY_TRUE).contains(true));\n", "    assertTrue(Booleans.asList(ARRAY_FALSE_TRUE).contains(false));\n", "    assertTrue(Booleans.asList(ARRAY_FALSE_TRUE).contains(true));\n", "  }\n", "\n", "  public void testAsListEquals() {\n", "    assertEquals(Booleans.asList(EMPTY), Collections.emptyList());\n", "    assertEquals(Booleans.asList(ARRAY_FALSE), Booleans.asList(ARRAY_FALSE));\n", "    assertFalse(Booleans.asList(ARRAY_FALSE).equals(ARRAY_FALSE));\n", "    assertFalse(Booleans.asList(ARRAY_FALSE).equals(null));\n", "    assertFalse(Booleans.asList(ARRAY_FALSE).equals(Booleans.asList(ARRAY_FALSE_TRUE)));\n", "    assertFalse(Booleans.asList(ARRAY_FALSE_FALSE).equals(Booleans.asList(ARRAY_FALSE_TRUE)));\n", "    assertEquals(1, Booleans.asList(ARRAY_FALSE_TRUE).lastIndexOf(true));\n", "    List<Boolean> reference = Booleans.asList(ARRAY_FALSE);\n", "    assertEquals(Booleans.asList(ARRAY_FALSE), reference);\n", "    assertEquals(reference, reference);\n", "  }\n", "\n", "  public void testAsListHashcode() {\n", "    assertEquals(1, Booleans.asList(EMPTY).hashCode());\n", "    assertEquals(Booleans.asList(ARRAY_FALSE).hashCode(), Booleans.asList(ARRAY_FALSE).hashCode());\n", "    List<Boolean> reference = Booleans.asList(ARRAY_FALSE);\n", "    assertEquals(Booleans.asList(ARRAY_FALSE).hashCode(), reference.hashCode());\n", "  }\n", "\n", "  public void testAsListToString() {\n", "    assertEquals(\"[false]\", Booleans.asList(ARRAY_FALSE).toString());\n", "    assertEquals(\"[false, true]\", Booleans.asList(ARRAY_FALSE_TRUE).toString());\n", "  }\n", "\n", "  public void testAsListSet() {\n", "    List<Boolean> list = Booleans.asList(ARRAY_FALSE);\n", "    assertFalse(list.set(0, true));\n", "    assertTrue(list.set(0, false));\n", "    try {\n", "      list.set(0, null);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "    try {\n", "      list.set(1, true);\n", "      fail();\n", "    } catch (IndexOutOfBoundsException expected) {\n", "    }\n", "  }\n", "\n", "  public void testCountTrue() {\n", "    assertEquals(0, Booleans.countTrue());\n", "    assertEquals(0, Booleans.countTrue(false));\n", "    assertEquals(1, Booleans.countTrue(true));\n", "    assertEquals(3, Booleans.countTrue(false, true, false, true, false, true));\n", "    assertEquals(1, Booleans.countTrue(false, false, true, false, false));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292]}}, {"175": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/ByteArrayAsListTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.TestListGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Test suite covering {@link Bytes#asList(byte[])}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ByteArrayAsListTest extends TestCase {\n", "\n", "  private static List<Byte> asList(Byte[] values) {\n", "    byte[] temp = new byte[values.length];\n", "    for (int i = 0; i < values.length; i++) {\n", "      temp[i] = checkNotNull(values[i]);  // checkNotNull for GWT (do not optimize).\n", "    }\n", "    return Bytes.asList(temp);\n", "  }\n", "\n", "  // Test generators.  To let the GWT test suite generator access them, they need to be\n", "  // public named classes with a public default constructor.\n", "\n", "  public static final class BytesAsListGenerator extends TestByteListGenerator {\n", "    @Override protected List<Byte> create(Byte[] elements) {\n", "      return asList(elements);\n", "    }\n", "  }\n", "\n", "  public static final class BytesAsListHeadSubListGenerator extends TestByteListGenerator {\n", "    @Override protected List<Byte> create(Byte[] elements) {\n", "      Byte[] suffix = {Byte.MIN_VALUE, Byte.MAX_VALUE};\n", "      Byte[] all = concat(elements, suffix);\n", "      return asList(all).subList(0, elements.length);\n", "    }\n", "  }\n", "\n", "  public static final class BytesAsListTailSubListGenerator extends TestByteListGenerator {\n", "    @Override protected List<Byte> create(Byte[] elements) {\n", "      Byte[] prefix = {(byte) 86, (byte) 99};\n", "      Byte[] all = concat(prefix, elements);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  public static final class BytesAsListMiddleSubListGenerator extends TestByteListGenerator {\n", "    @Override protected List<Byte> create(Byte[] elements) {\n", "      Byte[] prefix = {Byte.MIN_VALUE, Byte.MAX_VALUE};\n", "      Byte[] suffix = {(byte) 86, (byte) 99};\n", "      Byte[] all = concat(concat(prefix, elements), suffix);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  private static Byte[] concat(Byte[] left, Byte[] right) {\n", "    Byte[] result = new Byte[left.length + right.length];\n", "    System.arraycopy(left, 0, result, 0, left.length);\n", "    System.arraycopy(right, 0, result, left.length, right.length);\n", "    return result;\n", "  }\n", "\n", "  public static abstract class TestByteListGenerator\n", "      implements TestListGenerator<Byte> {\n", "    @Override\n", "    public SampleElements<Byte> samples() {\n", "      return new SampleBytes();\n", "    }\n", "\n", "    @Override\n", "    public List<Byte> create(Object... elements) {\n", "      Byte[] array = new Byte[elements.length];\n", "      int i = 0;\n", "      for (Object e : elements) {\n", "        array[i++] = (Byte) e;\n", "      }\n", "      return create(array);\n", "    }\n", "\n", "    /**\n", "     * Creates a new collection containing the given elements; implement this\n", "     * method instead of {@link #create(Object...)}.\n", "     */\n", "    protected abstract List<Byte> create(Byte[] elements);\n", "\n", "    @Override\n", "    public Byte[] createArray(int length) {\n", "      return new Byte[length];\n", "    }\n", "\n", "    /** Returns the original element list, unchanged. */\n", "    @Override\n", "    public List<Byte> order(List<Byte> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class SampleBytes extends SampleElements<Byte> {\n", "    public SampleBytes() {\n", "      super((byte) 0, (byte) 1, (byte) 2, (byte) 3, (byte) 4);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"176": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/BytesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link Bytes}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class BytesTest extends TestCase {\n", "  private static final byte[] EMPTY = {};\n", "  private static final byte[] ARRAY1 = {(byte) 1};\n", "  private static final byte[] ARRAY234\n", "      = {(byte) 2, (byte) 3, (byte) 4};\n", "\n", "  private static final byte[] VALUES =\n", "      { Byte.MIN_VALUE, -1, 0, 1, Byte.MAX_VALUE };\n", "\n", "  public void testHashCode() {\n", "    for (byte value : VALUES) {\n", "      assertEquals(((Byte) value).hashCode(), Bytes.hashCode(value));\n", "    }\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(Bytes.contains(EMPTY, (byte) 1));\n", "    assertFalse(Bytes.contains(ARRAY1, (byte) 2));\n", "    assertFalse(Bytes.contains(ARRAY234, (byte) 1));\n", "    assertTrue(Bytes.contains(new byte[] {(byte) -1}, (byte) -1));\n", "    assertTrue(Bytes.contains(ARRAY234, (byte) 2));\n", "    assertTrue(Bytes.contains(ARRAY234, (byte) 3));\n", "    assertTrue(Bytes.contains(ARRAY234, (byte) 4));\n", "  }\n", "\n", "  public void testIndexOf() {\n", "    assertEquals(-1, Bytes.indexOf(EMPTY, (byte) 1));\n", "    assertEquals(-1, Bytes.indexOf(ARRAY1, (byte) 2));\n", "    assertEquals(-1, Bytes.indexOf(ARRAY234, (byte) 1));\n", "    assertEquals(0, Bytes.indexOf(\n", "        new byte[] {(byte) -1}, (byte) -1));\n", "    assertEquals(0, Bytes.indexOf(ARRAY234, (byte) 2));\n", "    assertEquals(1, Bytes.indexOf(ARRAY234, (byte) 3));\n", "    assertEquals(2, Bytes.indexOf(ARRAY234, (byte) 4));\n", "    assertEquals(1, Bytes.indexOf(\n", "        new byte[] { (byte) 2, (byte) 3, (byte) 2, (byte) 3 },\n", "        (byte) 3));\n", "  }\n", "\n", "  public void testIndexOf_arrayTarget() {\n", "    assertEquals(0, Bytes.indexOf(EMPTY, EMPTY));\n", "    assertEquals(0, Bytes.indexOf(ARRAY234, EMPTY));\n", "    assertEquals(-1, Bytes.indexOf(EMPTY, ARRAY234));\n", "    assertEquals(-1, Bytes.indexOf(ARRAY234, ARRAY1));\n", "    assertEquals(-1, Bytes.indexOf(ARRAY1, ARRAY234));\n", "    assertEquals(0, Bytes.indexOf(ARRAY1, ARRAY1));\n", "    assertEquals(0, Bytes.indexOf(ARRAY234, ARRAY234));\n", "    assertEquals(0, Bytes.indexOf(\n", "        ARRAY234, new byte[] { (byte) 2, (byte) 3 }));\n", "    assertEquals(1, Bytes.indexOf(\n", "        ARRAY234, new byte[] { (byte) 3, (byte) 4 }));\n", "    assertEquals(1, Bytes.indexOf(ARRAY234, new byte[] { (byte) 3 }));\n", "    assertEquals(2, Bytes.indexOf(ARRAY234, new byte[] { (byte) 4 }));\n", "    assertEquals(1, Bytes.indexOf(new byte[] { (byte) 2, (byte) 3,\n", "        (byte) 3, (byte) 3, (byte) 3 },\n", "        new byte[] { (byte) 3 }\n", "    ));\n", "    assertEquals(2, Bytes.indexOf(\n", "        new byte[] { (byte) 2, (byte) 3, (byte) 2,\n", "            (byte) 3, (byte) 4, (byte) 2, (byte) 3},\n", "        new byte[] { (byte) 2, (byte) 3, (byte) 4}\n", "    ));\n", "    assertEquals(1, Bytes.indexOf(\n", "        new byte[] { (byte) 2, (byte) 2, (byte) 3,\n", "            (byte) 4, (byte) 2, (byte) 3, (byte) 4},\n", "        new byte[] { (byte) 2, (byte) 3, (byte) 4}\n", "    ));\n", "    assertEquals(-1, Bytes.indexOf(\n", "        new byte[] { (byte) 4, (byte) 3, (byte) 2},\n", "        new byte[] { (byte) 2, (byte) 3, (byte) 4}\n", "    ));\n", "  }\n", "\n", "  public void testLastIndexOf() {\n", "    assertEquals(-1, Bytes.lastIndexOf(EMPTY, (byte) 1));\n", "    assertEquals(-1, Bytes.lastIndexOf(ARRAY1, (byte) 2));\n", "    assertEquals(-1, Bytes.lastIndexOf(ARRAY234, (byte) 1));\n", "    assertEquals(0, Bytes.lastIndexOf(\n", "        new byte[] {(byte) -1}, (byte) -1));\n", "    assertEquals(0, Bytes.lastIndexOf(ARRAY234, (byte) 2));\n", "    assertEquals(1, Bytes.lastIndexOf(ARRAY234, (byte) 3));\n", "    assertEquals(2, Bytes.lastIndexOf(ARRAY234, (byte) 4));\n", "    assertEquals(3, Bytes.lastIndexOf(\n", "        new byte[] { (byte) 2, (byte) 3, (byte) 2, (byte) 3 },\n", "        (byte) 3));\n", "  }\n", "\n", "  public void testConcat() {\n", "    assertTrue(Arrays.equals(EMPTY, Bytes.concat()));\n", "    assertTrue(Arrays.equals(EMPTY, Bytes.concat(EMPTY)));\n", "    assertTrue(Arrays.equals(EMPTY, Bytes.concat(EMPTY, EMPTY, EMPTY)));\n", "    assertTrue(Arrays.equals(ARRAY1, Bytes.concat(ARRAY1)));\n", "    assertNotSame(ARRAY1, Bytes.concat(ARRAY1));\n", "    assertTrue(Arrays.equals(ARRAY1, Bytes.concat(EMPTY, ARRAY1, EMPTY)));\n", "    assertTrue(Arrays.equals(\n", "        new byte[] {(byte) 1, (byte) 1, (byte) 1},\n", "        Bytes.concat(ARRAY1, ARRAY1, ARRAY1)));\n", "    assertTrue(Arrays.equals(\n", "        new byte[] {(byte) 1, (byte) 2, (byte) 3, (byte) 4},\n", "        Bytes.concat(ARRAY1, ARRAY234)));\n", "  }\n", "\n", "  public void testEnsureCapacity() {\n", "    assertSame(EMPTY, Bytes.ensureCapacity(EMPTY, 0, 1));\n", "    assertSame(ARRAY1, Bytes.ensureCapacity(ARRAY1, 0, 1));\n", "    assertSame(ARRAY1, Bytes.ensureCapacity(ARRAY1, 1, 1));\n", "    assertTrue(Arrays.equals(\n", "        new byte[] {(byte) 1, (byte) 0, (byte) 0},\n", "        Bytes.ensureCapacity(ARRAY1, 2, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEnsureCapacity_fail() {\n", "    try {\n", "      Bytes.ensureCapacity(ARRAY1, -1, 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // notice that this should even fail when no growth was needed\n", "      Bytes.ensureCapacity(ARRAY1, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToArray() {\n", "    // need explicit type parameter to avoid javac warning!?\n", "    List<Byte> none = Arrays.<Byte>asList();\n", "    assertTrue(Arrays.equals(EMPTY, Bytes.toArray(none)));\n", "\n", "    List<Byte> one = Arrays.asList((byte) 1);\n", "    assertTrue(Arrays.equals(ARRAY1, Bytes.toArray(one)));\n", "\n", "    byte[] array = {(byte) 0, (byte) 1, (byte) 0x55};\n", "\n", "    List<Byte> three = Arrays.asList((byte) 0, (byte) 1, (byte) 0x55);\n", "    assertTrue(Arrays.equals(array, Bytes.toArray(three)));\n", "\n", "    assertTrue(Arrays.equals(array, Bytes.toArray(Bytes.asList(array))));\n", "  }\n", "\n", "  public void testToArray_threadSafe() {\n", "    for (int delta : new int[] { +1, 0, -1 }) {\n", "      for (int i = 0; i < VALUES.length; i++) {\n", "        List<Byte> list = Bytes.asList(VALUES).subList(0, i);\n", "        Collection<Byte> misleadingSize =\n", "            Helpers.misleadingSizeCollection(delta);\n", "        misleadingSize.addAll(list);\n", "        byte[] arr = Bytes.toArray(misleadingSize);\n", "        assertEquals(i, arr.length);\n", "        for (int j = 0; j < i; j++) {\n", "          assertEquals(VALUES[j], arr[j]);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testToArray_withNull() {\n", "    List<Byte> list = Arrays.asList((byte) 0, (byte) 1, null);\n", "    try {\n", "      Bytes.toArray(list);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToArray_withConversion() {\n", "    byte[] array = {(byte) 0, (byte) 1, (byte) 2};\n", "\n", "    List<Byte> bytes = Arrays.asList((byte) 0, (byte) 1, (byte) 2);\n", "    List<Short> shorts = Arrays.asList((short) 0, (short) 1, (short) 2);\n", "    List<Integer> ints = Arrays.asList(0, 1, 2);\n", "    List<Float> floats = Arrays.asList((float) 0, (float) 1, (float) 2);\n", "    List<Long> longs = Arrays.asList((long) 0, (long) 1, (long) 2);\n", "    List<Double> doubles = Arrays.asList((double) 0, (double) 1, (double) 2);\n", "\n", "    assertTrue(Arrays.equals(array, Bytes.toArray(bytes)));\n", "    assertTrue(Arrays.equals(array, Bytes.toArray(shorts)));\n", "    assertTrue(Arrays.equals(array, Bytes.toArray(ints)));\n", "    assertTrue(Arrays.equals(array, Bytes.toArray(floats)));\n", "    assertTrue(Arrays.equals(array, Bytes.toArray(longs)));\n", "    assertTrue(Arrays.equals(array, Bytes.toArray(doubles)));\n", "  }\n", "\n", "  public void testAsList_isAView() {\n", "    byte[] array = {(byte) 0, (byte) 1};\n", "    List<Byte> list = Bytes.asList(array);\n", "    list.set(0, (byte) 2);\n", "    assertTrue(Arrays.equals(new byte[] {(byte) 2, (byte) 1}, array));\n", "    array[1] = (byte) 3;\n", "    assertEquals(Arrays.asList((byte) 2, (byte) 3), list);\n", "  }\n", "\n", "  public void testAsList_toArray_roundTrip() {\n", "    byte[] array = { (byte) 0, (byte) 1, (byte) 2 };\n", "    List<Byte> list = Bytes.asList(array);\n", "    byte[] newArray = Bytes.toArray(list);\n", "\n", "    // Make sure it returned a copy\n", "    list.set(0, (byte) 4);\n", "    assertTrue(Arrays.equals(\n", "        new byte[] { (byte) 0, (byte) 1, (byte) 2 }, newArray));\n", "    newArray[1] = (byte) 5;\n", "    assertEquals((byte) 1, (byte) list.get(1));\n", "  }\n", "\n", "  // This test stems from a real bug found by andrewk\n", "  public void testAsList_subList_toArray_roundTrip() {\n", "    byte[] array = { (byte) 0, (byte) 1, (byte) 2, (byte) 3 };\n", "    List<Byte> list = Bytes.asList(array);\n", "    assertTrue(Arrays.equals(new byte[] { (byte) 1, (byte) 2 },\n", "        Bytes.toArray(list.subList(1, 3))));\n", "    assertTrue(Arrays.equals(new byte[] {},\n", "        Bytes.toArray(list.subList(2, 2))));\n", "  }\n", "\n", "  public void testAsListEmpty() {\n", "    assertSame(Collections.emptyList(), Bytes.asList(EMPTY));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257]}}, {"177": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/CharArrayAsListTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.TestListGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Test suite covering {@link Chars#asList(char[])}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CharArrayAsListTest extends TestCase {\n", "\n", "  private static List<Character> asList(Character[] values) {\n", "    char[] temp = new char[values.length];\n", "    for (int i = 0; i < values.length; i++) {\n", "      temp[i] = checkNotNull(values[i]);  // checkNotNull for GWT (do not optimize).\n", "    }\n", "    return Chars.asList(temp);\n", "  }\n", "\n", "  // Test generators.  To let the GWT test suite generator access them, they need to be\n", "  // public named classes with a public default constructor.\n", "\n", "  public static final class CharsAsListGenerator extends TestCharListGenerator {\n", "    @Override protected List<Character> create(Character[] elements) {\n", "      return asList(elements);\n", "    }\n", "  }\n", "\n", "  public static final class CharsAsListHeadSubListGenerator extends TestCharListGenerator {\n", "    @Override protected List<Character> create(Character[] elements) {\n", "      Character[] suffix = {Character.MIN_VALUE, Character.MAX_VALUE};\n", "      Character[] all = concat(elements, suffix);\n", "      return asList(all).subList(0, elements.length);\n", "    }\n", "  }\n", "\n", "  public static final class CharsAsListTailSubListGenerator extends TestCharListGenerator {\n", "    @Override protected List<Character> create(Character[] elements) {\n", "      Character[] prefix = {(char) 86, (char) 99};\n", "      Character[] all = concat(prefix, elements);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  public static final class CharsAsListMiddleSubListGenerator extends TestCharListGenerator {\n", "    @Override protected List<Character> create(Character[] elements) {\n", "      Character[] prefix = {Character.MIN_VALUE, Character.MAX_VALUE};\n", "      Character[] suffix = {(char) 86, (char) 99};\n", "      Character[] all = concat(concat(prefix, elements), suffix);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  private static Character[] concat(Character[] left, Character[] right) {\n", "    Character[] result = new Character[left.length + right.length];\n", "    System.arraycopy(left, 0, result, 0, left.length);\n", "    System.arraycopy(right, 0, result, left.length, right.length);\n", "    return result;\n", "  }\n", "\n", "  public static abstract class TestCharListGenerator\n", "      implements TestListGenerator<Character> {\n", "    @Override\n", "    public SampleElements<Character> samples() {\n", "      return new SampleChars();\n", "    }\n", "\n", "    @Override\n", "    public List<Character> create(Object... elements) {\n", "      Character[] array = new Character[elements.length];\n", "      int i = 0;\n", "      for (Object e : elements) {\n", "        array[i++] = (Character) e;\n", "      }\n", "      return create(array);\n", "    }\n", "\n", "    /**\n", "     * Creates a new collection containing the given elements; implement this\n", "     * method instead of {@link #create(Object...)}.\n", "     */\n", "    protected abstract List<Character> create(Character[] elements);\n", "\n", "    @Override\n", "    public Character[] createArray(int length) {\n", "      return new Character[length];\n", "    }\n", "\n", "    /** Returns the original element list, unchanged. */\n", "    @Override\n", "    public List<Character> order(List<Character> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class SampleChars extends SampleElements<Character> {\n", "    public SampleChars() {\n", "      super((char) 0, (char) 1, (char) 2, (char) 3, (char) 4);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"178": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/CharsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link Chars}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"cast\") // redundant casts are intentional and harmless\n", "public class CharsTest extends TestCase {\n", "  private static final char[] EMPTY = {};\n", "  private static final char[] ARRAY1 = {(char) 1};\n", "  private static final char[] ARRAY234\n", "      = {(char) 2, (char) 3, (char) 4};\n", "\n", "  private static final char LEAST = Character.MIN_VALUE;\n", "  private static final char GREATEST = Character.MAX_VALUE;\n", "\n", "  private static final char[] VALUES =\n", "      {LEAST, 'a', '\\u00e0', '\\udcaa', GREATEST};\n", "\n", "  public void testHashCode() {\n", "    for (char value : VALUES) {\n", "      assertEquals(((Character) value).hashCode(), Chars.hashCode(value));\n", "    }\n", "  }\n", "\n", "  public void testCheckedCast() {\n", "    for (char value : VALUES) {\n", "      assertEquals(value, Chars.checkedCast((long) value));\n", "    }\n", "    assertCastFails(GREATEST + 1L);\n", "    assertCastFails(LEAST - 1L);\n", "    assertCastFails(Long.MAX_VALUE);\n", "    assertCastFails(Long.MIN_VALUE);\n", "  }\n", "\n", "  public void testSaturatedCast() {\n", "    for (char value : VALUES) {\n", "      assertEquals(value, Chars.saturatedCast((long) value));\n", "    }\n", "    assertEquals(GREATEST, Chars.saturatedCast(GREATEST + 1L));\n", "    assertEquals(LEAST, Chars.saturatedCast(LEAST - 1L));\n", "    assertEquals(GREATEST, Chars.saturatedCast(Long.MAX_VALUE));\n", "    assertEquals(LEAST, Chars.saturatedCast(Long.MIN_VALUE));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  private void assertCastFails(long value) {\n", "    try {\n", "      Chars.checkedCast(value);\n", "      fail(\"Cast to char should have failed: \" + value);\n", "    } catch (IllegalArgumentException ex) {\n", "      assertTrue(value + \" not found in exception text: \" + ex.getMessage(),\n", "          ex.getMessage().contains(String.valueOf(value)));\n", "    }\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (char x : VALUES) {\n", "      for (char y : VALUES) {\n", "        // note: spec requires only that the sign is the same\n", "        assertEquals(x + \", \" + y,\n", "                     Character.valueOf(x).compareTo(y),\n", "                     Chars.compare(x, y));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(Chars.contains(EMPTY, (char) 1));\n", "    assertFalse(Chars.contains(ARRAY1, (char) 2));\n", "    assertFalse(Chars.contains(ARRAY234, (char) 1));\n", "    assertTrue(Chars.contains(new char[] {(char) -1}, (char) -1));\n", "    assertTrue(Chars.contains(ARRAY234, (char) 2));\n", "    assertTrue(Chars.contains(ARRAY234, (char) 3));\n", "    assertTrue(Chars.contains(ARRAY234, (char) 4));\n", "  }\n", "\n", "  public void testIndexOf() {\n", "    assertEquals(-1, Chars.indexOf(EMPTY, (char) 1));\n", "    assertEquals(-1, Chars.indexOf(ARRAY1, (char) 2));\n", "    assertEquals(-1, Chars.indexOf(ARRAY234, (char) 1));\n", "    assertEquals(0, Chars.indexOf(\n", "        new char[] {(char) -1}, (char) -1));\n", "    assertEquals(0, Chars.indexOf(ARRAY234, (char) 2));\n", "    assertEquals(1, Chars.indexOf(ARRAY234, (char) 3));\n", "    assertEquals(2, Chars.indexOf(ARRAY234, (char) 4));\n", "    assertEquals(1, Chars.indexOf(\n", "        new char[] { (char) 2, (char) 3, (char) 2, (char) 3 },\n", "        (char) 3));\n", "  }\n", "\n", "  public void testIndexOf_arrayTarget() {\n", "    assertEquals(0, Chars.indexOf(EMPTY, EMPTY));\n", "    assertEquals(0, Chars.indexOf(ARRAY234, EMPTY));\n", "    assertEquals(-1, Chars.indexOf(EMPTY, ARRAY234));\n", "    assertEquals(-1, Chars.indexOf(ARRAY234, ARRAY1));\n", "    assertEquals(-1, Chars.indexOf(ARRAY1, ARRAY234));\n", "    assertEquals(0, Chars.indexOf(ARRAY1, ARRAY1));\n", "    assertEquals(0, Chars.indexOf(ARRAY234, ARRAY234));\n", "    assertEquals(0, Chars.indexOf(\n", "        ARRAY234, new char[] { (char) 2, (char) 3 }));\n", "    assertEquals(1, Chars.indexOf(\n", "        ARRAY234, new char[] { (char) 3, (char) 4 }));\n", "    assertEquals(1, Chars.indexOf(ARRAY234, new char[] { (char) 3 }));\n", "    assertEquals(2, Chars.indexOf(ARRAY234, new char[] { (char) 4 }));\n", "    assertEquals(1, Chars.indexOf(new char[] { (char) 2, (char) 3,\n", "        (char) 3, (char) 3, (char) 3 },\n", "        new char[] { (char) 3 }\n", "    ));\n", "    assertEquals(2, Chars.indexOf(\n", "        new char[] { (char) 2, (char) 3, (char) 2,\n", "            (char) 3, (char) 4, (char) 2, (char) 3},\n", "        new char[] { (char) 2, (char) 3, (char) 4}\n", "    ));\n", "    assertEquals(1, Chars.indexOf(\n", "        new char[] { (char) 2, (char) 2, (char) 3,\n", "            (char) 4, (char) 2, (char) 3, (char) 4},\n", "        new char[] { (char) 2, (char) 3, (char) 4}\n", "    ));\n", "    assertEquals(-1, Chars.indexOf(\n", "        new char[] { (char) 4, (char) 3, (char) 2},\n", "        new char[] { (char) 2, (char) 3, (char) 4}\n", "    ));\n", "  }\n", "\n", "  public void testLastIndexOf() {\n", "    assertEquals(-1, Chars.lastIndexOf(EMPTY, (char) 1));\n", "    assertEquals(-1, Chars.lastIndexOf(ARRAY1, (char) 2));\n", "    assertEquals(-1, Chars.lastIndexOf(ARRAY234, (char) 1));\n", "    assertEquals(0, Chars.lastIndexOf(\n", "        new char[] {(char) -1}, (char) -1));\n", "    assertEquals(0, Chars.lastIndexOf(ARRAY234, (char) 2));\n", "    assertEquals(1, Chars.lastIndexOf(ARRAY234, (char) 3));\n", "    assertEquals(2, Chars.lastIndexOf(ARRAY234, (char) 4));\n", "    assertEquals(3, Chars.lastIndexOf(\n", "        new char[] { (char) 2, (char) 3, (char) 2, (char) 3 },\n", "        (char) 3));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      Chars.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMax() {\n", "    assertEquals(LEAST, Chars.max(LEAST));\n", "    assertEquals(GREATEST, Chars.max(GREATEST));\n", "    assertEquals((char) 9, Chars.max(\n", "        (char) 8, (char) 6, (char) 7,\n", "        (char) 5, (char) 3, (char) 0, (char) 9));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      Chars.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMin() {\n", "    assertEquals(LEAST, Chars.min(LEAST));\n", "    assertEquals(GREATEST, Chars.min(GREATEST));\n", "    assertEquals((char) 0, Chars.min(\n", "        (char) 8, (char) 6, (char) 7,\n", "        (char) 5, (char) 3, (char) 0, (char) 9));\n", "  }\n", "\n", "  public void testConcat() {\n", "    assertTrue(Arrays.equals(EMPTY, Chars.concat()));\n", "    assertTrue(Arrays.equals(EMPTY, Chars.concat(EMPTY)));\n", "    assertTrue(Arrays.equals(EMPTY, Chars.concat(EMPTY, EMPTY, EMPTY)));\n", "    assertTrue(Arrays.equals(ARRAY1, Chars.concat(ARRAY1)));\n", "    assertNotSame(ARRAY1, Chars.concat(ARRAY1));\n", "    assertTrue(Arrays.equals(ARRAY1, Chars.concat(EMPTY, ARRAY1, EMPTY)));\n", "    assertTrue(Arrays.equals(\n", "        new char[] {(char) 1, (char) 1, (char) 1},\n", "        Chars.concat(ARRAY1, ARRAY1, ARRAY1)));\n", "    assertTrue(Arrays.equals(\n", "        new char[] {(char) 1, (char) 2, (char) 3, (char) 4},\n", "        Chars.concat(ARRAY1, ARRAY234)));\n", "  }\n", "\n", "  public void testEnsureCapacity() {\n", "    assertSame(EMPTY, Chars.ensureCapacity(EMPTY, 0, 1));\n", "    assertSame(ARRAY1, Chars.ensureCapacity(ARRAY1, 0, 1));\n", "    assertSame(ARRAY1, Chars.ensureCapacity(ARRAY1, 1, 1));\n", "    assertTrue(Arrays.equals(\n", "        new char[] {(char) 1, (char) 0, (char) 0},\n", "        Chars.ensureCapacity(ARRAY1, 2, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEnsureCapacity_fail() {\n", "    try {\n", "      Chars.ensureCapacity(ARRAY1, -1, 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // notice that this should even fail when no growth was needed\n", "      Chars.ensureCapacity(ARRAY1, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testJoin() {\n", "    assertEquals(\"\", Chars.join(\",\", EMPTY));\n", "    assertEquals(\"1\", Chars.join(\",\", '1'));\n", "    assertEquals(\"1,2\", Chars.join(\",\", '1', '2'));\n", "    assertEquals(\"123\", Chars.join(\"\", '1', '2', '3'));\n", "  }\n", "\n", "  public void testLexicographicalComparator() {\n", "    List<char[]> ordered = Arrays.asList(\n", "        new char[] {},\n", "        new char[] {LEAST},\n", "        new char[] {LEAST, LEAST},\n", "        new char[] {LEAST, (char) 1},\n", "        new char[] {(char) 1},\n", "        new char[] {(char) 1, LEAST},\n", "        new char[] {GREATEST, GREATEST - (char) 1},\n", "        new char[] {GREATEST, GREATEST},\n", "        new char[] {GREATEST, GREATEST, GREATEST});\n", "\n", "    Comparator<char[]> comparator = Chars.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testToArray() {\n", "    // need explicit type parameter to avoid javac warning!?\n", "    List<Character> none = Arrays.<Character>asList();\n", "    assertTrue(Arrays.equals(EMPTY, Chars.toArray(none)));\n", "\n", "    List<Character> one = Arrays.asList((char) 1);\n", "    assertTrue(Arrays.equals(ARRAY1, Chars.toArray(one)));\n", "\n", "    char[] array = {(char) 0, (char) 1, 'A'};\n", "\n", "    List<Character> three = Arrays.asList((char) 0, (char) 1, 'A');\n", "    assertTrue(Arrays.equals(array, Chars.toArray(three)));\n", "\n", "    assertTrue(Arrays.equals(array, Chars.toArray(Chars.asList(array))));\n", "  }\n", "\n", "  public void testToArray_threadSafe() {\n", "    for (int delta : new int[] { +1, 0, -1 }) {\n", "      for (int i = 0; i < VALUES.length; i++) {\n", "        List<Character> list = Chars.asList(VALUES).subList(0, i);\n", "        Collection<Character> misleadingSize =\n", "            Helpers.misleadingSizeCollection(delta);\n", "        misleadingSize.addAll(list);\n", "        char[] arr = Chars.toArray(misleadingSize);\n", "        assertEquals(i, arr.length);\n", "        for (int j = 0; j < i; j++) {\n", "          assertEquals(VALUES[j], arr[j]);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testToArray_withNull() {\n", "    List<Character> list = Arrays.asList((char) 0, (char) 1, null);\n", "    try {\n", "      Chars.toArray(list);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testAsList_isAView() {\n", "    char[] array = {(char) 0, (char) 1};\n", "    List<Character> list = Chars.asList(array);\n", "    list.set(0, (char) 2);\n", "    assertTrue(Arrays.equals(new char[] {(char) 2, (char) 1}, array));\n", "    array[1] = (char) 3;\n", "    assertEquals(Arrays.asList((char) 2, (char) 3), list);\n", "  }\n", "\n", "  public void testAsList_toArray_roundTrip() {\n", "    char[] array = { (char) 0, (char) 1, (char) 2 };\n", "    List<Character> list = Chars.asList(array);\n", "    char[] newArray = Chars.toArray(list);\n", "\n", "    // Make sure it returned a copy\n", "    list.set(0, (char) 4);\n", "    assertTrue(Arrays.equals(\n", "        new char[] { (char) 0, (char) 1, (char) 2 }, newArray));\n", "    newArray[1] = (char) 5;\n", "    assertEquals((char) 1, (char) list.get(1));\n", "  }\n", "\n", "  // This test stems from a real bug found by andrewk\n", "  public void testAsList_subList_toArray_roundTrip() {\n", "    char[] array = { (char) 0, (char) 1, (char) 2, (char) 3 };\n", "    List<Character> list = Chars.asList(array);\n", "    assertTrue(Arrays.equals(new char[] { (char) 1, (char) 2 },\n", "        Chars.toArray(list.subList(1, 3))));\n", "    assertTrue(Arrays.equals(new char[] {},\n", "        Chars.toArray(list.subList(2, 2))));\n", "  }\n", "\n", "  public void testAsListEmpty() {\n", "    assertSame(Collections.emptyList(), Chars.asList(EMPTY));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343]}}, {"179": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/DoubleArrayAsListTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.TestListGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Test suite covering {@link Doubles#asList(double[])}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class DoubleArrayAsListTest extends TestCase {\n", "\n", "  private static List<Double> asList(Double[] values) {\n", "    double[] temp = new double[values.length];\n", "    for (int i = 0; i < values.length; i++) {\n", "      temp[i] = checkNotNull(values[i]);  // checkNotNull for GWT (do not optimize).\n", "    }\n", "    return Doubles.asList(temp);\n", "  }\n", "\n", "  // Test generators.  To let the GWT test suite generator access them, they need to be\n", "  // public named classes with a public default constructor.\n", "\n", "  public static final class DoublesAsListGenerator extends TestDoubleListGenerator {\n", "    @Override protected List<Double> create(Double[] elements) {\n", "      return asList(elements);\n", "    }\n", "  }\n", "\n", "  public static final class DoublsAsListHeadSubListGenerator extends TestDoubleListGenerator {\n", "    @Override protected List<Double> create(Double[] elements) {\n", "      Double[] suffix = {Double.MIN_VALUE, Double.MAX_VALUE};\n", "      Double[] all = concat(elements, suffix);\n", "      return asList(all).subList(0, elements.length);\n", "    }\n", "  }\n", "\n", "  public static final class DoublesAsListTailSubListGenerator extends TestDoubleListGenerator {\n", "    @Override protected List<Double> create(Double[] elements) {\n", "      Double[] prefix = {(double) 86, (double) 99};\n", "      Double[] all = concat(prefix, elements);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  public static final class DoublesAsListMiddleSubListGenerator extends TestDoubleListGenerator {\n", "    @Override protected List<Double> create(Double[] elements) {\n", "      Double[] prefix = {Double.MIN_VALUE, Double.MAX_VALUE};\n", "      Double[] suffix = {(double) 86, (double) 99};\n", "      Double[] all = concat(concat(prefix, elements), suffix);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  private static Double[] concat(Double[] left, Double[] right) {\n", "    Double[] result = new Double[left.length + right.length];\n", "    System.arraycopy(left, 0, result, 0, left.length);\n", "    System.arraycopy(right, 0, result, left.length, right.length);\n", "    return result;\n", "  }\n", "\n", "  public static abstract class TestDoubleListGenerator\n", "      implements TestListGenerator<Double> {\n", "    @Override\n", "    public SampleElements<Double> samples() {\n", "      return new SampleDoubles();\n", "    }\n", "\n", "    @Override\n", "    public List<Double> create(Object... elements) {\n", "      Double[] array = new Double[elements.length];\n", "      int i = 0;\n", "      for (Object e : elements) {\n", "        array[i++] = (Double) e;\n", "      }\n", "      return create(array);\n", "    }\n", "\n", "    /**\n", "     * Creates a new collection containing the given elements; implement this\n", "     * method instead of {@link #create(Object...)}.\n", "     */\n", "    protected abstract List<Double> create(Double[] elements);\n", "\n", "    @Override\n", "    public Double[] createArray(int length) {\n", "      return new Double[length];\n", "    }\n", "\n", "    /** Returns the original element list, unchanged. */\n", "    @Override\n", "    public List<Double> order(List<Double> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class SampleDoubles extends SampleElements<Double> {\n", "    public SampleDoubles() {\n", "      super((double) 0, (double) 1, (double) 2, (double) 3, (double) 4);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"180": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/DoublesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.lang.Double.NaN;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link Doubles}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"cast\") // redundant casts are intentional and harmless\n", "public class DoublesTest extends TestCase {\n", "  private static final double[] EMPTY = {};\n", "  private static final double[] ARRAY1 = {(double) 1};\n", "  private static final double[] ARRAY234\n", "      = {(double) 2, (double) 3, (double) 4};\n", "\n", "  private static final double LEAST = Double.NEGATIVE_INFINITY;\n", "  private static final double GREATEST = Double.POSITIVE_INFINITY;\n", "\n", "  private static final double[] NUMBERS = new double[] {\n", "      LEAST, -Double.MAX_VALUE, -1.0, -0.5, -0.1, -0.0, 0.0, 0.1, 0.5, 1.0,\n", "      Double.MAX_VALUE, GREATEST, Double.MIN_NORMAL, -Double.MIN_NORMAL,\n", "      Double.MIN_VALUE, -Double.MIN_VALUE, Integer.MIN_VALUE,\n", "      Integer.MAX_VALUE, Long.MIN_VALUE, Long.MAX_VALUE\n", "  };\n", "\n", "  private static final double[] VALUES\n", "      = Doubles.concat(NUMBERS, new double[] {NaN});\n", "\n", "  public void testHashCode() {\n", "    for (double value : VALUES) {\n", "      assertEquals(((Double) value).hashCode(), Doubles.hashCode(value));\n", "    }\n", "  }\n", "\n", "  public void testIsFinite() {\n", "    for (double value : NUMBERS) {\n", "      assertEquals(!(Double.isNaN(value) || Double.isInfinite(value)), Doubles.isFinite(value));\n", "    }\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (double x : VALUES) {\n", "      for (double y : VALUES) {\n", "        // note: spec requires only that the sign is the same\n", "        assertEquals(x + \", \" + y,\n", "                     Double.valueOf(x).compareTo(y),\n", "                     Doubles.compare(x, y));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(Doubles.contains(EMPTY, (double) 1));\n", "    assertFalse(Doubles.contains(ARRAY1, (double) 2));\n", "    assertFalse(Doubles.contains(ARRAY234, (double) 1));\n", "    assertTrue(Doubles.contains(new double[] {(double) -1}, (double) -1));\n", "    assertTrue(Doubles.contains(ARRAY234, (double) 2));\n", "    assertTrue(Doubles.contains(ARRAY234, (double) 3));\n", "    assertTrue(Doubles.contains(ARRAY234, (double) 4));\n", "\n", "    for (double value : NUMBERS) {\n", "      assertTrue(\"\" + value,\n", "          Doubles.contains(new double[] {5.0, value}, value));\n", "    }\n", "    assertFalse(Doubles.contains(new double[] {5.0, NaN}, NaN));\n", "  }\n", "\n", "  public void testIndexOf() {\n", "    assertEquals(-1, Doubles.indexOf(EMPTY, (double) 1));\n", "    assertEquals(-1, Doubles.indexOf(ARRAY1, (double) 2));\n", "    assertEquals(-1, Doubles.indexOf(ARRAY234, (double) 1));\n", "    assertEquals(0, Doubles.indexOf(\n", "        new double[] {(double) -1}, (double) -1));\n", "    assertEquals(0, Doubles.indexOf(ARRAY234, (double) 2));\n", "    assertEquals(1, Doubles.indexOf(ARRAY234, (double) 3));\n", "    assertEquals(2, Doubles.indexOf(ARRAY234, (double) 4));\n", "    assertEquals(1, Doubles.indexOf(\n", "        new double[] { (double) 2, (double) 3, (double) 2, (double) 3 },\n", "        (double) 3));\n", "\n", "    for (double value : NUMBERS) {\n", "      assertEquals(\"\" + value,\n", "          1, Doubles.indexOf(new double[] {5.0, value}, value));\n", "    }\n", "    assertEquals(-1, Doubles.indexOf(new double[] {5.0, NaN}, NaN));\n", "  }\n", "\n", "  public void testIndexOf_arrayTarget() {\n", "    assertEquals(0, Doubles.indexOf(EMPTY, EMPTY));\n", "    assertEquals(0, Doubles.indexOf(ARRAY234, EMPTY));\n", "    assertEquals(-1, Doubles.indexOf(EMPTY, ARRAY234));\n", "    assertEquals(-1, Doubles.indexOf(ARRAY234, ARRAY1));\n", "    assertEquals(-1, Doubles.indexOf(ARRAY1, ARRAY234));\n", "    assertEquals(0, Doubles.indexOf(ARRAY1, ARRAY1));\n", "    assertEquals(0, Doubles.indexOf(ARRAY234, ARRAY234));\n", "    assertEquals(0, Doubles.indexOf(\n", "        ARRAY234, new double[] { (double) 2, (double) 3 }));\n", "    assertEquals(1, Doubles.indexOf(\n", "        ARRAY234, new double[] { (double) 3, (double) 4 }));\n", "    assertEquals(1, Doubles.indexOf(ARRAY234, new double[] { (double) 3 }));\n", "    assertEquals(2, Doubles.indexOf(ARRAY234, new double[] { (double) 4 }));\n", "    assertEquals(1, Doubles.indexOf(new double[] { (double) 2, (double) 3,\n", "        (double) 3, (double) 3, (double) 3 },\n", "        new double[] { (double) 3 }\n", "    ));\n", "    assertEquals(2, Doubles.indexOf(\n", "        new double[] { (double) 2, (double) 3, (double) 2,\n", "            (double) 3, (double) 4, (double) 2, (double) 3},\n", "        new double[] { (double) 2, (double) 3, (double) 4}\n", "    ));\n", "    assertEquals(1, Doubles.indexOf(\n", "        new double[] { (double) 2, (double) 2, (double) 3,\n", "            (double) 4, (double) 2, (double) 3, (double) 4},\n", "        new double[] { (double) 2, (double) 3, (double) 4}\n", "    ));\n", "    assertEquals(-1, Doubles.indexOf(\n", "        new double[] { (double) 4, (double) 3, (double) 2},\n", "        new double[] { (double) 2, (double) 3, (double) 4}\n", "    ));\n", "\n", "    for (double value : NUMBERS) {\n", "      assertEquals(\"\" + value, 1, Doubles.indexOf(\n", "          new double[] {5.0, value, value, 5.0}, new double[] {value, value}));\n", "    }\n", "    assertEquals(-1, Doubles.indexOf(\n", "        new double[] {5.0, NaN, NaN, 5.0}, new double[] {NaN, NaN}));\n", "  }\n", "\n", "  public void testLastIndexOf() {\n", "    assertEquals(-1, Doubles.lastIndexOf(EMPTY, (double) 1));\n", "    assertEquals(-1, Doubles.lastIndexOf(ARRAY1, (double) 2));\n", "    assertEquals(-1, Doubles.lastIndexOf(ARRAY234, (double) 1));\n", "    assertEquals(0, Doubles.lastIndexOf(\n", "        new double[] {(double) -1}, (double) -1));\n", "    assertEquals(0, Doubles.lastIndexOf(ARRAY234, (double) 2));\n", "    assertEquals(1, Doubles.lastIndexOf(ARRAY234, (double) 3));\n", "    assertEquals(2, Doubles.lastIndexOf(ARRAY234, (double) 4));\n", "    assertEquals(3, Doubles.lastIndexOf(\n", "        new double[] { (double) 2, (double) 3, (double) 2, (double) 3 },\n", "        (double) 3));\n", "\n", "    for (double value : NUMBERS) {\n", "      assertEquals(\"\" + value,\n", "          0, Doubles.lastIndexOf(new double[] {value, 5.0}, value));\n", "    }\n", "    assertEquals(-1, Doubles.lastIndexOf(new double[] {NaN, 5.0}, NaN));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      Doubles.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMax() {\n", "    assertEquals(LEAST, Doubles.max(LEAST));\n", "    assertEquals(GREATEST, Doubles.max(GREATEST));\n", "    assertEquals((double) 9, Doubles.max(\n", "        (double) 8, (double) 6, (double) 7,\n", "        (double) 5, (double) 3, (double) 0, (double) 9));\n", "\n", "    assertEquals(0.0, Doubles.max(-0.0, 0.0));\n", "    assertEquals(0.0, Doubles.max(0.0, -0.0));\n", "    assertEquals(GREATEST, Doubles.max(NUMBERS));\n", "    assertTrue(Double.isNaN(Doubles.max(VALUES)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      Doubles.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMin() {\n", "    assertEquals(LEAST, Doubles.min(LEAST));\n", "    assertEquals(GREATEST, Doubles.min(GREATEST));\n", "    assertEquals((double) 0, Doubles.min(\n", "        (double) 8, (double) 6, (double) 7,\n", "        (double) 5, (double) 3, (double) 0, (double) 9));\n", "\n", "    assertEquals(-0.0, Doubles.min(-0.0, 0.0));\n", "    assertEquals(-0.0, Doubles.min(0.0, -0.0));\n", "    assertEquals(LEAST, Doubles.min(NUMBERS));\n", "    assertTrue(Double.isNaN(Doubles.min(VALUES)));\n", "  }\n", "\n", "  public void testConcat() {\n", "    assertTrue(Arrays.equals(EMPTY, Doubles.concat()));\n", "    assertTrue(Arrays.equals(EMPTY, Doubles.concat(EMPTY)));\n", "    assertTrue(Arrays.equals(EMPTY, Doubles.concat(EMPTY, EMPTY, EMPTY)));\n", "    assertTrue(Arrays.equals(ARRAY1, Doubles.concat(ARRAY1)));\n", "    assertNotSame(ARRAY1, Doubles.concat(ARRAY1));\n", "    assertTrue(Arrays.equals(ARRAY1, Doubles.concat(EMPTY, ARRAY1, EMPTY)));\n", "    assertTrue(Arrays.equals(\n", "        new double[] {(double) 1, (double) 1, (double) 1},\n", "        Doubles.concat(ARRAY1, ARRAY1, ARRAY1)));\n", "    assertTrue(Arrays.equals(\n", "        new double[] {(double) 1, (double) 2, (double) 3, (double) 4},\n", "        Doubles.concat(ARRAY1, ARRAY234)));\n", "  }\n", "\n", "  public void testEnsureCapacity() {\n", "    assertSame(EMPTY, Doubles.ensureCapacity(EMPTY, 0, 1));\n", "    assertSame(ARRAY1, Doubles.ensureCapacity(ARRAY1, 0, 1));\n", "    assertSame(ARRAY1, Doubles.ensureCapacity(ARRAY1, 1, 1));\n", "    assertTrue(Arrays.equals(\n", "        new double[] {(double) 1, (double) 0, (double) 0},\n", "        Doubles.ensureCapacity(ARRAY1, 2, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEnsureCapacity_fail() {\n", "    try {\n", "      Doubles.ensureCapacity(ARRAY1, -1, 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // notice that this should even fail when no growth was needed\n", "      Doubles.ensureCapacity(ARRAY1, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testJoinNonTrivialDoubles() {\n", "    assertEquals(\"\", Doubles.join(\",\", EMPTY));\n", "    assertEquals(\"1.2\", Doubles.join(\",\", 1.2));\n", "    assertEquals(\"1.3,2.4\", Doubles.join(\",\", 1.3, 2.4));\n", "    assertEquals(\"1.42.53.6\", Doubles.join(\"\", 1.4, 2.5, 3.6));\n", "  }\n", "\n", "  public void testLexicographicalComparator() {\n", "    List<double[]> ordered = Arrays.asList(\n", "        new double[] {},\n", "        new double[] {LEAST},\n", "        new double[] {LEAST, LEAST},\n", "        new double[] {LEAST, (double) 1},\n", "        new double[] {(double) 1},\n", "        new double[] {(double) 1, LEAST},\n", "        new double[] {GREATEST, Double.MAX_VALUE},\n", "        new double[] {GREATEST, GREATEST},\n", "        new double[] {GREATEST, GREATEST, GREATEST});\n", "\n", "    Comparator<double[]> comparator = Doubles.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testToArray() {\n", "    // need explicit type parameter to avoid javac warning!?\n", "    List<Double> none = Arrays.<Double>asList();\n", "    assertTrue(Arrays.equals(EMPTY, Doubles.toArray(none)));\n", "\n", "    List<Double> one = Arrays.asList((double) 1);\n", "    assertTrue(Arrays.equals(ARRAY1, Doubles.toArray(one)));\n", "\n", "    double[] array = {(double) 0, (double) 1, Math.PI};\n", "\n", "    List<Double> three = Arrays.asList((double) 0, (double) 1, Math.PI);\n", "    assertTrue(Arrays.equals(array, Doubles.toArray(three)));\n", "\n", "    assertTrue(Arrays.equals(array, Doubles.toArray(Doubles.asList(array))));\n", "  }\n", "\n", "  public void testToArray_threadSafe() {\n", "    for (int delta : new int[] { +1, 0, -1 }) {\n", "      for (int i = 0; i < VALUES.length; i++) {\n", "        List<Double> list = Doubles.asList(VALUES).subList(0, i);\n", "        Collection<Double> misleadingSize =\n", "            Helpers.misleadingSizeCollection(delta);\n", "        misleadingSize.addAll(list);\n", "        double[] arr = Doubles.toArray(misleadingSize);\n", "        assertEquals(i, arr.length);\n", "        for (int j = 0; j < i; j++) {\n", "          assertEquals(VALUES[j], arr[j]);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testToArray_withNull() {\n", "    List<Double> list = Arrays.asList((double) 0, (double) 1, null);\n", "    try {\n", "      Doubles.toArray(list);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToArray_withConversion() {\n", "    double[] array = {(double) 0, (double) 1, (double) 2};\n", "\n", "    List<Byte> bytes = Arrays.asList((byte) 0, (byte) 1, (byte) 2);\n", "    List<Short> shorts = Arrays.asList((short) 0, (short) 1, (short) 2);\n", "    List<Integer> ints = Arrays.asList(0, 1, 2);\n", "    List<Float> floats = Arrays.asList((float) 0, (float) 1, (float) 2);\n", "    List<Long> longs = Arrays.asList((long) 0, (long) 1, (long) 2);\n", "    List<Double> doubles = Arrays.asList((double) 0, (double) 1, (double) 2);\n", "\n", "    assertTrue(Arrays.equals(array, Doubles.toArray(bytes)));\n", "    assertTrue(Arrays.equals(array, Doubles.toArray(shorts)));\n", "    assertTrue(Arrays.equals(array, Doubles.toArray(ints)));\n", "    assertTrue(Arrays.equals(array, Doubles.toArray(floats)));\n", "    assertTrue(Arrays.equals(array, Doubles.toArray(longs)));\n", "    assertTrue(Arrays.equals(array, Doubles.toArray(doubles)));\n", "  }\n", "\n", "  public void testAsList_isAView() {\n", "    double[] array = {(double) 0, (double) 1};\n", "    List<Double> list = Doubles.asList(array);\n", "    list.set(0, (double) 2);\n", "    assertTrue(Arrays.equals(new double[] {(double) 2, (double) 1}, array));\n", "    array[1] = (double) 3;\n", "    assertThat(list).containsExactly((double) 2, (double) 3).inOrder();\n", "  }\n", "\n", "  public void testAsList_toArray_roundTrip() {\n", "    double[] array = { (double) 0, (double) 1, (double) 2 };\n", "    List<Double> list = Doubles.asList(array);\n", "    double[] newArray = Doubles.toArray(list);\n", "\n", "    // Make sure it returned a copy\n", "    list.set(0, (double) 4);\n", "    assertTrue(Arrays.equals(\n", "        new double[] { (double) 0, (double) 1, (double) 2 }, newArray));\n", "    newArray[1] = (double) 5;\n", "    assertEquals((double) 1, (double) list.get(1));\n", "  }\n", "\n", "  // This test stems from a real bug found by andrewk\n", "  public void testAsList_subList_toArray_roundTrip() {\n", "    double[] array = { (double) 0, (double) 1, (double) 2, (double) 3 };\n", "    List<Double> list = Doubles.asList(array);\n", "    assertTrue(Arrays.equals(new double[] { (double) 1, (double) 2 },\n", "        Doubles.toArray(list.subList(1, 3))));\n", "    assertTrue(Arrays.equals(new double[] {},\n", "        Doubles.toArray(list.subList(2, 2))));\n", "  }\n", "\n", "  public void testAsListEmpty() {\n", "    assertSame(Collections.emptyList(), Doubles.asList(EMPTY));\n", "  }\n", "\n", "  /**\n", "   * A reference implementation for {@code tryParse} that just catches the exception from\n", "   * {@link Double#valueOf}.\n", "   */\n", "  private static Double referenceTryParse(String input) {\n", "    if (input.trim().length() < input.length()) {\n", "      return null;\n", "    }\n", "    try {\n", "      return Double.valueOf(input);\n", "    } catch (NumberFormatException e) {\n", "      return null;\n", "    }\n", "  }\n", "\n", "  private static final String[] BAD_TRY_PARSE_INPUTS =\n", "    { \"\", \"+-\", \"+-0\", \" 5\", \"32 \", \" 55 \", \"infinity\", \"POSITIVE_INFINITY\", \"0x9A\", \"0x9A.bE-5\",\n", "      \".\", \".e5\", \"NaNd\", \"InfinityF\" };\n", "\n", "  public void testStringConverter_convert() {\n", "    Converter<String, Double> converter = Doubles.stringConverter();\n", "    assertEquals((Double) 1.0, converter.convert(\"1.0\"));\n", "    assertEquals((Double) 0.0, converter.convert(\"0.0\"));\n", "    assertEquals((Double) (-1.0), converter.convert(\"-1.0\"));\n", "    assertEquals((Double) 1.0, converter.convert(\"1\"));\n", "    assertEquals((Double) 0.0, converter.convert(\"0\"));\n", "    assertEquals((Double) (-1.0), converter.convert(\"-1\"));\n", "    assertEquals((Double) 1e6, converter.convert(\"1e6\"));\n", "    assertEquals((Double) 1e-6, converter.convert(\"1e-6\"));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testStringConverter_convertError() {\n", "    try {\n", "      Doubles.stringConverter().convert(\"notanumber\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testStringConverter_nullConversions() {\n", "    assertNull(Doubles.stringConverter().convert(null));\n", "    assertNull(Doubles.stringConverter().reverse().convert(null));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427]}}, {"181": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/FloatArrayAsListTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.TestListGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Test suite covering {@link Floats#asList(float[])})}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class FloatArrayAsListTest extends TestCase {\n", "\n", "  private static List<Float> asList(Float[] values) {\n", "    float[] temp = new float[values.length];\n", "    for (int i = 0; i < values.length; i++) {\n", "      temp[i] = checkNotNull(values[i]);  // checkNotNull for GWT (do not optimize).\n", "    }\n", "    return Floats.asList(temp);\n", "  }\n", "\n", "  // Test generators.  To let the GWT test suite generator access them, they need to be\n", "  // public named classes with a public default constructor.\n", "\n", "  public static final class FloatsAsListGenerator extends TestFloatListGenerator {\n", "    @Override protected List<Float> create(Float[] elements) {\n", "      return asList(elements);\n", "    }\n", "  }\n", "\n", "  public static final class FloatsAsListHeadSubListGenerator extends TestFloatListGenerator {\n", "    @Override protected List<Float> create(Float[] elements) {\n", "      Float[] suffix = {Float.MIN_VALUE, Float.MAX_VALUE};\n", "      Float[] all = concat(elements, suffix);\n", "      return asList(all).subList(0, elements.length);\n", "    }\n", "  }\n", "\n", "  public static final class FloatsAsListTailSubListGenerator extends TestFloatListGenerator {\n", "    @Override protected List<Float> create(Float[] elements) {\n", "      Float[] prefix = {(float) 86, (float) 99};\n", "      Float[] all = concat(prefix, elements);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  public static final class FloatsAsListMiddleSubListGenerator extends TestFloatListGenerator {\n", "    @Override protected List<Float> create(Float[] elements) {\n", "      Float[] prefix = {Float.MIN_VALUE, Float.MAX_VALUE};\n", "      Float[] suffix = {(float) 86, (float) 99};\n", "      Float[] all = concat(concat(prefix, elements), suffix);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  private static Float[] concat(Float[] left, Float[] right) {\n", "    Float[] result = new Float[left.length + right.length];\n", "    System.arraycopy(left, 0, result, 0, left.length);\n", "    System.arraycopy(right, 0, result, left.length, right.length);\n", "    return result;\n", "  }\n", "\n", "  public static abstract class TestFloatListGenerator\n", "      implements TestListGenerator<Float> {\n", "    @Override\n", "    public SampleElements<Float> samples() {\n", "      return new SampleFloats();\n", "    }\n", "\n", "    @Override\n", "    public List<Float> create(Object... elements) {\n", "      Float[] array = new Float[elements.length];\n", "      int i = 0;\n", "      for (Object e : elements) {\n", "        array[i++] = (Float) e;\n", "      }\n", "      return create(array);\n", "    }\n", "\n", "    /**\n", "     * Creates a new collection containing the given elements; implement this\n", "     * method instead of {@link #create(Object...)}.\n", "     */\n", "    protected abstract List<Float> create(Float[] elements);\n", "\n", "    @Override\n", "    public Float[] createArray(int length) {\n", "      return new Float[length];\n", "    }\n", "\n", "    /** Returns the original element list, unchanged. */\n", "    @Override\n", "    public List<Float> order(List<Float> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class SampleFloats extends SampleElements<Float> {\n", "    public SampleFloats() {\n", "      super((float) 0, (float) 1, (float) 2, (float) 3, (float) 4);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"182": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/FloatsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static java.lang.Float.NaN;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link Floats}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"cast\") // redundant casts are intentional and harmless\n", "public class FloatsTest extends TestCase {\n", "  private static final float[] EMPTY = {};\n", "  private static final float[] ARRAY1 = {(float) 1};\n", "  private static final float[] ARRAY234\n", "      = {(float) 2, (float) 3, (float) 4};\n", "\n", "  private static final float LEAST = Float.NEGATIVE_INFINITY;\n", "  private static final float GREATEST = Float.POSITIVE_INFINITY;\n", "\n", "  private static final float[] NUMBERS = new float[] {\n", "      LEAST, -Float.MAX_VALUE, -1f, -0f, 0f, 1f, Float.MAX_VALUE, GREATEST,\n", "      Float.MIN_NORMAL, -Float.MIN_NORMAL,  Float.MIN_VALUE, -Float.MIN_VALUE,\n", "      Integer.MIN_VALUE, Integer.MAX_VALUE, Long.MIN_VALUE, Long.MAX_VALUE\n", "  };\n", "\n", "  private static final float[] VALUES\n", "      = Floats.concat(NUMBERS, new float[] {NaN});\n", "\n", "  public void testHashCode() {\n", "    for (float value : VALUES) {\n", "      assertEquals(((Float) value).hashCode(), Floats.hashCode(value));\n", "    }\n", "  }\n", "\n", "  public void testIsFinite() {\n", "    for (float value : NUMBERS) {\n", "      assertEquals(!(Float.isInfinite(value) || Float.isNaN(value)), Floats.isFinite(value));\n", "    }\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (float x : VALUES) {\n", "      for (float y : VALUES) {\n", "        // note: spec requires only that the sign is the same\n", "        assertEquals(x + \", \" + y,\n", "                     Float.valueOf(x).compareTo(y),\n", "                     Floats.compare(x, y));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(Floats.contains(EMPTY, (float) 1));\n", "    assertFalse(Floats.contains(ARRAY1, (float) 2));\n", "    assertFalse(Floats.contains(ARRAY234, (float) 1));\n", "    assertTrue(Floats.contains(new float[] {(float) -1}, (float) -1));\n", "    assertTrue(Floats.contains(ARRAY234, (float) 2));\n", "    assertTrue(Floats.contains(ARRAY234, (float) 3));\n", "    assertTrue(Floats.contains(ARRAY234, (float) 4));\n", "\n", "    for (float value : NUMBERS) {\n", "      assertTrue(\"\" + value, Floats.contains(new float[] {5f, value}, value));\n", "    }\n", "    assertFalse(Floats.contains(new float[] {5f, NaN}, NaN));\n", "  }\n", "\n", "  public void testIndexOf() {\n", "    assertEquals(-1, Floats.indexOf(EMPTY, (float) 1));\n", "    assertEquals(-1, Floats.indexOf(ARRAY1, (float) 2));\n", "    assertEquals(-1, Floats.indexOf(ARRAY234, (float) 1));\n", "    assertEquals(0, Floats.indexOf(\n", "        new float[] {(float) -1}, (float) -1));\n", "    assertEquals(0, Floats.indexOf(ARRAY234, (float) 2));\n", "    assertEquals(1, Floats.indexOf(ARRAY234, (float) 3));\n", "    assertEquals(2, Floats.indexOf(ARRAY234, (float) 4));\n", "    assertEquals(1, Floats.indexOf(\n", "        new float[] { (float) 2, (float) 3, (float) 2, (float) 3 },\n", "        (float) 3));\n", "\n", "    for (float value : NUMBERS) {\n", "      assertEquals(\"\" + value, 1,\n", "          Floats.indexOf(new float[] {5f, value}, value));\n", "    }\n", "    assertEquals(-1, Floats.indexOf(new float[] {5f, NaN}, NaN));\n", "  }\n", "\n", "  public void testIndexOf_arrayTarget() {\n", "    assertEquals(0, Floats.indexOf(EMPTY, EMPTY));\n", "    assertEquals(0, Floats.indexOf(ARRAY234, EMPTY));\n", "    assertEquals(-1, Floats.indexOf(EMPTY, ARRAY234));\n", "    assertEquals(-1, Floats.indexOf(ARRAY234, ARRAY1));\n", "    assertEquals(-1, Floats.indexOf(ARRAY1, ARRAY234));\n", "    assertEquals(0, Floats.indexOf(ARRAY1, ARRAY1));\n", "    assertEquals(0, Floats.indexOf(ARRAY234, ARRAY234));\n", "    assertEquals(0, Floats.indexOf(\n", "        ARRAY234, new float[] { (float) 2, (float) 3 }));\n", "    assertEquals(1, Floats.indexOf(\n", "        ARRAY234, new float[] { (float) 3, (float) 4 }));\n", "    assertEquals(1, Floats.indexOf(ARRAY234, new float[] { (float) 3 }));\n", "    assertEquals(2, Floats.indexOf(ARRAY234, new float[] { (float) 4 }));\n", "    assertEquals(1, Floats.indexOf(new float[] { (float) 2, (float) 3,\n", "        (float) 3, (float) 3, (float) 3 },\n", "        new float[] { (float) 3 }\n", "    ));\n", "    assertEquals(2, Floats.indexOf(\n", "        new float[] { (float) 2, (float) 3, (float) 2,\n", "            (float) 3, (float) 4, (float) 2, (float) 3},\n", "        new float[] { (float) 2, (float) 3, (float) 4}\n", "    ));\n", "    assertEquals(1, Floats.indexOf(\n", "        new float[] { (float) 2, (float) 2, (float) 3,\n", "            (float) 4, (float) 2, (float) 3, (float) 4},\n", "        new float[] { (float) 2, (float) 3, (float) 4}\n", "    ));\n", "    assertEquals(-1, Floats.indexOf(\n", "        new float[] { (float) 4, (float) 3, (float) 2},\n", "        new float[] { (float) 2, (float) 3, (float) 4}\n", "    ));\n", "\n", "    for (float value : NUMBERS) {\n", "      assertEquals(\"\" + value, 1, Floats.indexOf(\n", "          new float[] {5f, value, value, 5f}, new float[] {value, value}));\n", "    }\n", "    assertEquals(-1, Floats.indexOf(\n", "        new float[] {5f, NaN, NaN, 5f}, new float[] {NaN, NaN}));\n", "  }\n", "\n", "  public void testLastIndexOf() {\n", "    assertEquals(-1, Floats.lastIndexOf(EMPTY, (float) 1));\n", "    assertEquals(-1, Floats.lastIndexOf(ARRAY1, (float) 2));\n", "    assertEquals(-1, Floats.lastIndexOf(ARRAY234, (float) 1));\n", "    assertEquals(0, Floats.lastIndexOf(\n", "        new float[] {(float) -1}, (float) -1));\n", "    assertEquals(0, Floats.lastIndexOf(ARRAY234, (float) 2));\n", "    assertEquals(1, Floats.lastIndexOf(ARRAY234, (float) 3));\n", "    assertEquals(2, Floats.lastIndexOf(ARRAY234, (float) 4));\n", "    assertEquals(3, Floats.lastIndexOf(\n", "        new float[] { (float) 2, (float) 3, (float) 2, (float) 3 },\n", "        (float) 3));\n", "\n", "    for (float value : NUMBERS) {\n", "      assertEquals(\"\" + value,\n", "          0, Floats.lastIndexOf(new float[] {value, 5f}, value));\n", "    }\n", "    assertEquals(-1, Floats.lastIndexOf(new float[] {NaN, 5f}, NaN));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      Floats.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMax() {\n", "    assertEquals(GREATEST, Floats.max(GREATEST));\n", "    assertEquals(LEAST, Floats.max(LEAST));\n", "    assertEquals((float) 9, Floats.max(\n", "        (float) 8, (float) 6, (float) 7,\n", "        (float) 5, (float) 3, (float) 0, (float) 9));\n", "\n", "    assertEquals(0f, Floats.max(-0f, 0f));\n", "    assertEquals(0f, Floats.max(0f, -0f));\n", "    assertEquals(GREATEST, Floats.max(NUMBERS));\n", "    assertTrue(Float.isNaN(Floats.max(VALUES)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      Floats.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMin() {\n", "    assertEquals(LEAST, Floats.min(LEAST));\n", "    assertEquals(GREATEST, Floats.min(GREATEST));\n", "    assertEquals((float) 0, Floats.min(\n", "        (float) 8, (float) 6, (float) 7,\n", "        (float) 5, (float) 3, (float) 0, (float) 9));\n", "\n", "    assertEquals(-0f, Floats.min(-0f, 0f));\n", "    assertEquals(-0f, Floats.min(0f, -0f));\n", "    assertEquals(LEAST, Floats.min(NUMBERS));\n", "    assertTrue(Float.isNaN(Floats.min(VALUES)));\n", "  }\n", "\n", "  public void testConcat() {\n", "    assertTrue(Arrays.equals(EMPTY, Floats.concat()));\n", "    assertTrue(Arrays.equals(EMPTY, Floats.concat(EMPTY)));\n", "    assertTrue(Arrays.equals(EMPTY, Floats.concat(EMPTY, EMPTY, EMPTY)));\n", "    assertTrue(Arrays.equals(ARRAY1, Floats.concat(ARRAY1)));\n", "    assertNotSame(ARRAY1, Floats.concat(ARRAY1));\n", "    assertTrue(Arrays.equals(ARRAY1, Floats.concat(EMPTY, ARRAY1, EMPTY)));\n", "    assertTrue(Arrays.equals(\n", "        new float[] {(float) 1, (float) 1, (float) 1},\n", "        Floats.concat(ARRAY1, ARRAY1, ARRAY1)));\n", "    assertTrue(Arrays.equals(\n", "        new float[] {(float) 1, (float) 2, (float) 3, (float) 4},\n", "        Floats.concat(ARRAY1, ARRAY234)));\n", "  }\n", "\n", "  public void testEnsureCapacity() {\n", "    assertSame(EMPTY, Floats.ensureCapacity(EMPTY, 0, 1));\n", "    assertSame(ARRAY1, Floats.ensureCapacity(ARRAY1, 0, 1));\n", "    assertSame(ARRAY1, Floats.ensureCapacity(ARRAY1, 1, 1));\n", "    assertTrue(Arrays.equals(\n", "        new float[] {(float) 1, (float) 0, (float) 0},\n", "        Floats.ensureCapacity(ARRAY1, 2, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEnsureCapacity_fail() {\n", "    try {\n", "      Floats.ensureCapacity(ARRAY1, -1, 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // notice that this should even fail when no growth was needed\n", "      Floats.ensureCapacity(ARRAY1, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testLexicographicalComparator() {\n", "    List<float[]> ordered = Arrays.asList(\n", "        new float[] {},\n", "        new float[] {LEAST},\n", "        new float[] {LEAST, LEAST},\n", "        new float[] {LEAST, (float) 1},\n", "        new float[] {(float) 1},\n", "        new float[] {(float) 1, LEAST},\n", "        new float[] {GREATEST, Float.MAX_VALUE},\n", "        new float[] {GREATEST, GREATEST},\n", "        new float[] {GREATEST, GREATEST, GREATEST});\n", "\n", "    Comparator<float[]> comparator = Floats.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testToArray() {\n", "    // need explicit type parameter to avoid javac warning!?\n", "    List<Float> none = Arrays.<Float>asList();\n", "    assertTrue(Arrays.equals(EMPTY, Floats.toArray(none)));\n", "\n", "    List<Float> one = Arrays.asList((float) 1);\n", "    assertTrue(Arrays.equals(ARRAY1, Floats.toArray(one)));\n", "\n", "    float[] array = {(float) 0, (float) 1, (float) 3};\n", "\n", "    List<Float> three = Arrays.asList((float) 0, (float) 1, (float) 3);\n", "    assertTrue(Arrays.equals(array, Floats.toArray(three)));\n", "\n", "    assertTrue(Arrays.equals(array, Floats.toArray(Floats.asList(array))));\n", "  }\n", "\n", "  public void testToArray_threadSafe() {\n", "    for (int delta : new int[] { +1, 0, -1 }) {\n", "      for (int i = 0; i < VALUES.length; i++) {\n", "        List<Float> list = Floats.asList(VALUES).subList(0, i);\n", "        Collection<Float> misleadingSize =\n", "            Helpers.misleadingSizeCollection(delta);\n", "        misleadingSize.addAll(list);\n", "        float[] arr = Floats.toArray(misleadingSize);\n", "        assertEquals(i, arr.length);\n", "        for (int j = 0; j < i; j++) {\n", "          assertEquals(VALUES[j], arr[j]);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testToArray_withNull() {\n", "    List<Float> list = Arrays.asList((float) 0, (float) 1, null);\n", "    try {\n", "      Floats.toArray(list);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToArray_withConversion() {\n", "    float[] array = {(float) 0, (float) 1, (float) 2};\n", "\n", "    List<Byte> bytes = Arrays.asList((byte) 0, (byte) 1, (byte) 2);\n", "    List<Short> shorts = Arrays.asList((short) 0, (short) 1, (short) 2);\n", "    List<Integer> ints = Arrays.asList(0, 1, 2);\n", "    List<Float> floats = Arrays.asList((float) 0, (float) 1, (float) 2);\n", "    List<Long> longs = Arrays.asList((long) 0, (long) 1, (long) 2);\n", "    List<Double> doubles = Arrays.asList((double) 0, (double) 1, (double) 2);\n", "\n", "    assertTrue(Arrays.equals(array, Floats.toArray(bytes)));\n", "    assertTrue(Arrays.equals(array, Floats.toArray(shorts)));\n", "    assertTrue(Arrays.equals(array, Floats.toArray(ints)));\n", "    assertTrue(Arrays.equals(array, Floats.toArray(floats)));\n", "    assertTrue(Arrays.equals(array, Floats.toArray(longs)));\n", "    assertTrue(Arrays.equals(array, Floats.toArray(doubles)));\n", "  }\n", "\n", "  public void testAsList_isAView() {\n", "    float[] array = {(float) 0, (float) 1};\n", "    List<Float> list = Floats.asList(array);\n", "    list.set(0, (float) 2);\n", "    assertTrue(Arrays.equals(new float[] {(float) 2, (float) 1}, array));\n", "    array[1] = (float) 3;\n", "    assertThat(list).containsExactly((float) 2, (float) 3).inOrder();\n", "  }\n", "\n", "  public void testAsList_toArray_roundTrip() {\n", "    float[] array = { (float) 0, (float) 1, (float) 2 };\n", "    List<Float> list = Floats.asList(array);\n", "    float[] newArray = Floats.toArray(list);\n", "\n", "    // Make sure it returned a copy\n", "    list.set(0, (float) 4);\n", "    assertTrue(Arrays.equals(\n", "        new float[] { (float) 0, (float) 1, (float) 2 }, newArray));\n", "    newArray[1] = (float) 5;\n", "    assertEquals((float) 1, (float) list.get(1));\n", "  }\n", "\n", "  // This test stems from a real bug found by andrewk\n", "  public void testAsList_subList_toArray_roundTrip() {\n", "    float[] array = { (float) 0, (float) 1, (float) 2, (float) 3 };\n", "    List<Float> list = Floats.asList(array);\n", "    assertTrue(Arrays.equals(new float[] { (float) 1, (float) 2 },\n", "        Floats.toArray(list.subList(1, 3))));\n", "    assertTrue(Arrays.equals(new float[] {},\n", "        Floats.toArray(list.subList(2, 2))));\n", "  }\n", "\n", "  public void testAsListEmpty() {\n", "    assertSame(Collections.emptyList(), Floats.asList(EMPTY));\n", "  }\n", "\n", "  /**\n", "   * A reference implementation for {@code tryParse} that just catches the exception from\n", "   * {@link Float#valueOf}.\n", "   */\n", "  private static Float referenceTryParse(String input) {\n", "    if (input.trim().length() < input.length()) {\n", "      return null;\n", "    }\n", "    try {\n", "      return Float.valueOf(input);\n", "    } catch (NumberFormatException e) {\n", "      return null;\n", "    }\n", " }\n", "\n", "  private static final String[] BAD_TRY_PARSE_INPUTS =\n", "    { \"\", \"+-\", \"+-0\", \" 5\", \"32 \", \" 55 \", \"infinity\", \"POSITIVE_INFINITY\", \"0x9A\", \"0x9A.bE-5\",\n", "      \".\", \".e5\", \"NaNd\", \"InfinityF\" };\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testStringConverter_convertError() {\n", "    try {\n", "      Floats.stringConverter().convert(\"notanumber\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testStringConverter_nullConversions() {\n", "    assertNull(Floats.stringConverter().convert(null));\n", "    assertNull(Floats.stringConverter().reverse().convert(null));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405]}}, {"183": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/IntArrayAsListTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.TestListGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Test suite covering {@link Ints#asList(int[])}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"cast\") // redundant casts are intentional and harmless\n", "public class IntArrayAsListTest extends TestCase {\n", "\n", "  private static List<Integer> asList(Integer[] values) {\n", "    int[] temp = new int[values.length];\n", "    for (int i = 0; i < values.length; i++) {\n", "      temp[i] = checkNotNull(values[i]);  // checkNotNull for GWT (do not optimize).\n", "    }\n", "    return Ints.asList(temp);\n", "  }\n", "\n", "  // Test generators.  To let the GWT test suite generator access them, they need to be\n", "  // public named classes with a public default constructor.\n", "\n", "  public static final class IntsAsListGenerator extends TestIntegerListGenerator {\n", "    @Override protected List<Integer> create(Integer[] elements) {\n", "      return asList(elements);\n", "    }\n", "  }\n", "\n", "  public static final class IntsAsListHeadSubListGenerator extends TestIntegerListGenerator {\n", "    @Override protected List<Integer> create(Integer[] elements) {\n", "      Integer[] suffix = {Integer.MIN_VALUE, Integer.MAX_VALUE};\n", "      Integer[] all = concat(elements, suffix);\n", "      return asList(all).subList(0, elements.length);\n", "    }\n", "  }\n", "\n", "  public static final class IntsAsListTailSubListGenerator extends TestIntegerListGenerator {\n", "    @Override protected List<Integer> create(Integer[] elements) {\n", "      Integer[] prefix = {(int) 86, (int) 99};\n", "      Integer[] all = concat(prefix, elements);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  public static final class IntsAsListMiddleSubListGenerator extends TestIntegerListGenerator {\n", "    @Override protected List<Integer> create(Integer[] elements) {\n", "      Integer[] prefix = {Integer.MIN_VALUE, Integer.MAX_VALUE};\n", "      Integer[] suffix = {(int) 86, (int) 99};\n", "      Integer[] all = concat(concat(prefix, elements), suffix);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  private static Integer[] concat(Integer[] left, Integer[] right) {\n", "    Integer[] result = new Integer[left.length + right.length];\n", "    System.arraycopy(left, 0, result, 0, left.length);\n", "    System.arraycopy(right, 0, result, left.length, right.length);\n", "    return result;\n", "  }\n", "\n", "  public static abstract class TestIntegerListGenerator\n", "      implements TestListGenerator<Integer> {\n", "    @Override\n", "    public SampleElements<Integer> samples() {\n", "      return new SampleIntegers();\n", "    }\n", "\n", "    @Override\n", "    public List<Integer> create(Object... elements) {\n", "      Integer[] array = new Integer[elements.length];\n", "      int i = 0;\n", "      for (Object e : elements) {\n", "        array[i++] = (Integer) e;\n", "      }\n", "      return create(array);\n", "    }\n", "\n", "    /**\n", "     * Creates a new collection containing the given elements; implement this\n", "     * method instead of {@link #create(Object...)}.\n", "     */\n", "    protected abstract List<Integer> create(Integer[] elements);\n", "\n", "    @Override public Integer[] createArray(int length) {\n", "      return new Integer[length];\n", "    }\n", "\n", "    /** Returns the original element list, unchanged. */\n", "    @Override\n", "    public List<Integer> order(List<Integer> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class SampleIntegers extends SampleElements<Integer> {\n", "    public SampleIntegers() {\n", "      super((int) 0, (int) 1, (int) 2, (int) 3, (int) 4);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"184": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/IntsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link Ints}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"cast\") // redundant casts are intentional and harmless\n", "public class IntsTest extends TestCase {\n", "  private static final int[] EMPTY = {};\n", "  private static final int[] ARRAY1 = {(int) 1};\n", "  private static final int[] ARRAY234\n", "      = {(int) 2, (int) 3, (int) 4};\n", "\n", "  private static final int LEAST = Integer.MIN_VALUE;\n", "  private static final int GREATEST = Integer.MAX_VALUE;\n", "\n", "  private static final int[] VALUES =\n", "      { LEAST, (int) -1, (int) 0, (int) 1, GREATEST };\n", "\n", "  public void testHashCode() {\n", "    for (int value : VALUES) {\n", "      assertEquals(((Integer) value).hashCode(), Ints.hashCode(value));\n", "    }\n", "  }\n", "\n", "  public void testCheckedCast() {\n", "    for (int value : VALUES) {\n", "      assertEquals(value, Ints.checkedCast((long) value));\n", "    }\n", "    assertCastFails(GREATEST + 1L);\n", "    assertCastFails(LEAST - 1L);\n", "    assertCastFails(Long.MAX_VALUE);\n", "    assertCastFails(Long.MIN_VALUE);\n", "  }\n", "\n", "  public void testSaturatedCast() {\n", "    for (int value : VALUES) {\n", "      assertEquals(value, Ints.saturatedCast((long) value));\n", "    }\n", "    assertEquals(GREATEST, Ints.saturatedCast(GREATEST + 1L));\n", "    assertEquals(LEAST, Ints.saturatedCast(LEAST - 1L));\n", "    assertEquals(GREATEST, Ints.saturatedCast(Long.MAX_VALUE));\n", "    assertEquals(LEAST, Ints.saturatedCast(Long.MIN_VALUE));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  private static void assertCastFails(long value) {\n", "    try {\n", "      Ints.checkedCast(value);\n", "      fail(\"Cast to int should have failed: \" + value);\n", "    } catch (IllegalArgumentException ex) {\n", "      assertTrue(value + \" not found in exception text: \" + ex.getMessage(),\n", "          ex.getMessage().contains(String.valueOf(value)));\n", "    }\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (int x : VALUES) {\n", "      for (int y : VALUES) {\n", "        // note: spec requires only that the sign is the same\n", "        assertEquals(x + \", \" + y,\n", "                     Integer.valueOf(x).compareTo(y),\n", "                     Ints.compare(x, y));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(Ints.contains(EMPTY, (int) 1));\n", "    assertFalse(Ints.contains(ARRAY1, (int) 2));\n", "    assertFalse(Ints.contains(ARRAY234, (int) 1));\n", "    assertTrue(Ints.contains(new int[] {(int) -1}, (int) -1));\n", "    assertTrue(Ints.contains(ARRAY234, (int) 2));\n", "    assertTrue(Ints.contains(ARRAY234, (int) 3));\n", "    assertTrue(Ints.contains(ARRAY234, (int) 4));\n", "  }\n", "\n", "  public void testIndexOf() {\n", "    assertEquals(-1, Ints.indexOf(EMPTY, (int) 1));\n", "    assertEquals(-1, Ints.indexOf(ARRAY1, (int) 2));\n", "    assertEquals(-1, Ints.indexOf(ARRAY234, (int) 1));\n", "    assertEquals(0, Ints.indexOf(\n", "        new int[] {(int) -1}, (int) -1));\n", "    assertEquals(0, Ints.indexOf(ARRAY234, (int) 2));\n", "    assertEquals(1, Ints.indexOf(ARRAY234, (int) 3));\n", "    assertEquals(2, Ints.indexOf(ARRAY234, (int) 4));\n", "    assertEquals(1, Ints.indexOf(\n", "        new int[] { (int) 2, (int) 3, (int) 2, (int) 3 },\n", "        (int) 3));\n", "  }\n", "\n", "  public void testIndexOf_arrayTarget() {\n", "    assertEquals(0, Ints.indexOf(EMPTY, EMPTY));\n", "    assertEquals(0, Ints.indexOf(ARRAY234, EMPTY));\n", "    assertEquals(-1, Ints.indexOf(EMPTY, ARRAY234));\n", "    assertEquals(-1, Ints.indexOf(ARRAY234, ARRAY1));\n", "    assertEquals(-1, Ints.indexOf(ARRAY1, ARRAY234));\n", "    assertEquals(0, Ints.indexOf(ARRAY1, ARRAY1));\n", "    assertEquals(0, Ints.indexOf(ARRAY234, ARRAY234));\n", "    assertEquals(0, Ints.indexOf(\n", "        ARRAY234, new int[] { (int) 2, (int) 3 }));\n", "    assertEquals(1, Ints.indexOf(\n", "        ARRAY234, new int[] { (int) 3, (int) 4 }));\n", "    assertEquals(1, Ints.indexOf(ARRAY234, new int[] { (int) 3 }));\n", "    assertEquals(2, Ints.indexOf(ARRAY234, new int[] { (int) 4 }));\n", "    assertEquals(1, Ints.indexOf(new int[] { (int) 2, (int) 3,\n", "        (int) 3, (int) 3, (int) 3 },\n", "        new int[] { (int) 3 }\n", "    ));\n", "    assertEquals(2, Ints.indexOf(\n", "        new int[] { (int) 2, (int) 3, (int) 2,\n", "            (int) 3, (int) 4, (int) 2, (int) 3},\n", "        new int[] { (int) 2, (int) 3, (int) 4}\n", "    ));\n", "    assertEquals(1, Ints.indexOf(\n", "        new int[] { (int) 2, (int) 2, (int) 3,\n", "            (int) 4, (int) 2, (int) 3, (int) 4},\n", "        new int[] { (int) 2, (int) 3, (int) 4}\n", "    ));\n", "    assertEquals(-1, Ints.indexOf(\n", "        new int[] { (int) 4, (int) 3, (int) 2},\n", "        new int[] { (int) 2, (int) 3, (int) 4}\n", "    ));\n", "  }\n", "\n", "  public void testLastIndexOf() {\n", "    assertEquals(-1, Ints.lastIndexOf(EMPTY, (int) 1));\n", "    assertEquals(-1, Ints.lastIndexOf(ARRAY1, (int) 2));\n", "    assertEquals(-1, Ints.lastIndexOf(ARRAY234, (int) 1));\n", "    assertEquals(0, Ints.lastIndexOf(\n", "        new int[] {(int) -1}, (int) -1));\n", "    assertEquals(0, Ints.lastIndexOf(ARRAY234, (int) 2));\n", "    assertEquals(1, Ints.lastIndexOf(ARRAY234, (int) 3));\n", "    assertEquals(2, Ints.lastIndexOf(ARRAY234, (int) 4));\n", "    assertEquals(3, Ints.lastIndexOf(\n", "        new int[] { (int) 2, (int) 3, (int) 2, (int) 3 },\n", "        (int) 3));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      Ints.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMax() {\n", "    assertEquals(LEAST, Ints.max(LEAST));\n", "    assertEquals(GREATEST, Ints.max(GREATEST));\n", "    assertEquals((int) 9, Ints.max(\n", "        (int) 8, (int) 6, (int) 7,\n", "        (int) 5, (int) 3, (int) 0, (int) 9));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      Ints.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMin() {\n", "    assertEquals(LEAST, Ints.min(LEAST));\n", "    assertEquals(GREATEST, Ints.min(GREATEST));\n", "    assertEquals((int) 0, Ints.min(\n", "        (int) 8, (int) 6, (int) 7,\n", "        (int) 5, (int) 3, (int) 0, (int) 9));\n", "  }\n", "\n", "  public void testConcat() {\n", "    assertTrue(Arrays.equals(EMPTY, Ints.concat()));\n", "    assertTrue(Arrays.equals(EMPTY, Ints.concat(EMPTY)));\n", "    assertTrue(Arrays.equals(EMPTY, Ints.concat(EMPTY, EMPTY, EMPTY)));\n", "    assertTrue(Arrays.equals(ARRAY1, Ints.concat(ARRAY1)));\n", "    assertNotSame(ARRAY1, Ints.concat(ARRAY1));\n", "    assertTrue(Arrays.equals(ARRAY1, Ints.concat(EMPTY, ARRAY1, EMPTY)));\n", "    assertTrue(Arrays.equals(\n", "        new int[] {(int) 1, (int) 1, (int) 1},\n", "        Ints.concat(ARRAY1, ARRAY1, ARRAY1)));\n", "    assertTrue(Arrays.equals(\n", "        new int[] {(int) 1, (int) 2, (int) 3, (int) 4},\n", "        Ints.concat(ARRAY1, ARRAY234)));\n", "  }\n", "\n", "  public void testEnsureCapacity() {\n", "    assertSame(EMPTY, Ints.ensureCapacity(EMPTY, 0, 1));\n", "    assertSame(ARRAY1, Ints.ensureCapacity(ARRAY1, 0, 1));\n", "    assertSame(ARRAY1, Ints.ensureCapacity(ARRAY1, 1, 1));\n", "    assertTrue(Arrays.equals(\n", "        new int[] {(int) 1, (int) 0, (int) 0},\n", "        Ints.ensureCapacity(ARRAY1, 2, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEnsureCapacity_fail() {\n", "    try {\n", "      Ints.ensureCapacity(ARRAY1, -1, 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // notice that this should even fail when no growth was needed\n", "      Ints.ensureCapacity(ARRAY1, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testJoin() {\n", "    assertEquals(\"\", Ints.join(\",\", EMPTY));\n", "    assertEquals(\"1\", Ints.join(\",\", ARRAY1));\n", "    assertEquals(\"1,2\", Ints.join(\",\", (int) 1, (int) 2));\n", "    assertEquals(\"123\",\n", "        Ints.join(\"\", (int) 1, (int) 2, (int) 3));\n", "  }\n", "\n", "  public void testLexicographicalComparator() {\n", "    List<int[]> ordered = Arrays.asList(\n", "        new int[] {},\n", "        new int[] {LEAST},\n", "        new int[] {LEAST, LEAST},\n", "        new int[] {LEAST, (int) 1},\n", "        new int[] {(int) 1},\n", "        new int[] {(int) 1, LEAST},\n", "        new int[] {GREATEST, GREATEST - (int) 1},\n", "        new int[] {GREATEST, GREATEST},\n", "        new int[] {GREATEST, GREATEST, GREATEST});\n", "\n", "    Comparator<int[]> comparator = Ints.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testToArray() {\n", "    // need explicit type parameter to avoid javac warning!?\n", "    List<Integer> none = Arrays.<Integer>asList();\n", "    assertTrue(Arrays.equals(EMPTY, Ints.toArray(none)));\n", "\n", "    List<Integer> one = Arrays.asList((int) 1);\n", "    assertTrue(Arrays.equals(ARRAY1, Ints.toArray(one)));\n", "\n", "    int[] array = {(int) 0, (int) 1, (int) 0xdeadbeef};\n", "\n", "    List<Integer> three = Arrays.asList((int) 0, (int) 1, (int) 0xdeadbeef);\n", "    assertTrue(Arrays.equals(array, Ints.toArray(three)));\n", "\n", "    assertTrue(Arrays.equals(array, Ints.toArray(Ints.asList(array))));\n", "  }\n", "\n", "  public void testToArray_threadSafe() {\n", "    for (int delta : new int[] { +1, 0, -1 }) {\n", "      for (int i = 0; i < VALUES.length; i++) {\n", "        List<Integer> list = Ints.asList(VALUES).subList(0, i);\n", "        Collection<Integer> misleadingSize =\n", "            Helpers.misleadingSizeCollection(delta);\n", "        misleadingSize.addAll(list);\n", "        int[] arr = Ints.toArray(misleadingSize);\n", "        assertEquals(i, arr.length);\n", "        for (int j = 0; j < i; j++) {\n", "          assertEquals(VALUES[j], arr[j]);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testToArray_withNull() {\n", "    List<Integer> list = Arrays.asList((int) 0, (int) 1, null);\n", "    try {\n", "      Ints.toArray(list);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToArray_withConversion() {\n", "    int[] array = {0, 1, 2};\n", "\n", "    List<Byte> bytes = Arrays.asList((byte) 0, (byte) 1, (byte) 2);\n", "    List<Short> shorts = Arrays.asList((short) 0, (short) 1, (short) 2);\n", "    List<Integer> ints = Arrays.asList(0, 1, 2);\n", "    List<Float> floats = Arrays.asList((float) 0, (float) 1, (float) 2);\n", "    List<Long> longs = Arrays.asList((long) 0, (long) 1, (long) 2);\n", "    List<Double> doubles = Arrays.asList((double) 0, (double) 1, (double) 2);\n", "\n", "    assertTrue(Arrays.equals(array, Ints.toArray(bytes)));\n", "    assertTrue(Arrays.equals(array, Ints.toArray(shorts)));\n", "    assertTrue(Arrays.equals(array, Ints.toArray(ints)));\n", "    assertTrue(Arrays.equals(array, Ints.toArray(floats)));\n", "    assertTrue(Arrays.equals(array, Ints.toArray(longs)));\n", "    assertTrue(Arrays.equals(array, Ints.toArray(doubles)));\n", "  }\n", "\n", "  public void testAsList_isAView() {\n", "    int[] array = {(int) 0, (int) 1};\n", "    List<Integer> list = Ints.asList(array);\n", "    list.set(0, (int) 2);\n", "    assertTrue(Arrays.equals(new int[] {(int) 2, (int) 1}, array));\n", "    array[1] = (int) 3;\n", "    assertEquals(Arrays.asList((int) 2, (int) 3), list);\n", "  }\n", "\n", "  public void testAsList_toArray_roundTrip() {\n", "    int[] array = { (int) 0, (int) 1, (int) 2 };\n", "    List<Integer> list = Ints.asList(array);\n", "    int[] newArray = Ints.toArray(list);\n", "\n", "    // Make sure it returned a copy\n", "    list.set(0, (int) 4);\n", "    assertTrue(Arrays.equals(\n", "        new int[] { (int) 0, (int) 1, (int) 2 }, newArray));\n", "    newArray[1] = (int) 5;\n", "    assertEquals((int) 1, (int) list.get(1));\n", "  }\n", "\n", "  // This test stems from a real bug found by andrewk\n", "  public void testAsList_subList_toArray_roundTrip() {\n", "    int[] array = { (int) 0, (int) 1, (int) 2, (int) 3 };\n", "    List<Integer> list = Ints.asList(array);\n", "    assertTrue(Arrays.equals(new int[] { (int) 1, (int) 2 },\n", "        Ints.toArray(list.subList(1, 3))));\n", "    assertTrue(Arrays.equals(new int[] {},\n", "        Ints.toArray(list.subList(2, 2))));\n", "  }\n", "\n", "  public void testAsListEmpty() {\n", "    assertSame(Collections.emptyList(), Ints.asList(EMPTY));\n", "  }\n", "\n", "  public void testStringConverter_convert() {\n", "    Converter<String, Integer> converter = Ints.stringConverter();\n", "    assertEquals((Integer) 1, converter.convert(\"1\"));\n", "    assertEquals((Integer) 0, converter.convert(\"0\"));\n", "    assertEquals((Integer) (-1), converter.convert(\"-1\"));\n", "    assertEquals((Integer) 255, converter.convert(\"0xff\"));\n", "    assertEquals((Integer) 255, converter.convert(\"0xFF\"));\n", "    assertEquals((Integer) (-255), converter.convert(\"-0xFF\"));\n", "    assertEquals((Integer) 255, converter.convert(\"#0000FF\"));\n", "    assertEquals((Integer) 438, converter.convert(\"0666\"));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testStringConverter_convertError() {\n", "    try {\n", "      Ints.stringConverter().convert(\"notanumber\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testStringConverter_nullConversions() {\n", "    assertNull(Ints.stringConverter().convert(null));\n", "    assertNull(Ints.stringConverter().reverse().convert(null));\n", "  }\n", "\n", "  public void testStringConverter_reverse() {\n", "    Converter<String, Integer> converter = Ints.stringConverter();\n", "    assertEquals(\"1\", converter.reverse().convert(1));\n", "    assertEquals(\"0\", converter.reverse().convert(0));\n", "    assertEquals(\"-1\", converter.reverse().convert(-1));\n", "    assertEquals(\"255\", converter.reverse().convert(0xff));\n", "    assertEquals(\"255\", converter.reverse().convert(0xFF));\n", "    assertEquals(\"-255\", converter.reverse().convert(-0xFF));\n", "    assertEquals(\"438\", converter.reverse().convert(0666));\n", "  }\n", "\n", "  public void testTryParse() {\n", "    tryParseAndAssertEquals(0, \"0\");\n", "    tryParseAndAssertEquals(0, \"-0\");\n", "    tryParseAndAssertEquals(1, \"1\");\n", "    tryParseAndAssertEquals(-1, \"-1\");\n", "    tryParseAndAssertEquals(8900, \"8900\");\n", "    tryParseAndAssertEquals(-8900, \"-8900\");\n", "    tryParseAndAssertEquals(GREATEST, Integer.toString(GREATEST));\n", "    tryParseAndAssertEquals(LEAST, Integer.toString(LEAST));\n", "    assertNull(Ints.tryParse(\"\"));\n", "    assertNull(Ints.tryParse(\"-\"));\n", "    assertNull(Ints.tryParse(\"+1\"));\n", "    assertNull(Ints.tryParse(\"9999999999999999\"));\n", "    assertNull(\"Max integer + 1\",\n", "        Ints.tryParse(Long.toString(((long) GREATEST) + 1)));\n", "    assertNull(\"Max integer * 10\",\n", "        Ints.tryParse(Long.toString(((long) GREATEST) * 10)));\n", "    assertNull(\"Min integer - 1\",\n", "        Ints.tryParse(Long.toString(((long) LEAST) - 1)));\n", "    assertNull(\"Min integer * 10\",\n", "        Ints.tryParse(Long.toString(((long) LEAST) * 10)));\n", "    assertNull(\"Max long\", Ints.tryParse(Long.toString(Long.MAX_VALUE)));\n", "    assertNull(\"Min long\", Ints.tryParse(Long.toString(Long.MIN_VALUE)));\n", "    assertNull(Ints.tryParse(\"\\u0662\\u06f3\"));\n", "  }\n", "\n", "  /**\n", "   * Applies {@link Ints#tryParse(String)} to the given string and asserts that\n", "   * the result is as expected.\n", "   */\n", "  private static void tryParseAndAssertEquals(Integer expected, String value) {\n", "    assertEquals(expected, Ints.tryParse(value));\n", "  }\n", "\n", "  public void testTryParse_radix() {\n", "    for (int radix = Character.MIN_RADIX;\n", "        radix <= Character.MAX_RADIX; radix++) {\n", "      radixEncodeParseAndAssertEquals(0, radix);\n", "      radixEncodeParseAndAssertEquals(8000, radix);\n", "      radixEncodeParseAndAssertEquals(-8000, radix);\n", "      radixEncodeParseAndAssertEquals(GREATEST, radix);\n", "      radixEncodeParseAndAssertEquals(LEAST, radix);\n", "      assertNull(\"Radix: \" + radix, Ints.tryParse(\"9999999999999999\", radix));\n", "      assertNull(\"Radix: \" + radix,\n", "          Ints.tryParse(Long.toString((long) GREATEST + 1, radix), radix));\n", "      assertNull(\"Radix: \" + radix,\n", "          Ints.tryParse(Long.toString((long) LEAST - 1, radix), radix));\n", "    }\n", "    assertNull(\"Hex string and dec parm\", Ints.tryParse(\"FFFF\", 10));\n", "    assertEquals(\"Mixed hex case\", 65535, (int) Ints.tryParse(\"ffFF\", 16));\n", "  }\n", "\n", "  /**\n", "   * Encodes the an integer as a string with given radix, then uses\n", "   * {@link Ints#tryParse(String, int)} to parse the result. Asserts the result\n", "   * is the same as what we started with.\n", "   */\n", "  private static void radixEncodeParseAndAssertEquals(Integer value,\n", "      int radix) {\n", "    assertEquals(\"Radix: \" + radix, value,\n", "        Ints.tryParse(Integer.toString(value, radix), radix));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testTryParse_radixTooBig() {\n", "    try {\n", "      Ints.tryParse(\"0\", Character.MAX_RADIX + 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testTryParse_radixTooSmall() {\n", "    try {\n", "      Ints.tryParse(\"0\", Character.MIN_RADIX - 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481]}}, {"185": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/LongArrayAsListTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.TestListGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Test suite covering {@link Longs#asList(long[])}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class LongArrayAsListTest extends TestCase {\n", "\n", "  private static List<Long> asList(Long[] values) {\n", "    long[] temp = new long[values.length];\n", "    for (int i = 0; i < values.length; i++) {\n", "      temp[i] = checkNotNull(values[i]);  // checkNotNull for GWT (do not optimize).\n", "    }\n", "    return Longs.asList(temp);\n", "  }\n", "\n", "  // Test generators.  To let the GWT test suite generator access them, they need to be\n", "  // public named classes with a public default constructor.\n", "\n", "  public static final class LongsAsListGenerator extends TestLongListGenerator {\n", "    @Override protected List<Long> create(Long[] elements) {\n", "      return asList(elements);\n", "    }\n", "  }\n", "\n", "  public static final class LongsAsListHeadSubListGenerator extends TestLongListGenerator {\n", "    @Override protected List<Long> create(Long[] elements) {\n", "      Long[] suffix = {Long.MIN_VALUE, Long.MAX_VALUE};\n", "      Long[] all = concat(elements, suffix);\n", "      return asList(all).subList(0, elements.length);\n", "    }\n", "  }\n", "\n", "  public static final class LongsAsListTailSubListGenerator extends TestLongListGenerator {\n", "    @Override protected List<Long> create(Long[] elements) {\n", "      Long[] prefix = {(long) 86, (long) 99};\n", "      Long[] all = concat(prefix, elements);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  public static final class LongsAsListMiddleSubListGenerator extends TestLongListGenerator {\n", "    @Override protected List<Long> create(Long[] elements) {\n", "      Long[] prefix = {Long.MIN_VALUE, Long.MAX_VALUE};\n", "      Long[] suffix = {(long) 86, (long) 99};\n", "      Long[] all = concat(concat(prefix, elements), suffix);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  private static Long[] concat(Long[] left, Long[] right) {\n", "    Long[] result = new Long[left.length + right.length];\n", "    System.arraycopy(left, 0, result, 0, left.length);\n", "    System.arraycopy(right, 0, result, left.length, right.length);\n", "    return result;\n", "  }\n", "\n", "  public static abstract class TestLongListGenerator\n", "      implements TestListGenerator<Long> {\n", "    @Override\n", "    public SampleElements<Long> samples() {\n", "      return new SampleLongs();\n", "    }\n", "\n", "    @Override\n", "    public List<Long> create(Object... elements) {\n", "      Long[] array = new Long[elements.length];\n", "      int i = 0;\n", "      for (Object e : elements) {\n", "        array[i++] = (Long) e;\n", "      }\n", "      return create(array);\n", "    }\n", "\n", "    /**\n", "     * Creates a new collection containing the given elements; implement this\n", "     * method instead of {@link #create(Object...)}.\n", "     */\n", "    protected abstract List<Long> create(Long[] elements);\n", "\n", "    @Override\n", "    public Long[] createArray(int length) {\n", "      return new Long[length];\n", "    }\n", "\n", "    /** Returns the original element list, unchanged. */\n", "    @Override\n", "    public List<Long> order(List<Long> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class SampleLongs extends SampleElements<Long> {\n", "    public SampleLongs() {\n", "      super((long) 0, (long) 1, (long) 2, (long) 3, (long) 4);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"186": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/LongsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static java.lang.Long.MAX_VALUE;\n", "import static java.lang.Long.MIN_VALUE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.math.BigInteger;\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "import java.util.Random;\n", "\n", "/**\n", " * Unit test for {@link Longs}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"cast\") // redundant casts are intentional and harmless\n", "public class LongsTest extends TestCase {\n", "  private static final long[] EMPTY = {};\n", "  private static final long[] ARRAY1 = {(long) 1};\n", "  private static final long[] ARRAY234\n", "      = {(long) 2, (long) 3, (long) 4};\n", "\n", "  private static final long[] VALUES =\n", "      { MIN_VALUE, (long) -1, (long) 0, (long) 1, MAX_VALUE };\n", "\n", "  public void testCompare() {\n", "    for (long x : VALUES) {\n", "      for (long y : VALUES) {\n", "        // note: spec requires only that the sign is the same\n", "        assertEquals(x + \", \" + y,\n", "                     Long.valueOf(x).compareTo(y),\n", "                     Longs.compare(x, y));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(Longs.contains(EMPTY, (long) 1));\n", "    assertFalse(Longs.contains(ARRAY1, (long) 2));\n", "    assertFalse(Longs.contains(ARRAY234, (long) 1));\n", "    assertTrue(Longs.contains(new long[] {(long) -1}, (long) -1));\n", "    assertTrue(Longs.contains(ARRAY234, (long) 2));\n", "    assertTrue(Longs.contains(ARRAY234, (long) 3));\n", "    assertTrue(Longs.contains(ARRAY234, (long) 4));\n", "  }\n", "\n", "  public void testIndexOf() {\n", "    assertEquals(-1, Longs.indexOf(EMPTY, (long) 1));\n", "    assertEquals(-1, Longs.indexOf(ARRAY1, (long) 2));\n", "    assertEquals(-1, Longs.indexOf(ARRAY234, (long) 1));\n", "    assertEquals(0, Longs.indexOf(\n", "        new long[] {(long) -1}, (long) -1));\n", "    assertEquals(0, Longs.indexOf(ARRAY234, (long) 2));\n", "    assertEquals(1, Longs.indexOf(ARRAY234, (long) 3));\n", "    assertEquals(2, Longs.indexOf(ARRAY234, (long) 4));\n", "    assertEquals(1, Longs.indexOf(\n", "        new long[] { (long) 2, (long) 3, (long) 2, (long) 3 },\n", "        (long) 3));\n", "  }\n", "\n", "  public void testIndexOf_arrayTarget() {\n", "    assertEquals(0, Longs.indexOf(EMPTY, EMPTY));\n", "    assertEquals(0, Longs.indexOf(ARRAY234, EMPTY));\n", "    assertEquals(-1, Longs.indexOf(EMPTY, ARRAY234));\n", "    assertEquals(-1, Longs.indexOf(ARRAY234, ARRAY1));\n", "    assertEquals(-1, Longs.indexOf(ARRAY1, ARRAY234));\n", "    assertEquals(0, Longs.indexOf(ARRAY1, ARRAY1));\n", "    assertEquals(0, Longs.indexOf(ARRAY234, ARRAY234));\n", "    assertEquals(0, Longs.indexOf(\n", "        ARRAY234, new long[] { (long) 2, (long) 3 }));\n", "    assertEquals(1, Longs.indexOf(\n", "        ARRAY234, new long[] { (long) 3, (long) 4 }));\n", "    assertEquals(1, Longs.indexOf(ARRAY234, new long[] { (long) 3 }));\n", "    assertEquals(2, Longs.indexOf(ARRAY234, new long[] { (long) 4 }));\n", "    assertEquals(1, Longs.indexOf(new long[] { (long) 2, (long) 3,\n", "        (long) 3, (long) 3, (long) 3 },\n", "        new long[] { (long) 3 }\n", "    ));\n", "    assertEquals(2, Longs.indexOf(\n", "        new long[] { (long) 2, (long) 3, (long) 2,\n", "            (long) 3, (long) 4, (long) 2, (long) 3},\n", "        new long[] { (long) 2, (long) 3, (long) 4}\n", "    ));\n", "    assertEquals(1, Longs.indexOf(\n", "        new long[] { (long) 2, (long) 2, (long) 3,\n", "            (long) 4, (long) 2, (long) 3, (long) 4},\n", "        new long[] { (long) 2, (long) 3, (long) 4}\n", "    ));\n", "    assertEquals(-1, Longs.indexOf(\n", "        new long[] { (long) 4, (long) 3, (long) 2},\n", "        new long[] { (long) 2, (long) 3, (long) 4}\n", "    ));\n", "  }\n", "\n", "  public void testLastIndexOf() {\n", "    assertEquals(-1, Longs.lastIndexOf(EMPTY, (long) 1));\n", "    assertEquals(-1, Longs.lastIndexOf(ARRAY1, (long) 2));\n", "    assertEquals(-1, Longs.lastIndexOf(ARRAY234, (long) 1));\n", "    assertEquals(0, Longs.lastIndexOf(\n", "        new long[] {(long) -1}, (long) -1));\n", "    assertEquals(0, Longs.lastIndexOf(ARRAY234, (long) 2));\n", "    assertEquals(1, Longs.lastIndexOf(ARRAY234, (long) 3));\n", "    assertEquals(2, Longs.lastIndexOf(ARRAY234, (long) 4));\n", "    assertEquals(3, Longs.lastIndexOf(\n", "        new long[] { (long) 2, (long) 3, (long) 2, (long) 3 },\n", "        (long) 3));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      Longs.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMax() {\n", "    assertEquals(MIN_VALUE, Longs.max(MIN_VALUE));\n", "    assertEquals(MAX_VALUE, Longs.max(MAX_VALUE));\n", "    assertEquals((long) 9, Longs.max(\n", "        (long) 8, (long) 6, (long) 7,\n", "        (long) 5, (long) 3, (long) 0, (long) 9));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      Longs.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMin() {\n", "    assertEquals(MIN_VALUE, Longs.min(MIN_VALUE));\n", "    assertEquals(MAX_VALUE, Longs.min(MAX_VALUE));\n", "    assertEquals((long) 0, Longs.min(\n", "        (long) 8, (long) 6, (long) 7,\n", "        (long) 5, (long) 3, (long) 0, (long) 9));\n", "  }\n", "\n", "  public void testConcat() {\n", "    assertTrue(Arrays.equals(EMPTY, Longs.concat()));\n", "    assertTrue(Arrays.equals(EMPTY, Longs.concat(EMPTY)));\n", "    assertTrue(Arrays.equals(EMPTY, Longs.concat(EMPTY, EMPTY, EMPTY)));\n", "    assertTrue(Arrays.equals(ARRAY1, Longs.concat(ARRAY1)));\n", "    assertNotSame(ARRAY1, Longs.concat(ARRAY1));\n", "    assertTrue(Arrays.equals(ARRAY1, Longs.concat(EMPTY, ARRAY1, EMPTY)));\n", "    assertTrue(Arrays.equals(\n", "        new long[] {(long) 1, (long) 1, (long) 1},\n", "        Longs.concat(ARRAY1, ARRAY1, ARRAY1)));\n", "    assertTrue(Arrays.equals(\n", "        new long[] {(long) 1, (long) 2, (long) 3, (long) 4},\n", "        Longs.concat(ARRAY1, ARRAY234)));\n", "  }\n", "\n", "  private static void assertByteArrayEquals(byte[] expected, byte[] actual) {\n", "    assertTrue(\n", "        \"Expected: \" + Arrays.toString(expected) + \", but got: \" + Arrays.toString(actual),\n", "        Arrays.equals(expected, actual));\n", "  }\n", "\n", "  public void testToByteArray() {\n", "    assertByteArrayEquals(\n", "        new byte[] {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19},\n", "        Longs.toByteArray(0x1213141516171819L));\n", "    assertByteArrayEquals(\n", "        new byte[] {\n", "            (byte) 0xFF, (byte) 0xEE, (byte) 0xDD, (byte) 0xCC,\n", "            (byte) 0xBB, (byte) 0xAA, (byte) 0x99, (byte) 0x88},\n", "        Longs.toByteArray(0xFFEEDDCCBBAA9988L));\n", "  }\n", "\n", "  public void testFromByteArray() {\n", "    assertEquals(0x1213141516171819L, Longs.fromByteArray(\n", "        new byte[] {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x33}));\n", "    assertEquals(0xFFEEDDCCBBAA9988L, Longs.fromByteArray(\n", "        new byte[] {\n", "            (byte) 0xFF, (byte) 0xEE, (byte) 0xDD, (byte) 0xCC,\n", "            (byte) 0xBB, (byte) 0xAA, (byte) 0x99, (byte) 0x88}));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testFromByteArrayFails() {\n", "    try {\n", "      Longs.fromByteArray(new byte[Longs.BYTES - 1]);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testFromBytes() {\n", "    assertEquals(0x1213141516171819L, Longs.fromBytes(\n", "        (byte) 0x12, (byte) 0x13, (byte) 0x14, (byte) 0x15,\n", "        (byte) 0x16, (byte) 0x17, (byte) 0x18, (byte) 0x19));\n", "    assertEquals(0xFFEEDDCCBBAA9988L, Longs.fromBytes(\n", "        (byte) 0xFF, (byte) 0xEE, (byte) 0xDD, (byte) 0xCC,\n", "        (byte) 0xBB, (byte) 0xAA, (byte) 0x99, (byte) 0x88));\n", "  }\n", "\n", "  public void testByteArrayRoundTrips() {\n", "    Random r = new Random(5);\n", "    byte[] b = new byte[Longs.BYTES];\n", "\n", "    // total overkill, but, it takes 0.1 sec so why not...\n", "    for (int i = 0; i < 10000; i++) {\n", "      long num = r.nextLong();\n", "      assertEquals(num, Longs.fromByteArray(Longs.toByteArray(num)));\n", "\n", "      r.nextBytes(b);\n", "      long value = Longs.fromByteArray(b);\n", "      assertTrue(\"\" + value, Arrays.equals(b, Longs.toByteArray(value)));\n", "    }\n", "  }\n", "\n", "  public void testEnsureCapacity() {\n", "    assertSame(EMPTY, Longs.ensureCapacity(EMPTY, 0, 1));\n", "    assertSame(ARRAY1, Longs.ensureCapacity(ARRAY1, 0, 1));\n", "    assertSame(ARRAY1, Longs.ensureCapacity(ARRAY1, 1, 1));\n", "    assertTrue(Arrays.equals(\n", "        new long[] {(long) 1, (long) 0, (long) 0},\n", "        Longs.ensureCapacity(ARRAY1, 2, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEnsureCapacity_fail() {\n", "    try {\n", "      Longs.ensureCapacity(ARRAY1, -1, 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // notice that this should even fail when no growth was needed\n", "      Longs.ensureCapacity(ARRAY1, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testJoin() {\n", "    assertEquals(\"\", Longs.join(\",\", EMPTY));\n", "    assertEquals(\"1\", Longs.join(\",\", ARRAY1));\n", "    assertEquals(\"1,2\", Longs.join(\",\", (long) 1, (long) 2));\n", "    assertEquals(\"123\",\n", "        Longs.join(\"\", (long) 1, (long) 2, (long) 3));\n", "  }\n", "\n", "  public void testLexicographicalComparator() {\n", "    List<long[]> ordered = Arrays.asList(\n", "        new long[] {},\n", "        new long[] {MIN_VALUE},\n", "        new long[] {MIN_VALUE, MIN_VALUE},\n", "        new long[] {MIN_VALUE, (long) 1},\n", "        new long[] {(long) 1},\n", "        new long[] {(long) 1, MIN_VALUE},\n", "        new long[] {MAX_VALUE, MAX_VALUE - (long) 1},\n", "        new long[] {MAX_VALUE, MAX_VALUE},\n", "        new long[] {MAX_VALUE, MAX_VALUE, MAX_VALUE});\n", "\n", "    Comparator<long[]> comparator = Longs.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testToArray() {\n", "    // need explicit type parameter to avoid javac warning!?\n", "    List<Long> none = Arrays.<Long>asList();\n", "    assertTrue(Arrays.equals(EMPTY, Longs.toArray(none)));\n", "\n", "    List<Long> one = Arrays.asList((long) 1);\n", "    assertTrue(Arrays.equals(ARRAY1, Longs.toArray(one)));\n", "\n", "    long[] array = {(long) 0, (long) 1, 0x0FF1C1AL};\n", "\n", "    List<Long> three = Arrays.asList((long) 0, (long) 1, 0x0FF1C1AL);\n", "    assertTrue(Arrays.equals(array, Longs.toArray(three)));\n", "\n", "    assertTrue(Arrays.equals(array, Longs.toArray(Longs.asList(array))));\n", "  }\n", "\n", "  public void testToArray_threadSafe() {\n", "    for (int delta : new int[] { +1, 0, -1 }) {\n", "      for (int i = 0; i < VALUES.length; i++) {\n", "        List<Long> list = Longs.asList(VALUES).subList(0, i);\n", "        Collection<Long> misleadingSize =\n", "            Helpers.misleadingSizeCollection(delta);\n", "        misleadingSize.addAll(list);\n", "        long[] arr = Longs.toArray(misleadingSize);\n", "        assertEquals(i, arr.length);\n", "        for (int j = 0; j < i; j++) {\n", "          assertEquals(VALUES[j], arr[j]);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testToArray_withNull() {\n", "    List<Long> list = Arrays.asList((long) 0, (long) 1, null);\n", "    try {\n", "      Longs.toArray(list);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToArray_withConversion() {\n", "    long[] array = {(long) 0, (long) 1, (long) 2};\n", "\n", "    List<Byte> bytes = Arrays.asList((byte) 0, (byte) 1, (byte) 2);\n", "    List<Short> shorts = Arrays.asList((short) 0, (short) 1, (short) 2);\n", "    List<Integer> ints = Arrays.asList(0, 1, 2);\n", "    List<Float> floats = Arrays.asList((float) 0, (float) 1, (float) 2);\n", "    List<Long> longs = Arrays.asList((long) 0, (long) 1, (long) 2);\n", "    List<Double> doubles = Arrays.asList((double) 0, (double) 1, (double) 2);\n", "\n", "    assertTrue(Arrays.equals(array, Longs.toArray(bytes)));\n", "    assertTrue(Arrays.equals(array, Longs.toArray(shorts)));\n", "    assertTrue(Arrays.equals(array, Longs.toArray(ints)));\n", "    assertTrue(Arrays.equals(array, Longs.toArray(floats)));\n", "    assertTrue(Arrays.equals(array, Longs.toArray(longs)));\n", "    assertTrue(Arrays.equals(array, Longs.toArray(doubles)));\n", "  }\n", "\n", "  public void testAsList_isAView() {\n", "    long[] array = {(long) 0, (long) 1};\n", "    List<Long> list = Longs.asList(array);\n", "    list.set(0, (long) 2);\n", "    assertTrue(Arrays.equals(new long[] {(long) 2, (long) 1}, array));\n", "    array[1] = (long) 3;\n", "    assertEquals(Arrays.asList((long) 2, (long) 3), list);\n", "  }\n", "\n", "  public void testAsList_toArray_roundTrip() {\n", "    long[] array = { (long) 0, (long) 1, (long) 2 };\n", "    List<Long> list = Longs.asList(array);\n", "    long[] newArray = Longs.toArray(list);\n", "\n", "    // Make sure it returned a copy\n", "    list.set(0, (long) 4);\n", "    assertTrue(Arrays.equals(\n", "        new long[] { (long) 0, (long) 1, (long) 2 }, newArray));\n", "    newArray[1] = (long) 5;\n", "    assertEquals((long) 1, (long) list.get(1));\n", "  }\n", "\n", "  // This test stems from a real bug found by andrewk\n", "  public void testAsList_subList_toArray_roundTrip() {\n", "    long[] array = { (long) 0, (long) 1, (long) 2, (long) 3 };\n", "    List<Long> list = Longs.asList(array);\n", "    assertTrue(Arrays.equals(new long[] { (long) 1, (long) 2 },\n", "        Longs.toArray(list.subList(1, 3))));\n", "    assertTrue(Arrays.equals(new long[] {},\n", "        Longs.toArray(list.subList(2, 2))));\n", "  }\n", "\n", "  public void testAsListEmpty() {\n", "    assertSame(Collections.emptyList(), Longs.asList(EMPTY));\n", "  }\n", "\n", "  public void testStringConverter_convert() {\n", "    Converter<String, Long> converter = Longs.stringConverter();\n", "    assertEquals((Long) 1L, converter.convert(\"1\"));\n", "    assertEquals((Long) 0L, converter.convert(\"0\"));\n", "    assertEquals((Long) (-1L), converter.convert(\"-1\"));\n", "    assertEquals((Long) 255L, converter.convert(\"0xff\"));\n", "    assertEquals((Long) 255L, converter.convert(\"0xFF\"));\n", "    assertEquals((Long) (-255L), converter.convert(\"-0xFF\"));\n", "    assertEquals((Long) 255L, converter.convert(\"#0000FF\"));\n", "    assertEquals((Long) 438L, converter.convert(\"0666\"));\n", "  }\n", "\n", "  public void testStringConverter_convertError() {\n", "    try {\n", "      Longs.stringConverter().convert(\"notanumber\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testStringConverter_nullConversions() {\n", "    assertNull(Longs.stringConverter().convert(null));\n", "    assertNull(Longs.stringConverter().reverse().convert(null));\n", "  }\n", "\n", "  public void testStringConverter_reverse() {\n", "    Converter<String, Long> converter = Longs.stringConverter();\n", "    assertEquals(\"1\", converter.reverse().convert(1L));\n", "    assertEquals(\"0\", converter.reverse().convert(0L));\n", "    assertEquals(\"-1\", converter.reverse().convert(-1L));\n", "    assertEquals(\"255\", converter.reverse().convert(0xffL));\n", "    assertEquals(\"255\", converter.reverse().convert(0xFFL));\n", "    assertEquals(\"-255\", converter.reverse().convert(-0xFFL));\n", "    assertEquals(\"438\", converter.reverse().convert(0666L));\n", "  }\n", "\n", "  public void testTryParse() {\n", "    tryParseAndAssertEquals(0L, \"0\");\n", "    tryParseAndAssertEquals(0L, \"-0\");\n", "    tryParseAndAssertEquals(1L, \"1\");\n", "    tryParseAndAssertEquals(-1L, \"-1\");\n", "    tryParseAndAssertEquals(8900L, \"8900\");\n", "    tryParseAndAssertEquals(-8900L, \"-8900\");\n", "    tryParseAndAssertEquals(MAX_VALUE, Long.toString(MAX_VALUE));\n", "    tryParseAndAssertEquals(MIN_VALUE, Long.toString(MIN_VALUE));\n", "    assertNull(Longs.tryParse(\"\"));\n", "    assertNull(Longs.tryParse(\"-\"));\n", "    assertNull(Longs.tryParse(\"+1\"));\n", "    assertNull(Longs.tryParse(\"999999999999999999999999\"));\n", "    assertNull(\"Max long + 1\",\n", "        Longs.tryParse(BigInteger.valueOf(MAX_VALUE).add(BigInteger.ONE).toString()));\n", "    assertNull(\"Max long * 10\",\n", "        Longs.tryParse(BigInteger.valueOf(MAX_VALUE).multiply(BigInteger.TEN).toString()));\n", "    assertNull(\"Min long - 1\",\n", "        Longs.tryParse(BigInteger.valueOf(MIN_VALUE).subtract(BigInteger.ONE).toString()));\n", "    assertNull(\"Min long * 10\",\n", "        Longs.tryParse(BigInteger.valueOf(MIN_VALUE).multiply(BigInteger.TEN).toString()));\n", "    assertNull(Longs.tryParse(\"\\u0662\\u06f3\"));\n", "  }\n", "\n", "  /**\n", "   * Applies {@link Longs#tryParse(String)} to the given string and asserts that\n", "   * the result is as expected.\n", "   */\n", "  private static void tryParseAndAssertEquals(Long expected, String value) {\n", "    assertEquals(expected, Longs.tryParse(value));\n", "  }\n", "\n", "  public void testTryParse_radix() {\n", "    for (int radix = Character.MIN_RADIX;\n", "        radix <= Character.MAX_RADIX; radix++) {\n", "      radixEncodeParseAndAssertEquals((long) 0, radix);\n", "      radixEncodeParseAndAssertEquals((long) 8000, radix);\n", "      radixEncodeParseAndAssertEquals((long) -8000, radix);\n", "      radixEncodeParseAndAssertEquals(MAX_VALUE, radix);\n", "      radixEncodeParseAndAssertEquals(MIN_VALUE, radix);\n", "      assertNull(\"Radix: \" + radix, Longs.tryParse(\"999999999999999999999999\", radix));\n", "      assertNull(\"Radix: \" + radix,\n", "          Longs.tryParse(BigInteger.valueOf(MAX_VALUE).add(BigInteger.ONE).toString(), radix));\n", "      assertNull(\"Radix: \" + radix,\n", "          Longs.tryParse(BigInteger.valueOf(MIN_VALUE).subtract(BigInteger.ONE).toString(), radix));\n", "    }\n", "    assertNull(\"Hex string and dec parm\", Longs.tryParse(\"FFFF\", 10));\n", "    assertEquals(\"Mixed hex case\", 65535, Longs.tryParse(\"ffFF\", 16).longValue());\n", "  }\n", "\n", "  /**\n", "   * Encodes the long as a string with given radix, then uses\n", "   * {@link Longs#tryParse(String, int)} to parse the result. Asserts the result\n", "   * is the same as what we started with.\n", "   */\n", "  private static void radixEncodeParseAndAssertEquals(Long value, int radix) {\n", "    assertEquals(\"Radix: \" + radix, value,\n", "        Longs.tryParse(Long.toString(value, radix), radix));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testTryParse_radixTooBig() {\n", "    try {\n", "      Longs.tryParse(\"0\", Character.MAX_RADIX + 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testTryParse_radixTooSmall() {\n", "    try {\n", "      Longs.tryParse(\"0\", Character.MIN_RADIX - 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501]}}, {"187": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/ShortArrayAsListTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static com.google.common.base.Preconditions.checkNotNull;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.SampleElements;\n", "import com.google.common.collect.testing.TestListGenerator;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.List;\n", "\n", "/**\n", " * Test suite covering {@link Shorts#asList(short[])}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class ShortArrayAsListTest extends TestCase {\n", "\n", "  private static List<Short> asList(Short[] values) {\n", "    short[] temp = new short[values.length];\n", "    for (short i = 0; i < values.length; i++) {\n", "      temp[i] = checkNotNull(values[i]);  // checkNotNull for GWT (do not optimize).\n", "    }\n", "    return Shorts.asList(temp);\n", "  }\n", "\n", "  // Test generators.  To let the GWT test suite generator access them, they need to be\n", "  // public named classes with a public default constructor.\n", "\n", "  public static final class ShortsAsListGenerator extends TestShortListGenerator {\n", "    @Override protected List<Short> create(Short[] elements) {\n", "      return asList(elements);\n", "    }\n", "  }\n", "\n", "  public static final class ShortsAsListHeadSubListGenerator extends TestShortListGenerator {\n", "    @Override protected List<Short> create(Short[] elements) {\n", "      Short[] suffix = {Short.MIN_VALUE, Short.MAX_VALUE};\n", "      Short[] all = concat(elements, suffix);\n", "      return asList(all).subList(0, elements.length);\n", "    }\n", "  }\n", "\n", "  public static final class ShortsAsListTailSubListGenerator extends TestShortListGenerator {\n", "    @Override protected List<Short> create(Short[] elements) {\n", "      Short[] prefix = {(short) 86, (short) 99};\n", "      Short[] all = concat(prefix, elements);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  public static final class ShortsAsListMiddleSubListGenerator extends TestShortListGenerator {\n", "    @Override protected List<Short> create(Short[] elements) {\n", "      Short[] prefix = {Short.MIN_VALUE, Short.MAX_VALUE};\n", "      Short[] suffix = {(short) 86, (short) 99};\n", "      Short[] all = concat(concat(prefix, elements), suffix);\n", "      return asList(all).subList(2, elements.length + 2);\n", "    }\n", "  }\n", "\n", "  private static Short[] concat(Short[] left, Short[] right) {\n", "    Short[] result = new Short[left.length + right.length];\n", "    System.arraycopy(left, 0, result, 0, left.length);\n", "    System.arraycopy(right, 0, result, left.length, right.length);\n", "    return result;\n", "  }\n", "\n", "  public static abstract class TestShortListGenerator\n", "      implements TestListGenerator<Short> {\n", "    @Override\n", "    public SampleElements<Short> samples() {\n", "      return new SampleShorts();\n", "    }\n", "\n", "    @Override\n", "    public List<Short> create(Object... elements) {\n", "      Short[] array = new Short[elements.length];\n", "      short i = 0;\n", "      for (Object e : elements) {\n", "        array[i++] = (Short) e;\n", "      }\n", "      return create(array);\n", "    }\n", "\n", "    /**\n", "     * Creates a new collection containing the given elements; implement this\n", "     * method instead of {@link #create(Object...)}.\n", "     */\n", "    protected abstract List<Short> create(Short[] elements);\n", "\n", "    @Override\n", "    public Short[] createArray(int length) {\n", "      return new Short[length];\n", "    }\n", "\n", "    /** Returns the original element list, unchanged. */\n", "    @Override\n", "    public List<Short> order(List<Short> insertionOrder) {\n", "      return insertionOrder;\n", "    }\n", "  }\n", "\n", "  public static class SampleShorts extends SampleElements<Short> {\n", "    public SampleShorts() {\n", "      super((short) 0, (short) 1, (short) 2, (short) 3, (short) 4);\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]}}, {"188": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/ShortsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Converter;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Collection;\n", "import java.util.Collections;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link Shorts}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"cast\") // redundant casts are intentional and harmless\n", "public class ShortsTest extends TestCase {\n", "  private static final short[] EMPTY = {};\n", "  private static final short[] ARRAY1 = {(short) 1};\n", "  private static final short[] ARRAY234\n", "      = {(short) 2, (short) 3, (short) 4};\n", "\n", "  private static final short LEAST = Short.MIN_VALUE;\n", "  private static final short GREATEST = Short.MAX_VALUE;\n", "\n", "  private static final short[] VALUES =\n", "      { LEAST, (short) -1, (short) 0, (short) 1, GREATEST };\n", "\n", "  public void testHashCode() {\n", "    for (short value : VALUES) {\n", "      assertEquals(((Short) value).hashCode(), Shorts.hashCode(value));\n", "    }\n", "  }\n", "\n", "  public void testCheckedCast() {\n", "    for (short value : VALUES) {\n", "      assertEquals(value, Shorts.checkedCast((long) value));\n", "    }\n", "    assertCastFails(GREATEST + 1L);\n", "    assertCastFails(LEAST - 1L);\n", "    assertCastFails(Long.MAX_VALUE);\n", "    assertCastFails(Long.MIN_VALUE);\n", "  }\n", "\n", "  public void testSaturatedCast() {\n", "    for (short value : VALUES) {\n", "      assertEquals(value, Shorts.saturatedCast((long) value));\n", "    }\n", "    assertEquals(GREATEST, Shorts.saturatedCast(GREATEST + 1L));\n", "    assertEquals(LEAST, Shorts.saturatedCast(LEAST - 1L));\n", "    assertEquals(GREATEST, Shorts.saturatedCast(Long.MAX_VALUE));\n", "    assertEquals(LEAST, Shorts.saturatedCast(Long.MIN_VALUE));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  private static void assertCastFails(long value) {\n", "    try {\n", "      Shorts.checkedCast(value);\n", "      fail(\"Cast to short should have failed: \" + value);\n", "    } catch (IllegalArgumentException ex) {\n", "      assertTrue(value + \" not found in exception text: \" + ex.getMessage(),\n", "          ex.getMessage().contains(String.valueOf(value)));\n", "    }\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (short x : VALUES) {\n", "      for (short y : VALUES) {\n", "        // Only compare the sign of the result of compareTo().\n", "        int expected = Short.valueOf(x).compareTo(y);\n", "        int actual = Shorts.compare(x, y);\n", "        if (expected == 0) {\n", "          assertEquals(x + \", \" + y, expected, actual);\n", "        } else if (expected < 0) {\n", "          assertTrue(x + \", \" + y + \" (expected: \" + expected + \", actual\" + actual + \")\",\n", "              actual < 0);\n", "        } else {\n", "          assertTrue(x + \", \" + y + \" (expected: \" + expected + \", actual\" + actual + \")\",\n", "              actual > 0);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testContains() {\n", "    assertFalse(Shorts.contains(EMPTY, (short) 1));\n", "    assertFalse(Shorts.contains(ARRAY1, (short) 2));\n", "    assertFalse(Shorts.contains(ARRAY234, (short) 1));\n", "    assertTrue(Shorts.contains(new short[] {(short) -1}, (short) -1));\n", "    assertTrue(Shorts.contains(ARRAY234, (short) 2));\n", "    assertTrue(Shorts.contains(ARRAY234, (short) 3));\n", "    assertTrue(Shorts.contains(ARRAY234, (short) 4));\n", "  }\n", "\n", "  public void testIndexOf() {\n", "    assertEquals(-1, Shorts.indexOf(EMPTY, (short) 1));\n", "    assertEquals(-1, Shorts.indexOf(ARRAY1, (short) 2));\n", "    assertEquals(-1, Shorts.indexOf(ARRAY234, (short) 1));\n", "    assertEquals(0, Shorts.indexOf(\n", "        new short[] {(short) -1}, (short) -1));\n", "    assertEquals(0, Shorts.indexOf(ARRAY234, (short) 2));\n", "    assertEquals(1, Shorts.indexOf(ARRAY234, (short) 3));\n", "    assertEquals(2, Shorts.indexOf(ARRAY234, (short) 4));\n", "    assertEquals(1, Shorts.indexOf(\n", "        new short[] { (short) 2, (short) 3, (short) 2, (short) 3 },\n", "        (short) 3));\n", "  }\n", "\n", "  public void testIndexOf_arrayTarget() {\n", "    assertEquals(0, Shorts.indexOf(EMPTY, EMPTY));\n", "    assertEquals(0, Shorts.indexOf(ARRAY234, EMPTY));\n", "    assertEquals(-1, Shorts.indexOf(EMPTY, ARRAY234));\n", "    assertEquals(-1, Shorts.indexOf(ARRAY234, ARRAY1));\n", "    assertEquals(-1, Shorts.indexOf(ARRAY1, ARRAY234));\n", "    assertEquals(0, Shorts.indexOf(ARRAY1, ARRAY1));\n", "    assertEquals(0, Shorts.indexOf(ARRAY234, ARRAY234));\n", "    assertEquals(0, Shorts.indexOf(\n", "        ARRAY234, new short[] { (short) 2, (short) 3 }));\n", "    assertEquals(1, Shorts.indexOf(\n", "        ARRAY234, new short[] { (short) 3, (short) 4 }));\n", "    assertEquals(1, Shorts.indexOf(ARRAY234, new short[] { (short) 3 }));\n", "    assertEquals(2, Shorts.indexOf(ARRAY234, new short[] { (short) 4 }));\n", "    assertEquals(1, Shorts.indexOf(new short[] { (short) 2, (short) 3,\n", "        (short) 3, (short) 3, (short) 3 },\n", "        new short[] { (short) 3 }\n", "    ));\n", "    assertEquals(2, Shorts.indexOf(\n", "        new short[] { (short) 2, (short) 3, (short) 2,\n", "            (short) 3, (short) 4, (short) 2, (short) 3},\n", "        new short[] { (short) 2, (short) 3, (short) 4}\n", "    ));\n", "    assertEquals(1, Shorts.indexOf(\n", "        new short[] { (short) 2, (short) 2, (short) 3,\n", "            (short) 4, (short) 2, (short) 3, (short) 4},\n", "        new short[] { (short) 2, (short) 3, (short) 4}\n", "    ));\n", "    assertEquals(-1, Shorts.indexOf(\n", "        new short[] { (short) 4, (short) 3, (short) 2},\n", "        new short[] { (short) 2, (short) 3, (short) 4}\n", "    ));\n", "  }\n", "\n", "  public void testLastIndexOf() {\n", "    assertEquals(-1, Shorts.lastIndexOf(EMPTY, (short) 1));\n", "    assertEquals(-1, Shorts.lastIndexOf(ARRAY1, (short) 2));\n", "    assertEquals(-1, Shorts.lastIndexOf(ARRAY234, (short) 1));\n", "    assertEquals(0, Shorts.lastIndexOf(\n", "        new short[] {(short) -1}, (short) -1));\n", "    assertEquals(0, Shorts.lastIndexOf(ARRAY234, (short) 2));\n", "    assertEquals(1, Shorts.lastIndexOf(ARRAY234, (short) 3));\n", "    assertEquals(2, Shorts.lastIndexOf(ARRAY234, (short) 4));\n", "    assertEquals(3, Shorts.lastIndexOf(\n", "        new short[] { (short) 2, (short) 3, (short) 2, (short) 3 },\n", "        (short) 3));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      Shorts.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMax() {\n", "    assertEquals(LEAST, Shorts.max(LEAST));\n", "    assertEquals(GREATEST, Shorts.max(GREATEST));\n", "    assertEquals((short) 9, Shorts.max(\n", "        (short) 8, (short) 6, (short) 7,\n", "        (short) 5, (short) 3, (short) 0, (short) 9));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      Shorts.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMin() {\n", "    assertEquals(LEAST, Shorts.min(LEAST));\n", "    assertEquals(GREATEST, Shorts.min(GREATEST));\n", "    assertEquals((short) 0, Shorts.min(\n", "        (short) 8, (short) 6, (short) 7,\n", "        (short) 5, (short) 3, (short) 0, (short) 9));\n", "  }\n", "\n", "  public void testConcat() {\n", "    assertTrue(Arrays.equals(EMPTY, Shorts.concat()));\n", "    assertTrue(Arrays.equals(EMPTY, Shorts.concat(EMPTY)));\n", "    assertTrue(Arrays.equals(EMPTY, Shorts.concat(EMPTY, EMPTY, EMPTY)));\n", "    assertTrue(Arrays.equals(ARRAY1, Shorts.concat(ARRAY1)));\n", "    assertNotSame(ARRAY1, Shorts.concat(ARRAY1));\n", "    assertTrue(Arrays.equals(ARRAY1, Shorts.concat(EMPTY, ARRAY1, EMPTY)));\n", "    assertTrue(Arrays.equals(\n", "        new short[] {(short) 1, (short) 1, (short) 1},\n", "        Shorts.concat(ARRAY1, ARRAY1, ARRAY1)));\n", "    assertTrue(Arrays.equals(\n", "        new short[] {(short) 1, (short) 2, (short) 3, (short) 4},\n", "        Shorts.concat(ARRAY1, ARRAY234)));\n", "  }\n", "\n", "  public void testEnsureCapacity() {\n", "    assertSame(EMPTY, Shorts.ensureCapacity(EMPTY, 0, 1));\n", "    assertSame(ARRAY1, Shorts.ensureCapacity(ARRAY1, 0, 1));\n", "    assertSame(ARRAY1, Shorts.ensureCapacity(ARRAY1, 1, 1));\n", "    assertTrue(Arrays.equals(\n", "        new short[] {(short) 1, (short) 0, (short) 0},\n", "        Shorts.ensureCapacity(ARRAY1, 2, 1)));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testEnsureCapacity_fail() {\n", "    try {\n", "      Shorts.ensureCapacity(ARRAY1, -1, 1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "    try {\n", "      // notice that this should even fail when no growth was needed\n", "      Shorts.ensureCapacity(ARRAY1, 1, -1);\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testJoin() {\n", "    assertEquals(\"\", Shorts.join(\",\", EMPTY));\n", "    assertEquals(\"1\", Shorts.join(\",\", ARRAY1));\n", "    assertEquals(\"1,2\", Shorts.join(\",\", (short) 1, (short) 2));\n", "    assertEquals(\"123\",\n", "        Shorts.join(\"\", (short) 1, (short) 2, (short) 3));\n", "  }\n", "\n", "  public void testLexicographicalComparator() {\n", "    List<short[]> ordered = Arrays.asList(\n", "        new short[] {},\n", "        new short[] {LEAST},\n", "        new short[] {LEAST, LEAST},\n", "        new short[] {LEAST, (short) 1},\n", "        new short[] {(short) 1},\n", "        new short[] {(short) 1, LEAST},\n", "        new short[] {GREATEST, GREATEST - (short) 1},\n", "        new short[] {GREATEST, GREATEST},\n", "        new short[] {GREATEST, GREATEST, GREATEST});\n", "\n", "    Comparator<short[]> comparator = Shorts.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testToArray() {\n", "    // need explicit type parameter to avoid javac warning!?\n", "    List<Short> none = Arrays.<Short>asList();\n", "    assertTrue(Arrays.equals(EMPTY, Shorts.toArray(none)));\n", "\n", "    List<Short> one = Arrays.asList((short) 1);\n", "    assertTrue(Arrays.equals(ARRAY1, Shorts.toArray(one)));\n", "\n", "    short[] array = {(short) 0, (short) 1, (short) 3};\n", "\n", "    List<Short> three = Arrays.asList((short) 0, (short) 1, (short) 3);\n", "    assertTrue(Arrays.equals(array, Shorts.toArray(three)));\n", "\n", "    assertTrue(Arrays.equals(array, Shorts.toArray(Shorts.asList(array))));\n", "  }\n", "\n", "  public void testToArray_threadSafe() {\n", "    for (int delta : new int[] { +1, 0, -1 }) {\n", "      for (int i = 0; i < VALUES.length; i++) {\n", "        List<Short> list = Shorts.asList(VALUES).subList(0, i);\n", "        Collection<Short> misleadingSize =\n", "            Helpers.misleadingSizeCollection(delta);\n", "        misleadingSize.addAll(list);\n", "        short[] arr = Shorts.toArray(misleadingSize);\n", "        assertEquals(i, arr.length);\n", "        for (int j = 0; j < i; j++) {\n", "          assertEquals(VALUES[j], arr[j]);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testToArray_withNull() {\n", "    List<Short> list = Arrays.asList((short) 0, (short) 1, null);\n", "    try {\n", "      Shorts.toArray(list);\n", "      fail();\n", "    } catch (NullPointerException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToArray_withConversion() {\n", "    short[] array = {(short) 0, (short) 1, (short) 2};\n", "\n", "    List<Byte> bytes = Arrays.asList((byte) 0, (byte) 1, (byte) 2);\n", "    List<Short> shorts = Arrays.asList((short) 0, (short) 1, (short) 2);\n", "    List<Integer> ints = Arrays.asList(0, 1, 2);\n", "    List<Float> floats = Arrays.asList((float) 0, (float) 1, (float) 2);\n", "    List<Long> longs = Arrays.asList((long) 0, (long) 1, (long) 2);\n", "    List<Double> doubles = Arrays.asList((double) 0, (double) 1, (double) 2);\n", "\n", "    assertTrue(Arrays.equals(array, Shorts.toArray(bytes)));\n", "    assertTrue(Arrays.equals(array, Shorts.toArray(shorts)));\n", "    assertTrue(Arrays.equals(array, Shorts.toArray(ints)));\n", "    assertTrue(Arrays.equals(array, Shorts.toArray(floats)));\n", "    assertTrue(Arrays.equals(array, Shorts.toArray(longs)));\n", "    assertTrue(Arrays.equals(array, Shorts.toArray(doubles)));\n", "  }\n", "\n", "  public void testAsList_isAView() {\n", "    short[] array = {(short) 0, (short) 1};\n", "    List<Short> list = Shorts.asList(array);\n", "    list.set(0, (short) 2);\n", "    assertTrue(Arrays.equals(new short[] {(short) 2, (short) 1}, array));\n", "    array[1] = (short) 3;\n", "    assertEquals(Arrays.asList((short) 2, (short) 3), list);\n", "  }\n", "\n", "  public void testAsList_toArray_roundTrip() {\n", "    short[] array = { (short) 0, (short) 1, (short) 2 };\n", "    List<Short> list = Shorts.asList(array);\n", "    short[] newArray = Shorts.toArray(list);\n", "\n", "    // Make sure it returned a copy\n", "    list.set(0, (short) 4);\n", "    assertTrue(Arrays.equals(\n", "        new short[] { (short) 0, (short) 1, (short) 2 }, newArray));\n", "    newArray[1] = (short) 5;\n", "    assertEquals((short) 1, (short) list.get(1));\n", "  }\n", "\n", "  // This test stems from a real bug found by andrewk\n", "  public void testAsList_subList_toArray_roundTrip() {\n", "    short[] array = { (short) 0, (short) 1, (short) 2, (short) 3 };\n", "    List<Short> list = Shorts.asList(array);\n", "    assertTrue(Arrays.equals(new short[] { (short) 1, (short) 2 },\n", "        Shorts.toArray(list.subList(1, 3))));\n", "    assertTrue(Arrays.equals(new short[] {},\n", "        Shorts.toArray(list.subList(2, 2))));\n", "  }\n", "\n", "  public void testAsListEmpty() {\n", "    assertSame(Collections.emptyList(), Shorts.asList(EMPTY));\n", "  }\n", "\n", "  public void testStringConverter_convert() {\n", "    Converter<String, Short> converter = Shorts.stringConverter();\n", "    assertEquals((Short) (short) 1, converter.convert(\"1\"));\n", "    assertEquals((Short) (short) 0, converter.convert(\"0\"));\n", "    assertEquals((Short) (short) (-1), converter.convert(\"-1\"));\n", "    assertEquals((Short) (short) 255, converter.convert(\"0xff\"));\n", "    assertEquals((Short) (short) 255, converter.convert(\"0xFF\"));\n", "    assertEquals((Short) (short) (-255), converter.convert(\"-0xFF\"));\n", "    assertEquals((Short) (short) 255, converter.convert(\"#0000FF\"));\n", "    assertEquals((Short) (short) 438, converter.convert(\"0666\"));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testStringConverter_convertError() {\n", "    try {\n", "      Shorts.stringConverter().convert(\"notanumber\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testStringConverter_nullConversions() {\n", "    assertNull(Shorts.stringConverter().convert(null));\n", "    assertNull(Shorts.stringConverter().reverse().convert(null));\n", "  }\n", "\n", "  public void testStringConverter_reverse() {\n", "    Converter<String, Short> converter = Shorts.stringConverter();\n", "    assertEquals(\"1\", converter.reverse().convert((short) 1));\n", "    assertEquals(\"0\", converter.reverse().convert((short) 0));\n", "    assertEquals(\"-1\", converter.reverse().convert((short) -1));\n", "    assertEquals(\"255\", converter.reverse().convert((short) 0xff));\n", "    assertEquals(\"255\", converter.reverse().convert((short) 0xFF));\n", "    assertEquals(\"-255\", converter.reverse().convert((short) -0xFF));\n", "    assertEquals(\"438\", converter.reverse().convert((short) 0666));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408]}}, {"189": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/SignedBytesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Unit test for {@link SignedBytes}.\n", " *\n", " * @author Kevin Bourrillion\n", " */\n", "@GwtCompatible(emulated = true)\n", "@SuppressWarnings(\"cast\") // redundant casts are intentional and harmless\n", "public class SignedBytesTest extends TestCase {\n", "  private static final byte[] EMPTY = {};\n", "  private static final byte[] ARRAY1 = {(byte) 1};\n", "\n", "  private static final byte LEAST = Byte.MIN_VALUE;\n", "  private static final byte GREATEST = Byte.MAX_VALUE;\n", "\n", "  private static final byte[] VALUES =\n", "      {LEAST, -1, 0, 1, GREATEST};\n", "\n", "  public void testCheckedCast() {\n", "    for (byte value : VALUES) {\n", "      assertEquals(value, SignedBytes.checkedCast((long) value));\n", "    }\n", "    assertCastFails(GREATEST + 1L);\n", "    assertCastFails(LEAST - 1L);\n", "    assertCastFails(Long.MAX_VALUE);\n", "    assertCastFails(Long.MIN_VALUE);\n", "  }\n", "\n", "  public void testSaturatedCast() {\n", "    for (byte value : VALUES) {\n", "      assertEquals(value, SignedBytes.saturatedCast((long) value));\n", "    }\n", "    assertEquals(GREATEST, SignedBytes.saturatedCast(GREATEST + 1L));\n", "    assertEquals(LEAST, SignedBytes.saturatedCast(LEAST - 1L));\n", "    assertEquals(GREATEST, SignedBytes.saturatedCast(Long.MAX_VALUE));\n", "    assertEquals(LEAST, SignedBytes.saturatedCast(Long.MIN_VALUE));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  private static void assertCastFails(long value) {\n", "    try {\n", "      SignedBytes.checkedCast(value);\n", "      fail(\"Cast to byte should have failed: \" + value);\n", "    } catch (IllegalArgumentException ex) {\n", "      assertTrue(value + \" not found in exception text: \" + ex.getMessage(),\n", "          ex.getMessage().contains(String.valueOf(value)));\n", "    }\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (byte x : VALUES) {\n", "      for (byte y : VALUES) {\n", "        // Only compare the sign of the result of compareTo().\n", "        int expected = Byte.valueOf(x).compareTo(y);\n", "        int actual = SignedBytes.compare(x, y);\n", "        if (expected == 0) {\n", "          assertEquals(x + \", \" + y, expected, actual);\n", "        } else if (expected < 0) {\n", "          assertTrue(x + \", \" + y + \" (expected: \" + expected + \", actual\" + actual + \")\",\n", "              actual < 0);\n", "        } else {\n", "          assertTrue(x + \", \" + y + \" (expected: \" + expected + \", actual\" + actual + \")\",\n", "              actual > 0);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      SignedBytes.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMax() {\n", "    assertEquals(LEAST, SignedBytes.max(LEAST));\n", "    assertEquals(GREATEST, SignedBytes.max(GREATEST));\n", "    assertEquals((byte) 127, SignedBytes.max(\n", "        (byte) 0, (byte) -128, (byte) -1, (byte) 127, (byte) 1));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      SignedBytes.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMin() {\n", "    assertEquals(LEAST, SignedBytes.min(LEAST));\n", "    assertEquals(GREATEST, SignedBytes.min(GREATEST));\n", "    assertEquals((byte) -128, SignedBytes.min(\n", "        (byte) 0, (byte) -128, (byte) -1, (byte) 127, (byte) 1));\n", "  }\n", "\n", "  public void testJoin() {\n", "    assertEquals(\"\", SignedBytes.join(\",\", EMPTY));\n", "    assertEquals(\"1\", SignedBytes.join(\",\", ARRAY1));\n", "    assertEquals(\"1,2\", SignedBytes.join(\",\", (byte) 1, (byte) 2));\n", "    assertEquals(\"123\", SignedBytes.join(\"\", (byte) 1, (byte) 2, (byte) 3));\n", "    assertEquals(\"-128,-1\", SignedBytes.join(\",\", (byte) -128, (byte) -1));\n", "  }\n", "\n", "  public void testLexicographicalComparator() {\n", "    List<byte[]> ordered = Arrays.asList(\n", "        new byte[] {},\n", "        new byte[] {LEAST},\n", "        new byte[] {LEAST, LEAST},\n", "        new byte[] {LEAST, (byte) 1},\n", "        new byte[] {(byte) 1},\n", "        new byte[] {(byte) 1, LEAST},\n", "        new byte[] {GREATEST, GREATEST - (byte) 1},\n", "        new byte[] {GREATEST, GREATEST},\n", "        new byte[] {GREATEST, GREATEST, GREATEST});\n", "\n", "    Comparator<byte[]> comparator = SignedBytes.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151]}}, {"190": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/UnsignedIntsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the\n", " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n", " * express or implied. See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Arrays;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Tests for UnsignedInts\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class UnsignedIntsTest extends TestCase {\n", "  private static final long[] UNSIGNED_INTS = {\n", "      0L,\n", "      1L,\n", "      2L,\n", "      3L,\n", "      0x12345678L,\n", "      0x5a4316b8L,\n", "      0x6cf78a4bL,\n", "      0xff1a618bL,\n", "      0xfffffffdL,\n", "      0xfffffffeL,\n", "      0xffffffffL};\n", "\n", "  private static final int LEAST = (int) 0L;\n", "  private static final int GREATEST = (int) 0xffffffffL;\n", "\n", "  public void testToLong() {\n", "    for (long a : UNSIGNED_INTS) {\n", "      assertEquals(a, UnsignedInts.toLong((int) a));\n", "    }\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (long a : UNSIGNED_INTS) {\n", "      for (long b : UNSIGNED_INTS) {\n", "        int cmpAsLongs = Longs.compare(a, b);\n", "        int cmpAsUInt = UnsignedInts.compare((int) a, (int) b);\n", "        assertEquals(Integer.signum(cmpAsLongs), Integer.signum(cmpAsUInt));\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      UnsignedInts.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "\n", "  public void testMax() {\n", "    assertEquals(LEAST, UnsignedInts.max(LEAST));\n", "    assertEquals(GREATEST, UnsignedInts.max(GREATEST));\n", "    assertEquals((int) 0xff1a618bL, UnsignedInts.max(\n", "        (int) 8L, (int) 6L, (int) 7L,\n", "        (int) 0x12345678L, (int) 0x5a4316b8L,\n", "        (int) 0xff1a618bL, (int) 0L));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      UnsignedInts.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "  \n", "  public void testMin() {\n", "    assertEquals(LEAST, UnsignedInts.min(LEAST));\n", "    assertEquals(GREATEST, UnsignedInts.min(GREATEST));\n", "    assertEquals((int) 0L, UnsignedInts.min(\n", "        (int) 8L, (int) 6L, (int) 7L,\n", "        (int) 0x12345678L, (int) 0x5a4316b8L,\n", "        (int) 0xff1a618bL, (int) 0L));\n", "  }\n", "  \n", "  public void testLexicographicalComparator() {\n", "    List<int[]> ordered = Arrays.asList(\n", "        new int[] {},\n", "        new int[] {LEAST},\n", "        new int[] {LEAST, LEAST},\n", "        new int[] {LEAST, (int) 1L},\n", "        new int[] {(int) 1L},\n", "        new int[] {(int) 1L, LEAST},\n", "        new int[] {GREATEST, (GREATEST - (int) 1L)},\n", "        new int[] {GREATEST, GREATEST},\n", "        new int[] {GREATEST, GREATEST, GREATEST}\n", "        );\n", "\n", "    Comparator<int[]> comparator = UnsignedInts.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testDivide() {\n", "    for (long a : UNSIGNED_INTS) {\n", "      for (long b : UNSIGNED_INTS) {\n", "        try {\n", "          assertEquals((int) (a / b), UnsignedInts.divide((int) a, (int) b));\n", "          assertFalse(b == 0);\n", "        } catch (ArithmeticException e) {\n", "          assertEquals(0, b);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testRemainder() {\n", "    for (long a : UNSIGNED_INTS) {\n", "      for (long b : UNSIGNED_INTS) {\n", "        try {\n", "          assertEquals((int) (a % b), UnsignedInts.remainder((int) a, (int) b));\n", "          assertFalse(b == 0);\n", "        } catch (ArithmeticException e) {\n", "          assertEquals(0, b);\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testParseInt() {\n", "    for (long a : UNSIGNED_INTS) {\n", "      assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a)));\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testParseIntFail() {\n", "    try {\n", "      UnsignedInts.parseUnsignedInt(Long.toString(1L << 32));\n", "      fail(\"Expected NumberFormatException\");\n", "    } catch (NumberFormatException expected) {}\n", "  }\n", "\n", "  public void testParseIntWithRadix() {\n", "    for (long a : UNSIGNED_INTS) {\n", "      for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {\n", "        assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a, radix), radix));\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testParseIntWithRadixLimits() {\n", "    // loops through all legal radix values.\n", "    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {\n", "      // tests can successfully parse a number string with this radix.\n", "      String maxAsString = Long.toString((1L << 32) - 1, radix);\n", "      assertEquals(-1, UnsignedInts.parseUnsignedInt(maxAsString, radix));\n", "\n", "      try {\n", "        // tests that we get exception whre an overflow would occur.\n", "        long overflow = 1L << 32;\n", "        String overflowAsString = Long.toString(overflow, radix);\n", "        UnsignedInts.parseUnsignedInt(overflowAsString, radix);\n", "        fail();\n", "      } catch (NumberFormatException expected) {}\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testParseIntThrowsExceptionForInvalidRadix() {\n", "    // Valid radix values are Character.MIN_RADIX to Character.MAX_RADIX,\n", "    // inclusive.\n", "    try {\n", "      UnsignedInts.parseUnsignedInt(\"0\", Character.MIN_RADIX - 1);\n", "      fail();\n", "    } catch (NumberFormatException expected) {}\n", "\n", "    try {\n", "      UnsignedInts.parseUnsignedInt(\"0\", Character.MAX_RADIX + 1);\n", "      fail();\n", "    } catch (NumberFormatException expected) {}\n", "\n", "    // The radix is used as an array index, so try a negative value.\n", "    try {\n", "      UnsignedInts.parseUnsignedInt(\"0\", -1);\n", "      fail();\n", "    } catch (NumberFormatException expected) {}\n", "  }\n", "\n", "  public void testDecodeInt() {\n", "    assertEquals(0xffffffff, UnsignedInts.decode(\"0xffffffff\"));\n", "    assertEquals(01234567, UnsignedInts.decode(\"01234567\")); // octal\n", "    assertEquals(0x12345678, UnsignedInts.decode(\"#12345678\"));\n", "    assertEquals(76543210, UnsignedInts.decode(\"76543210\"));\n", "    assertEquals(0x13579135, UnsignedInts.decode(\"0x13579135\"));\n", "    assertEquals(0x13579135, UnsignedInts.decode(\"0X13579135\"));\n", "    assertEquals(0, UnsignedInts.decode(\"0\"));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testDecodeIntFails() {\n", "    try {\n", "      // One more than maximum value\n", "      UnsignedInts.decode(\"0xfffffffff\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "\n", "    try {\n", "      UnsignedInts.decode(\"-5\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "\n", "    try {\n", "      UnsignedInts.decode(\"-0x5\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "\n", "    try {\n", "      UnsignedInts.decode(\"-05\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToString() {\n", "    int[] bases = {2, 5, 7, 8, 10, 16};\n", "    for (long a : UNSIGNED_INTS) {\n", "      for (int base : bases) {\n", "        assertEquals(UnsignedInts.toString((int) a, base), Long.toString(a, base));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testJoin() {\n", "    assertEquals(\"\", join());\n", "    assertEquals(\"1\", join(1));\n", "    assertEquals(\"1,2\", join(1, 2));\n", "    assertEquals(\"4294967295,2147483648\", join(-1, Integer.MIN_VALUE));\n", "\n", "    assertEquals(\"123\", UnsignedInts.join(\"\", 1, 2, 3));\n", "  }\n", "\n", "  private static String join(int... values) {\n", "    return UnsignedInts.join(\",\", values);\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265]}}, {"191": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/UnsignedLongTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the\n", " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n", " * express or implied. See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableSet;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.math.BigInteger;\n", "\n", "/**\n", " * Tests for {@code UnsignedLong}.\n", " *\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class UnsignedLongTest extends TestCase {\n", "  private static final ImmutableSet<Long> TEST_LONGS;\n", "  private static final ImmutableSet<BigInteger> TEST_BIG_INTEGERS;\n", "\n", "  static {\n", "    ImmutableSet.Builder<Long> testLongsBuilder = ImmutableSet.builder();\n", "    ImmutableSet.Builder<BigInteger> testBigIntegersBuilder = ImmutableSet.builder();\n", "    for (long i = -3; i <= 3; i++) {\n", "      testLongsBuilder\n", "          .add(i)\n", "          .add(Long.MAX_VALUE + i)\n", "          .add(Long.MIN_VALUE + i)\n", "          .add(Integer.MIN_VALUE + i)\n", "          .add(Integer.MAX_VALUE + i);\n", "      BigInteger bigI = BigInteger.valueOf(i);\n", "      testBigIntegersBuilder\n", "          .add(bigI)\n", "          .add(BigInteger.valueOf(Long.MAX_VALUE).add(bigI))\n", "          .add(BigInteger.valueOf(Long.MIN_VALUE).add(bigI))\n", "          .add(BigInteger.valueOf(Integer.MAX_VALUE).add(bigI))\n", "          .add(BigInteger.valueOf(Integer.MIN_VALUE).add(bigI))\n", "          .add(BigInteger.ONE.shiftLeft(63).add(bigI))\n", "          .add(BigInteger.ONE.shiftLeft(64).add(bigI));\n", "    }\n", "    TEST_LONGS = testLongsBuilder.build();\n", "    TEST_BIG_INTEGERS = testBigIntegersBuilder.build();\n", "  }\n", "\n", "  public void testAsUnsignedAndLongValueAreInverses() {\n", "    for (long value : TEST_LONGS) {\n", "      assertEquals(\n", "          UnsignedLongs.toString(value), value, UnsignedLong.fromLongBits(value).longValue());\n", "    }\n", "  }\n", "\n", "  public void testAsUnsignedBigIntegerValue() {\n", "    for (long value : TEST_LONGS) {\n", "      BigInteger expected = (value >= 0)\n", "          ? BigInteger.valueOf(value)\n", "          : BigInteger.valueOf(value).add(BigInteger.ZERO.setBit(64));\n", "      assertEquals(UnsignedLongs.toString(value), expected,\n", "          UnsignedLong.fromLongBits(value).bigIntegerValue());\n", "    }\n", "  }\n", "  \n", "  public void testValueOfLong() {\n", "    for (long value : TEST_LONGS) {\n", "      boolean expectSuccess = value >= 0;\n", "      try {\n", "        assertEquals(value, UnsignedLong.valueOf(value).longValue());\n", "        assertTrue(expectSuccess);\n", "      } catch (IllegalArgumentException e) {\n", "        assertFalse(expectSuccess);\n", "      }\n", "    }\n", "  }\n", "  \n", "  public void testValueOfBigInteger() {\n", "    BigInteger min = BigInteger.ZERO;\n", "    BigInteger max = UnsignedLong.MAX_VALUE.bigIntegerValue();\n", "    for (BigInteger big : TEST_BIG_INTEGERS) {\n", "      boolean expectSuccess =\n", "          big.compareTo(min) >= 0 && big.compareTo(max) <= 0;\n", "      try {\n", "        assertEquals(big, UnsignedLong.valueOf(big).bigIntegerValue());\n", "        assertTrue(expectSuccess);\n", "      } catch (IllegalArgumentException e) {\n", "        assertFalse(expectSuccess);\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testToString() {\n", "    for (long value : TEST_LONGS) {\n", "      UnsignedLong unsignedValue = UnsignedLong.fromLongBits(value);\n", "      assertEquals(unsignedValue.bigIntegerValue().toString(), unsignedValue.toString());\n", "    }\n", "  }\n", "\n", "  public void testToStringRadixQuick() {\n", "    int[] radices = {2, 3, 5, 7, 10, 12, 16, 21, 31, 36};\n", "    for (int radix : radices) {\n", "      for (long l : TEST_LONGS) {\n", "        UnsignedLong value = UnsignedLong.fromLongBits(l);\n", "        assertEquals(value.bigIntegerValue().toString(radix), value.toString(radix));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testFloatValue() {\n", "    for (long value : TEST_LONGS) {\n", "      UnsignedLong unsignedValue = UnsignedLong.fromLongBits(value);\n", "      assertEquals(unsignedValue.bigIntegerValue().floatValue(), unsignedValue.floatValue());\n", "    }\n", "  }\n", "\n", "  public void testDoubleValue() {\n", "    for (long value : TEST_LONGS) {\n", "      UnsignedLong unsignedValue = UnsignedLong.fromLongBits(value);\n", "      assertEquals(unsignedValue.bigIntegerValue().doubleValue(), unsignedValue.doubleValue());\n", "    }\n", "  }\n", "\n", "  public void testPlus() {\n", "    for (long a : TEST_LONGS) {\n", "      for (long b : TEST_LONGS) {\n", "        UnsignedLong aUnsigned = UnsignedLong.fromLongBits(a);\n", "        UnsignedLong bUnsigned = UnsignedLong.fromLongBits(b);\n", "        long expected = aUnsigned\n", "            .bigIntegerValue()\n", "            .add(bUnsigned.bigIntegerValue())\n", "            .longValue();\n", "        UnsignedLong unsignedSum = aUnsigned.plus(bUnsigned);\n", "        assertEquals(expected, unsignedSum.longValue());\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testMinus() {\n", "    for (long a : TEST_LONGS) {\n", "      for (long b : TEST_LONGS) {\n", "        UnsignedLong aUnsigned = UnsignedLong.fromLongBits(a);\n", "        UnsignedLong bUnsigned = UnsignedLong.fromLongBits(b);\n", "        long expected = aUnsigned\n", "            .bigIntegerValue()\n", "            .subtract(bUnsigned.bigIntegerValue())\n", "            .longValue();\n", "        UnsignedLong unsignedSub = aUnsigned.minus(bUnsigned);\n", "        assertEquals(expected, unsignedSub.longValue());\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testTimes() {\n", "    for (long a : TEST_LONGS) {\n", "      for (long b : TEST_LONGS) {\n", "        UnsignedLong aUnsigned = UnsignedLong.fromLongBits(a);\n", "        UnsignedLong bUnsigned = UnsignedLong.fromLongBits(b);\n", "        long expected = aUnsigned\n", "            .bigIntegerValue()\n", "            .multiply(bUnsigned.bigIntegerValue())\n", "            .longValue();\n", "        UnsignedLong unsignedMul = aUnsigned.times(bUnsigned);\n", "        assertEquals(expected, unsignedMul.longValue());\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testDividedBy() {\n", "    for (long a : TEST_LONGS) {\n", "      for (long b : TEST_LONGS) {\n", "        if (b != 0) {\n", "          UnsignedLong aUnsigned = UnsignedLong.fromLongBits(a);\n", "          UnsignedLong bUnsigned = UnsignedLong.fromLongBits(b);\n", "          long expected = aUnsigned\n", "              .bigIntegerValue()\n", "              .divide(bUnsigned.bigIntegerValue())\n", "              .longValue();\n", "          UnsignedLong unsignedDiv = aUnsigned.dividedBy(bUnsigned);\n", "          assertEquals(expected, unsignedDiv.longValue());\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"ReturnValueIgnored\")\n", "  public void testDivideByZeroThrows() {\n", "    for (long a : TEST_LONGS) {\n", "      try {\n", "        UnsignedLong.fromLongBits(a).dividedBy(UnsignedLong.ZERO);\n", "        fail(\"Expected ArithmeticException\");\n", "      } catch (ArithmeticException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testMod() {\n", "    for (long a : TEST_LONGS) {\n", "      for (long b : TEST_LONGS) {\n", "        if (b != 0) {\n", "          UnsignedLong aUnsigned = UnsignedLong.fromLongBits(a);\n", "          UnsignedLong bUnsigned = UnsignedLong.fromLongBits(b);\n", "          long expected = aUnsigned\n", "              .bigIntegerValue()\n", "              .remainder(bUnsigned.bigIntegerValue())\n", "              .longValue();\n", "          UnsignedLong unsignedRem = aUnsigned.mod(bUnsigned);\n", "          assertEquals(expected, unsignedRem.longValue());\n", "        }\n", "      }\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testModByZero() {\n", "    for (long a : TEST_LONGS) {\n", "      try {\n", "        UnsignedLong.fromLongBits(a).mod(UnsignedLong.ZERO);\n", "        fail(\"Expected ArithmeticException\");\n", "      } catch (ArithmeticException expected) {}\n", "    }\n", "  }\n", "\n", "  public void testCompare() {\n", "    for (long a : TEST_LONGS) {\n", "      for (long b : TEST_LONGS) {\n", "        UnsignedLong aUnsigned = UnsignedLong.fromLongBits(a);\n", "        UnsignedLong bUnsigned = UnsignedLong.fromLongBits(b);\n", "        assertEquals(aUnsigned.bigIntegerValue().compareTo(bUnsigned.bigIntegerValue()),\n", "            aUnsigned.compareTo(bUnsigned));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testIntValue() {\n", "    for (long a : TEST_LONGS) {\n", "      UnsignedLong aUnsigned = UnsignedLong.fromLongBits(a);\n", "      int intValue = aUnsigned.bigIntegerValue().intValue();\n", "      assertEquals(intValue, aUnsigned.intValue());\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251]}}, {"192": "guava-gwt/test-super/com/google/common/primitives/super/com/google/common/primitives/UnsignedLongsTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n", " * in compliance with the License. You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software distributed under the\n", " * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n", " * express or implied. See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.primitives;\n", "\n", "import static java.math.BigInteger.ONE;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.testing.Helpers;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.math.BigInteger;\n", "import java.util.Arrays;\n", "import java.util.Comparator;\n", "import java.util.List;\n", "\n", "/**\n", " * Tests for UnsignedLongs\n", " *\n", " * @author Brian Milch\n", " * @author Louis Wasserman\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class UnsignedLongsTest extends TestCase {\n", "  private static final long LEAST = 0L;\n", "  private static final long GREATEST = 0xffffffffffffffffL;\n", "  \n", "  public void testCompare() {\n", "    // max value\n", "    assertTrue(UnsignedLongs.compare(0, 0xffffffffffffffffL) < 0);\n", "    assertTrue(UnsignedLongs.compare(0xffffffffffffffffL, 0) > 0);\n", "\n", "    // both with high bit set\n", "    assertTrue(UnsignedLongs.compare(0xff1a618b7f65ea12L, 0xffffffffffffffffL) < 0);\n", "    assertTrue(UnsignedLongs.compare(0xffffffffffffffffL, 0xff1a618b7f65ea12L) > 0);\n", "\n", "    // one with high bit set\n", "    assertTrue(UnsignedLongs.compare(0x5a4316b8c153ac4dL, 0xff1a618b7f65ea12L) < 0);\n", "    assertTrue(UnsignedLongs.compare(0xff1a618b7f65ea12L, 0x5a4316b8c153ac4dL) > 0);\n", "\n", "    // neither with high bit set\n", "    assertTrue(UnsignedLongs.compare(0x5a4316b8c153ac4dL, 0x6cf78a4b139a4e2aL) < 0);\n", "    assertTrue(UnsignedLongs.compare(0x6cf78a4b139a4e2aL, 0x5a4316b8c153ac4dL) > 0);\n", "\n", "    // same value\n", "    assertTrue(UnsignedLongs.compare(0xff1a618b7f65ea12L, 0xff1a618b7f65ea12L) == 0);\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMax_noArgs() {\n", "    try {\n", "      UnsignedLongs.max();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "  \n", "  public void testMax() {\n", "    assertEquals(LEAST, UnsignedLongs.max(LEAST));\n", "    assertEquals(GREATEST, UnsignedLongs.max(GREATEST));\n", "    assertEquals(0xff1a618b7f65ea12L, UnsignedLongs.max(\n", "        0x5a4316b8c153ac4dL, 8L, 100L,\n", "        0L, 0x6cf78a4b139a4e2aL, 0xff1a618b7f65ea12L));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testMin_noArgs() {\n", "    try {\n", "      UnsignedLongs.min();\n", "      fail();\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "  \n", "  public void testMin() {\n", "    assertEquals(LEAST, UnsignedLongs.min(LEAST));\n", "    assertEquals(GREATEST, UnsignedLongs.min(GREATEST));\n", "    assertEquals(0L, UnsignedLongs.min(\n", "        0x5a4316b8c153ac4dL, 8L, 100L,\n", "        0L, 0x6cf78a4b139a4e2aL, 0xff1a618b7f65ea12L));\n", "  }\n", "  \n", "  public void testLexicographicalComparator() {\n", "    List<long[]> ordered = Arrays.asList(\n", "        new long[] {},\n", "        new long[] {LEAST},\n", "        new long[] {LEAST, LEAST},\n", "        new long[] {LEAST, (long) 1},\n", "        new long[] {(long) 1},\n", "        new long[] {(long) 1, LEAST},\n", "        new long[] {GREATEST, GREATEST - (long) 1},\n", "        new long[] {GREATEST, GREATEST},\n", "        new long[] {GREATEST, GREATEST, GREATEST});\n", "    \n", "    Comparator<long[]> comparator = UnsignedLongs.lexicographicalComparator();\n", "    Helpers.testComparator(comparator, ordered);\n", "  }\n", "\n", "  public void testDivide() {\n", "    assertEquals(2, UnsignedLongs.divide(14, 5));\n", "    assertEquals(0, UnsignedLongs.divide(0, 50));\n", "    assertEquals(1, UnsignedLongs.divide(0xfffffffffffffffeL, 0xfffffffffffffffdL));\n", "    assertEquals(0, UnsignedLongs.divide(0xfffffffffffffffdL, 0xfffffffffffffffeL));\n", "    assertEquals(281479271743488L, UnsignedLongs.divide(0xfffffffffffffffeL, 65535));\n", "    assertEquals(0x7fffffffffffffffL, UnsignedLongs.divide(0xfffffffffffffffeL, 2));\n", "    assertEquals(3689348814741910322L, UnsignedLongs.divide(0xfffffffffffffffeL, 5));\n", "  }\n", "\n", "  public void testRemainder() {\n", "    assertEquals(4, UnsignedLongs.remainder(14, 5));\n", "    assertEquals(0, UnsignedLongs.remainder(0, 50));\n", "    assertEquals(1, UnsignedLongs.remainder(0xfffffffffffffffeL, 0xfffffffffffffffdL));\n", "    assertEquals(0xfffffffffffffffdL,\n", "        UnsignedLongs.remainder(0xfffffffffffffffdL, 0xfffffffffffffffeL));\n", "    assertEquals(65534L, UnsignedLongs.remainder(0xfffffffffffffffeL, 65535));\n", "    assertEquals(0, UnsignedLongs.remainder(0xfffffffffffffffeL, 2));\n", "    assertEquals(4, UnsignedLongs.remainder(0xfffffffffffffffeL, 5));\n", "  }\n", "\n", "  public void testParseLong() {\n", "    assertEquals(0xffffffffffffffffL, UnsignedLongs.parseUnsignedLong(\"18446744073709551615\"));\n", "    assertEquals(0x7fffffffffffffffL, UnsignedLongs.parseUnsignedLong(\"9223372036854775807\"));\n", "    assertEquals(0xff1a618b7f65ea12L, UnsignedLongs.parseUnsignedLong(\"18382112080831834642\"));\n", "    assertEquals(0x5a4316b8c153ac4dL, UnsignedLongs.parseUnsignedLong(\"6504067269626408013\"));\n", "    assertEquals(0x6cf78a4b139a4e2aL, UnsignedLongs.parseUnsignedLong(\"7851896530399809066\"));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testParseLongFails() {\n", "    try {\n", "      // One more than maximum value\n", "      UnsignedLongs.parseUnsignedLong(\"18446744073709551616\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testDecodeLong() {\n", "    assertEquals(0xffffffffffffffffL, UnsignedLongs.decode(\"0xffffffffffffffff\"));\n", "    assertEquals(01234567, UnsignedLongs.decode(\"01234567\")); // octal\n", "    assertEquals(0x1234567890abcdefL, UnsignedLongs.decode(\"#1234567890abcdef\"));\n", "    assertEquals(987654321012345678L, UnsignedLongs.decode(\"987654321012345678\"));\n", "    assertEquals(0x135791357913579L, UnsignedLongs.decode(\"0x135791357913579\"));\n", "    assertEquals(0x135791357913579L, UnsignedLongs.decode(\"0X135791357913579\"));\n", "    assertEquals(0L, UnsignedLongs.decode(\"0\"));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testDecodeLongFails() {\n", "    try {\n", "      // One more than maximum value\n", "      UnsignedLongs.decode(\"0xfffffffffffffffff\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "\n", "    try {\n", "      UnsignedLongs.decode(\"-5\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "\n", "    try {\n", "      UnsignedLongs.decode(\"-0x5\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "\n", "    try {\n", "      UnsignedLongs.decode(\"-05\");\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testParseLongWithRadix() {\n", "    assertEquals(0xffffffffffffffffL, UnsignedLongs.parseUnsignedLong(\"ffffffffffffffff\", 16));\n", "    assertEquals(0x1234567890abcdefL, UnsignedLongs.parseUnsignedLong(\"1234567890abcdef\", 16));\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testParseLongWithRadixLimits() {\n", "    BigInteger max = BigInteger.ZERO.setBit(64).subtract(ONE);\n", "    // loops through all legal radix values.\n", "    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {\n", "      // tests can successfully parse a number string with this radix.\n", "      String maxAsString = max.toString(radix);\n", "      assertEquals(max.longValue(), UnsignedLongs.parseUnsignedLong(maxAsString, radix));\n", "\n", "      try {\n", "        // tests that we get exception whre an overflow would occur.\n", "        BigInteger overflow = max.add(ONE);\n", "        String overflowAsString = overflow.toString(radix);\n", "        UnsignedLongs.parseUnsignedLong(overflowAsString, radix);\n", "        fail();\n", "      } catch (NumberFormatException expected) {\n", "      }\n", "    }\n", "\n", "    try {\n", "      UnsignedLongs.parseUnsignedLong(\"1234567890abcdef1\", 16);\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  @SuppressWarnings(\"CheckReturnValue\")\n", "  public void testParseLongThrowsExceptionForInvalidRadix() {\n", "    // Valid radix values are Character.MIN_RADIX to Character.MAX_RADIX, inclusive.\n", "    try {\n", "      UnsignedLongs.parseUnsignedLong(\"0\", Character.MIN_RADIX - 1);\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "\n", "    try {\n", "      UnsignedLongs.parseUnsignedLong(\"0\", Character.MAX_RADIX + 1);\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "\n", "    // The radix is used as an array index, so try a negative value.\n", "    try {\n", "      UnsignedLongs.parseUnsignedLong(\"0\", -1);\n", "      fail();\n", "    } catch (NumberFormatException expected) {\n", "    }\n", "  }\n", "\n", "  public void testToString() {\n", "    String[] tests = {\n", "        \"ffffffffffffffff\",\n", "        \"7fffffffffffffff\",\n", "        \"ff1a618b7f65ea12\",\n", "        \"5a4316b8c153ac4d\",\n", "        \"6cf78a4b139a4e2a\"\n", "    };\n", "    int[] bases = { 2, 5, 7, 8, 10, 16 };\n", "    for (int base : bases) {\n", "      for (String x : tests) {\n", "        BigInteger xValue = new BigInteger(x, 16);\n", "        long xLong = xValue.longValue(); // signed\n", "        assertEquals(xValue.toString(base), UnsignedLongs.toString(xLong, base));\n", "      }\n", "    }\n", "  }\n", "\n", "  public void testJoin() {\n", "    assertEquals(\"\", UnsignedLongs.join(\",\"));\n", "    assertEquals(\"1\", UnsignedLongs.join(\",\", 1));\n", "    assertEquals(\"1,2\", UnsignedLongs.join(\",\", 1, 2));\n", "    assertEquals(\"18446744073709551615,9223372036854775808\",\n", "        UnsignedLongs.join(\",\", -1, Long.MIN_VALUE));\n", "    assertEquals(\"123\", UnsignedLongs.join(\"\", 1, 2, 3));\n", "    assertEquals(\"184467440737095516159223372036854775808\",\n", "        UnsignedLongs.join(\"\", -1, Long.MIN_VALUE));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271]}}, {"193": "guava-gwt/test-super/com/google/common/testing/super/com/google/common/testing/FakeTickerTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.testing;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.EnumSet;\n", "import java.util.concurrent.TimeUnit;\n", "\n", "/**\n", " * Unit test for {@link FakeTicker}.\n", " *\n", " * @author Jige Yu\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class FakeTickerTest extends TestCase {\n", "\n", "  public void testAdvance() {\n", "    FakeTicker ticker = new FakeTicker();\n", "    assertEquals(0, ticker.read());\n", "    assertSame(ticker, ticker.advance(10));\n", "    assertEquals(10, ticker.read());\n", "    ticker.advance(1, TimeUnit.MILLISECONDS);\n", "    assertEquals(1000010L, ticker.read());\n", "  }\n", "\n", "  public void testAutoIncrementStep_returnsSameInstance() {\n", "    FakeTicker ticker = new FakeTicker();\n", "    assertSame(ticker, ticker.setAutoIncrementStep(10, TimeUnit.NANOSECONDS));\n", "  }\n", "\n", "  public void testAutoIncrementStep_nanos() {\n", "    FakeTicker ticker = new FakeTicker().setAutoIncrementStep(10, TimeUnit.NANOSECONDS);\n", "    assertEquals(0, ticker.read());\n", "    assertEquals(10, ticker.read());\n", "    assertEquals(20, ticker.read());\n", "  }\n", "\n", "  public void testAutoIncrementStep_millis() {\n", "    FakeTicker ticker = new FakeTicker().setAutoIncrementStep(1, TimeUnit.MILLISECONDS);\n", "    assertEquals(0, ticker.read());\n", "    assertEquals(1000000, ticker.read());\n", "    assertEquals(2000000, ticker.read());\n", "  }\n", "\n", "  public void testAutoIncrementStep_seconds() {\n", "    FakeTicker ticker = new FakeTicker().setAutoIncrementStep(3, TimeUnit.SECONDS);\n", "    assertEquals(0, ticker.read());\n", "    assertEquals(3000000000L, ticker.read());\n", "    assertEquals(6000000000L, ticker.read());\n", "  }\n", "\n", "  public void testAutoIncrementStep_resetToZero() {\n", "    FakeTicker ticker = new FakeTicker().setAutoIncrementStep(10, TimeUnit.NANOSECONDS);\n", "    assertEquals(0, ticker.read());\n", "    assertEquals(10, ticker.read());\n", "    assertEquals(20, ticker.read());\n", "\n", "    for (TimeUnit timeUnit : EnumSet.allOf(TimeUnit.class)) {\n", "      ticker.setAutoIncrementStep(0, timeUnit);\n", "      assertEquals(\n", "          \"Expected no auto-increment when setting autoIncrementStep to 0 \" + timeUnit,\n", "          30, ticker.read());\n", "    }\n", "  }\n", "\n", "  public void testAutoIncrement_negative() {\n", "    FakeTicker ticker = new FakeTicker();\n", "    try {\n", "      ticker.setAutoIncrementStep(-1, TimeUnit.NANOSECONDS);\n", "      fail(\"Expected IllegalArgumentException\");\n", "    } catch (IllegalArgumentException expected) {\n", "    }\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92]}}, {"194": "guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AtomicLongMapTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.collect.ImmutableMap;\n", "import com.google.common.collect.Sets;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.Map;\n", "import java.util.Random;\n", "import java.util.Set;\n", "\n", "/**\n", " * Tests for {@link AtomicLongMap}.\n", " *\n", " * @author mike nonemacher\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class AtomicLongMapTest extends TestCase {\n", "  private static final int ITERATIONS = 100;\n", "  private static final int MAX_ADDEND = 100;\n", "\n", "  private Random random = new Random(301);\n", "\n", "  public void testCreate_map() {\n", "    Map<String, Long> in = ImmutableMap.of(\"1\", 1L, \"2\", 2L, \"3\", 3L);\n", "    AtomicLongMap<String> map = AtomicLongMap.create(in);\n", "    assertFalse(map.isEmpty());\n", "    assertSame(3, map.size());\n", "    assertTrue(map.containsKey(\"1\"));\n", "    assertTrue(map.containsKey(\"2\"));\n", "    assertTrue(map.containsKey(\"3\"));\n", "    assertEquals(1L, map.get(\"1\"));\n", "    assertEquals(2L, map.get(\"2\"));\n", "    assertEquals(3L, map.get(\"3\"));\n", "  }\n", "\n", "  public void testIncrementAndGet() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      long result = map.incrementAndGet(key);\n", "      long after = map.get(key);\n", "      assertEquals(before + 1, after);\n", "      assertEquals(after, result);\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "    assertEquals(ITERATIONS, (int) map.get(key));\n", "  }\n", "\n", "  public void testIncrementAndGet_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(1L, map.incrementAndGet(key));\n", "    assertEquals(1L, map.get(key));\n", "\n", "    assertEquals(0L, map.decrementAndGet(key));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(1L, map.incrementAndGet(key));\n", "    assertEquals(1L, map.get(key));\n", "  }\n", "\n", "  public void testGetAndIncrement() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      long result = map.getAndIncrement(key);\n", "      long after = map.get(key);\n", "      assertEquals(before + 1, after);\n", "      assertEquals(before, result);\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "    assertEquals(ITERATIONS, (int) map.get(key));\n", "  }\n", "\n", "  public void testGetAndIncrement_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.getAndIncrement(key));\n", "    assertEquals(1L, map.get(key));\n", "\n", "    assertEquals(1L, map.getAndDecrement(key));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.getAndIncrement(key));\n", "    assertEquals(1L, map.get(key));\n", "  }\n", "\n", "  public void testDecrementAndGet() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      long result = map.decrementAndGet(key);\n", "      long after = map.get(key);\n", "      assertEquals(before - 1, after);\n", "      assertEquals(after, result);\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "    assertEquals(-1 * ITERATIONS, (int) map.get(key));\n", "  }\n", "\n", "  public void testDecrementAndGet_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(-1L, map.decrementAndGet(key));\n", "    assertEquals(-1L, map.get(key));\n", "\n", "    assertEquals(0L, map.incrementAndGet(key));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(-1L, map.decrementAndGet(key));\n", "    assertEquals(-1L, map.get(key));\n", "  }\n", "\n", "  public void testGetAndDecrement() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      long result = map.getAndDecrement(key);\n", "      long after = map.get(key);\n", "      assertEquals(before - 1, after);\n", "      assertEquals(before, result);\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "    assertEquals(-1 * ITERATIONS, (int) map.get(key));\n", "  }\n", "\n", "  public void testGetAndDecrement_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.getAndDecrement(key));\n", "    assertEquals(-1L, map.get(key));\n", "\n", "    assertEquals(-1L, map.getAndIncrement(key));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.getAndDecrement(key));\n", "    assertEquals(-1L, map.get(key));\n", "  }\n", "\n", "  public void testAddAndGet() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long addend = random.nextInt(MAX_ADDEND);\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      long result = map.addAndGet(key, addend);\n", "      long after = map.get(key);\n", "      assertEquals(before + addend, after);\n", "      assertEquals(after, result);\n", "      addend = after;\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "  }\n", "\n", "  public void testAddAndGet_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long value = random.nextInt(MAX_ADDEND);\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(value, map.addAndGet(key, value));\n", "    assertEquals(value, map.get(key));\n", "\n", "    assertEquals(0L, map.addAndGet(key, -1 * value));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(value, map.addAndGet(key, value));\n", "    assertEquals(value, map.get(key));\n", "  }\n", "\n", "  public void testGetAndAdd() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long addend = random.nextInt(MAX_ADDEND);\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      long result = map.getAndAdd(key, addend);\n", "      long after = map.get(key);\n", "      assertEquals(before + addend, after);\n", "      assertEquals(before, result);\n", "      addend = after;\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "  }\n", "\n", "  public void testGetAndAdd_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long value = random.nextInt(MAX_ADDEND);\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.getAndAdd(key, value));\n", "    assertEquals(value, map.get(key));\n", "\n", "    assertEquals(value, map.getAndAdd(key, -1 * value));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.getAndAdd(key, value));\n", "    assertEquals(value, map.get(key));\n", "  }\n", "\n", "  public void testPut() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long newValue = random.nextInt(MAX_ADDEND);\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      long result = map.put(key, newValue);\n", "      long after = map.get(key);\n", "      assertEquals(newValue, after);\n", "      assertEquals(before, result);\n", "      newValue += newValue;\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "  }\n", "\n", "  public void testPut_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long value = random.nextInt(MAX_ADDEND);\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.put(key, value));\n", "    assertEquals(value, map.get(key));\n", "\n", "    assertEquals(value, map.put(key, 0L));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.put(key, value));\n", "    assertEquals(value, map.get(key));\n", "  }\n", "\n", "  public void testPutAll() {\n", "    Map<String, Long> in = ImmutableMap.of(\"1\", 1L, \"2\", 2L, \"3\", 3L);\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    assertTrue(map.isEmpty());\n", "    assertSame(0, map.size());\n", "    assertFalse(map.containsKey(\"1\"));\n", "    assertFalse(map.containsKey(\"2\"));\n", "    assertFalse(map.containsKey(\"3\"));\n", "    assertEquals(0L, map.get(\"1\"));\n", "    assertEquals(0L, map.get(\"2\"));\n", "    assertEquals(0L, map.get(\"3\"));\n", "\n", "    map.putAll(in);\n", "    assertFalse(map.isEmpty());\n", "    assertSame(3, map.size());\n", "    assertTrue(map.containsKey(\"1\"));\n", "    assertTrue(map.containsKey(\"2\"));\n", "    assertTrue(map.containsKey(\"3\"));\n", "    assertEquals(1L, map.get(\"1\"));\n", "    assertEquals(2L, map.get(\"2\"));\n", "    assertEquals(3L, map.get(\"3\"));\n", "  }\n", "\n", "  public void testPutIfAbsent() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long newValue = random.nextInt(MAX_ADDEND);\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      long result = map.putIfAbsent(key, newValue);\n", "      long after = map.get(key);\n", "      assertEquals(before, result);\n", "      assertEquals(before == 0 ? newValue : before, after);\n", "\n", "      map.remove(key);\n", "      before = map.get(key);\n", "      result = map.putIfAbsent(key, newValue);\n", "      after = map.get(key);\n", "      assertEquals(0, before);\n", "      assertEquals(before, result);\n", "      assertEquals(newValue, after);\n", "\n", "      map.put(key, 0L);\n", "      before = map.get(key);\n", "      result = map.putIfAbsent(key, newValue);\n", "      after = map.get(key);\n", "      assertEquals(0, before);\n", "      assertEquals(before, result);\n", "      assertEquals(newValue, after);\n", "\n", "      newValue += newValue;\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "  }\n", "\n", "  public void testPutIfAbsent_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long value = random.nextInt(MAX_ADDEND);\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.putIfAbsent(key, value));\n", "    assertEquals(value, map.get(key));\n", "\n", "    assertEquals(value, map.put(key, 0L));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.putIfAbsent(key, value));\n", "    assertEquals(value, map.get(key));\n", "  }\n", "\n", "  public void testReplace() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long newValue = random.nextInt(MAX_ADDEND);\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      long before = map.get(key);\n", "      assertFalse(map.replace(key, before + 1, newValue + 1));\n", "      assertFalse(map.replace(key, before - 1, newValue - 1));\n", "      assertTrue(map.replace(key, before, newValue));\n", "      long after = map.get(key);\n", "      assertEquals(newValue, after);\n", "      newValue += newValue;\n", "    }\n", "    assertEquals(1, map.size());\n", "    assertTrue(!map.isEmpty());\n", "    assertTrue(map.containsKey(key));\n", "  }\n", "\n", "  public void testReplace_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    long value = random.nextInt(MAX_ADDEND);\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertTrue(map.replace(key, 0L, value));\n", "    assertEquals(value, map.get(key));\n", "\n", "    assertTrue(map.replace(key, value, 0L));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertTrue(map.replace(key, 0L, value));\n", "    assertEquals(value, map.get(key));\n", "  }\n", "\n", "  public void testRemove() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    assertEquals(0, map.size());\n", "    assertTrue(map.isEmpty());\n", "    assertEquals(0L, map.remove(key));\n", "\n", "    long newValue = random.nextInt(MAX_ADDEND);\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      map.put(key, newValue);\n", "      assertTrue(map.containsKey(key));\n", "\n", "      long before = map.get(key);\n", "      long result = map.remove(key);\n", "      long after = map.get(key);\n", "      assertFalse(map.containsKey(key));\n", "      assertEquals(before, result);\n", "      assertEquals(0L, after);\n", "      newValue += newValue;\n", "    }\n", "    assertEquals(0, map.size());\n", "    assertTrue(map.isEmpty());\n", "  }\n", "\n", "  public void testRemove_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.remove(key));\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.put(key, 0L));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.remove(key));\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "  }\n", "\n", "  public void testRemoveValue() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    assertEquals(0, map.size());\n", "    assertTrue(map.isEmpty());\n", "    assertFalse(map.remove(key, 0L));\n", "\n", "    long newValue = random.nextInt(MAX_ADDEND);\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      map.put(key, newValue);\n", "      assertTrue(map.containsKey(key));\n", "\n", "      long before = map.get(key);\n", "      assertFalse(map.remove(key, newValue + 1));\n", "      assertFalse(map.remove(key, newValue - 1));\n", "      assertTrue(map.remove(key, newValue));\n", "      long after = map.get(key);\n", "      assertFalse(map.containsKey(key));\n", "      assertEquals(0L, after);\n", "      newValue += newValue;\n", "    }\n", "    assertEquals(0, map.size());\n", "    assertTrue(map.isEmpty());\n", "  }\n", "\n", "  public void testRemoveValue_zero() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    String key = \"key\";\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertFalse(map.remove(key, 0L));\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "\n", "    assertEquals(0L, map.put(key, 0L));\n", "    assertEquals(0L, map.get(key));\n", "    assertTrue(map.containsKey(key));\n", "\n", "    assertTrue(map.remove(key, 0L));\n", "    assertEquals(0L, map.get(key));\n", "    assertFalse(map.containsKey(key));\n", "  }\n", "\n", "  public void testRemoveZeros() {\n", "    AtomicLongMap<Object> map = AtomicLongMap.create();\n", "    Set<Object> nonZeroKeys = Sets.newHashSet();\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      Object key = new Object();\n", "      long value = i % 2;\n", "      map.put(key, value);\n", "      if (value != 0L) {\n", "        nonZeroKeys.add(key);\n", "      }\n", "    }\n", "    assertEquals(ITERATIONS, map.size());\n", "    assertTrue(map.asMap().containsValue(0L));\n", "\n", "    map.removeAllZeros();\n", "    assertFalse(map.asMap().containsValue(0L));\n", "    assertEquals(ITERATIONS / 2, map.size());\n", "    assertEquals(nonZeroKeys, map.asMap().keySet());\n", "  }\n", "\n", "  public void testClear() {\n", "    AtomicLongMap<Object> map = AtomicLongMap.create();\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      map.put(new Object(), i);\n", "    }\n", "    assertEquals(ITERATIONS, map.size());\n", "\n", "    map.clear();\n", "    assertEquals(0, map.size());\n", "    assertTrue(map.isEmpty());\n", "  }\n", "\n", "  public void testSum() {\n", "    AtomicLongMap<Object> map = AtomicLongMap.create();\n", "    long sum = 0;\n", "    for (int i = 0; i < ITERATIONS; i++) {\n", "      map.put(new Object(), i);\n", "      sum += i;\n", "    }\n", "    assertEquals(ITERATIONS, map.size());\n", "    assertEquals(sum, map.sum());\n", "  }\n", "\n", "  public void testEmpty() {\n", "    AtomicLongMap<String> map = AtomicLongMap.create();\n", "    assertEquals(0L, map.get(\"a\"));\n", "    assertEquals(0, map.size());\n", "    assertTrue(map.isEmpty());\n", "    assertFalse(map.remove(\"a\", 1L));\n", "    assertFalse(map.remove(\"a\", 0L));\n", "    assertFalse(map.replace(\"a\", 1L, 0L));\n", "  }\n", "}\n", "\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542]}}, {"195": "guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/CallablesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2009 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.concurrent.Callable;\n", "\n", "/**\n", " * Unit tests for {@link Callables}.\n", " *\n", " * @author Isaac Shum\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class CallablesTest extends TestCase {\n", "\n", "  public void testReturning() throws Exception {\n", "    assertNull(Callables.returning(null).call());\n", "\n", "    Object value = new Object();\n", "    Callable<Object> callable = Callables.returning(value);\n", "    assertSame(value, callable.call());\n", "    // Expect the same value on subsequent calls\n", "    assertSame(value, callable.call());\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]}}, {"196": "guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/FutureCallbackTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2011 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.truth.Truth.assertThat;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Preconditions;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.concurrent.CancellationException;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.TimeUnit;\n", "\n", "import javax.annotation.Nullable;\n", "\n", "/**\n", " * Test for {@link FutureCallback}.\n", " *\n", " * @author Anthony Zana\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class FutureCallbackTest extends TestCase {\n", "  public void testSameThreadSuccess() {\n", "    SettableFuture<String> f = SettableFuture.create();\n", "    MockCallback callback = new MockCallback(\"foo\");\n", "    Futures.addCallback(f, callback);\n", "    f.set(\"foo\");\n", "  }\n", "\n", "  public void testExecutorSuccess() {\n", "    CountingSameThreadExecutor ex = new CountingSameThreadExecutor();\n", "    SettableFuture<String> f = SettableFuture.create();\n", "    MockCallback callback = new MockCallback(\"foo\");\n", "    Futures.addCallback(f, callback, ex);\n", "    f.set(\"foo\");\n", "    assertEquals(1, ex.runCount);\n", "  }\n", "\n", "  // Error cases\n", "  public void testSameThreadExecutionException() {\n", "    SettableFuture<String> f = SettableFuture.create();\n", "    Exception e = new IllegalArgumentException(\"foo not found\");\n", "    MockCallback callback = new MockCallback(e);\n", "    Futures.addCallback(f, callback);\n", "    f.setException(e);\n", "  }\n", "\n", "  public void testCancel() {\n", "    SettableFuture<String> f = SettableFuture.create();\n", "    FutureCallback<String> callback =\n", "        new FutureCallback<String>() {\n", "          private boolean called = false;\n", "\n", "          @Override\n", "          public void onSuccess(String result) {\n", "            fail(\"Was not expecting onSuccess() to be called.\");\n", "          }\n", "\n", "          @Override\n", "          public synchronized void onFailure(Throwable t) {\n", "            assertFalse(called);\n", "            assertThat(t).isInstanceOf(CancellationException.class);\n", "            called = true;\n", "          }\n", "        };\n", "    Futures.addCallback(f, callback);\n", "    f.cancel(true);\n", "  }\n", "\n", "  public void testThrowErrorFromGet() {\n", "    Error error = new AssertionError(\"ASSERT!\");\n", "    ListenableFuture<String> f = ThrowingFuture.throwingError(error);\n", "    MockCallback callback = new MockCallback(error);\n", "    Futures.addCallback(f, callback);\n", "  }\n", "\n", "  public void testRuntimeExeceptionFromGet() {\n", "    RuntimeException e = new IllegalArgumentException(\"foo not found\");\n", "    ListenableFuture<String> f = ThrowingFuture.throwingRuntimeException(e);\n", "    MockCallback callback = new MockCallback(e);\n", "    Futures.addCallback(f, callback);\n", "  }\n", "\n", "  public void testWildcardFuture() {\n", "    SettableFuture<String> settable = SettableFuture.create();\n", "    ListenableFuture<?> f = settable;\n", "    FutureCallback<Object> callback = new FutureCallback<Object>() {\n", "      @Override\n", "      public void onSuccess(Object result) {}\n", "\n", "      @Override\n", "      public void onFailure(Throwable t) {}\n", "    };\n", "    Futures.addCallback(f, callback);\n", "  }\n", "\n", "  private class CountingSameThreadExecutor implements Executor {\n", "    int runCount = 0;\n", "    @Override\n", "    public void execute(Runnable command) {\n", "      command.run();\n", "      runCount++;\n", "    }\n", "  }\n", "\n", "  // TODO(user): Move to testing, unify with RuntimeExceptionThrowingFuture\n", "\n", "  /**\n", "   * A {@link Future} implementation which always throws directly from calls to\n", "   * get() (i.e. not wrapped in ExecutionException.\n", "   * For just a normal Future failure, use {@link SettableFuture}).\n", "   *\n", "   * <p>Useful for testing the behavior of Future utilities against odd futures.\n", "   *\n", "   * @author Anthony Zana\n", "   */\n", "  private static class ThrowingFuture<V> implements ListenableFuture<V> {\n", "    private final Error error;\n", "    private final RuntimeException runtime;\n", "\n", "    public static <V> ListenableFuture<V> throwingError(Error error) {\n", "      return new ThrowingFuture<V>(error);\n", "    }\n", "\n", "    public static <V> ListenableFuture<V>\n", "        throwingRuntimeException(RuntimeException e) {\n", "      return new ThrowingFuture<V>(e);\n", "    }\n", "\n", "    private ThrowingFuture(Error error) {\n", "      this.error = Preconditions.checkNotNull(error);\n", "      this.runtime = null;\n", "    }\n", "\n", "    public ThrowingFuture(RuntimeException e) {\n", "      this.runtime = Preconditions.checkNotNull(e);\n", "      this.error = null;\n", "    }\n", "\n", "    @Override\n", "    public boolean cancel(boolean mayInterruptIfRunning) {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean isCancelled() {\n", "      return false;\n", "    }\n", "\n", "    @Override\n", "    public boolean isDone() {\n", "      return true;\n", "    }\n", "\n", "    @Override\n", "    public V get() {\n", "      throwOnGet();\n", "      throw new AssertionError(\"Unreachable\");\n", "    }\n", "\n", "    @Override\n", "    public V get(long timeout, TimeUnit unit) {\n", "      throwOnGet();\n", "      throw new AssertionError(\"Unreachable\");\n", "    }\n", "\n", "    @Override\n", "    public void addListener(Runnable listener, Executor executor) {\n", "      executor.execute(listener);\n", "    }\n", "\n", "    private void throwOnGet() {\n", "      if (error != null) {\n", "        throw error;\n", "      } else {\n", "        throw runtime;\n", "      }\n", "    }\n", "  }\n", "\n", "  private final class MockCallback implements FutureCallback<String> {\n", "    @Nullable private String value = null;\n", "    @Nullable private Throwable failure = null;\n", "    private boolean wasCalled = false;\n", "\n", "    MockCallback(String expectedValue) {\n", "      this.value = expectedValue;\n", "    }\n", "\n", "    public MockCallback(Throwable expectedFailure) {\n", "      this.failure = expectedFailure;\n", "    }\n", "\n", "    @Override\n", "    public synchronized void onSuccess(String result) {\n", "      assertFalse(wasCalled);\n", "      wasCalled = true;\n", "      assertEquals(value, result);\n", "    }\n", "\n", "    @Override\n", "    public synchronized void onFailure(Throwable t) {\n", "      assertFalse(wasCalled);\n", "      wasCalled = true;\n", "      assertEquals(failure, t);\n", "    }\n", "  }\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224]}}, {"197": "guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/FuturesTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2008 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.collect.Iterables.getOnlyElement;\n", "import static com.google.common.truth.Truth.assertThat;\n", "import static com.google.common.util.concurrent.Futures.allAsList;\n", "import static com.google.common.util.concurrent.Futures.immediateFailedFuture;\n", "import static com.google.common.util.concurrent.Futures.immediateFuture;\n", "import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n", "import static com.google.common.util.concurrent.TestPlatform.clearInterrupt;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "import com.google.common.base.Function;\n", "import com.google.common.base.Functions;\n", "import com.google.common.collect.Lists;\n", "import com.google.common.testing.TestLogHandler;\n", "\n", "import junit.framework.AssertionFailedError;\n", "import junit.framework.TestCase;\n", "\n", "import java.io.IOException;\n", "import java.util.List;\n", "import java.util.concurrent.CancellationException;\n", "import java.util.concurrent.CountDownLatch;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.Executor;\n", "import java.util.concurrent.Future;\n", "import java.util.concurrent.RejectedExecutionException;\n", "import java.util.concurrent.TimeUnit;\n", "import java.util.logging.LogRecord;\n", "import java.util.logging.Logger;\n", "\n", "/**\n", " * Unit tests for {@link Futures}.\n", " *\n", " * @author Nishant Thakkar\n", " */\n", "@SuppressWarnings(\"CheckReturnValue\")\n", "@GwtCompatible(emulated = true)\n", "public class FuturesTest extends TestCase {\n", "  private static final Logger aggregateFutureLogger =\n", "      Logger.getLogger(AggregateFuture.class.getName());\n", "  private final TestLogHandler aggregateFutureLogHandler = new TestLogHandler();\n", "\n", "  private static final String DATA1 = \"data\";\n", "  private static final String DATA2 = \"more data\";\n", "  private static final String DATA3 = \"most data\";\n", "\n", "  @Override\n", "  protected void setUp() throws Exception {\n", "    super.setUp();\n", "    aggregateFutureLogger.addHandler(aggregateFutureLogHandler);\n", "  }\n", "\n", "  @Override\n", "  protected void tearDown() throws Exception {\n", "    /*\n", "     * Clear interrupt for future tests.\n", "     *\n", "     * (Ideally we would perform interrupts only in threads that we create, but\n", "     * it's hard to imagine that anything will break in practice.)\n", "     */\n", "    clearInterrupt();\n", "    aggregateFutureLogger.removeHandler(aggregateFutureLogHandler);\n", "    super.tearDown();\n", "  }\n", "\n", "  public void testImmediateFuture() throws Exception {\n", "    ListenableFuture<String> future = Futures.immediateFuture(DATA1);\n", "\n", "    // Verify that the proper object is returned without waiting\n", "    assertSame(DATA1, future.get(0L, TimeUnit.MILLISECONDS));\n", "  }\n", "\n", "  public void testMultipleImmediateFutures() throws Exception {\n", "    ListenableFuture<String> future1 = Futures.immediateFuture(DATA1);\n", "    ListenableFuture<String> future2 = Futures.immediateFuture(DATA2);\n", "\n", "    // Verify that the proper objects are returned without waiting\n", "    assertSame(DATA1, future1.get(0L, TimeUnit.MILLISECONDS));\n", "    assertSame(DATA2, future2.get(0L, TimeUnit.MILLISECONDS));\n", "  }\n", "\n", "  public void testImmediateFailedFuture() throws Exception {\n", "    Exception exception = new Exception();\n", "    ListenableFuture<String> future =\n", "        Futures.immediateFailedFuture(exception);\n", "\n", "    try {\n", "      future.get(0L, TimeUnit.MILLISECONDS);\n", "      fail(\"This call was supposed to throw an ExecutionException\");\n", "    } catch (ExecutionException expected) {\n", "      // This is good and expected\n", "      assertSame(exception, expected.getCause());\n", "    }\n", "  }\n", "\n", "  public void testImmediateFailedFuture_cancellationException() throws Exception {\n", "    CancellationException exception = new CancellationException();\n", "    ListenableFuture<String> future =\n", "        Futures.immediateFailedFuture(exception);\n", "\n", "    try {\n", "      future.get(0L, TimeUnit.MILLISECONDS);\n", "      fail(\"This call was supposed to throw an ExecutionException\");\n", "    } catch (ExecutionException expected) {\n", "      // This is good and expected\n", "      assertSame(exception, expected.getCause());\n", "      assertFalse(future.isCancelled());\n", "    }\n", "  }\n", "\n", "  private static class MyException extends Exception {\n", "\n", "  }\n", "\n", "  // Class hierarchy for generics sanity checks\n", "  private static class Foo {\n", "\n", "  }\n", "\n", "  private static class FooChild extends Foo {\n", "\n", "  }\n", "\n", "  private static class Bar {\n", "\n", "  }\n", "\n", "  private static class BarChild extends Bar {\n", "\n", "  }\n", "\n", "  public void testTransform_genericsNull() throws Exception {\n", "    ListenableFuture<?> nullFuture = Futures.immediateFuture(null);\n", "    ListenableFuture<?> transformedFuture =\n", "        Futures.transform(nullFuture, Functions.constant(null));\n", "    assertNull(transformedFuture.get());\n", "  }\n", "\n", "  public void testTransform_genericsHierarchy() throws Exception {\n", "    ListenableFuture<FooChild> future = Futures.immediateFuture(null);\n", "    final BarChild barChild = new BarChild();\n", "    Function<Foo, BarChild> function = new Function<Foo, BarChild>() {\n", "      @Override\n", "      public BarChild apply(Foo unused) {\n", "        return barChild;\n", "      }\n", "    };\n", "    Bar bar = Futures.transform(future, function).get();\n", "    assertSame(barChild, bar);\n", "  }\n", "\n", "  public void testTransform_cancelPropagatesToInput() throws Exception {\n", "    SettableFuture<Foo> input = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n", "      @Override\n", "      public ListenableFuture<Bar> apply(Foo unused) {\n", "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n", "      }\n", "    };\n", "    assertTrue(Futures.transform(input, function).cancel(false));\n", "    assertTrue(input.isCancelled());\n", "    assertFalse(input.wasInterrupted());\n", "  }\n", "\n", "  public void testTransform_interruptPropagatesToInput() throws Exception {\n", "    SettableFuture<Foo> input = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n", "      @Override\n", "      public ListenableFuture<Bar> apply(Foo unused) {\n", "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n", "      }\n", "    };\n", "    assertTrue(Futures.transform(input, function).cancel(true));\n", "    assertTrue(input.isCancelled());\n", "    assertTrue(input.wasInterrupted());\n", "  }\n", "\n", "  public void testTransform_cancelPropagatesToAsyncOutput() throws Exception {\n", "    ListenableFuture<Foo> immediate = Futures.immediateFuture(new Foo());\n", "    final SettableFuture<Bar> secondary = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n", "      @Override\n", "      public ListenableFuture<Bar> apply(Foo unused) {\n", "        return secondary;\n", "      }\n", "    };\n", "    assertTrue(Futures.transform(immediate, function).cancel(false));\n", "    assertTrue(secondary.isCancelled());\n", "    assertFalse(secondary.wasInterrupted());\n", "  }\n", "\n", "  public void testTransform_interruptPropagatesToAsyncOutput()\n", "      throws Exception {\n", "    ListenableFuture<Foo> immediate = Futures.immediateFuture(new Foo());\n", "    final SettableFuture<Bar> secondary = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n", "      @Override\n", "      public ListenableFuture<Bar> apply(Foo unused) {\n", "        return secondary;\n", "      }\n", "    };\n", "    assertTrue(Futures.transform(immediate, function).cancel(true));\n", "    assertTrue(secondary.isCancelled());\n", "    assertTrue(secondary.wasInterrupted());\n", "  }\n", "\n", "  public void testTransform_inputCancelButNotInterruptPropagatesToOutput() throws Exception {\n", "    SettableFuture<String> f1 = SettableFuture.create();\n", "    ListenableFuture<Object> f2 = Futures.transform(f1, Functions.identity());\n", "    f1.cancel(true);\n", "    assertTrue(f2.isCancelled());\n", "    /*\n", "     * We might like to propagate interruption, too, but it's not clear that it matters. For now, we\n", "     * test for the behavior that we have today.\n", "     */\n", "    assertFalse(((AbstractFuture<?>) f2).wasInterrupted());\n", "  }\n", "\n", "  public void testTransformAsync_cancelPropagatesToInput() throws Exception {\n", "    SettableFuture<Foo> input = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n", "      @Override\n", "      public ListenableFuture<Bar> apply(Foo unused) {\n", "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n", "      }\n", "    };\n", "    assertTrue(Futures.transformAsync(input, function).cancel(false));\n", "    assertTrue(input.isCancelled());\n", "    assertFalse(input.wasInterrupted());\n", "  }\n", "\n", "  public void testTransformAsync_interruptPropagatesToInput() throws Exception {\n", "    SettableFuture<Foo> input = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n", "      @Override\n", "      public ListenableFuture<Bar> apply(Foo unused) {\n", "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n", "      }\n", "    };\n", "    assertTrue(Futures.transformAsync(input, function).cancel(true));\n", "    assertTrue(input.isCancelled());\n", "    assertTrue(input.wasInterrupted());\n", "  }\n", "\n", "  public void testTransformAsync_cancelPropagatesToAsyncOutput() throws Exception {\n", "    ListenableFuture<Foo> immediate = Futures.immediateFuture(new Foo());\n", "    final SettableFuture<Bar> secondary = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n", "      @Override\n", "      public ListenableFuture<Bar> apply(Foo unused) {\n", "        return secondary;\n", "      }\n", "    };\n", "    assertTrue(Futures.transformAsync(immediate, function).cancel(false));\n", "    assertTrue(secondary.isCancelled());\n", "    assertFalse(secondary.wasInterrupted());\n", "  }\n", "\n", "  public void testTransformAsync_interruptPropagatesToAsyncOutput()\n", "      throws Exception {\n", "    ListenableFuture<Foo> immediate = Futures.immediateFuture(new Foo());\n", "    final SettableFuture<Bar> secondary = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n", "      @Override\n", "      public ListenableFuture<Bar> apply(Foo unused) {\n", "        return secondary;\n", "      }\n", "    };\n", "    assertTrue(Futures.transformAsync(immediate, function).cancel(true));\n", "    assertTrue(secondary.isCancelled());\n", "    assertTrue(secondary.wasInterrupted());\n", "  }\n", "\n", "  public void testTransformAsync_inputCancelButNotInterruptPropagatesToOutput() throws Exception {\n", "    SettableFuture<Foo> f1 = SettableFuture.create();\n", "    final SettableFuture<Bar> secondary = SettableFuture.create();\n", "    AsyncFunction<Foo, Bar> function =\n", "        new AsyncFunction<Foo, Bar>() {\n", "          @Override\n", "          public ListenableFuture<Bar> apply(Foo unused) {\n", "            return secondary;\n", "          }\n", "        };\n", "    ListenableFuture<Bar> f2 = Futures.transformAsync(f1, function);\n", "    f1.cancel(true);\n", "    assertTrue(f2.isCancelled());\n", "    /*\n", "     * We might like to propagate interruption, too, but it's not clear that it matters. For now, we\n", "     * test for the behavior that we have today.\n", "     */\n", "    assertFalse(((AbstractFuture<?>) f2).wasInterrupted());\n", "  }\n", "\n", "  public void testTransform_rejectionPropagatesToOutput()\n", "      throws Exception {\n", "    SettableFuture<Foo> input = SettableFuture.create();\n", "    ListenableFuture<String> transformed =\n", "        Futures.transform(input, Functions.toStringFunction(), REJECTING_EXECUTOR);\n", "    input.set(new Foo());\n", "    try {\n", "      transformed.get(5, TimeUnit.SECONDS);\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Tests that the function is invoked only once, even if it throws an exception.\n", "   */\n", "  public void testTransformValueRemainsMemoized() throws Exception {\n", "    class Holder {\n", "\n", "      int value = 2;\n", "    }\n", "    final Holder holder = new Holder();\n", "\n", "    // This function adds the holder's value to the input value.\n", "    Function<Integer, Integer> adder = new Function<Integer, Integer>() {\n", "      @Override\n", "      public Integer apply(Integer from) {\n", "        return from + holder.value;\n", "      }\n", "    };\n", "\n", "    // Since holder.value is 2, applying 4 should yield 6.\n", "    assertEquals(6, adder.apply(4).intValue());\n", "\n", "    ListenableFuture<Integer> immediateFuture = Futures.immediateFuture(4);\n", "    Future<Integer> transformedFuture = Futures.transform(immediateFuture, adder);\n", "\n", "    // The composed future also yields 6.\n", "    assertEquals(6, transformedFuture.get().intValue());\n", "\n", "    // Repeated calls yield the same value even though the function's behavior\n", "    // changes\n", "    holder.value = 3;\n", "    assertEquals(6, transformedFuture.get().intValue());\n", "    assertEquals(7, adder.apply(4).intValue());\n", "\n", "    // Once more, with feeling.\n", "    holder.value = 4;\n", "    assertEquals(6, transformedFuture.get().intValue());\n", "    assertEquals(8, adder.apply(4).intValue());\n", "\n", "    // Memoized get also retains the value.\n", "    assertEquals(6, transformedFuture.get(1000, TimeUnit.SECONDS).intValue());\n", "\n", "    // Unsurprisingly, recomposing the future will return an updated value.\n", "    assertEquals(8, Futures.transform(immediateFuture, adder).get().intValue());\n", "\n", "    // Repeating, with the timeout version\n", "    assertEquals(8, Futures.transform(immediateFuture, adder).get(\n", "        1000, TimeUnit.SECONDS).intValue());\n", "  }\n", "\n", "  static class MyError extends Error {\n", "\n", "  }\n", "\n", "  static class MyRuntimeException extends RuntimeException {\n", "\n", "  }\n", "\n", "  // TODO(cpovirk): top-level class?\n", "  static class ExecutorSpy implements Executor {\n", "\n", "    Executor delegate;\n", "    boolean wasExecuted;\n", "\n", "    public ExecutorSpy(Executor delegate) {\n", "      this.delegate = delegate;\n", "    }\n", "\n", "    @Override\n", "    public void execute(Runnable command) {\n", "      delegate.execute(command);\n", "      wasExecuted = true;\n", "    }\n", "  }\n", "\n", "  public void testTransform_Executor() throws Exception {\n", "    Object value = new Object();\n", "    ExecutorSpy spy = new ExecutorSpy(directExecutor());\n", "\n", "    assertFalse(spy.wasExecuted);\n", "\n", "    ListenableFuture<Object> future = Futures.transform(\n", "        Futures.immediateFuture(value),\n", "        Functions.identity(), spy);\n", "\n", "    assertSame(value, future.get());\n", "    assertTrue(spy.wasExecuted);\n", "  }\n", "\n", "  private static class FunctionSpy<I, O> implements Function<I, O> {\n", "    private int applyCount;\n", "    private final Function<I, O> delegate;\n", "\n", "    public FunctionSpy(Function<I, O> delegate) {\n", "      this.delegate = delegate;\n", "    }\n", "\n", "    @Override\n", "    public O apply(I input) {\n", "      applyCount++;\n", "      return delegate.apply(input);\n", "    }\n", "\n", "    void verifyCallCount(int expected) {\n", "      assertThat(applyCount).isEqualTo(expected);\n", "    }\n", "  }\n", "\n", "  private static <I, O> FunctionSpy<I, O> spy(Function<I, O> delegate) {\n", "    return new FunctionSpy<I, O>(delegate);\n", "  }\n", "\n", "  private static <X extends Throwable, V> Function<X, V> unexpectedFunction() {\n", "    return new Function<X, V>() {\n", "      @Override\n", "      public V apply(X t) {\n", "        throw newAssertionError(\"Unexpected fallback\", t);\n", "      }\n", "    };\n", "  }\n", "\n", "  private static class FutureFallbackSpy<V> implements FutureFallback<V> {\n", "\n", "    private int count;\n", "    private final FutureFallback<V> delegate;\n", "\n", "    public FutureFallbackSpy(FutureFallback<V> delegate) {\n", "      this.delegate = delegate;\n", "    }\n", "\n", "    @Override\n", "    public final ListenableFuture<V> create(Throwable t) throws Exception {\n", "      count++;\n", "      return delegate.create(t);\n", "    }\n", "\n", "    void verifyCallCount(int expected) {\n", "      assertThat(count).isEqualTo(expected);\n", "    }\n", "  }\n", "\n", "  private static <V> FutureFallbackSpy<V> spy(FutureFallback<V> delegate) {\n", "    return new FutureFallbackSpy<V>(delegate);\n", "  }\n", "\n", "  private static <V> FutureFallback<V> unexpectedFallback() {\n", "    return new FutureFallback<V>() {\n", "      @Override\n", "      public ListenableFuture<V> create(Throwable t) {\n", "        throw newAssertionError(\"Unexpected fallback\", t);\n", "      }\n", "    };\n", "  }\n", "\n", "  private static class AsyncFunctionSpy<X extends Throwable, V> implements AsyncFunction<X, V> {\n", "    private int count;\n", "    private final AsyncFunction<X, V> delegate;\n", "\n", "    public AsyncFunctionSpy(AsyncFunction<X, V> delegate) {\n", "      this.delegate = delegate;\n", "    }\n", "\n", "    @Override\n", "    public final ListenableFuture<V> apply(X t) throws Exception {\n", "      count++;\n", "      return delegate.apply(t);\n", "    }\n", "\n", "    void verifyCallCount(int expected) {\n", "      assertThat(count).isEqualTo(expected);\n", "    }\n", "  }\n", "\n", "  private static <X extends Throwable, V> AsyncFunctionSpy<X, V> spy(AsyncFunction<X, V> delegate) {\n", "    return new AsyncFunctionSpy<X, V>(delegate);\n", "  }\n", "\n", "  private static <X extends Throwable, V> AsyncFunction<X, V> unexpectedAsyncFunction() {\n", "    return new AsyncFunction<X, V>() {\n", "      @Override\n", "      public ListenableFuture<V> apply(X t) {\n", "        throw newAssertionError(\"Unexpected fallback\", t);\n", "      }\n", "    };\n", "  }\n", "\n", "  /** Alternative to AssertionError(String, Throwable), which doesn't exist in GWT 2.6.1. */\n", "  private static AssertionError newAssertionError(String message, Throwable cause) {\n", "    AssertionError e = new AssertionError(message);\n", "    e.initCause(cause);\n", "    return e;\n", "  }\n", "\n", "  public void testWithFallback_inputDoesNotRaiseException() throws Exception {\n", "    FutureFallback<Integer> fallback = unexpectedFallback();\n", "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n", "    ListenableFuture<Integer> faultToleranteFuture = Futures.withFallback(originalFuture, fallback);\n", "    assertEquals(7, faultToleranteFuture.get().intValue());\n", "  }\n", "\n", "  public void testWithFallback_inputRaisesException() throws Exception {\n", "    final RuntimeException raisedException = new RuntimeException();\n", "    FutureFallbackSpy<Integer> fallback = spy(new FutureFallback<Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> create(Throwable t) throws Exception {\n", "        assertThat(t).isSameAs(raisedException);\n", "        return Futures.immediateFuture(20);\n", "      }\n", "    });\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n", "    ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(failingFuture, fallback);\n", "    assertEquals(20, faultTolerantFuture.get().intValue());\n", "    fallback.verifyCallCount(1);\n", "  }\n", "\n", "  public void testWithFallback_fallbackGeneratesRuntimeException() throws Exception {\n", "    RuntimeException expectedException = new RuntimeException();\n", "    runExpectedExceptionFallbackTest(expectedException, false);\n", "  }\n", "\n", "  public void testWithFallback_fallbackGeneratesCheckedException() throws Exception {\n", "    Exception expectedException = new Exception() {\n", "    };\n", "    runExpectedExceptionFallbackTest(expectedException, false);\n", "  }\n", "\n", "  public void testWithFallback_fallbackGeneratesError() throws Exception {\n", "    final Error error = new Error(\"deliberate\");\n", "    FutureFallback<Integer> fallback = new FutureFallback<Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> create(Throwable t) throws Exception {\n", "        throw error;\n", "      }\n", "    };\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n", "    try {\n", "      Futures.withFallback(failingFuture, fallback).get();\n", "      fail(\"An Exception should have been thrown!\");\n", "    } catch (ExecutionException expected) {\n", "      assertSame(error, expected.getCause());\n", "    }\n", "  }\n", "\n", "  public void testWithFallback_fallbackReturnsRuntimeException() throws Exception {\n", "    RuntimeException expectedException = new RuntimeException();\n", "    runExpectedExceptionFallbackTest(expectedException, true);\n", "  }\n", "\n", "  public void testWithFallback_fallbackReturnsCheckedException() throws Exception {\n", "    Exception expectedException = new Exception() {\n", "    };\n", "    runExpectedExceptionFallbackTest(expectedException, true);\n", "  }\n", "\n", "  private void runExpectedExceptionFallbackTest(\n", "      final Exception expectedException, final boolean wrapInFuture) throws Exception {\n", "    FutureFallbackSpy<Integer> fallback = spy(new FutureFallback<Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> create(Throwable t) throws Exception {\n", "        if (!wrapInFuture) {\n", "          throw expectedException;\n", "        } else {\n", "          return Futures.immediateFailedFuture(expectedException);\n", "        }\n", "      }\n", "    });\n", "\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n", "\n", "    ListenableFuture<Integer> faultToleranteFuture = Futures.withFallback(failingFuture, fallback);\n", "    try {\n", "      faultToleranteFuture.get();\n", "      fail(\"An Exception should have been thrown!\");\n", "    } catch (ExecutionException ee) {\n", "      assertSame(expectedException, ee.getCause());\n", "    }\n", "    fallback.verifyCallCount(1);\n", "  }\n", "\n", "  public void testWithFallback_fallbackNotReady() throws Exception {\n", "    ListenableFuture<Integer> primary = immediateFailedFuture(new Exception());\n", "    final SettableFuture<Integer> secondary = SettableFuture.create();\n", "    FutureFallback<Integer> fallback = new FutureFallback<Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> create(Throwable t) {\n", "        return secondary;\n", "      }\n", "    };\n", "    ListenableFuture<Integer> derived = Futures.withFallback(primary, fallback);\n", "    secondary.set(1);\n", "    assertEquals(1, (int) derived.get());\n", "  }\n", "\n", "  public void testWithFallback_resultInterruptedBeforeFallback() throws Exception {\n", "    SettableFuture<Integer> primary = SettableFuture.create();\n", "    FutureFallback<Integer> fallback = unexpectedFallback();\n", "    ListenableFuture<Integer> derived = Futures.withFallback(primary, fallback);\n", "    derived.cancel(true);\n", "    assertTrue(primary.isCancelled());\n", "    assertTrue(primary.wasInterrupted());\n", "  }\n", "\n", "  public void testWithFallback_resultCancelledBeforeFallback() throws Exception {\n", "    SettableFuture<Integer> primary = SettableFuture.create();\n", "    FutureFallback<Integer> fallback = unexpectedFallback();\n", "    ListenableFuture<Integer> derived = Futures.withFallback(primary, fallback);\n", "    derived.cancel(false);\n", "    assertTrue(primary.isCancelled());\n", "    assertFalse(primary.wasInterrupted());\n", "  }\n", "\n", "  public void testWithFallback_nullInsteadOfFuture() throws Exception {\n", "    ListenableFuture<Integer> inputFuture = immediateFailedFuture(new Exception());\n", "    ListenableFuture<?> chainedFuture =\n", "        Futures.withFallback(inputFuture, new FutureFallback<Integer>() {\n", "          @Override\n", "          public ListenableFuture<Integer> create(Throwable t) {\n", "            return null;\n", "          }\n", "        });\n", "    try {\n", "      chainedFuture.get();\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      NullPointerException cause = (NullPointerException) expected.getCause();\n", "      assertThat(cause).hasMessage(\"FutureFallback.create returned null instead of a Future. \"\n", "          + \"Did you mean to return immediateFuture(null)?\");\n", "    }\n", "  }\n", "\n", "  // catchingAsync tests cloned from the old withFallback tests:\n", "\n", "  public void testCatchingAsync_inputDoesNotRaiseException() throws Exception {\n", "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n", "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n", "    ListenableFuture<Integer> faultToleranteFuture =\n", "        Futures.catchingAsync(originalFuture, Throwable.class, fallback);\n", "    assertEquals(7, faultToleranteFuture.get().intValue());\n", "  }\n", "\n", "  public void testCatchingAsync_inputRaisesException() throws Exception {\n", "    final RuntimeException raisedException = new RuntimeException();\n", "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n", "        assertThat(t).isSameAs(raisedException);\n", "        return Futures.immediateFuture(20);\n", "      }\n", "    });\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n", "    ListenableFuture<Integer> faultTolerantFuture =\n", "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n", "    assertEquals(20, faultTolerantFuture.get().intValue());\n", "    fallback.verifyCallCount(1);\n", "  }\n", "\n", "  public void testCatchingAsync_fallbackGeneratesRuntimeException() throws Exception {\n", "    RuntimeException expectedException = new RuntimeException();\n", "    runExpectedExceptionCatchingAsyncTest(expectedException, false);\n", "  }\n", "\n", "  public void testCatchingAsync_fallbackGeneratesCheckedException() throws Exception {\n", "    Exception expectedException = new Exception() {\n", "    };\n", "    runExpectedExceptionCatchingAsyncTest(expectedException, false);\n", "  }\n", "\n", "  public void testCatchingAsync_fallbackGeneratesError() throws Exception {\n", "    final Error error = new Error(\"deliberate\");\n", "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n", "        throw error;\n", "      }\n", "    };\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n", "    try {\n", "      Futures.catchingAsync(failingFuture, Throwable.class, fallback).get();\n", "      fail(\"An Exception should have been thrown!\");\n", "    } catch (ExecutionException expected) {\n", "      assertSame(error, expected.getCause());\n", "    }\n", "  }\n", "\n", "  public void testCatchingAsync_fallbackReturnsRuntimeException() throws Exception {\n", "    RuntimeException expectedException = new RuntimeException();\n", "    runExpectedExceptionCatchingAsyncTest(expectedException, true);\n", "  }\n", "\n", "  public void testCatchingAsync_fallbackReturnsCheckedException() throws Exception {\n", "    Exception expectedException = new Exception() {\n", "    };\n", "    runExpectedExceptionCatchingAsyncTest(expectedException, true);\n", "  }\n", "\n", "  private void runExpectedExceptionCatchingAsyncTest(\n", "      final Exception expectedException, final boolean wrapInFuture) throws Exception {\n", "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n", "        if (!wrapInFuture) {\n", "          throw expectedException;\n", "        } else {\n", "          return Futures.immediateFailedFuture(expectedException);\n", "        }\n", "      }\n", "    });\n", "\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n", "\n", "    ListenableFuture<Integer> faultToleranteFuture =\n", "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n", "    try {\n", "      faultToleranteFuture.get();\n", "      fail(\"An Exception should have been thrown!\");\n", "    } catch (ExecutionException ee) {\n", "      assertSame(expectedException, ee.getCause());\n", "    }\n", "    fallback.verifyCallCount(1);\n", "  }\n", "\n", "  public void testCatchingAsync_fallbackNotReady() throws Exception {\n", "    ListenableFuture<Integer> primary = immediateFailedFuture(new Exception());\n", "    final SettableFuture<Integer> secondary = SettableFuture.create();\n", "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> apply(Throwable t) {\n", "        return secondary;\n", "      }\n", "    };\n", "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n", "    secondary.set(1);\n", "    assertEquals(1, (int) derived.get());\n", "  }\n", "\n", "  public void testCatchingAsync_resultInterruptedBeforeFallback() throws Exception {\n", "    SettableFuture<Integer> primary = SettableFuture.create();\n", "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n", "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n", "    derived.cancel(true);\n", "    assertTrue(primary.isCancelled());\n", "    assertTrue(primary.wasInterrupted());\n", "  }\n", "\n", "  public void testCatchingAsync_resultCancelledBeforeFallback() throws Exception {\n", "    SettableFuture<Integer> primary = SettableFuture.create();\n", "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n", "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n", "    derived.cancel(false);\n", "    assertTrue(primary.isCancelled());\n", "    assertFalse(primary.wasInterrupted());\n", "  }\n", "\n", "  public void testCatchingAsync_nullInsteadOfFuture() throws Exception {\n", "    ListenableFuture<Integer> inputFuture = immediateFailedFuture(new Exception());\n", "    ListenableFuture<?> chainedFuture = Futures.catchingAsync(inputFuture, Throwable.class,\n", "        new AsyncFunction<Throwable, Integer>() {\n", "          @Override\n", "          @SuppressWarnings(\"AsyncFunctionReturnsNull\")\n", "          public ListenableFuture<Integer> apply(Throwable t) {\n", "            return null;\n", "          }\n", "        });\n", "    try {\n", "      chainedFuture.get();\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      NullPointerException cause = (NullPointerException) expected.getCause();\n", "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n", "          + \"Did you mean to return immediateFuture(null)?\");\n", "    }\n", "  }\n", "\n", "  // catching tests cloned from the old withFallback tests:\n", "\n", "  public void testCatching_inputDoesNotRaiseException() throws Exception {\n", "    Function<Throwable, Integer> fallback = unexpectedFunction();\n", "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n", "    ListenableFuture<Integer> faultToleranteFuture =\n", "        Futures.catching(originalFuture, Throwable.class, fallback);\n", "    assertEquals(7, faultToleranteFuture.get().intValue());\n", "  }\n", "\n", "  public void testCatching_inputRaisesException() throws Exception {\n", "    final RuntimeException raisedException = new RuntimeException();\n", "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n", "      @Override\n", "      public Integer apply(Throwable t) {\n", "        assertThat(t).isSameAs(raisedException);\n", "        return 20;\n", "      }\n", "    });\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n", "    ListenableFuture<Integer> faultTolerantFuture =\n", "        Futures.catching(failingFuture, Throwable.class, fallback);\n", "    assertEquals(20, faultTolerantFuture.get().intValue());\n", "    fallback.verifyCallCount(1);\n", "  }\n", "\n", "  public void testCatching_fallbackGeneratesRuntimeException() throws Exception {\n", "    RuntimeException expectedException = new RuntimeException();\n", "    runExpectedExceptionCatchingTest(expectedException);\n", "  }\n", "\n", "  /*\n", "   * catching() uses a plain Function, so there's no\n", "   * testCatching_fallbackGeneratesCheckedException().\n", "   */\n", "\n", "  public void testCatching_fallbackGeneratesError() throws Exception {\n", "    final Error error = new Error(\"deliberate\");\n", "    Function<Throwable, Integer> fallback = new Function<Throwable, Integer>() {\n", "      @Override\n", "      public Integer apply(Throwable t) {\n", "        throw error;\n", "      }\n", "    };\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n", "    try {\n", "      Futures.catching(failingFuture, Throwable.class, fallback).get();\n", "      fail(\"An Exception should have been thrown!\");\n", "    } catch (ExecutionException expected) {\n", "      assertSame(error, expected.getCause());\n", "    }\n", "  }\n", "\n", "  /*\n", "   * catching() uses a plain Function, so there's no testCatching_fallbackReturnsRuntimeException()\n", "   * or testCatching_fallbackReturnsCheckedException().\n", "   */\n", "\n", "  private void runExpectedExceptionCatchingTest(final RuntimeException expectedException)\n", "      throws Exception {\n", "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n", "      @Override\n", "      public Integer apply(Throwable t) {\n", "        throw expectedException;\n", "      }\n", "    });\n", "\n", "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n", "\n", "    ListenableFuture<Integer> faultToleranteFuture =\n", "        Futures.catching(failingFuture, Throwable.class, fallback);\n", "    try {\n", "      faultToleranteFuture.get();\n", "      fail(\"An Exception should have been thrown!\");\n", "    } catch (ExecutionException ee) {\n", "      assertSame(expectedException, ee.getCause());\n", "    }\n", "    fallback.verifyCallCount(1);\n", "  }\n", "\n", "  // catching() uses a plain Function, so there's no testCatching_fallbackNotReady().\n", "\n", "  public void testCatching_resultInterruptedBeforeFallback() throws Exception {\n", "    SettableFuture<Integer> primary = SettableFuture.create();\n", "    Function<Throwable, Integer> fallback = unexpectedFunction();\n", "    ListenableFuture<Integer> derived = Futures.catching(primary, Throwable.class, fallback);\n", "    derived.cancel(true);\n", "    assertTrue(primary.isCancelled());\n", "    assertTrue(primary.wasInterrupted());\n", "  }\n", "\n", "  public void testCatching_resultCancelledBeforeFallback() throws Exception {\n", "    SettableFuture<Integer> primary = SettableFuture.create();\n", "    Function<Throwable, Integer> fallback = unexpectedFunction();\n", "    ListenableFuture<Integer> derived = Futures.catching(primary, Throwable.class, fallback);\n", "    derived.cancel(false);\n", "    assertTrue(primary.isCancelled());\n", "    assertFalse(primary.wasInterrupted());\n", "  }\n", "\n", "  // catching() uses a plain Function, so there's no testCatching_resultCancelledAfterFallback().\n", "\n", "  // catching() uses a plain Function, so there's no testCatching_nullInsteadOfFuture().\n", "\n", "  // Some tests of the exceptionType parameter:\n", "\n", "  public void testCatching_Throwable() throws Exception {\n", "    Function<Throwable, Integer> fallback = functionReturningOne();\n", "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new IOException());\n", "    ListenableFuture<Integer> faultTolerantFuture =\n", "        Futures.catching(originalFuture, Throwable.class, fallback);\n", "    assertEquals(1, (int) faultTolerantFuture.get());\n", "  }\n", "\n", "  public void testCatchingAsync_Throwable() throws Exception {\n", "    AsyncFunction<Throwable, Integer> fallback = asyncFunctionReturningOne();\n", "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new IOException());\n", "    ListenableFuture<Integer> faultTolerantFuture =\n", "        Futures.catchingAsync(originalFuture, Throwable.class, fallback);\n", "    assertEquals(1, (int) faultTolerantFuture.get());\n", "  }\n", "\n", "  public void testCatchingAsync_rejectionPropagatesToOutput() throws Exception {\n", "    SettableFuture<String> input = SettableFuture.create();\n", "    ListenableFuture<String> transformed =\n", "        Futures.catching(input, Throwable.class, Functions.toStringFunction(), REJECTING_EXECUTOR);\n", "    input.setException(new Exception());\n", "    try {\n", "      transformed.get(5, TimeUnit.SECONDS);\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);\n", "    }\n", "  }\n", "\n", "  private <X extends Throwable> Function<X, Integer> functionReturningOne() {\n", "    return new Function<X, Integer>() {\n", "      @Override\n", "      public Integer apply(X t) {\n", "        return 1;\n", "      }\n", "    };\n", "  }\n", "\n", "  private <X extends Throwable> AsyncFunction<X, Integer> asyncFunctionReturningOne() {\n", "    return new AsyncFunction<X, Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> apply(X t) {\n", "        return immediateFuture(1);\n", "      }\n", "    };\n", "  }\n", "\n", "  private static <I, O> AsyncFunction<I, O> constantAsyncFunction(\n", "      final ListenableFuture<O> output) {\n", "    return new AsyncFunction<I, O>() {\n", "      @Override\n", "      public ListenableFuture<O> apply(I input) {\n", "        return output;\n", "      }\n", "    };\n", "  }\n", "\n", "  public void testTransform_genericsWildcard_AsyncFunction() throws Exception {\n", "    ListenableFuture<?> nullFuture = immediateFuture(null);\n", "    ListenableFuture<?> chainedFuture =\n", "        Futures.transform(nullFuture, constantAsyncFunction(nullFuture));\n", "    assertNull(chainedFuture.get());\n", "  }\n", "\n", "  public void testTransform_genericsHierarchy_AsyncFunction() throws Exception {\n", "    ListenableFuture<FooChild> future = Futures.immediateFuture(null);\n", "    final BarChild barChild = new BarChild();\n", "    AsyncFunction<Foo, BarChild> function =\n", "        new AsyncFunction<Foo, BarChild>() {\n", "          @Override\n", "          public AbstractFuture<BarChild> apply(Foo unused) {\n", "            AbstractFuture<BarChild> future = new AbstractFuture<BarChild>() {\n", "            };\n", "            future.set(barChild);\n", "            return future;\n", "          }\n", "        };\n", "    Bar bar = Futures.transform(future, function).get();\n", "    assertSame(barChild, bar);\n", "  }\n", "\n", "  public void testTransform_asyncFunction_error() throws InterruptedException {\n", "    final Error error = new Error(\"deliberate\");\n", "    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> apply(String input) {\n", "        throw error;\n", "      }\n", "    };\n", "    SettableFuture<String> inputFuture = SettableFuture.create();\n", "    ListenableFuture<Integer> outputFuture = Futures.transform(inputFuture, function);\n", "    inputFuture.set(\"value\");\n", "    try {\n", "      outputFuture.get();\n", "      fail(\"should have thrown error\");\n", "    } catch (ExecutionException e) {\n", "      assertSame(error, e.getCause());\n", "    }\n", "  }\n", "\n", "  public void testTransform_asyncFunction_nullInsteadOfFuture() throws Exception {\n", "    ListenableFuture<?> inputFuture = immediateFuture(\"a\");\n", "    ListenableFuture<?> chainedFuture =\n", "        Futures.transform(inputFuture, constantAsyncFunction(null));\n", "    try {\n", "      chainedFuture.get();\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      NullPointerException cause = (NullPointerException) expected.getCause();\n", "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n", "          + \"Did you mean to return immediateFuture(null)?\");\n", "    }\n", "  }\n", "\n", "  public void testTransformAsync_genericsWildcard_AsyncFunction() throws Exception {\n", "    ListenableFuture<?> nullFuture = immediateFuture(null);\n", "    ListenableFuture<?> chainedFuture =\n", "        Futures.transformAsync(nullFuture, constantAsyncFunction(nullFuture));\n", "    assertNull(chainedFuture.get());\n", "  }\n", "\n", "  public void testTransformAsync_genericsHierarchy_AsyncFunction() throws Exception {\n", "    ListenableFuture<FooChild> future = Futures.immediateFuture(null);\n", "    final BarChild barChild = new BarChild();\n", "    AsyncFunction<Foo, BarChild> function =\n", "        new AsyncFunction<Foo, BarChild>() {\n", "          @Override\n", "          public AbstractFuture<BarChild> apply(Foo unused) {\n", "            AbstractFuture<BarChild> future = new AbstractFuture<BarChild>() {\n", "            };\n", "            future.set(barChild);\n", "            return future;\n", "          }\n", "        };\n", "    Bar bar = Futures.transformAsync(future, function).get();\n", "    assertSame(barChild, bar);\n", "  }\n", "\n", "  public void testTransformAsync_asyncFunction_error() throws InterruptedException {\n", "    final Error error = new Error(\"deliberate\");\n", "    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {\n", "      @Override\n", "      public ListenableFuture<Integer> apply(String input) {\n", "        throw error;\n", "      }\n", "    };\n", "    SettableFuture<String> inputFuture = SettableFuture.create();\n", "    ListenableFuture<Integer> outputFuture = Futures.transformAsync(inputFuture, function);\n", "    inputFuture.set(\"value\");\n", "    try {\n", "      outputFuture.get();\n", "      fail(\"should have thrown error\");\n", "    } catch (ExecutionException e) {\n", "      assertSame(error, e.getCause());\n", "    }\n", "  }\n", "\n", "  public void testTransformAsync_asyncFunction_nullInsteadOfFuture() throws Exception {\n", "    ListenableFuture<?> inputFuture = immediateFuture(\"a\");\n", "    ListenableFuture<?> chainedFuture =\n", "        Futures.transformAsync(inputFuture, constantAsyncFunction(null));\n", "    try {\n", "      chainedFuture.get();\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      NullPointerException cause = (NullPointerException) expected.getCause();\n", "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n", "          + \"Did you mean to return immediateFuture(null)?\");\n", "    }\n", "  }\n", "\n", "  public void testDereference_genericsWildcard() throws Exception {\n", "    ListenableFuture<?> inner = Futures.immediateFuture(null);\n", "    ListenableFuture<ListenableFuture<?>> outer =\n", "        Futures.<ListenableFuture<?>>immediateFuture(inner);\n", "    ListenableFuture<?> dereferenced = Futures.dereference(outer);\n", "    assertNull(dereferenced.get());\n", "  }\n", "\n", "  public void testDereference_genericsHierarchy() throws Exception {\n", "    FooChild fooChild = new FooChild();\n", "    ListenableFuture<FooChild> inner = Futures.immediateFuture(fooChild);\n", "    ListenableFuture<ListenableFuture<FooChild>> outer = Futures.immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = Futures.<Foo>dereference(outer);\n", "    assertSame(fooChild, dereferenced.get());\n", "  }\n", "\n", "  public void testDereference_resultCancelsOuter() throws Exception {\n", "    ListenableFuture<ListenableFuture<Foo>> outer = SettableFuture.create();\n", "    ListenableFuture<Foo> dereferenced = Futures.dereference(outer);\n", "    dereferenced.cancel(true);\n", "    assertTrue(outer.isCancelled());\n", "  }\n", "\n", "  public void testDereference_resultCancelsInner() throws Exception {\n", "    ListenableFuture<Foo> inner = SettableFuture.create();\n", "    ListenableFuture<ListenableFuture<Foo>> outer = Futures.immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = Futures.dereference(outer);\n", "    dereferenced.cancel(true);\n", "    assertTrue(inner.isCancelled());\n", "  }\n", "\n", "  public void testDereference_outerCancelsResult() throws Exception {\n", "    ListenableFuture<ListenableFuture<Foo>> outer = SettableFuture.create();\n", "    ListenableFuture<Foo> dereferenced = Futures.dereference(outer);\n", "    outer.cancel(true);\n", "    assertTrue(dereferenced.isCancelled());\n", "  }\n", "\n", "  public void testDereference_innerCancelsResult() throws Exception {\n", "    ListenableFuture<Foo> inner = SettableFuture.create();\n", "    ListenableFuture<ListenableFuture<Foo>> outer = Futures.immediateFuture(inner);\n", "    ListenableFuture<Foo> dereferenced = Futures.dereference(outer);\n", "    inner.cancel(true);\n", "    assertTrue(dereferenced.isCancelled());\n", "  }\n", "\n", "  /**\n", "   * Runnable which can be called a single time, and only after {@link #expectCall} is called.\n", "   */\n", "  // TODO(cpovirk): top-level class?\n", "  static class SingleCallListener implements Runnable {\n", "\n", "    private boolean expectCall = false;\n", "    private final CountDownLatch calledCountDown =\n", "        new CountDownLatch(1);\n", "\n", "    @Override\n", "    public void run() {\n", "      assertTrue(\"Listener called before it was expected\", expectCall);\n", "      assertFalse(\"Listener called more than once\", wasCalled());\n", "      calledCountDown.countDown();\n", "    }\n", "\n", "    public void expectCall() {\n", "      assertFalse(\"expectCall is already true\", expectCall);\n", "      expectCall = true;\n", "    }\n", "\n", "    public boolean wasCalled() {\n", "      return calledCountDown.getCount() == 0;\n", "    }\n", "\n", "    public void waitForCall() throws InterruptedException {\n", "      assertTrue(\"expectCall is false\", expectCall);\n", "      calledCountDown.await();\n", "    }\n", "  }\n", "\n", "  public void testAllAsList() throws Exception {\n", "    // Create input and output\n", "    SettableFuture<String> future1 = SettableFuture.create();\n", "    SettableFuture<String> future2 = SettableFuture.create();\n", "    SettableFuture<String> future3 = SettableFuture.create();\n", "    @SuppressWarnings(\"unchecked\") // array is never modified\n", "        ListenableFuture<List<String>> compound =\n", "        Futures.allAsList(future1, future2, future3);\n", "\n", "    // Attach a listener\n", "    SingleCallListener listener = new SingleCallListener();\n", "    compound.addListener(listener, directExecutor());\n", "\n", "    // Satisfy each input and check the output\n", "    assertFalse(compound.isDone());\n", "    future1.set(DATA1);\n", "    assertFalse(compound.isDone());\n", "    future2.set(DATA2);\n", "    assertFalse(compound.isDone());\n", "    listener.expectCall();\n", "    future3.set(DATA3);\n", "    assertTrue(compound.isDone());\n", "    assertTrue(listener.wasCalled());\n", "\n", "    List<String> results = compound.get();\n", "    assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();\n", "  }\n", "\n", "  public void testAllAsList_emptyArray() throws Exception {\n", "    SingleCallListener listener = new SingleCallListener();\n", "    listener.expectCall();\n", "    @SuppressWarnings(\"unchecked\") // array is never modified\n", "        ListenableFuture<List<String>> compound = Futures.allAsList();\n", "    compound.addListener(listener, directExecutor());\n", "    assertTrue(compound.isDone());\n", "    assertTrue(compound.get().isEmpty());\n", "    assertTrue(listener.wasCalled());\n", "  }\n", "\n", "  public void testAllAsList_failure() throws Exception {\n", "    SingleCallListener listener = new SingleCallListener();\n", "    SettableFuture<String> future1 = SettableFuture.create();\n", "    SettableFuture<String> future2 = SettableFuture.create();\n", "    @SuppressWarnings(\"unchecked\") // array is never modified\n", "        ListenableFuture<List<String>> compound =\n", "        Futures.allAsList(future1, future2);\n", "    compound.addListener(listener, directExecutor());\n", "\n", "    listener.expectCall();\n", "    Throwable exception = new Throwable(\"failed1\");\n", "    future1.setException(exception);\n", "    assertTrue(compound.isDone());\n", "    assertTrue(listener.wasCalled());\n", "    future2.set(\"result2\");\n", "\n", "    try {\n", "      compound.get();\n", "      fail(\"Expected exception not thrown\");\n", "    } catch (ExecutionException e) {\n", "      assertSame(exception, e.getCause());\n", "    }\n", "  }\n", "\n", "  public void testAllAsList_cancelled() throws Exception {\n", "    SingleCallListener listener = new SingleCallListener();\n", "    SettableFuture<String> future1 = SettableFuture.create();\n", "    SettableFuture<String> future2 = SettableFuture.create();\n", "    @SuppressWarnings(\"unchecked\") // array is never modified\n", "        ListenableFuture<List<String>> compound =\n", "        Futures.allAsList(future1, future2);\n", "    compound.addListener(listener, directExecutor());\n", "\n", "    listener.expectCall();\n", "    future1.cancel(true);\n", "    assertTrue(compound.isDone());\n", "    assertTrue(listener.wasCalled());\n", "    future2.setException(new Throwable(\"failed2\"));\n", "\n", "    try {\n", "      compound.get();\n", "      fail(\"Expected exception not thrown\");\n", "    } catch (CancellationException e) {\n", "      // Expected\n", "    }\n", "  }\n", "\n", "  public void testAllAsList_resultCancelled() throws Exception {\n", "    SettableFuture<String> future1 = SettableFuture.create();\n", "    SettableFuture<String> future2 = SettableFuture.create();\n", "    @SuppressWarnings(\"unchecked\") // array is never modified\n", "        ListenableFuture<List<String>> compound =\n", "        Futures.allAsList(future1, future2);\n", "\n", "    future2.set(DATA2);\n", "    assertFalse(compound.isDone());\n", "    assertTrue(compound.cancel(false));\n", "    assertTrue(compound.isCancelled());\n", "    assertTrue(future1.isCancelled());\n", "    assertFalse(future1.wasInterrupted());\n", "  }\n", "\n", "  public void testAllAsList_resultCancelledInterrupted_withSecondaryListFuture()\n", "      throws Exception {\n", "    SettableFuture<String> future1 = SettableFuture.create();\n", "    SettableFuture<String> future2 = SettableFuture.create();\n", "    ListenableFuture<List<String>> compound =\n", "        Futures.allAsList(future1, future2);\n", "    // There was a bug where the event listener for the combined future would\n", "    // result in the sub-futures being cancelled without being interrupted.\n", "    ListenableFuture<List<String>> otherCompound =\n", "        Futures.allAsList(future1, future2);\n", "\n", "    assertTrue(compound.cancel(true));\n", "    assertTrue(future1.isCancelled());\n", "    assertTrue(future1.wasInterrupted());\n", "    assertTrue(future2.isCancelled());\n", "    assertTrue(future2.wasInterrupted());\n", "    assertTrue(otherCompound.isCancelled());\n", "  }\n", "\n", "  public void testAllAsList_resultCancelled_withSecondaryListFuture()\n", "      throws Exception {\n", "    SettableFuture<String> future1 = SettableFuture.create();\n", "    SettableFuture<String> future2 = SettableFuture.create();\n", "    ListenableFuture<List<String>> compound =\n", "        Futures.allAsList(future1, future2);\n", "    // This next call is \"unused,\" but it is an important part of the test. Don't remove it!\n", "    Futures.allAsList(future1, future2);\n", "\n", "    assertTrue(compound.cancel(false));\n", "    assertTrue(future1.isCancelled());\n", "    assertFalse(future1.wasInterrupted());\n", "    assertTrue(future2.isCancelled());\n", "    assertFalse(future2.wasInterrupted());\n", "  }\n", "\n", "  public void testAllAsList_resultInterrupted() throws Exception {\n", "    SettableFuture<String> future1 = SettableFuture.create();\n", "    SettableFuture<String> future2 = SettableFuture.create();\n", "    @SuppressWarnings(\"unchecked\") // array is never modified\n", "        ListenableFuture<List<String>> compound =\n", "        Futures.allAsList(future1, future2);\n", "\n", "    future2.set(DATA2);\n", "    assertFalse(compound.isDone());\n", "    assertTrue(compound.cancel(true));\n", "    assertTrue(compound.isCancelled());\n", "    assertTrue(future1.isCancelled());\n", "    assertTrue(future1.wasInterrupted());\n", "  }\n", "\n", "  /**\n", "   * Test the case where the futures are fulfilled prior to constructing the ListFuture.  There was\n", "   * a bug where the loop that connects a Listener to each of the futures would die on the last\n", "   * loop-check as done() on ListFuture nulled out the variable being looped over (the list of\n", "   * futures).\n", "   */\n", "  public void testAllAsList_doneFutures() throws Exception {\n", "    // Create input and output\n", "    SettableFuture<String> future1 = SettableFuture.create();\n", "    SettableFuture<String> future2 = SettableFuture.create();\n", "    SettableFuture<String> future3 = SettableFuture.create();\n", "\n", "    // Satisfy each input prior to creating compound and check the output\n", "    future1.set(DATA1);\n", "    future2.set(DATA2);\n", "    future3.set(DATA3);\n", "\n", "    @SuppressWarnings(\"unchecked\") // array is never modified\n", "        ListenableFuture<List<String>> compound =\n", "        Futures.allAsList(future1, future2, future3);\n", "\n", "    // Attach a listener\n", "    SingleCallListener listener = new SingleCallListener();\n", "    listener.expectCall();\n", "    compound.addListener(listener, directExecutor());\n", "\n", "    assertTrue(compound.isDone());\n", "    assertTrue(listener.wasCalled());\n", "\n", "    List<String> results = compound.get();\n", "    assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();\n", "  }\n", "\n", "  /**\n", "   * A single non-error failure is not logged because it is reported via the output future.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testAllAsList_logging_exception() throws Exception {\n", "    try {\n", "      Futures.allAsList(immediateFailedFuture(new MyException())).get();\n", "      fail();\n", "    } catch (ExecutionException e) {\n", "      assertThat(e.getCause()).isInstanceOf(MyException.class);\n", "      assertEquals(\n", "          \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Ensure that errors are always logged.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testAllAsList_logging_error() throws Exception {\n", "    try {\n", "      Futures.allAsList(immediateFailedFuture(new MyError())).get();\n", "      fail();\n", "    } catch (ExecutionException e) {\n", "      assertThat(e.getCause()).isInstanceOf(MyError.class);\n", "      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n", "      assertThat(logged).hasSize(1); // errors are always logged\n", "      assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * All as list will log extra exceptions that have already occurred.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testAllAsList_logging_multipleExceptions_alreadyDone() throws Exception {\n", "    try {\n", "      Futures.allAsList(immediateFailedFuture(new MyException()),\n", "          immediateFailedFuture(new MyException())).get();\n", "      fail();\n", "    } catch (ExecutionException e) {\n", "      assertThat(e.getCause()).isInstanceOf(MyException.class);\n", "      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n", "      assertThat(logged).hasSize(1); // the second failure is logged\n", "      assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * All as list will log extra exceptions that occur later.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testAllAsList_logging_multipleExceptions_doneLater() throws Exception {\n", "    SettableFuture<Object> future1 = SettableFuture.create();\n", "    SettableFuture<Object> future2 = SettableFuture.create();\n", "    SettableFuture<Object> future3 = SettableFuture.create();\n", "    ListenableFuture<List<Object>> all = Futures.allAsList(future1, future2, future3);\n", "\n", "    future1.setException(new MyException());\n", "    future2.setException(new MyException());\n", "    future3.setException(new MyException());\n", "\n", "    try {\n", "      all.get();\n", "    } catch (ExecutionException e) {\n", "      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n", "      assertThat(logged).hasSize(2); // failures after the first are logged\n", "      assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\n", "      assertThat(logged.get(1).getThrown()).isInstanceOf(MyException.class);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * The same exception happening on multiple futures should not be logged.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testAllAsList_logging_same_exception() throws Exception {\n", "    try {\n", "      MyException sameInstance = new MyException();\n", "      Futures.allAsList(immediateFailedFuture(sameInstance),\n", "          immediateFailedFuture(sameInstance)).get();\n", "      fail();\n", "    } catch (ExecutionException e) {\n", "      assertThat(e.getCause()).isInstanceOf(MyException.class);\n", "      assertEquals(\n", "          \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n", "    }\n", "  }\n", "\n", "  public void testAllAsList_logging_seenExceptionUpdateRace() throws Exception {\n", "    final MyException sameInstance = new MyException();\n", "    SettableFuture<Object> firstFuture = SettableFuture.create();\n", "    final SettableFuture<Object> secondFuture = SettableFuture.create();\n", "    ListenableFuture<List<Object>> bulkFuture = allAsList(firstFuture, secondFuture);\n", "\n", "    bulkFuture.addListener(new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        /*\n", "         * firstFuture just completed, but AggregateFuture hasn't yet had time to record the\n", "         * exception in seenExceptions. When we complete secondFuture with the same exception,\n", "         * we want for AggregateFuture to still detect that it's been previously seen.\n", "         */\n", "        secondFuture.setException(sameInstance);\n", "      }\n", "    }, directExecutor());\n", "    firstFuture.setException(sameInstance);\n", "\n", "    try {\n", "      bulkFuture.get();\n", "      fail();\n", "    } catch (ExecutionException expected) {\n", "      assertThat(expected.getCause()).isInstanceOf(MyException.class);\n", "      assertThat(aggregateFutureLogHandler.getStoredLogRecords()).isEmpty();\n", "    }\n", "  }\n", "\n", "  public void testAllAsList_logging_seenExceptionUpdateCancelRace() throws Exception {\n", "    final MyException subsequentFailure = new MyException();\n", "    SettableFuture<Object> firstFuture = SettableFuture.create();\n", "    final SettableFuture<Object> secondFuture = SettableFuture.create();\n", "    ListenableFuture<List<Object>> bulkFuture = allAsList(firstFuture, secondFuture);\n", "\n", "    bulkFuture.addListener(new Runnable() {\n", "      @Override\n", "      public void run() {\n", "        /*\n", "         * This is similar to the above test, but this time we're making sure that we recognize that\n", "         * the output Future is done early not because of an exception but because of a\n", "         * cancellation.\n", "         */\n", "        secondFuture.setException(subsequentFailure);\n", "      }\n", "    }, directExecutor());\n", "    firstFuture.cancel(false);\n", "\n", "    try {\n", "      bulkFuture.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "      assertThat(getOnlyElement(aggregateFutureLogHandler.getStoredLogRecords()).getThrown())\n", "          .isSameAs(subsequentFailure);\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Different exceptions happening on multiple futures with the same cause should not be logged.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testAllAsList_logging_same_cause() throws Exception {\n", "    try {\n", "      MyException exception1 = new MyException();\n", "      MyException exception2 = new MyException();\n", "      MyException exception3 = new MyException();\n", "\n", "      MyException sameInstance = new MyException();\n", "      exception1.initCause(sameInstance);\n", "      exception2.initCause(sameInstance);\n", "      exception3.initCause(exception2);\n", "      Futures.allAsList(immediateFailedFuture(exception1),\n", "          immediateFailedFuture(exception3)).get();\n", "      fail();\n", "    } catch (ExecutionException e) {\n", "      assertThat(e.getCause()).isInstanceOf(MyException.class);\n", "      assertEquals(\n", "          \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n", "    }\n", "  }\n", "\n", "  private static String createCombinedResult(Integer i, Boolean b) {\n", "    return \"-\" + i + \"-\" + b;\n", "  }\n", "\n", "  /*\n", "   * TODO(cpovirk): maybe pass around TestFuture instances instead of\n", "   * ListenableFuture instances\n", "   */\n", "\n", "  /**\n", "   * Non-Error exceptions are never logged.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testSuccessfulAsList_logging_exception() throws Exception {\n", "    assertEquals(Lists.newArrayList((Object) null),\n", "        Futures.successfulAsList(\n", "            immediateFailedFuture(new MyException())).get());\n", "    assertEquals(\"Nothing should be logged\", 0,\n", "        aggregateFutureLogHandler.getStoredLogRecords().size());\n", "\n", "    // Not even if there are a bunch of failures.\n", "    assertEquals(Lists.newArrayList(null, null, null),\n", "        Futures.successfulAsList(\n", "            immediateFailedFuture(new MyException()),\n", "            immediateFailedFuture(new MyException()),\n", "            immediateFailedFuture(new MyException())).get());\n", "    assertEquals(\"Nothing should be logged\", 0,\n", "        aggregateFutureLogHandler.getStoredLogRecords().size());\n", "  }\n", "\n", "  /**\n", "   * Ensure that errors are always logged.\n", "   */\n", "  @SuppressWarnings(\"unchecked\")\n", "  public void testSuccessfulAsList_logging_error() throws Exception {\n", "    assertEquals(Lists.newArrayList((Object) null),\n", "        Futures.successfulAsList(\n", "            immediateFailedFuture(new MyError())).get());\n", "    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n", "    assertThat(logged).hasSize(1); // errors are always logged\n", "    assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);\n", "  }\n", "\n", "  // Mostly an example of how it would look like to use a list of mixed types\n", "\n", "  static AssertionFailedError failureWithCause(Throwable cause, String message) {\n", "    AssertionFailedError failure = new AssertionFailedError(message);\n", "    failure.initCause(cause);\n", "    return failure;\n", "  }\n", "\n", "  /**\n", "   * A future that throws a runtime exception from get.\n", "   */\n", "  static class BuggyFuture extends AbstractFuture<String> {\n", "\n", "    @Override\n", "    public String get() {\n", "      throw new RuntimeException();\n", "    }\n", "\n", "    @Override\n", "    public boolean set(String v) {\n", "      return super.set(v);\n", "    }\n", "  }\n", "\n", "  // This test covers a bug where an Error thrown from a callback could cause the TimeoutFuture to\n", "  // never complete when timing out.  Notably, nothing would get logged since the Error would get\n", "  // stuck in the ScheduledFuture inside of TimeoutFuture and nothing ever calls get on it.\n", "\n", "  // Simulate a timeout that fires before the call the SES.schedule returns but the future is\n", "  // already completed.\n", "\n", "  private static final Executor REJECTING_EXECUTOR =\n", "      new Executor() {\n", "        @Override\n", "        public void execute(Runnable runnable) {\n", "          throw new RejectedExecutionException();\n", "        }\n", "      };\n", "}\n"]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586]}}, {"198": "guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/TrustedListenableFutureTaskTest.java", "added": {}, "removed": {"1": ["/*\n", " * Copyright (C) 2014 The Guava Authors\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "package com.google.common.util.concurrent;\n", "\n", "import static com.google.common.util.concurrent.Callables.returning;\n", "import static com.google.common.util.concurrent.TestPlatform.verifyThreadWasNotInterrupted;\n", "\n", "import com.google.common.annotations.GwtCompatible;\n", "\n", "import junit.framework.TestCase;\n", "\n", "import java.util.concurrent.Callable;\n", "import java.util.concurrent.CancellationException;\n", "import java.util.concurrent.ExecutionException;\n", "\n", "/**\n", " * Test case for {@link TrustedListenableFutureTask}.\n", " */\n", "@GwtCompatible(emulated = true)\n", "public class TrustedListenableFutureTaskTest extends TestCase {\n", "\n", "  public void testSuccessful() throws Exception {\n", "    TrustedListenableFutureTask<Integer> task = TrustedListenableFutureTask.create(returning(2));\n", "    assertFalse(task.isDone());\n", "    task.run();\n", "    assertTrue(task.isDone());\n", "    assertFalse(task.isCancelled());\n", "    assertEquals(2, task.get().intValue());\n", "  }\n", "\n", "  public void testCancelled() throws Exception {\n", "    TrustedListenableFutureTask<Integer> task = TrustedListenableFutureTask.create(returning(2));\n", "    assertFalse(task.isDone());\n", "    task.cancel(false);\n", "    assertTrue(task.isDone());\n", "    assertTrue(task.isCancelled());\n", "    assertFalse(task.wasInterrupted());\n", "    try {\n", "      task.get();\n", "      fail();\n", "    } catch (CancellationException expected) {\n", "    }\n", "    verifyThreadWasNotInterrupted();\n", "  }\n", "\n", "  public void testFailed() throws Exception {\n", "    final Exception e = new Exception();\n", "    TrustedListenableFutureTask<Integer> task = TrustedListenableFutureTask.create(\n", "        new Callable<Integer>() {\n", "          @Override public Integer call() throws Exception {\n", "            throw e;\n", "          }\n", "        });\n", "    task.run();\n", "    assertTrue(task.isDone());\n", "    assertFalse(task.isCancelled());\n", "    try {\n", "      task.get();\n", "      fail();\n", "    } catch (ExecutionException executionException) {\n", "      assertEquals(e, executionException.getCause());\n", "    }\n", "  }\n", "}\n", ""]}, "added_lines": {}, "removed_lines": {"1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79]}}]}
