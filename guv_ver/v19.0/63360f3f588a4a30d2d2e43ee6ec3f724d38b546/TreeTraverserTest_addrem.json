{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n",
        "5": " * in compliance with the License.  You may obtain a copy of the License at\n",
        "6": " *\n",
        "7": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "8": " *\n",
        "9": " * Unless required by applicable law or agreed to in writing, software distributed under the License\n",
        "10": " * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n",
        "11": " * or implied.  See the License for the specific language governing permissions and limitations\n",
        "12": " * under the License.\n",
        "13": " */\n",
        "14": "\n",
        "15": "package com.google.common.collect;\n",
        "16": "\n",
        "17": "import static com.google.common.truth.Truth.assertThat;\n",
        "18": "\n",
        "19": "import com.google.common.annotations.GwtCompatible;\n",
        "20": "import com.google.common.base.Optional;\n",
        "21": "\n",
        "22": "import junit.framework.TestCase;\n",
        "23": "\n",
        "24": "import java.util.Arrays;\n",
        "25": "import java.util.List;\n",
        "26": "\n",
        "27": "import javax.annotation.Nullable;\n",
        "28": "\n",
        "29": "/**\n",
        "30": " * Tests for {@code TreeTraverser}.\n",
        "31": " *\n",
        "32": " * @author Louis Wasserman\n",
        "33": " */\n",
        "34": "@GwtCompatible(emulated = true)\n",
        "35": "public class TreeTraverserTest extends TestCase {\n",
        "36": "  private static final class Tree {\n",
        "37": "    final char value;\n",
        "38": "    final List<Tree> children;\n",
        "39": "\n",
        "40": "    public Tree(char value, Tree... children) {\n",
        "41": "      this.value = value;\n",
        "42": "      this.children = Arrays.asList(children);\n",
        "43": "    }\n",
        "44": "  }\n",
        "45": "\n",
        "46": "  private static final class BinaryTree {\n",
        "47": "    final char value;\n",
        "48": "    @Nullable\n",
        "49": "    final BinaryTree left;\n",
        "50": "    @Nullable\n",
        "51": "    final BinaryTree right;\n",
        "52": "\n",
        "53": "    private BinaryTree(char value, BinaryTree left, BinaryTree right) {\n",
        "54": "      this.value = value;\n",
        "55": "      this.left = left;\n",
        "56": "      this.right = right;\n",
        "57": "    }\n",
        "58": "  }\n",
        "59": "\n",
        "60": "  private static final TreeTraverser<Tree> ADAPTER = new TreeTraverser<Tree>() {\n",
        "61": "    @Override\n",
        "62": "    public Iterable<Tree> children(Tree node) {\n",
        "63": "      return node.children;\n",
        "64": "    }\n",
        "65": "  };\n",
        "66": "\n",
        "67": "  private static final BinaryTreeTraverser<BinaryTree> BIN_ADAPTER =\n",
        "68": "      new BinaryTreeTraverser<BinaryTree>() {\n",
        "69": "\n",
        "70": "    @Override\n",
        "71": "    public Optional<BinaryTree> leftChild(BinaryTree node) {\n",
        "72": "      return Optional.fromNullable(node.left);\n",
        "73": "    }\n",
        "74": "\n",
        "75": "    @Override\n",
        "76": "    public Optional<BinaryTree> rightChild(BinaryTree node) {\n",
        "77": "      return Optional.fromNullable(node.right);\n",
        "78": "    }\n",
        "79": "  };\n",
        "80": "\n",
        "81": "  //        h\n",
        "82": "  //      / | \\\n",
        "83": "  //     /  e  \\\n",
        "84": "  //    d       g\n",
        "85": "  //   /|\\      |\n",
        "86": "  //  / | \\     f\n",
        "87": "  // a  b  c\n",
        "88": "  static final Tree a = new Tree('a');\n",
        "89": "  static final Tree b = new Tree('b');\n",
        "90": "  static final Tree c = new Tree('c');\n",
        "91": "  static final Tree d = new Tree('d', a, b, c);\n",
        "92": "  static final Tree e = new Tree('e');\n",
        "93": "  static final Tree f = new Tree('f');\n",
        "94": "  static final Tree g = new Tree('g', f);\n",
        "95": "  static final Tree h = new Tree('h', d, e, g);\n",
        "96": "\n",
        "97": "  //      d\n",
        "98": "  //     / \\\n",
        "99": "  //    b   e\n",
        "100": "  //   / \\   \\\n",
        "101": "  //  a   c   f\n",
        "102": "  //         /\n",
        "103": "  //        g\n",
        "104": "  static final BinaryTree ba = new BinaryTree('a', null, null);\n",
        "105": "  static final BinaryTree bc = new BinaryTree('c', null, null);\n",
        "106": "  static final BinaryTree bb = new BinaryTree('b', ba, bc);\n",
        "107": "  static final BinaryTree bg = new BinaryTree('g', null, null);\n",
        "108": "  static final BinaryTree bf = new BinaryTree('f', bg, null);\n",
        "109": "  static final BinaryTree be = new BinaryTree('e', null, bf);\n",
        "110": "  static final BinaryTree bd = new BinaryTree('d', bb, be);\n",
        "111": "\n",
        "112": "  static String iterationOrder(Iterable<Tree> iterable) {\n",
        "113": "    StringBuilder builder = new StringBuilder();\n",
        "114": "    for (Tree t : iterable) {\n",
        "115": "      builder.append(t.value);\n",
        "116": "    }\n",
        "117": "    return builder.toString();\n",
        "118": "  }\n",
        "119": "\n",
        "120": "  static String binaryIterationOrder(Iterable<BinaryTree> iterable) {\n",
        "121": "    StringBuilder builder = new StringBuilder();\n",
        "122": "    for (BinaryTree t : iterable) {\n",
        "123": "      builder.append(t.value);\n",
        "124": "    }\n",
        "125": "    return builder.toString();\n",
        "126": "  }\n",
        "127": "\n",
        "128": "  public void testPreOrder() {\n",
        "129": "    assertThat(iterationOrder(ADAPTER.preOrderTraversal(h))).isEqualTo(\"hdabcegf\");\n",
        "130": "    assertThat(binaryIterationOrder(BIN_ADAPTER.preOrderTraversal(bd))).isEqualTo(\"dbacefg\");\n",
        "131": "  }\n",
        "132": "\n",
        "133": "  public void testPostOrder() {\n",
        "134": "    assertThat(iterationOrder(ADAPTER.postOrderTraversal(h))).isEqualTo(\"abcdefgh\");\n",
        "135": "    assertThat(binaryIterationOrder(BIN_ADAPTER.postOrderTraversal(bd))).isEqualTo(\"acbgfed\");\n",
        "136": "  }\n",
        "137": "\n",
        "138": "  public void testBreadthOrder() {\n",
        "139": "    assertThat(iterationOrder(ADAPTER.breadthFirstTraversal(h))).isEqualTo(\"hdegabcf\");\n",
        "140": "    assertThat(binaryIterationOrder(BIN_ADAPTER.breadthFirstTraversal(bd))).isEqualTo(\"dbeacfg\");\n",
        "141": "  }\n",
        "142": "\n",
        "143": "  public void testInOrder() {\n",
        "144": "    assertThat(binaryIterationOrder(BIN_ADAPTER.inOrderTraversal(bd))).isEqualTo(\"abcdegf\");\n",
        "145": "  }\n",
        "146": "}\n",
        "147": "\n"
    }
}