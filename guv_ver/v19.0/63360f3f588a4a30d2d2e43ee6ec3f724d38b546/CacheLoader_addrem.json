{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.cache;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "\n",
        "21": "import com.google.common.annotations.GwtCompatible;\n",
        "22": "import com.google.common.base.Function;\n",
        "23": "import com.google.common.base.Supplier;\n",
        "24": "\n",
        "25": "import java.io.Serializable;\n",
        "26": "import java.util.Map;\n",
        "27": "\n",
        "28": "/**\n",
        "29": " * Computes or retrieves values, based on a key, for use in populating a {@link LoadingCache}.\n",
        "30": " *\n",
        "31": " * <p>Most implementations will only need to implement {@link #load}. Other methods may be\n",
        "32": " * overridden as desired.\n",
        "33": " *\n",
        "34": " * <p>Usage example: <pre>   {@code\n",
        "35": " *\n",
        "36": " *   CacheLoader<Key, Graph> loader = new CacheLoader<Key, Graph>() {\n",
        "37": " *     public Graph load(Key key) throws AnyException {\n",
        "38": " *       return createExpensiveGraph(key);\n",
        "39": " *     }\n",
        "40": " *   };\n",
        "41": " *   LoadingCache<Key, Graph> cache = CacheBuilder.newBuilder().build(loader);}</pre>\n",
        "42": " *\n",
        "43": " * @author Charles Fry\n",
        "44": " * @since 10.0\n",
        "45": " */\n",
        "46": "@GwtCompatible(emulated = true)\n",
        "47": "public abstract class CacheLoader<K, V> {\n",
        "48": "  /**\n",
        "49": "   * Constructor for use by subclasses.\n",
        "50": "   */\n",
        "51": "  protected CacheLoader() {}\n",
        "52": "\n",
        "53": "  /**\n",
        "54": "   * Computes or retrieves the value corresponding to {@code key}.\n",
        "55": "   *\n",
        "56": "   * @param key the non-null key whose value should be loaded\n",
        "57": "   * @return the value associated with {@code key}; <b>must not be null</b>\n",
        "58": "   * @throws Exception if unable to load the result\n",
        "59": "   * @throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n",
        "60": "   *     treated like any other {@code Exception} in all respects except that, when it is caught,\n",
        "61": "   *     the thread's interrupt status is set\n",
        "62": "   */\n",
        "63": "  public abstract V load(K key) throws Exception;\n",
        "64": "\n",
        "65": "  /**\n",
        "66": "   * Computes or retrieves the values corresponding to {@code keys}. This method is called by\n",
        "67": "   * {@link LoadingCache#getAll}.\n",
        "68": "   *\n",
        "69": "   * <p>If the returned map doesn't contain all requested {@code keys} then the entries it does\n",
        "70": "   * contain will be cached, but {@code getAll} will throw an exception. If the returned map\n",
        "71": "   * contains extra keys not present in {@code keys} then all returned entries will be cached,\n",
        "72": "   * but only the entries for {@code keys} will be returned from {@code getAll}.\n",
        "73": "   *\n",
        "74": "   * <p>This method should be overriden when bulk retrieval is significantly more efficient than\n",
        "75": "   * many individual lookups. Note that {@link LoadingCache#getAll} will defer to individual calls\n",
        "76": "   * to {@link LoadingCache#get} if this method is not overriden.\n",
        "77": "   *\n",
        "78": "   * @param keys the unique, non-null keys whose values should be loaded\n",
        "79": "   * @return a map from each key in {@code keys} to the value associated with that key;\n",
        "80": "   *     <b>may not contain null values</b>\n",
        "81": "   * @throws Exception if unable to load the result\n",
        "82": "   * @throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n",
        "83": "   *     treated like any other {@code Exception} in all respects except that, when it is caught,\n",
        "84": "   *     the thread's interrupt status is set\n",
        "85": "   * @since 11.0\n",
        "86": "   */\n",
        "87": "  public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {\n",
        "88": "    // This will be caught by getAll(), causing it to fall back to multiple calls to\n",
        "89": "    // LoadingCache.get\n",
        "90": "    throw new UnsupportedLoadingOperationException();\n",
        "91": "  }\n",
        "92": "\n",
        "93": "  /**\n",
        "94": "   * Returns a cache loader based on an <i>existing</i> function instance. Note that there's no need\n",
        "95": "   * to create a <i>new</i> function just to pass it in here; just subclass {@code CacheLoader} and\n",
        "96": "   * implement {@link #load load} instead.\n",
        "97": "   *\n",
        "98": "   * @param function the function to be used for loading values; must never return {@code null}\n",
        "99": "   * @return a cache loader that loads values by passing each key to {@code function}\n",
        "100": "   */\n",
        "101": "  public static <K, V> CacheLoader<K, V> from(Function<K, V> function) {\n",
        "102": "    return new FunctionToCacheLoader<K, V>(function);\n",
        "103": "  }\n",
        "104": "\n",
        "105": "  private static final class FunctionToCacheLoader<K, V>\n",
        "106": "      extends CacheLoader<K, V> implements Serializable {\n",
        "107": "    private final Function<K, V> computingFunction;\n",
        "108": "\n",
        "109": "    public FunctionToCacheLoader(Function<K, V> computingFunction) {\n",
        "110": "      this.computingFunction = checkNotNull(computingFunction);\n",
        "111": "    }\n",
        "112": "\n",
        "113": "    @Override\n",
        "114": "    public V load(K key) {\n",
        "115": "      return computingFunction.apply(checkNotNull(key));\n",
        "116": "    }\n",
        "117": "\n",
        "118": "    private static final long serialVersionUID = 0;\n",
        "119": "  }\n",
        "120": "\n",
        "121": "  /**\n",
        "122": "   * Returns a cache loader based on an <i>existing</i> supplier instance. Note that there's no need\n",
        "123": "   * to create a <i>new</i> supplier just to pass it in here; just subclass {@code CacheLoader} and\n",
        "124": "   * implement {@link #load load} instead.\n",
        "125": "   *\n",
        "126": "   * @param supplier the supplier to be used for loading values; must never return {@code null}\n",
        "127": "   * @return a cache loader that loads values by calling {@link Supplier#get}, irrespective of the\n",
        "128": "   *     key\n",
        "129": "   */\n",
        "130": "  public static <V> CacheLoader<Object, V> from(Supplier<V> supplier) {\n",
        "131": "    return new SupplierToCacheLoader<V>(supplier);\n",
        "132": "  }\n",
        "133": "\n",
        "134": "  private static final class SupplierToCacheLoader<V>\n",
        "135": "      extends CacheLoader<Object, V> implements Serializable {\n",
        "136": "    private final Supplier<V> computingSupplier;\n",
        "137": "\n",
        "138": "    public SupplierToCacheLoader(Supplier<V> computingSupplier) {\n",
        "139": "      this.computingSupplier = checkNotNull(computingSupplier);\n",
        "140": "    }\n",
        "141": "\n",
        "142": "    @Override\n",
        "143": "    public V load(Object key) {\n",
        "144": "      checkNotNull(key);\n",
        "145": "      return computingSupplier.get();\n",
        "146": "    }\n",
        "147": "\n",
        "148": "    private static final long serialVersionUID = 0;\n",
        "149": "  }\n",
        "150": "\n",
        "151": "  /**\n",
        "152": "   * Exception thrown by {@code loadAll()} to indicate that it is not supported.\n",
        "153": "   *\n",
        "154": "   * @since 19.0\n",
        "155": "   */\n",
        "156": "  public static final class UnsupportedLoadingOperationException\n",
        "157": "      extends UnsupportedOperationException {\n",
        "158": "    // Package-private because this should only be thrown by loadAll() when it is not overridden.\n",
        "159": "    // Cache implementors may want to catch it but should not need to be able to throw it.\n",
        "160": "    UnsupportedLoadingOperationException() {}\n",
        "161": "  }\n",
        "162": "\n",
        "163": "  /**\n",
        "164": "   * Thrown to indicate that an invalid response was returned from a call to {@link CacheLoader}.\n",
        "165": "   *\n",
        "166": "   * @since 11.0\n",
        "167": "   */\n",
        "168": "  public static final class InvalidCacheLoadException extends RuntimeException {\n",
        "169": "    public InvalidCacheLoadException(String message) {\n",
        "170": "      super(message);\n",
        "171": "    }\n",
        "172": "  }\n",
        "173": "}\n",
        "174": "\n"
    }
}