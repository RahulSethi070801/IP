{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2007 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.collect;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "20": "import static com.google.common.collect.CollectPreconditions.checkNonnegative;\n",
        "21": "import static com.google.common.collect.CollectPreconditions.checkRemove;\n",
        "22": "\n",
        "23": "import com.google.common.annotations.Beta;\n",
        "24": "import com.google.common.annotations.GwtCompatible;\n",
        "25": "import com.google.common.base.Function;\n",
        "26": "import com.google.common.base.Predicate;\n",
        "27": "import com.google.common.base.Predicates;\n",
        "28": "import com.google.common.base.Supplier;\n",
        "29": "import com.google.common.collect.Maps.EntryTransformer;\n",
        "30": "import com.google.j2objc.annotations.Weak;\n",
        "31": "import com.google.j2objc.annotations.WeakOuter;\n",
        "32": "\n",
        "33": "import java.io.Serializable;\n",
        "34": "import java.util.AbstractCollection;\n",
        "35": "import java.util.Collection;\n",
        "36": "import java.util.Collections;\n",
        "37": "import java.util.Comparator;\n",
        "38": "import java.util.HashSet;\n",
        "39": "import java.util.Iterator;\n",
        "40": "import java.util.List;\n",
        "41": "import java.util.Map;\n",
        "42": "import java.util.Map.Entry;\n",
        "43": "import java.util.NoSuchElementException;\n",
        "44": "import java.util.Set;\n",
        "45": "import java.util.SortedSet;\n",
        "46": "\n",
        "47": "import javax.annotation.CheckReturnValue;\n",
        "48": "import javax.annotation.Nullable;\n",
        "49": "\n",
        "50": "/**\n",
        "51": " * Provides static methods acting on or generating a {@code Multimap}.\n",
        "52": " *\n",
        "53": " * <p>See the Guava User Guide article on <a href=\n",
        "54": " * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps\">\n",
        "55": " * {@code Multimaps}</a>.\n",
        "56": " *\n",
        "57": " * @author Jared Levy\n",
        "58": " * @author Robert Konigsberg\n",
        "59": " * @author Mike Bostock\n",
        "60": " * @author Louis Wasserman\n",
        "61": " * @since 2.0\n",
        "62": " */\n",
        "63": "@GwtCompatible(emulated = true)\n",
        "64": "public final class Multimaps {\n",
        "65": "  private Multimaps() {}\n",
        "66": "\n",
        "67": "  /**\n",
        "68": "   * Creates a new {@code Multimap} backed by {@code map}, whose internal value\n",
        "69": "   * collections are generated by {@code factory}.\n",
        "70": "   *\n",
        "71": "   * <b>Warning: do not use</b> this method when the collections returned by\n",
        "72": "   * {@code factory} implement either {@link List} or {@code Set}! Use the more\n",
        "73": "   * specific method {@link #newListMultimap}, {@link #newSetMultimap} or {@link\n",
        "74": "   * #newSortedSetMultimap} instead, to avoid very surprising behavior from\n",
        "75": "   * {@link Multimap#equals}.\n",
        "76": "   *\n",
        "77": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "78": "   * multimap iteration order. They also specify the behavior of the\n",
        "79": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "80": "   * multimap and its returned views. However, the multimap's {@code get}\n",
        "81": "   * method returns instances of a different class than {@code factory.get()}\n",
        "82": "   * does.\n",
        "83": "   *\n",
        "84": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "85": "   * collections generated by {@code factory}, and the multimap contents are all\n",
        "86": "   * serializable.\n",
        "87": "   *\n",
        "88": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "89": "   * multimap, even if {@code map} and the instances generated by\n",
        "90": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "91": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "92": "   * {@link #synchronizedMultimap}.\n",
        "93": "   *\n",
        "94": "   * <p>Call this method only when the simpler methods\n",
        "95": "   * {@link ArrayListMultimap#create()}, {@link HashMultimap#create()},\n",
        "96": "   * {@link LinkedHashMultimap#create()}, {@link LinkedListMultimap#create()},\n",
        "97": "   * {@link TreeMultimap#create()}, and\n",
        "98": "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "99": "   *\n",
        "100": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "101": "   * the collections returned by {@code factory}. Those objects should not be\n",
        "102": "   * manually updated and they should not use soft, weak, or phantom references.\n",
        "103": "   *\n",
        "104": "   * @param map place to store the mapping from each key to its corresponding\n",
        "105": "   *     values\n",
        "106": "   * @param factory supplier of new, empty collections that will each hold all\n",
        "107": "   *     values for a given key\n",
        "108": "   * @throws IllegalArgumentException if {@code map} is not empty\n",
        "109": "   */\n",
        "110": "  public static <K, V> Multimap<K, V> newMultimap(\n",
        "111": "      Map<K, Collection<V>> map, final Supplier<? extends Collection<V>> factory) {\n",
        "112": "    return new CustomMultimap<K, V>(map, factory);\n",
        "113": "  }\n",
        "114": "\n",
        "115": "  private static class CustomMultimap<K, V> extends AbstractMapBasedMultimap<K, V> {\n",
        "116": "    transient Supplier<? extends Collection<V>> factory;\n",
        "117": "\n",
        "118": "    CustomMultimap(Map<K, Collection<V>> map, Supplier<? extends Collection<V>> factory) {\n",
        "119": "      super(map);\n",
        "120": "      this.factory = checkNotNull(factory);\n",
        "121": "    }\n",
        "122": "\n",
        "123": "    @Override\n",
        "124": "    protected Collection<V> createCollection() {\n",
        "125": "      return factory.get();\n",
        "126": "    }\n",
        "127": "\n",
        "128": "    // can't use Serialization writeMultimap and populateMultimap methods since\n",
        "129": "    // there's no way to generate the empty backing map.\n",
        "130": "  }\n",
        "131": "\n",
        "132": "  /**\n",
        "133": "   * Creates a new {@code ListMultimap} that uses the provided map and factory.\n",
        "134": "   * It can generate a multimap based on arbitrary {@link Map} and {@link List}\n",
        "135": "   * classes.\n",
        "136": "   *\n",
        "137": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "138": "   * multimap iteration order. They also specify the behavior of the\n",
        "139": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "140": "   * multimap and its returned views. The multimap's {@code get}, {@code\n",
        "141": "   * removeAll}, and {@code replaceValues} methods return {@code RandomAccess}\n",
        "142": "   * lists if the factory does. However, the multimap's {@code get} method\n",
        "143": "   * returns instances of a different class than does {@code factory.get()}.\n",
        "144": "   *\n",
        "145": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "146": "   * lists generated by {@code factory}, and the multimap contents are all\n",
        "147": "   * serializable.\n",
        "148": "   *\n",
        "149": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "150": "   * multimap, even if {@code map} and the instances generated by\n",
        "151": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "152": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "153": "   * {@link #synchronizedListMultimap}.\n",
        "154": "   *\n",
        "155": "   * <p>Call this method only when the simpler methods\n",
        "156": "   * {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}\n",
        "157": "   * won't suffice.\n",
        "158": "   *\n",
        "159": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "160": "   * the lists returned by {@code factory}. Those objects should not be manually\n",
        "161": "   * updated, they should be empty when provided, and they should not use soft,\n",
        "162": "   * weak, or phantom references.\n",
        "163": "   *\n",
        "164": "   * @param map place to store the mapping from each key to its corresponding\n",
        "165": "   *     values\n",
        "166": "   * @param factory supplier of new, empty lists that will each hold all values\n",
        "167": "   *     for a given key\n",
        "168": "   * @throws IllegalArgumentException if {@code map} is not empty\n",
        "169": "   */\n",
        "170": "  public static <K, V> ListMultimap<K, V> newListMultimap(\n",
        "171": "      Map<K, Collection<V>> map, final Supplier<? extends List<V>> factory) {\n",
        "172": "    return new CustomListMultimap<K, V>(map, factory);\n",
        "173": "  }\n",
        "174": "\n",
        "175": "  private static class CustomListMultimap<K, V> extends AbstractListMultimap<K, V> {\n",
        "176": "    transient Supplier<? extends List<V>> factory;\n",
        "177": "\n",
        "178": "    CustomListMultimap(Map<K, Collection<V>> map, Supplier<? extends List<V>> factory) {\n",
        "179": "      super(map);\n",
        "180": "      this.factory = checkNotNull(factory);\n",
        "181": "    }\n",
        "182": "\n",
        "183": "    @Override\n",
        "184": "    protected List<V> createCollection() {\n",
        "185": "      return factory.get();\n",
        "186": "    }\n",
        "187": "  }\n",
        "188": "\n",
        "189": "  /**\n",
        "190": "   * Creates a new {@code SetMultimap} that uses the provided map and factory.\n",
        "191": "   * It can generate a multimap based on arbitrary {@link Map} and {@link Set}\n",
        "192": "   * classes.\n",
        "193": "   *\n",
        "194": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "195": "   * multimap iteration order. They also specify the behavior of the\n",
        "196": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "197": "   * multimap and its returned views. However, the multimap's {@code get}\n",
        "198": "   * method returns instances of a different class than {@code factory.get()}\n",
        "199": "   * does.\n",
        "200": "   *\n",
        "201": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "202": "   * sets generated by {@code factory}, and the multimap contents are all\n",
        "203": "   * serializable.\n",
        "204": "   *\n",
        "205": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "206": "   * multimap, even if {@code map} and the instances generated by\n",
        "207": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "208": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "209": "   * {@link #synchronizedSetMultimap}.\n",
        "210": "   *\n",
        "211": "   * <p>Call this method only when the simpler methods\n",
        "212": "   * {@link HashMultimap#create()}, {@link LinkedHashMultimap#create()},\n",
        "213": "   * {@link TreeMultimap#create()}, and\n",
        "214": "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "215": "   *\n",
        "216": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "217": "   * the sets returned by {@code factory}. Those objects should not be manually\n",
        "218": "   * updated and they should not use soft, weak, or phantom references.\n",
        "219": "   *\n",
        "220": "   * @param map place to store the mapping from each key to its corresponding\n",
        "221": "   *     values\n",
        "222": "   * @param factory supplier of new, empty sets that will each hold all values\n",
        "223": "   *     for a given key\n",
        "224": "   * @throws IllegalArgumentException if {@code map} is not empty\n",
        "225": "   */\n",
        "226": "  public static <K, V> SetMultimap<K, V> newSetMultimap(\n",
        "227": "      Map<K, Collection<V>> map, final Supplier<? extends Set<V>> factory) {\n",
        "228": "    return new CustomSetMultimap<K, V>(map, factory);\n",
        "229": "  }\n",
        "230": "\n",
        "231": "  private static class CustomSetMultimap<K, V> extends AbstractSetMultimap<K, V> {\n",
        "232": "    transient Supplier<? extends Set<V>> factory;\n",
        "233": "\n",
        "234": "    CustomSetMultimap(Map<K, Collection<V>> map, Supplier<? extends Set<V>> factory) {\n",
        "235": "      super(map);\n",
        "236": "      this.factory = checkNotNull(factory);\n",
        "237": "    }\n",
        "238": "\n",
        "239": "    @Override\n",
        "240": "    protected Set<V> createCollection() {\n",
        "241": "      return factory.get();\n",
        "242": "    }\n",
        "243": "  }\n",
        "244": "\n",
        "245": "  /**\n",
        "246": "   * Creates a new {@code SortedSetMultimap} that uses the provided map and\n",
        "247": "   * factory. It can generate a multimap based on arbitrary {@link Map} and\n",
        "248": "   * {@link SortedSet} classes.\n",
        "249": "   *\n",
        "250": "   * <p>The {@code factory}-generated and {@code map} classes determine the\n",
        "251": "   * multimap iteration order. They also specify the behavior of the\n",
        "252": "   * {@code equals}, {@code hashCode}, and {@code toString} methods for the\n",
        "253": "   * multimap and its returned views. However, the multimap's {@code get}\n",
        "254": "   * method returns instances of a different class than {@code factory.get()}\n",
        "255": "   * does.\n",
        "256": "   *\n",
        "257": "   * <p>The multimap is serializable if {@code map}, {@code factory}, the\n",
        "258": "   * sets generated by {@code factory}, and the multimap contents are all\n",
        "259": "   * serializable.\n",
        "260": "   *\n",
        "261": "   * <p>The multimap is not threadsafe when any concurrent operations update the\n",
        "262": "   * multimap, even if {@code map} and the instances generated by\n",
        "263": "   * {@code factory} are. Concurrent read operations will work correctly. To\n",
        "264": "   * allow concurrent update operations, wrap the multimap with a call to\n",
        "265": "   * {@link #synchronizedSortedSetMultimap}.\n",
        "266": "   *\n",
        "267": "   * <p>Call this method only when the simpler methods\n",
        "268": "   * {@link TreeMultimap#create()} and\n",
        "269": "   * {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.\n",
        "270": "   *\n",
        "271": "   * <p>Note: the multimap assumes complete ownership over of {@code map} and\n",
        "272": "   * the sets returned by {@code factory}. Those objects should not be manually\n",
        "273": "   * updated and they should not use soft, weak, or phantom references.\n",
        "274": "   *\n",
        "275": "   * @param map place to store the mapping from each key to its corresponding\n",
        "276": "   *     values\n",
        "277": "   * @param factory supplier of new, empty sorted sets that will each hold\n",
        "278": "   *     all values for a given key\n",
        "279": "   * @throws IllegalArgumentException if {@code map} is not empty\n",
        "280": "   */\n",
        "281": "  public static <K, V> SortedSetMultimap<K, V> newSortedSetMultimap(\n",
        "282": "      Map<K, Collection<V>> map, final Supplier<? extends SortedSet<V>> factory) {\n",
        "283": "    return new CustomSortedSetMultimap<K, V>(map, factory);\n",
        "284": "  }\n",
        "285": "\n",
        "286": "  private static class CustomSortedSetMultimap<K, V> extends AbstractSortedSetMultimap<K, V> {\n",
        "287": "    transient Supplier<? extends SortedSet<V>> factory;\n",
        "288": "    transient Comparator<? super V> valueComparator;\n",
        "289": "\n",
        "290": "    CustomSortedSetMultimap(Map<K, Collection<V>> map, Supplier<? extends SortedSet<V>> factory) {\n",
        "291": "      super(map);\n",
        "292": "      this.factory = checkNotNull(factory);\n",
        "293": "      valueComparator = factory.get().comparator();\n",
        "294": "    }\n",
        "295": "\n",
        "296": "    @Override\n",
        "297": "    protected SortedSet<V> createCollection() {\n",
        "298": "      return factory.get();\n",
        "299": "    }\n",
        "300": "\n",
        "301": "    @Override\n",
        "302": "    public Comparator<? super V> valueComparator() {\n",
        "303": "      return valueComparator;\n",
        "304": "    }\n",
        "305": "  }\n",
        "306": "\n",
        "307": "  /**\n",
        "308": "   * Copies each key-value mapping in {@code source} into {@code dest}, with\n",
        "309": "   * its key and value reversed.\n",
        "310": "   *\n",
        "311": "   * <p>If {@code source} is an {@link ImmutableMultimap}, consider using\n",
        "312": "   * {@link ImmutableMultimap#inverse} instead.\n",
        "313": "   *\n",
        "314": "   * @param source any multimap\n",
        "315": "   * @param dest the multimap to copy into; usually empty\n",
        "316": "   * @return {@code dest}\n",
        "317": "   */\n",
        "318": "  public static <K, V, M extends Multimap<K, V>> M invertFrom(\n",
        "319": "      Multimap<? extends V, ? extends K> source, M dest) {\n",
        "320": "    checkNotNull(dest);\n",
        "321": "    for (Map.Entry<? extends V, ? extends K> entry : source.entries()) {\n",
        "322": "      dest.put(entry.getValue(), entry.getKey());\n",
        "323": "    }\n",
        "324": "    return dest;\n",
        "325": "  }\n",
        "326": "\n",
        "327": "  /**\n",
        "328": "   * Returns a synchronized (thread-safe) multimap backed by the specified\n",
        "329": "   * multimap. In order to guarantee serial access, it is critical that\n",
        "330": "   * <b>all</b> access to the backing multimap is accomplished through the\n",
        "331": "   * returned multimap.\n",
        "332": "   *\n",
        "333": "   * <p>It is imperative that the user manually synchronize on the returned\n",
        "334": "   * multimap when accessing any of its collection views: <pre>   {@code\n",
        "335": "   *\n",
        "336": "   *   Multimap<K, V> multimap = Multimaps.synchronizedMultimap(\n",
        "337": "   *       HashMultimap.<K, V>create());\n",
        "338": "   *   ...\n",
        "339": "   *   Collection<V> values = multimap.get(key);  // Needn't be in synchronized block\n",
        "340": "   *   ...\n",
        "341": "   *   synchronized (multimap) {  // Synchronizing on multimap, not values!\n",
        "342": "   *     Iterator<V> i = values.iterator(); // Must be in synchronized block\n",
        "343": "   *     while (i.hasNext()) {\n",
        "344": "   *       foo(i.next());\n",
        "345": "   *     }\n",
        "346": "   *   }}</pre>\n",
        "347": "   *\n",
        "348": "   * <p>Failure to follow this advice may result in non-deterministic behavior.\n",
        "349": "   *\n",
        "350": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "351": "   * {@link Multimap#replaceValues} methods return collections that aren't\n",
        "352": "   * synchronized.\n",
        "353": "   *\n",
        "354": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "355": "   * serializable.\n",
        "356": "   *\n",
        "357": "   * @param multimap the multimap to be wrapped in a synchronized view\n",
        "358": "   * @return a synchronized view of the specified multimap\n",
        "359": "   */\n",
        "360": "  public static <K, V> Multimap<K, V> synchronizedMultimap(Multimap<K, V> multimap) {\n",
        "361": "    return Synchronized.multimap(multimap, null);\n",
        "362": "  }\n",
        "363": "\n",
        "364": "  /**\n",
        "365": "   * Returns an unmodifiable view of the specified multimap. Query operations on\n",
        "366": "   * the returned multimap \"read through\" to the specified multimap, and\n",
        "367": "   * attempts to modify the returned multimap, either directly or through the\n",
        "368": "   * multimap's views, result in an {@code UnsupportedOperationException}.\n",
        "369": "   *\n",
        "370": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "371": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "372": "   * modifiable.\n",
        "373": "   *\n",
        "374": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "375": "   * serializable.\n",
        "376": "   *\n",
        "377": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "378": "   *     returned\n",
        "379": "   * @return an unmodifiable view of the specified multimap\n",
        "380": "   */\n",
        "381": "  public static <K, V> Multimap<K, V> unmodifiableMultimap(Multimap<K, V> delegate) {\n",
        "382": "    if (delegate instanceof UnmodifiableMultimap || delegate instanceof ImmutableMultimap) {\n",
        "383": "      return delegate;\n",
        "384": "    }\n",
        "385": "    return new UnmodifiableMultimap<K, V>(delegate);\n",
        "386": "  }\n",
        "387": "\n",
        "388": "  /**\n",
        "389": "   * Simply returns its argument.\n",
        "390": "   *\n",
        "391": "   * @deprecated no need to use this\n",
        "392": "   * @since 10.0\n",
        "393": "   */\n",
        "394": "  @Deprecated\n",
        "395": "  public static <K, V> Multimap<K, V> unmodifiableMultimap(ImmutableMultimap<K, V> delegate) {\n",
        "396": "    return checkNotNull(delegate);\n",
        "397": "  }\n",
        "398": "\n",
        "399": "  private static class UnmodifiableMultimap<K, V> extends ForwardingMultimap<K, V>\n",
        "400": "      implements Serializable {\n",
        "401": "    final Multimap<K, V> delegate;\n",
        "402": "    transient Collection<Entry<K, V>> entries;\n",
        "403": "    transient Multiset<K> keys;\n",
        "404": "    transient Set<K> keySet;\n",
        "405": "    transient Collection<V> values;\n",
        "406": "    transient Map<K, Collection<V>> map;\n",
        "407": "\n",
        "408": "    UnmodifiableMultimap(final Multimap<K, V> delegate) {\n",
        "409": "      this.delegate = checkNotNull(delegate);\n",
        "410": "    }\n",
        "411": "\n",
        "412": "    @Override\n",
        "413": "    protected Multimap<K, V> delegate() {\n",
        "414": "      return delegate;\n",
        "415": "    }\n",
        "416": "\n",
        "417": "    @Override\n",
        "418": "    public void clear() {\n",
        "419": "      throw new UnsupportedOperationException();\n",
        "420": "    }\n",
        "421": "\n",
        "422": "    @Override\n",
        "423": "    public Map<K, Collection<V>> asMap() {\n",
        "424": "      Map<K, Collection<V>> result = map;\n",
        "425": "      if (result == null) {\n",
        "426": "        result = map =\n",
        "427": "            Collections.unmodifiableMap(\n",
        "428": "                Maps.transformValues(\n",
        "429": "                    delegate.asMap(),\n",
        "430": "                    new Function<Collection<V>, Collection<V>>() {\n",
        "431": "                      @Override\n",
        "432": "                      public Collection<V> apply(Collection<V> collection) {\n",
        "433": "                        return unmodifiableValueCollection(collection);\n",
        "434": "                      }\n",
        "435": "                    }));\n",
        "436": "      }\n",
        "437": "      return result;\n",
        "438": "    }\n",
        "439": "\n",
        "440": "    @Override\n",
        "441": "    public Collection<Entry<K, V>> entries() {\n",
        "442": "      Collection<Entry<K, V>> result = entries;\n",
        "443": "      if (result == null) {\n",
        "444": "        entries = result = unmodifiableEntries(delegate.entries());\n",
        "445": "      }\n",
        "446": "      return result;\n",
        "447": "    }\n",
        "448": "\n",
        "449": "    @Override\n",
        "450": "    public Collection<V> get(K key) {\n",
        "451": "      return unmodifiableValueCollection(delegate.get(key));\n",
        "452": "    }\n",
        "453": "\n",
        "454": "    @Override\n",
        "455": "    public Multiset<K> keys() {\n",
        "456": "      Multiset<K> result = keys;\n",
        "457": "      if (result == null) {\n",
        "458": "        keys = result = Multisets.unmodifiableMultiset(delegate.keys());\n",
        "459": "      }\n",
        "460": "      return result;\n",
        "461": "    }\n",
        "462": "\n",
        "463": "    @Override\n",
        "464": "    public Set<K> keySet() {\n",
        "465": "      Set<K> result = keySet;\n",
        "466": "      if (result == null) {\n",
        "467": "        keySet = result = Collections.unmodifiableSet(delegate.keySet());\n",
        "468": "      }\n",
        "469": "      return result;\n",
        "470": "    }\n",
        "471": "\n",
        "472": "    @Override\n",
        "473": "    public boolean put(K key, V value) {\n",
        "474": "      throw new UnsupportedOperationException();\n",
        "475": "    }\n",
        "476": "\n",
        "477": "    @Override\n",
        "478": "    public boolean putAll(K key, Iterable<? extends V> values) {\n",
        "479": "      throw new UnsupportedOperationException();\n",
        "480": "    }\n",
        "481": "\n",
        "482": "    @Override\n",
        "483": "    public boolean putAll(Multimap<? extends K, ? extends V> multimap) {\n",
        "484": "      throw new UnsupportedOperationException();\n",
        "485": "    }\n",
        "486": "\n",
        "487": "    @Override\n",
        "488": "    public boolean remove(Object key, Object value) {\n",
        "489": "      throw new UnsupportedOperationException();\n",
        "490": "    }\n",
        "491": "\n",
        "492": "    @Override\n",
        "493": "    public Collection<V> removeAll(Object key) {\n",
        "494": "      throw new UnsupportedOperationException();\n",
        "495": "    }\n",
        "496": "\n",
        "497": "    @Override\n",
        "498": "    public Collection<V> replaceValues(K key, Iterable<? extends V> values) {\n",
        "499": "      throw new UnsupportedOperationException();\n",
        "500": "    }\n",
        "501": "\n",
        "502": "    @Override\n",
        "503": "    public Collection<V> values() {\n",
        "504": "      Collection<V> result = values;\n",
        "505": "      if (result == null) {\n",
        "506": "        values = result = Collections.unmodifiableCollection(delegate.values());\n",
        "507": "      }\n",
        "508": "      return result;\n",
        "509": "    }\n",
        "510": "\n",
        "511": "    private static final long serialVersionUID = 0;\n",
        "512": "  }\n",
        "513": "\n",
        "514": "  private static class UnmodifiableListMultimap<K, V> extends UnmodifiableMultimap<K, V>\n",
        "515": "      implements ListMultimap<K, V> {\n",
        "516": "    UnmodifiableListMultimap(ListMultimap<K, V> delegate) {\n",
        "517": "      super(delegate);\n",
        "518": "    }\n",
        "519": "\n",
        "520": "    @Override\n",
        "521": "    public ListMultimap<K, V> delegate() {\n",
        "522": "      return (ListMultimap<K, V>) super.delegate();\n",
        "523": "    }\n",
        "524": "\n",
        "525": "    @Override\n",
        "526": "    public List<V> get(K key) {\n",
        "527": "      return Collections.unmodifiableList(delegate().get(key));\n",
        "528": "    }\n",
        "529": "\n",
        "530": "    @Override\n",
        "531": "    public List<V> removeAll(Object key) {\n",
        "532": "      throw new UnsupportedOperationException();\n",
        "533": "    }\n",
        "534": "\n",
        "535": "    @Override\n",
        "536": "    public List<V> replaceValues(K key, Iterable<? extends V> values) {\n",
        "537": "      throw new UnsupportedOperationException();\n",
        "538": "    }\n",
        "539": "\n",
        "540": "    private static final long serialVersionUID = 0;\n",
        "541": "  }\n",
        "542": "\n",
        "543": "  private static class UnmodifiableSetMultimap<K, V> extends UnmodifiableMultimap<K, V>\n",
        "544": "      implements SetMultimap<K, V> {\n",
        "545": "    UnmodifiableSetMultimap(SetMultimap<K, V> delegate) {\n",
        "546": "      super(delegate);\n",
        "547": "    }\n",
        "548": "\n",
        "549": "    @Override\n",
        "550": "    public SetMultimap<K, V> delegate() {\n",
        "551": "      return (SetMultimap<K, V>) super.delegate();\n",
        "552": "    }\n",
        "553": "\n",
        "554": "    @Override\n",
        "555": "    public Set<V> get(K key) {\n",
        "556": "      /*\n",
        "557": "       * Note that this doesn't return a SortedSet when delegate is a\n",
        "558": "       * SortedSetMultiset, unlike (SortedSet<V>) super.get().\n",
        "559": "       */\n",
        "560": "      return Collections.unmodifiableSet(delegate().get(key));\n",
        "561": "    }\n",
        "562": "\n",
        "563": "    @Override\n",
        "564": "    public Set<Map.Entry<K, V>> entries() {\n",
        "565": "      return Maps.unmodifiableEntrySet(delegate().entries());\n",
        "566": "    }\n",
        "567": "\n",
        "568": "    @Override\n",
        "569": "    public Set<V> removeAll(Object key) {\n",
        "570": "      throw new UnsupportedOperationException();\n",
        "571": "    }\n",
        "572": "\n",
        "573": "    @Override\n",
        "574": "    public Set<V> replaceValues(K key, Iterable<? extends V> values) {\n",
        "575": "      throw new UnsupportedOperationException();\n",
        "576": "    }\n",
        "577": "\n",
        "578": "    private static final long serialVersionUID = 0;\n",
        "579": "  }\n",
        "580": "\n",
        "581": "  private static class UnmodifiableSortedSetMultimap<K, V> extends UnmodifiableSetMultimap<K, V>\n",
        "582": "      implements SortedSetMultimap<K, V> {\n",
        "583": "    UnmodifiableSortedSetMultimap(SortedSetMultimap<K, V> delegate) {\n",
        "584": "      super(delegate);\n",
        "585": "    }\n",
        "586": "\n",
        "587": "    @Override\n",
        "588": "    public SortedSetMultimap<K, V> delegate() {\n",
        "589": "      return (SortedSetMultimap<K, V>) super.delegate();\n",
        "590": "    }\n",
        "591": "\n",
        "592": "    @Override\n",
        "593": "    public SortedSet<V> get(K key) {\n",
        "594": "      return Collections.unmodifiableSortedSet(delegate().get(key));\n",
        "595": "    }\n",
        "596": "\n",
        "597": "    @Override\n",
        "598": "    public SortedSet<V> removeAll(Object key) {\n",
        "599": "      throw new UnsupportedOperationException();\n",
        "600": "    }\n",
        "601": "\n",
        "602": "    @Override\n",
        "603": "    public SortedSet<V> replaceValues(K key, Iterable<? extends V> values) {\n",
        "604": "      throw new UnsupportedOperationException();\n",
        "605": "    }\n",
        "606": "\n",
        "607": "    @Override\n",
        "608": "    public Comparator<? super V> valueComparator() {\n",
        "609": "      return delegate().valueComparator();\n",
        "610": "    }\n",
        "611": "\n",
        "612": "    private static final long serialVersionUID = 0;\n",
        "613": "  }\n",
        "614": "\n",
        "615": "  /**\n",
        "616": "   * Returns a synchronized (thread-safe) {@code SetMultimap} backed by the\n",
        "617": "   * specified multimap.\n",
        "618": "   *\n",
        "619": "   * <p>You must follow the warnings described in {@link #synchronizedMultimap}.\n",
        "620": "   *\n",
        "621": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "622": "   * serializable.\n",
        "623": "   *\n",
        "624": "   * @param multimap the multimap to be wrapped\n",
        "625": "   * @return a synchronized view of the specified multimap\n",
        "626": "   */\n",
        "627": "  public static <K, V> SetMultimap<K, V> synchronizedSetMultimap(SetMultimap<K, V> multimap) {\n",
        "628": "    return Synchronized.setMultimap(multimap, null);\n",
        "629": "  }\n",
        "630": "\n",
        "631": "  /**\n",
        "632": "   * Returns an unmodifiable view of the specified {@code SetMultimap}. Query\n",
        "633": "   * operations on the returned multimap \"read through\" to the specified\n",
        "634": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "635": "   * through the multimap's views, result in an\n",
        "636": "   * {@code UnsupportedOperationException}.\n",
        "637": "   *\n",
        "638": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "639": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "640": "   * modifiable.\n",
        "641": "   *\n",
        "642": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "643": "   * serializable.\n",
        "644": "   *\n",
        "645": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "646": "   *     returned\n",
        "647": "   * @return an unmodifiable view of the specified multimap\n",
        "648": "   */\n",
        "649": "  public static <K, V> SetMultimap<K, V> unmodifiableSetMultimap(SetMultimap<K, V> delegate) {\n",
        "650": "    if (delegate instanceof UnmodifiableSetMultimap || delegate instanceof ImmutableSetMultimap) {\n",
        "651": "      return delegate;\n",
        "652": "    }\n",
        "653": "    return new UnmodifiableSetMultimap<K, V>(delegate);\n",
        "654": "  }\n",
        "655": "\n",
        "656": "  /**\n",
        "657": "   * Simply returns its argument.\n",
        "658": "   *\n",
        "659": "   * @deprecated no need to use this\n",
        "660": "   * @since 10.0\n",
        "661": "   */\n",
        "662": "  @Deprecated\n",
        "663": "  public static <K, V> SetMultimap<K, V> unmodifiableSetMultimap(\n",
        "664": "      ImmutableSetMultimap<K, V> delegate) {\n",
        "665": "    return checkNotNull(delegate);\n",
        "666": "  }\n",
        "667": "\n",
        "668": "  /**\n",
        "669": "   * Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by\n",
        "670": "   * the specified multimap.\n",
        "671": "   *\n",
        "672": "   * <p>You must follow the warnings described in {@link #synchronizedMultimap}.\n",
        "673": "   *\n",
        "674": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "675": "   * serializable.\n",
        "676": "   *\n",
        "677": "   * @param multimap the multimap to be wrapped\n",
        "678": "   * @return a synchronized view of the specified multimap\n",
        "679": "   */\n",
        "680": "  public static <K, V> SortedSetMultimap<K, V> synchronizedSortedSetMultimap(\n",
        "681": "      SortedSetMultimap<K, V> multimap) {\n",
        "682": "    return Synchronized.sortedSetMultimap(multimap, null);\n",
        "683": "  }\n",
        "684": "\n",
        "685": "  /**\n",
        "686": "   * Returns an unmodifiable view of the specified {@code SortedSetMultimap}.\n",
        "687": "   * Query operations on the returned multimap \"read through\" to the specified\n",
        "688": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "689": "   * through the multimap's views, result in an\n",
        "690": "   * {@code UnsupportedOperationException}.\n",
        "691": "   *\n",
        "692": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "693": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "694": "   * modifiable.\n",
        "695": "   *\n",
        "696": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "697": "   * serializable.\n",
        "698": "   *\n",
        "699": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "700": "   *     returned\n",
        "701": "   * @return an unmodifiable view of the specified multimap\n",
        "702": "   */\n",
        "703": "  public static <K, V> SortedSetMultimap<K, V> unmodifiableSortedSetMultimap(\n",
        "704": "      SortedSetMultimap<K, V> delegate) {\n",
        "705": "    if (delegate instanceof UnmodifiableSortedSetMultimap) {\n",
        "706": "      return delegate;\n",
        "707": "    }\n",
        "708": "    return new UnmodifiableSortedSetMultimap<K, V>(delegate);\n",
        "709": "  }\n",
        "710": "\n",
        "711": "  /**\n",
        "712": "   * Returns a synchronized (thread-safe) {@code ListMultimap} backed by the\n",
        "713": "   * specified multimap.\n",
        "714": "   *\n",
        "715": "   * <p>You must follow the warnings described in {@link #synchronizedMultimap}.\n",
        "716": "   *\n",
        "717": "   * @param multimap the multimap to be wrapped\n",
        "718": "   * @return a synchronized view of the specified multimap\n",
        "719": "   */\n",
        "720": "  public static <K, V> ListMultimap<K, V> synchronizedListMultimap(ListMultimap<K, V> multimap) {\n",
        "721": "    return Synchronized.listMultimap(multimap, null);\n",
        "722": "  }\n",
        "723": "\n",
        "724": "  /**\n",
        "725": "   * Returns an unmodifiable view of the specified {@code ListMultimap}. Query\n",
        "726": "   * operations on the returned multimap \"read through\" to the specified\n",
        "727": "   * multimap, and attempts to modify the returned multimap, either directly or\n",
        "728": "   * through the multimap's views, result in an\n",
        "729": "   * {@code UnsupportedOperationException}.\n",
        "730": "   *\n",
        "731": "   * <p>Note that the generated multimap's {@link Multimap#removeAll} and\n",
        "732": "   * {@link Multimap#replaceValues} methods return collections that are\n",
        "733": "   * modifiable.\n",
        "734": "   *\n",
        "735": "   * <p>The returned multimap will be serializable if the specified multimap is\n",
        "736": "   * serializable.\n",
        "737": "   *\n",
        "738": "   * @param delegate the multimap for which an unmodifiable view is to be\n",
        "739": "   *     returned\n",
        "740": "   * @return an unmodifiable view of the specified multimap\n",
        "741": "   */\n",
        "742": "  public static <K, V> ListMultimap<K, V> unmodifiableListMultimap(ListMultimap<K, V> delegate) {\n",
        "743": "    if (delegate instanceof UnmodifiableListMultimap || delegate instanceof ImmutableListMultimap) {\n",
        "744": "      return delegate;\n",
        "745": "    }\n",
        "746": "    return new UnmodifiableListMultimap<K, V>(delegate);\n",
        "747": "  }\n",
        "748": "\n",
        "749": "  /**\n",
        "750": "   * Simply returns its argument.\n",
        "751": "   *\n",
        "752": "   * @deprecated no need to use this\n",
        "753": "   * @since 10.0\n",
        "754": "   */\n",
        "755": "  @Deprecated\n",
        "756": "  public static <K, V> ListMultimap<K, V> unmodifiableListMultimap(\n",
        "757": "      ImmutableListMultimap<K, V> delegate) {\n",
        "758": "    return checkNotNull(delegate);\n",
        "759": "  }\n",
        "760": "\n",
        "761": "  /**\n",
        "762": "   * Returns an unmodifiable view of the specified collection, preserving the\n",
        "763": "   * interface for instances of {@code SortedSet}, {@code Set}, {@code List} and\n",
        "764": "   * {@code Collection}, in that order of preference.\n",
        "765": "   *\n",
        "766": "   * @param collection the collection for which to return an unmodifiable view\n",
        "767": "   * @return an unmodifiable view of the collection\n",
        "768": "   */\n",
        "769": "  private static <V> Collection<V> unmodifiableValueCollection(Collection<V> collection) {\n",
        "770": "    if (collection instanceof SortedSet) {\n",
        "771": "      return Collections.unmodifiableSortedSet((SortedSet<V>) collection);\n",
        "772": "    } else if (collection instanceof Set) {\n",
        "773": "      return Collections.unmodifiableSet((Set<V>) collection);\n",
        "774": "    } else if (collection instanceof List) {\n",
        "775": "      return Collections.unmodifiableList((List<V>) collection);\n",
        "776": "    }\n",
        "777": "    return Collections.unmodifiableCollection(collection);\n",
        "778": "  }\n",
        "779": "\n",
        "780": "  /**\n",
        "781": "   * Returns an unmodifiable view of the specified collection of entries. The\n",
        "782": "   * {@link Entry#setValue} operation throws an {@link\n",
        "783": "   * UnsupportedOperationException}. If the specified collection is a {@code\n",
        "784": "   * Set}, the returned collection is also a {@code Set}.\n",
        "785": "   *\n",
        "786": "   * @param entries the entries for which to return an unmodifiable view\n",
        "787": "   * @return an unmodifiable view of the entries\n",
        "788": "   */\n",
        "789": "  private static <K, V> Collection<Entry<K, V>> unmodifiableEntries(\n",
        "790": "      Collection<Entry<K, V>> entries) {\n",
        "791": "    if (entries instanceof Set) {\n",
        "792": "      return Maps.unmodifiableEntrySet((Set<Entry<K, V>>) entries);\n",
        "793": "    }\n",
        "794": "    return new Maps.UnmodifiableEntries<K, V>(Collections.unmodifiableCollection(entries));\n",
        "795": "  }\n",
        "796": "\n",
        "797": "  /**\n",
        "798": "   * Returns {@link ListMultimap#asMap multimap.asMap()}, with its type\n",
        "799": "   * corrected from {@code Map<K, Collection<V>>} to {@code Map<K, List<V>>}.\n",
        "800": "   *\n",
        "801": "   * @since 15.0\n",
        "802": "   */\n",
        "803": "  @Beta\n",
        "804": "  @SuppressWarnings(\"unchecked\")\n",
        "805": "  // safe by specification of ListMultimap.asMap()\n",
        "806": "  public static <K, V> Map<K, List<V>> asMap(ListMultimap<K, V> multimap) {\n",
        "807": "    return (Map<K, List<V>>) (Map<K, ?>) multimap.asMap();\n",
        "808": "  }\n",
        "809": "\n",
        "810": "  /**\n",
        "811": "   * Returns {@link SetMultimap#asMap multimap.asMap()}, with its type corrected\n",
        "812": "   * from {@code Map<K, Collection<V>>} to {@code Map<K, Set<V>>}.\n",
        "813": "   *\n",
        "814": "   * @since 15.0\n",
        "815": "   */\n",
        "816": "  @Beta\n",
        "817": "  @SuppressWarnings(\"unchecked\")\n",
        "818": "  // safe by specification of SetMultimap.asMap()\n",
        "819": "  public static <K, V> Map<K, Set<V>> asMap(SetMultimap<K, V> multimap) {\n",
        "820": "    return (Map<K, Set<V>>) (Map<K, ?>) multimap.asMap();\n",
        "821": "  }\n",
        "822": "\n",
        "823": "  /**\n",
        "824": "   * Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type\n",
        "825": "   * corrected from {@code Map<K, Collection<V>>} to\n",
        "826": "   * {@code Map<K, SortedSet<V>>}.\n",
        "827": "   *\n",
        "828": "   * @since 15.0\n",
        "829": "   */\n",
        "830": "  @Beta\n",
        "831": "  @SuppressWarnings(\"unchecked\")\n",
        "832": "  // safe by specification of SortedSetMultimap.asMap()\n",
        "833": "  public static <K, V> Map<K, SortedSet<V>> asMap(SortedSetMultimap<K, V> multimap) {\n",
        "834": "    return (Map<K, SortedSet<V>>) (Map<K, ?>) multimap.asMap();\n",
        "835": "  }\n",
        "836": "\n",
        "837": "  /**\n",
        "838": "   * Returns {@link Multimap#asMap multimap.asMap()}. This is provided for\n",
        "839": "   * parity with the other more strongly-typed {@code asMap()} implementations.\n",
        "840": "   *\n",
        "841": "   * @since 15.0\n",
        "842": "   */\n",
        "843": "  @Beta\n",
        "844": "  public static <K, V> Map<K, Collection<V>> asMap(Multimap<K, V> multimap) {\n",
        "845": "    return multimap.asMap();\n",
        "846": "  }\n",
        "847": "\n",
        "848": "  /**\n",
        "849": "   * Returns a multimap view of the specified map. The multimap is backed by the\n",
        "850": "   * map, so changes to the map are reflected in the multimap, and vice versa.\n",
        "851": "   * If the map is modified while an iteration over one of the multimap's\n",
        "852": "   * collection views is in progress (except through the iterator's own {@code\n",
        "853": "   * remove} operation, or through the {@code setValue} operation on a map entry\n",
        "854": "   * returned by the iterator), the results of the iteration are undefined.\n",
        "855": "   *\n",
        "856": "   * <p>The multimap supports mapping removal, which removes the corresponding\n",
        "857": "   * mapping from the map. It does not support any operations which might add\n",
        "858": "   * mappings, such as {@code put}, {@code putAll} or {@code replaceValues}.\n",
        "859": "   *\n",
        "860": "   * <p>The returned multimap will be serializable if the specified map is\n",
        "861": "   * serializable.\n",
        "862": "   *\n",
        "863": "   * @param map the backing map for the returned multimap view\n",
        "864": "   */\n",
        "865": "  public static <K, V> SetMultimap<K, V> forMap(Map<K, V> map) {\n",
        "866": "    return new MapMultimap<K, V>(map);\n",
        "867": "  }\n",
        "868": "\n",
        "869": "  /** @see Multimaps#forMap */\n",
        "870": "  private static class MapMultimap<K, V> extends AbstractMultimap<K, V>\n",
        "871": "      implements SetMultimap<K, V>, Serializable {\n",
        "872": "    final Map<K, V> map;\n",
        "873": "\n",
        "874": "    MapMultimap(Map<K, V> map) {\n",
        "875": "      this.map = checkNotNull(map);\n",
        "876": "    }\n",
        "877": "\n",
        "878": "    @Override\n",
        "879": "    public int size() {\n",
        "880": "      return map.size();\n",
        "881": "    }\n",
        "882": "\n",
        "883": "    @Override\n",
        "884": "    public boolean containsKey(Object key) {\n",
        "885": "      return map.containsKey(key);\n",
        "886": "    }\n",
        "887": "\n",
        "888": "    @Override\n",
        "889": "    public boolean containsValue(Object value) {\n",
        "890": "      return map.containsValue(value);\n",
        "891": "    }\n",
        "892": "\n",
        "893": "    @Override\n",
        "894": "    public boolean containsEntry(Object key, Object value) {\n",
        "895": "      return map.entrySet().contains(Maps.immutableEntry(key, value));\n",
        "896": "    }\n",
        "897": "\n",
        "898": "    @Override\n",
        "899": "    public Set<V> get(final K key) {\n",
        "900": "      return new Sets.ImprovedAbstractSet<V>() {\n",
        "901": "        @Override\n",
        "902": "        public Iterator<V> iterator() {\n",
        "903": "          return new Iterator<V>() {\n",
        "904": "            int i;\n",
        "905": "\n",
        "906": "            @Override\n",
        "907": "            public boolean hasNext() {\n",
        "908": "              return (i == 0) && map.containsKey(key);\n",
        "909": "            }\n",
        "910": "\n",
        "911": "            @Override\n",
        "912": "            public V next() {\n",
        "913": "              if (!hasNext()) {\n",
        "914": "                throw new NoSuchElementException();\n",
        "915": "              }\n",
        "916": "              i++;\n",
        "917": "              return map.get(key);\n",
        "918": "            }\n",
        "919": "\n",
        "920": "            @Override\n",
        "921": "            public void remove() {\n",
        "922": "              checkRemove(i == 1);\n",
        "923": "              i = -1;\n",
        "924": "              map.remove(key);\n",
        "925": "            }\n",
        "926": "          };\n",
        "927": "        }\n",
        "928": "\n",
        "929": "        @Override\n",
        "930": "        public int size() {\n",
        "931": "          return map.containsKey(key) ? 1 : 0;\n",
        "932": "        }\n",
        "933": "      };\n",
        "934": "    }\n",
        "935": "\n",
        "936": "    @Override\n",
        "937": "    public boolean put(K key, V value) {\n",
        "938": "      throw new UnsupportedOperationException();\n",
        "939": "    }\n",
        "940": "\n",
        "941": "    @Override\n",
        "942": "    public boolean putAll(K key, Iterable<? extends V> values) {\n",
        "943": "      throw new UnsupportedOperationException();\n",
        "944": "    }\n",
        "945": "\n",
        "946": "    @Override\n",
        "947": "    public boolean putAll(Multimap<? extends K, ? extends V> multimap) {\n",
        "948": "      throw new UnsupportedOperationException();\n",
        "949": "    }\n",
        "950": "\n",
        "951": "    @Override\n",
        "952": "    public Set<V> replaceValues(K key, Iterable<? extends V> values) {\n",
        "953": "      throw new UnsupportedOperationException();\n",
        "954": "    }\n",
        "955": "\n",
        "956": "    @Override\n",
        "957": "    public boolean remove(Object key, Object value) {\n",
        "958": "      return map.entrySet().remove(Maps.immutableEntry(key, value));\n",
        "959": "    }\n",
        "960": "\n",
        "961": "    @Override\n",
        "962": "    public Set<V> removeAll(Object key) {\n",
        "963": "      Set<V> values = new HashSet<V>(2);\n",
        "964": "      if (!map.containsKey(key)) {\n",
        "965": "        return values;\n",
        "966": "      }\n",
        "967": "      values.add(map.remove(key));\n",
        "968": "      return values;\n",
        "969": "    }\n",
        "970": "\n",
        "971": "    @Override\n",
        "972": "    public void clear() {\n",
        "973": "      map.clear();\n",
        "974": "    }\n",
        "975": "\n",
        "976": "    @Override\n",
        "977": "    public Set<K> keySet() {\n",
        "978": "      return map.keySet();\n",
        "979": "    }\n",
        "980": "\n",
        "981": "    @Override\n",
        "982": "    public Collection<V> values() {\n",
        "983": "      return map.values();\n",
        "984": "    }\n",
        "985": "\n",
        "986": "    @Override\n",
        "987": "    public Set<Entry<K, V>> entries() {\n",
        "988": "      return map.entrySet();\n",
        "989": "    }\n",
        "990": "\n",
        "991": "    @Override\n",
        "992": "    Iterator<Entry<K, V>> entryIterator() {\n",
        "993": "      return map.entrySet().iterator();\n",
        "994": "    }\n",
        "995": "\n",
        "996": "    @Override\n",
        "997": "    Map<K, Collection<V>> createAsMap() {\n",
        "998": "      return new AsMap<K, V>(this);\n",
        "999": "    }\n",
        "1000": "\n",
        "1001": "    @Override\n",
        "1002": "    public int hashCode() {\n",
        "1003": "      return map.hashCode();\n",
        "1004": "    }\n",
        "1005": "\n",
        "1006": "    private static final long serialVersionUID = 7845222491160860175L;\n",
        "1007": "  }\n",
        "1008": "\n",
        "1009": "  /**\n",
        "1010": "   * Returns a view of a multimap where each value is transformed by a function.\n",
        "1011": "   * All other properties of the multimap, such as iteration order, are left\n",
        "1012": "   * intact. For example, the code: <pre>   {@code\n",
        "1013": "   *\n",
        "1014": "   * Multimap<String, Integer> multimap =\n",
        "1015": "   *     ImmutableSetMultimap.of(\"a\", 2, \"b\", -3, \"b\", -3, \"a\", 4, \"c\", 6);\n",
        "1016": "   * Function<Integer, String> square = new Function<Integer, String>() {\n",
        "1017": "   *     public String apply(Integer in) {\n",
        "1018": "   *       return Integer.toString(in * in);\n",
        "1019": "   *     }\n",
        "1020": "   * };\n",
        "1021": "   * Multimap<String, String> transformed =\n",
        "1022": "   *     Multimaps.transformValues(multimap, square);\n",
        "1023": "   *   System.out.println(transformed);}</pre>\n",
        "1024": "   *\n",
        "1025": "   * ... prints {@code {a=[4, 16], b=[9, 9], c=[36]}}.\n",
        "1026": "   *\n",
        "1027": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1028": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1029": "   * in the underlying multimap.\n",
        "1030": "   *\n",
        "1031": "   * <p>It's acceptable for the underlying multimap to contain null keys, and\n",
        "1032": "   * even null values provided that the function is capable of accepting null\n",
        "1033": "   * input.  The transformed multimap might contain null values, if the function\n",
        "1034": "   * sometimes gives a null result.\n",
        "1035": "   *\n",
        "1036": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1037": "   * underlying multimap is.  The {@code equals} and {@code hashCode} methods\n",
        "1038": "   * of the returned multimap are meaningless, since there is not a definition\n",
        "1039": "   * of {@code equals} or {@code hashCode} for general collections, and\n",
        "1040": "   * {@code get()} will return a general {@code Collection} as opposed to a\n",
        "1041": "   * {@code List} or a {@code Set}.\n",
        "1042": "   *\n",
        "1043": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1044": "   * for the returned multimap to be a view, but it means that the function will\n",
        "1045": "   * be applied many times for bulk operations like\n",
        "1046": "   * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1047": "   * perform well, {@code function} should be fast. To avoid lazy evaluation\n",
        "1048": "   * when the returned multimap doesn't need to be a view, copy the returned\n",
        "1049": "   * multimap into a new multimap of your choosing.\n",
        "1050": "   *\n",
        "1051": "   * @since 7.0\n",
        "1052": "   */\n",
        "1053": "  public static <K, V1, V2> Multimap<K, V2> transformValues(\n",
        "1054": "      Multimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {\n",
        "1055": "    checkNotNull(function);\n",
        "1056": "    EntryTransformer<K, V1, V2> transformer = Maps.asEntryTransformer(function);\n",
        "1057": "    return transformEntries(fromMultimap, transformer);\n",
        "1058": "  }\n",
        "1059": "\n",
        "1060": "  /**\n",
        "1061": "   * Returns a view of a multimap whose values are derived from the original\n",
        "1062": "   * multimap's entries. In contrast to {@link #transformValues}, this method's\n",
        "1063": "   * entry-transformation logic may depend on the key as well as the value.\n",
        "1064": "   *\n",
        "1065": "   * <p>All other properties of the transformed multimap, such as iteration\n",
        "1066": "   * order, are left intact. For example, the code: <pre>   {@code\n",
        "1067": "   *\n",
        "1068": "   *   SetMultimap<String, Integer> multimap =\n",
        "1069": "   *       ImmutableSetMultimap.of(\"a\", 1, \"a\", 4, \"b\", -6);\n",
        "1070": "   *   EntryTransformer<String, Integer, String> transformer =\n",
        "1071": "   *       new EntryTransformer<String, Integer, String>() {\n",
        "1072": "   *         public String transformEntry(String key, Integer value) {\n",
        "1073": "   *            return (value >= 0) ? key : \"no\" + key;\n",
        "1074": "   *         }\n",
        "1075": "   *       };\n",
        "1076": "   *   Multimap<String, String> transformed =\n",
        "1077": "   *       Multimaps.transformEntries(multimap, transformer);\n",
        "1078": "   *   System.out.println(transformed);}</pre>\n",
        "1079": "   *\n",
        "1080": "   * ... prints {@code {a=[a, a], b=[nob]}}.\n",
        "1081": "   *\n",
        "1082": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1083": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1084": "   * in the underlying multimap.\n",
        "1085": "   *\n",
        "1086": "   * <p>It's acceptable for the underlying multimap to contain null keys and\n",
        "1087": "   * null values provided that the transformer is capable of accepting null\n",
        "1088": "   * inputs. The transformed multimap might contain null values if the\n",
        "1089": "   * transformer sometimes gives a null result.\n",
        "1090": "   *\n",
        "1091": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1092": "   * underlying multimap is.  The {@code equals} and {@code hashCode} methods\n",
        "1093": "   * of the returned multimap are meaningless, since there is not a definition\n",
        "1094": "   * of {@code equals} or {@code hashCode} for general collections, and\n",
        "1095": "   * {@code get()} will return a general {@code Collection} as opposed to a\n",
        "1096": "   * {@code List} or a {@code Set}.\n",
        "1097": "   *\n",
        "1098": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1099": "   * necessary for the returned multimap to be a view, but it means that the\n",
        "1100": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1101": "   * Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1102": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1103": "   * returned multimap doesn't need to be a view, copy the returned multimap\n",
        "1104": "   * into a new multimap of your choosing.\n",
        "1105": "   *\n",
        "1106": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1107": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1108": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1109": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1110": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1111": "   * the transformed multimap.\n",
        "1112": "   *\n",
        "1113": "   * @since 7.0\n",
        "1114": "   */\n",
        "1115": "  public static <K, V1, V2> Multimap<K, V2> transformEntries(\n",
        "1116": "      Multimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1117": "    return new TransformedEntriesMultimap<K, V1, V2>(fromMap, transformer);\n",
        "1118": "  }\n",
        "1119": "\n",
        "1120": "  private static class TransformedEntriesMultimap<K, V1, V2> extends AbstractMultimap<K, V2> {\n",
        "1121": "    final Multimap<K, V1> fromMultimap;\n",
        "1122": "    final EntryTransformer<? super K, ? super V1, V2> transformer;\n",
        "1123": "\n",
        "1124": "    TransformedEntriesMultimap(\n",
        "1125": "        Multimap<K, V1> fromMultimap,\n",
        "1126": "        final EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1127": "      this.fromMultimap = checkNotNull(fromMultimap);\n",
        "1128": "      this.transformer = checkNotNull(transformer);\n",
        "1129": "    }\n",
        "1130": "\n",
        "1131": "    Collection<V2> transform(K key, Collection<V1> values) {\n",
        "1132": "      Function<? super V1, V2> function = Maps.asValueToValueFunction(transformer, key);\n",
        "1133": "      if (values instanceof List) {\n",
        "1134": "        return Lists.transform((List<V1>) values, function);\n",
        "1135": "      } else {\n",
        "1136": "        return Collections2.transform(values, function);\n",
        "1137": "      }\n",
        "1138": "    }\n",
        "1139": "\n",
        "1140": "    @Override\n",
        "1141": "    Map<K, Collection<V2>> createAsMap() {\n",
        "1142": "      return Maps.transformEntries(\n",
        "1143": "          fromMultimap.asMap(),\n",
        "1144": "          new EntryTransformer<K, Collection<V1>, Collection<V2>>() {\n",
        "1145": "            @Override\n",
        "1146": "            public Collection<V2> transformEntry(K key, Collection<V1> value) {\n",
        "1147": "              return transform(key, value);\n",
        "1148": "            }\n",
        "1149": "          });\n",
        "1150": "    }\n",
        "1151": "\n",
        "1152": "    @Override\n",
        "1153": "    public void clear() {\n",
        "1154": "      fromMultimap.clear();\n",
        "1155": "    }\n",
        "1156": "\n",
        "1157": "    @Override\n",
        "1158": "    public boolean containsKey(Object key) {\n",
        "1159": "      return fromMultimap.containsKey(key);\n",
        "1160": "    }\n",
        "1161": "\n",
        "1162": "    @Override\n",
        "1163": "    Iterator<Entry<K, V2>> entryIterator() {\n",
        "1164": "      return Iterators.transform(\n",
        "1165": "          fromMultimap.entries().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n",
        "1166": "    }\n",
        "1167": "\n",
        "1168": "    @Override\n",
        "1169": "    public Collection<V2> get(final K key) {\n",
        "1170": "      return transform(key, fromMultimap.get(key));\n",
        "1171": "    }\n",
        "1172": "\n",
        "1173": "    @Override\n",
        "1174": "    public boolean isEmpty() {\n",
        "1175": "      return fromMultimap.isEmpty();\n",
        "1176": "    }\n",
        "1177": "\n",
        "1178": "    @Override\n",
        "1179": "    public Set<K> keySet() {\n",
        "1180": "      return fromMultimap.keySet();\n",
        "1181": "    }\n",
        "1182": "\n",
        "1183": "    @Override\n",
        "1184": "    public Multiset<K> keys() {\n",
        "1185": "      return fromMultimap.keys();\n",
        "1186": "    }\n",
        "1187": "\n",
        "1188": "    @Override\n",
        "1189": "    public boolean put(K key, V2 value) {\n",
        "1190": "      throw new UnsupportedOperationException();\n",
        "1191": "    }\n",
        "1192": "\n",
        "1193": "    @Override\n",
        "1194": "    public boolean putAll(K key, Iterable<? extends V2> values) {\n",
        "1195": "      throw new UnsupportedOperationException();\n",
        "1196": "    }\n",
        "1197": "\n",
        "1198": "    @Override\n",
        "1199": "    public boolean putAll(Multimap<? extends K, ? extends V2> multimap) {\n",
        "1200": "      throw new UnsupportedOperationException();\n",
        "1201": "    }\n",
        "1202": "\n",
        "1203": "    @SuppressWarnings(\"unchecked\")\n",
        "1204": "    @Override\n",
        "1205": "    public boolean remove(Object key, Object value) {\n",
        "1206": "      return get((K) key).remove(value);\n",
        "1207": "    }\n",
        "1208": "\n",
        "1209": "    @SuppressWarnings(\"unchecked\")\n",
        "1210": "    @Override\n",
        "1211": "    public Collection<V2> removeAll(Object key) {\n",
        "1212": "      return transform((K) key, fromMultimap.removeAll(key));\n",
        "1213": "    }\n",
        "1214": "\n",
        "1215": "    @Override\n",
        "1216": "    public Collection<V2> replaceValues(K key, Iterable<? extends V2> values) {\n",
        "1217": "      throw new UnsupportedOperationException();\n",
        "1218": "    }\n",
        "1219": "\n",
        "1220": "    @Override\n",
        "1221": "    public int size() {\n",
        "1222": "      return fromMultimap.size();\n",
        "1223": "    }\n",
        "1224": "\n",
        "1225": "    @Override\n",
        "1226": "    Collection<V2> createValues() {\n",
        "1227": "      return Collections2.transform(\n",
        "1228": "          fromMultimap.entries(), Maps.<K, V1, V2>asEntryToValueFunction(transformer));\n",
        "1229": "    }\n",
        "1230": "  }\n",
        "1231": "\n",
        "1232": "  /**\n",
        "1233": "   * Returns a view of a {@code ListMultimap} where each value is transformed by\n",
        "1234": "   * a function. All other properties of the multimap, such as iteration order,\n",
        "1235": "   * are left intact. For example, the code: <pre>   {@code\n",
        "1236": "   *\n",
        "1237": "   *   ListMultimap<String, Integer> multimap\n",
        "1238": "   *        = ImmutableListMultimap.of(\"a\", 4, \"a\", 16, \"b\", 9);\n",
        "1239": "   *   Function<Integer, Double> sqrt =\n",
        "1240": "   *       new Function<Integer, Double>() {\n",
        "1241": "   *         public Double apply(Integer in) {\n",
        "1242": "   *           return Math.sqrt((int) in);\n",
        "1243": "   *         }\n",
        "1244": "   *       };\n",
        "1245": "   *   ListMultimap<String, Double> transformed = Multimaps.transformValues(map,\n",
        "1246": "   *       sqrt);\n",
        "1247": "   *   System.out.println(transformed);}</pre>\n",
        "1248": "   *\n",
        "1249": "   * ... prints {@code {a=[2.0, 4.0], b=[3.0]}}.\n",
        "1250": "   *\n",
        "1251": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1252": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1253": "   * in the underlying multimap.\n",
        "1254": "   *\n",
        "1255": "   * <p>It's acceptable for the underlying multimap to contain null keys, and\n",
        "1256": "   * even null values provided that the function is capable of accepting null\n",
        "1257": "   * input.  The transformed multimap might contain null values, if the function\n",
        "1258": "   * sometimes gives a null result.\n",
        "1259": "   *\n",
        "1260": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1261": "   * underlying multimap is.\n",
        "1262": "   *\n",
        "1263": "   * <p>The function is applied lazily, invoked when needed. This is necessary\n",
        "1264": "   * for the returned multimap to be a view, but it means that the function will\n",
        "1265": "   * be applied many times for bulk operations like\n",
        "1266": "   * {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to\n",
        "1267": "   * perform well, {@code function} should be fast. To avoid lazy evaluation\n",
        "1268": "   * when the returned multimap doesn't need to be a view, copy the returned\n",
        "1269": "   * multimap into a new multimap of your choosing.\n",
        "1270": "   *\n",
        "1271": "   * @since 7.0\n",
        "1272": "   */\n",
        "1273": "  public static <K, V1, V2> ListMultimap<K, V2> transformValues(\n",
        "1274": "      ListMultimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {\n",
        "1275": "    checkNotNull(function);\n",
        "1276": "    EntryTransformer<K, V1, V2> transformer = Maps.asEntryTransformer(function);\n",
        "1277": "    return transformEntries(fromMultimap, transformer);\n",
        "1278": "  }\n",
        "1279": "\n",
        "1280": "  /**\n",
        "1281": "   * Returns a view of a {@code ListMultimap} whose values are derived from the\n",
        "1282": "   * original multimap's entries. In contrast to\n",
        "1283": "   * {@link #transformValues(ListMultimap, Function)}, this method's\n",
        "1284": "   * entry-transformation logic may depend on the key as well as the value.\n",
        "1285": "   *\n",
        "1286": "   * <p>All other properties of the transformed multimap, such as iteration\n",
        "1287": "   * order, are left intact. For example, the code: <pre>   {@code\n",
        "1288": "   *\n",
        "1289": "   *   Multimap<String, Integer> multimap =\n",
        "1290": "   *       ImmutableMultimap.of(\"a\", 1, \"a\", 4, \"b\", 6);\n",
        "1291": "   *   EntryTransformer<String, Integer, String> transformer =\n",
        "1292": "   *       new EntryTransformer<String, Integer, String>() {\n",
        "1293": "   *         public String transformEntry(String key, Integer value) {\n",
        "1294": "   *           return key + value;\n",
        "1295": "   *         }\n",
        "1296": "   *       };\n",
        "1297": "   *   Multimap<String, String> transformed =\n",
        "1298": "   *       Multimaps.transformEntries(multimap, transformer);\n",
        "1299": "   *   System.out.println(transformed);}</pre>\n",
        "1300": "   *\n",
        "1301": "   * ... prints {@code {\"a\"=[\"a1\", \"a4\"], \"b\"=[\"b6\"]}}.\n",
        "1302": "   *\n",
        "1303": "   * <p>Changes in the underlying multimap are reflected in this view.\n",
        "1304": "   * Conversely, this view supports removal operations, and these are reflected\n",
        "1305": "   * in the underlying multimap.\n",
        "1306": "   *\n",
        "1307": "   * <p>It's acceptable for the underlying multimap to contain null keys and\n",
        "1308": "   * null values provided that the transformer is capable of accepting null\n",
        "1309": "   * inputs. The transformed multimap might contain null values if the\n",
        "1310": "   * transformer sometimes gives a null result.\n",
        "1311": "   *\n",
        "1312": "   * <p>The returned multimap is not thread-safe or serializable, even if the\n",
        "1313": "   * underlying multimap is.\n",
        "1314": "   *\n",
        "1315": "   * <p>The transformer is applied lazily, invoked when needed. This is\n",
        "1316": "   * necessary for the returned multimap to be a view, but it means that the\n",
        "1317": "   * transformer will be applied many times for bulk operations like {@link\n",
        "1318": "   * Multimap#containsValue} and {@link Object#toString}. For this to perform\n",
        "1319": "   * well, {@code transformer} should be fast. To avoid lazy evaluation when the\n",
        "1320": "   * returned multimap doesn't need to be a view, copy the returned multimap\n",
        "1321": "   * into a new multimap of your choosing.\n",
        "1322": "   *\n",
        "1323": "   * <p><b>Warning:</b> This method assumes that for any instance {@code k} of\n",
        "1324": "   * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies\n",
        "1325": "   * that {@code k2} is also of type {@code K}. Using an {@code\n",
        "1326": "   * EntryTransformer} key type for which this may not hold, such as {@code\n",
        "1327": "   * ArrayList}, may risk a {@code ClassCastException} when calling methods on\n",
        "1328": "   * the transformed multimap.\n",
        "1329": "   *\n",
        "1330": "   * @since 7.0\n",
        "1331": "   */\n",
        "1332": "  public static <K, V1, V2> ListMultimap<K, V2> transformEntries(\n",
        "1333": "      ListMultimap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1334": "    return new TransformedEntriesListMultimap<K, V1, V2>(fromMap, transformer);\n",
        "1335": "  }\n",
        "1336": "\n",
        "1337": "  private static final class TransformedEntriesListMultimap<K, V1, V2>\n",
        "1338": "      extends TransformedEntriesMultimap<K, V1, V2> implements ListMultimap<K, V2> {\n",
        "1339": "\n",
        "1340": "    TransformedEntriesListMultimap(\n",
        "1341": "        ListMultimap<K, V1> fromMultimap, EntryTransformer<? super K, ? super V1, V2> transformer) {\n",
        "1342": "      super(fromMultimap, transformer);\n",
        "1343": "    }\n",
        "1344": "\n",
        "1345": "    @Override\n",
        "1346": "    List<V2> transform(K key, Collection<V1> values) {\n",
        "1347": "      return Lists.transform((List<V1>) values, Maps.asValueToValueFunction(transformer, key));\n",
        "1348": "    }\n",
        "1349": "\n",
        "1350": "    @Override\n",
        "1351": "    public List<V2> get(K key) {\n",
        "1352": "      return transform(key, fromMultimap.get(key));\n",
        "1353": "    }\n",
        "1354": "\n",
        "1355": "    @SuppressWarnings(\"unchecked\")\n",
        "1356": "    @Override\n",
        "1357": "    public List<V2> removeAll(Object key) {\n",
        "1358": "      return transform((K) key, fromMultimap.removeAll(key));\n",
        "1359": "    }\n",
        "1360": "\n",
        "1361": "    @Override\n",
        "1362": "    public List<V2> replaceValues(K key, Iterable<? extends V2> values) {\n",
        "1363": "      throw new UnsupportedOperationException();\n",
        "1364": "    }\n",
        "1365": "  }\n",
        "1366": "\n",
        "1367": "  /**\n",
        "1368": "   * Creates an index {@code ImmutableListMultimap} that contains the results of\n",
        "1369": "   * applying a specified function to each item in an {@code Iterable} of\n",
        "1370": "   * values. Each value will be stored as a value in the resulting multimap,\n",
        "1371": "   * yielding a multimap with the same size as the input iterable. The key used\n",
        "1372": "   * to store that value in the multimap will be the result of calling the\n",
        "1373": "   * function on that value. The resulting multimap is created as an immutable\n",
        "1374": "   * snapshot. In the returned multimap, keys appear in the order they are first\n",
        "1375": "   * encountered, and the values corresponding to each key appear in the same\n",
        "1376": "   * order as they are encountered.\n",
        "1377": "   *\n",
        "1378": "   * <p>For example, <pre>   {@code\n",
        "1379": "   *\n",
        "1380": "   *   List<String> badGuys =\n",
        "1381": "   *       Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1382": "   *   Function<String, Integer> stringLengthFunction = ...;\n",
        "1383": "   *   Multimap<Integer, String> index =\n",
        "1384": "   *       Multimaps.index(badGuys, stringLengthFunction);\n",
        "1385": "   *   System.out.println(index);}</pre>\n",
        "1386": "   *\n",
        "1387": "   * <p>prints <pre>   {@code\n",
        "1388": "   *\n",
        "1389": "   *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>\n",
        "1390": "   *\n",
        "1391": "   * <p>The returned multimap is serializable if its keys and values are all\n",
        "1392": "   * serializable.\n",
        "1393": "   *\n",
        "1394": "   * @param values the values to use when constructing the {@code\n",
        "1395": "   *     ImmutableListMultimap}\n",
        "1396": "   * @param keyFunction the function used to produce the key for each value\n",
        "1397": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the\n",
        "1398": "   *     function {@code keyFunction} on each value in the input collection to\n",
        "1399": "   *     that value\n",
        "1400": "   * @throws NullPointerException if any of the following cases is true:\n",
        "1401": "   *     <ul>\n",
        "1402": "   *     <li>{@code values} is null\n",
        "1403": "   *     <li>{@code keyFunction} is null\n",
        "1404": "   *     <li>An element in {@code values} is null\n",
        "1405": "   *     <li>{@code keyFunction} returns {@code null} for any element of {@code\n",
        "1406": "   *         values}\n",
        "1407": "   *     </ul>\n",
        "1408": "   */\n",
        "1409": "  public static <K, V> ImmutableListMultimap<K, V> index(\n",
        "1410": "      Iterable<V> values, Function<? super V, K> keyFunction) {\n",
        "1411": "    return index(values.iterator(), keyFunction);\n",
        "1412": "  }\n",
        "1413": "\n",
        "1414": "  /**\n",
        "1415": "   * Creates an index {@code ImmutableListMultimap} that contains the results of\n",
        "1416": "   * applying a specified function to each item in an {@code Iterator} of\n",
        "1417": "   * values. Each value will be stored as a value in the resulting multimap,\n",
        "1418": "   * yielding a multimap with the same size as the input iterator. The key used\n",
        "1419": "   * to store that value in the multimap will be the result of calling the\n",
        "1420": "   * function on that value. The resulting multimap is created as an immutable\n",
        "1421": "   * snapshot. In the returned multimap, keys appear in the order they are first\n",
        "1422": "   * encountered, and the values corresponding to each key appear in the same\n",
        "1423": "   * order as they are encountered.\n",
        "1424": "   *\n",
        "1425": "   * <p>For example, <pre>   {@code\n",
        "1426": "   *\n",
        "1427": "   *   List<String> badGuys =\n",
        "1428": "   *       Arrays.asList(\"Inky\", \"Blinky\", \"Pinky\", \"Pinky\", \"Clyde\");\n",
        "1429": "   *   Function<String, Integer> stringLengthFunction = ...;\n",
        "1430": "   *   Multimap<Integer, String> index =\n",
        "1431": "   *       Multimaps.index(badGuys.iterator(), stringLengthFunction);\n",
        "1432": "   *   System.out.println(index);}</pre>\n",
        "1433": "   *\n",
        "1434": "   * <p>prints <pre>   {@code\n",
        "1435": "   *\n",
        "1436": "   *   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>\n",
        "1437": "   *\n",
        "1438": "   * <p>The returned multimap is serializable if its keys and values are all\n",
        "1439": "   * serializable.\n",
        "1440": "   *\n",
        "1441": "   * @param values the values to use when constructing the {@code\n",
        "1442": "   *     ImmutableListMultimap}\n",
        "1443": "   * @param keyFunction the function used to produce the key for each value\n",
        "1444": "   * @return {@code ImmutableListMultimap} mapping the result of evaluating the\n",
        "1445": "   *     function {@code keyFunction} on each value in the input collection to\n",
        "1446": "   *     that value\n",
        "1447": "   * @throws NullPointerException if any of the following cases is true:\n",
        "1448": "   *     <ul>\n",
        "1449": "   *     <li>{@code values} is null\n",
        "1450": "   *     <li>{@code keyFunction} is null\n",
        "1451": "   *     <li>An element in {@code values} is null\n",
        "1452": "   *     <li>{@code keyFunction} returns {@code null} for any element of {@code\n",
        "1453": "   *         values}\n",
        "1454": "   *     </ul>\n",
        "1455": "   * @since 10.0\n",
        "1456": "   */\n",
        "1457": "  public static <K, V> ImmutableListMultimap<K, V> index(\n",
        "1458": "      Iterator<V> values, Function<? super V, K> keyFunction) {\n",
        "1459": "    checkNotNull(keyFunction);\n",
        "1460": "    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n",
        "1461": "    while (values.hasNext()) {\n",
        "1462": "      V value = values.next();\n",
        "1463": "      checkNotNull(value, values);\n",
        "1464": "      builder.put(keyFunction.apply(value), value);\n",
        "1465": "    }\n",
        "1466": "    return builder.build();\n",
        "1467": "  }\n",
        "1468": "\n",
        "1469": "  static class Keys<K, V> extends AbstractMultiset<K> {\n",
        "1470": "    @Weak final Multimap<K, V> multimap;\n",
        "1471": "\n",
        "1472": "    Keys(Multimap<K, V> multimap) {\n",
        "1473": "      this.multimap = multimap;\n",
        "1474": "    }\n",
        "1475": "\n",
        "1476": "    @Override\n",
        "1477": "    Iterator<Multiset.Entry<K>> entryIterator() {\n",
        "1478": "      return new TransformedIterator<Map.Entry<K, Collection<V>>, Multiset.Entry<K>>(\n",
        "1479": "          multimap.asMap().entrySet().iterator()) {\n",
        "1480": "        @Override\n",
        "1481": "        Multiset.Entry<K> transform(final Map.Entry<K, Collection<V>> backingEntry) {\n",
        "1482": "          return new Multisets.AbstractEntry<K>() {\n",
        "1483": "            @Override\n",
        "1484": "            public K getElement() {\n",
        "1485": "              return backingEntry.getKey();\n",
        "1486": "            }\n",
        "1487": "\n",
        "1488": "            @Override\n",
        "1489": "            public int getCount() {\n",
        "1490": "              return backingEntry.getValue().size();\n",
        "1491": "            }\n",
        "1492": "          };\n",
        "1493": "        }\n",
        "1494": "      };\n",
        "1495": "    }\n",
        "1496": "\n",
        "1497": "    @Override\n",
        "1498": "    int distinctElements() {\n",
        "1499": "      return multimap.asMap().size();\n",
        "1500": "    }\n",
        "1501": "\n",
        "1502": "    @Override\n",
        "1503": "    Set<Multiset.Entry<K>> createEntrySet() {\n",
        "1504": "      return new KeysEntrySet();\n",
        "1505": "    }\n",
        "1506": "\n",
        "1507": "    @WeakOuter\n",
        "1508": "    class KeysEntrySet extends Multisets.EntrySet<K> {\n",
        "1509": "      @Override\n",
        "1510": "      Multiset<K> multiset() {\n",
        "1511": "        return Keys.this;\n",
        "1512": "      }\n",
        "1513": "\n",
        "1514": "      @Override\n",
        "1515": "      public Iterator<Multiset.Entry<K>> iterator() {\n",
        "1516": "        return entryIterator();\n",
        "1517": "      }\n",
        "1518": "\n",
        "1519": "      @Override\n",
        "1520": "      public int size() {\n",
        "1521": "        return distinctElements();\n",
        "1522": "      }\n",
        "1523": "\n",
        "1524": "      @Override\n",
        "1525": "      public boolean isEmpty() {\n",
        "1526": "        return multimap.isEmpty();\n",
        "1527": "      }\n",
        "1528": "\n",
        "1529": "      @Override\n",
        "1530": "      public boolean contains(@Nullable Object o) {\n",
        "1531": "        if (o instanceof Multiset.Entry) {\n",
        "1532": "          Multiset.Entry<?> entry = (Multiset.Entry<?>) o;\n",
        "1533": "          Collection<V> collection = multimap.asMap().get(entry.getElement());\n",
        "1534": "          return collection != null && collection.size() == entry.getCount();\n",
        "1535": "        }\n",
        "1536": "        return false;\n",
        "1537": "      }\n",
        "1538": "\n",
        "1539": "      @Override\n",
        "1540": "      public boolean remove(@Nullable Object o) {\n",
        "1541": "        if (o instanceof Multiset.Entry) {\n",
        "1542": "          Multiset.Entry<?> entry = (Multiset.Entry<?>) o;\n",
        "1543": "          Collection<V> collection = multimap.asMap().get(entry.getElement());\n",
        "1544": "          if (collection != null && collection.size() == entry.getCount()) {\n",
        "1545": "            collection.clear();\n",
        "1546": "            return true;\n",
        "1547": "          }\n",
        "1548": "        }\n",
        "1549": "        return false;\n",
        "1550": "      }\n",
        "1551": "    }\n",
        "1552": "\n",
        "1553": "    @Override\n",
        "1554": "    public boolean contains(@Nullable Object element) {\n",
        "1555": "      return multimap.containsKey(element);\n",
        "1556": "    }\n",
        "1557": "\n",
        "1558": "    @Override\n",
        "1559": "    public Iterator<K> iterator() {\n",
        "1560": "      return Maps.keyIterator(multimap.entries().iterator());\n",
        "1561": "    }\n",
        "1562": "\n",
        "1563": "    @Override\n",
        "1564": "    public int count(@Nullable Object element) {\n",
        "1565": "      Collection<V> values = Maps.safeGet(multimap.asMap(), element);\n",
        "1566": "      return (values == null) ? 0 : values.size();\n",
        "1567": "    }\n",
        "1568": "\n",
        "1569": "    @Override\n",
        "1570": "    public int remove(@Nullable Object element, int occurrences) {\n",
        "1571": "      checkNonnegative(occurrences, \"occurrences\");\n",
        "1572": "      if (occurrences == 0) {\n",
        "1573": "        return count(element);\n",
        "1574": "      }\n",
        "1575": "\n",
        "1576": "      Collection<V> values = Maps.safeGet(multimap.asMap(), element);\n",
        "1577": "\n",
        "1578": "      if (values == null) {\n",
        "1579": "        return 0;\n",
        "1580": "      }\n",
        "1581": "\n",
        "1582": "      int oldCount = values.size();\n",
        "1583": "      if (occurrences >= oldCount) {\n",
        "1584": "        values.clear();\n",
        "1585": "      } else {\n",
        "1586": "        Iterator<V> iterator = values.iterator();\n",
        "1587": "        for (int i = 0; i < occurrences; i++) {\n",
        "1588": "          iterator.next();\n",
        "1589": "          iterator.remove();\n",
        "1590": "        }\n",
        "1591": "      }\n",
        "1592": "      return oldCount;\n",
        "1593": "    }\n",
        "1594": "\n",
        "1595": "    @Override\n",
        "1596": "    public void clear() {\n",
        "1597": "      multimap.clear();\n",
        "1598": "    }\n",
        "1599": "\n",
        "1600": "    @Override\n",
        "1601": "    public Set<K> elementSet() {\n",
        "1602": "      return multimap.keySet();\n",
        "1603": "    }\n",
        "1604": "  }\n",
        "1605": "\n",
        "1606": "  /**\n",
        "1607": "   * A skeleton implementation of {@link Multimap#entries()}.\n",
        "1608": "   */\n",
        "1609": "  abstract static class Entries<K, V> extends AbstractCollection<Map.Entry<K, V>> {\n",
        "1610": "    abstract Multimap<K, V> multimap();\n",
        "1611": "\n",
        "1612": "    @Override\n",
        "1613": "    public int size() {\n",
        "1614": "      return multimap().size();\n",
        "1615": "    }\n",
        "1616": "\n",
        "1617": "    @Override\n",
        "1618": "    public boolean contains(@Nullable Object o) {\n",
        "1619": "      if (o instanceof Map.Entry) {\n",
        "1620": "        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n",
        "1621": "        return multimap().containsEntry(entry.getKey(), entry.getValue());\n",
        "1622": "      }\n",
        "1623": "      return false;\n",
        "1624": "    }\n",
        "1625": "\n",
        "1626": "    @Override\n",
        "1627": "    public boolean remove(@Nullable Object o) {\n",
        "1628": "      if (o instanceof Map.Entry) {\n",
        "1629": "        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n",
        "1630": "        return multimap().remove(entry.getKey(), entry.getValue());\n",
        "1631": "      }\n",
        "1632": "      return false;\n",
        "1633": "    }\n",
        "1634": "\n",
        "1635": "    @Override\n",
        "1636": "    public void clear() {\n",
        "1637": "      multimap().clear();\n",
        "1638": "    }\n",
        "1639": "  }\n",
        "1640": "\n",
        "1641": "  /**\n",
        "1642": "   * A skeleton implementation of {@link Multimap#asMap()}.\n",
        "1643": "   */\n",
        "1644": "  static final class AsMap<K, V> extends Maps.ViewCachingAbstractMap<K, Collection<V>> {\n",
        "1645": "    @Weak private final Multimap<K, V> multimap;\n",
        "1646": "\n",
        "1647": "    AsMap(Multimap<K, V> multimap) {\n",
        "1648": "      this.multimap = checkNotNull(multimap);\n",
        "1649": "    }\n",
        "1650": "\n",
        "1651": "    @Override\n",
        "1652": "    public int size() {\n",
        "1653": "      return multimap.keySet().size();\n",
        "1654": "    }\n",
        "1655": "\n",
        "1656": "    @Override\n",
        "1657": "    protected Set<Entry<K, Collection<V>>> createEntrySet() {\n",
        "1658": "      return new EntrySet();\n",
        "1659": "    }\n",
        "1660": "\n",
        "1661": "    void removeValuesForKey(Object key) {\n",
        "1662": "      multimap.keySet().remove(key);\n",
        "1663": "    }\n",
        "1664": "\n",
        "1665": "    @WeakOuter\n",
        "1666": "    class EntrySet extends Maps.EntrySet<K, Collection<V>> {\n",
        "1667": "      @Override\n",
        "1668": "      Map<K, Collection<V>> map() {\n",
        "1669": "        return AsMap.this;\n",
        "1670": "      }\n",
        "1671": "\n",
        "1672": "      @Override\n",
        "1673": "      public Iterator<Entry<K, Collection<V>>> iterator() {\n",
        "1674": "        return Maps.asMapEntryIterator(\n",
        "1675": "            multimap.keySet(),\n",
        "1676": "            new Function<K, Collection<V>>() {\n",
        "1677": "              @Override\n",
        "1678": "              public Collection<V> apply(K key) {\n",
        "1679": "                return multimap.get(key);\n",
        "1680": "              }\n",
        "1681": "            });\n",
        "1682": "      }\n",
        "1683": "\n",
        "1684": "      @Override\n",
        "1685": "      public boolean remove(Object o) {\n",
        "1686": "        if (!contains(o)) {\n",
        "1687": "          return false;\n",
        "1688": "        }\n",
        "1689": "        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n",
        "1690": "        removeValuesForKey(entry.getKey());\n",
        "1691": "        return true;\n",
        "1692": "      }\n",
        "1693": "    }\n",
        "1694": "\n",
        "1695": "    @SuppressWarnings(\"unchecked\")\n",
        "1696": "    @Override\n",
        "1697": "    public Collection<V> get(Object key) {\n",
        "1698": "      return containsKey(key) ? multimap.get((K) key) : null;\n",
        "1699": "    }\n",
        "1700": "\n",
        "1701": "    @Override\n",
        "1702": "    public Collection<V> remove(Object key) {\n",
        "1703": "      return containsKey(key) ? multimap.removeAll(key) : null;\n",
        "1704": "    }\n",
        "1705": "\n",
        "1706": "    @Override\n",
        "1707": "    public Set<K> keySet() {\n",
        "1708": "      return multimap.keySet();\n",
        "1709": "    }\n",
        "1710": "\n",
        "1711": "    @Override\n",
        "1712": "    public boolean isEmpty() {\n",
        "1713": "      return multimap.isEmpty();\n",
        "1714": "    }\n",
        "1715": "\n",
        "1716": "    @Override\n",
        "1717": "    public boolean containsKey(Object key) {\n",
        "1718": "      return multimap.containsKey(key);\n",
        "1719": "    }\n",
        "1720": "\n",
        "1721": "    @Override\n",
        "1722": "    public void clear() {\n",
        "1723": "      multimap.clear();\n",
        "1724": "    }\n",
        "1725": "  }\n",
        "1726": "\n",
        "1727": "  /**\n",
        "1728": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "1729": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1730": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1731": "   *\n",
        "1732": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1733": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1734": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "1735": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1736": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1737": "   *\n",
        "1738": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1739": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1740": "   * filter will be removed from the underlying multimap.\n",
        "1741": "   *\n",
        "1742": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1743": "   * {@code unfiltered} is.\n",
        "1744": "   *\n",
        "1745": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1746": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1747": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1748": "   * faster to copy the filtered multimap and use the copy.\n",
        "1749": "   *\n",
        "1750": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "1751": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1752": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1753": "   * with equals.\n",
        "1754": "   *\n",
        "1755": "   * @since 11.0\n",
        "1756": "   */\n",
        "1757": "  @CheckReturnValue\n",
        "1758": "  public static <K, V> Multimap<K, V> filterKeys(\n",
        "1759": "      Multimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n",
        "1760": "    if (unfiltered instanceof SetMultimap) {\n",
        "1761": "      return filterKeys((SetMultimap<K, V>) unfiltered, keyPredicate);\n",
        "1762": "    } else if (unfiltered instanceof ListMultimap) {\n",
        "1763": "      return filterKeys((ListMultimap<K, V>) unfiltered, keyPredicate);\n",
        "1764": "    } else if (unfiltered instanceof FilteredKeyMultimap) {\n",
        "1765": "      FilteredKeyMultimap<K, V> prev = (FilteredKeyMultimap<K, V>) unfiltered;\n",
        "1766": "      return new FilteredKeyMultimap<K, V>(\n",
        "1767": "          prev.unfiltered, Predicates.and(prev.keyPredicate, keyPredicate));\n",
        "1768": "    } else if (unfiltered instanceof FilteredMultimap) {\n",
        "1769": "      FilteredMultimap<K, V> prev = (FilteredMultimap<K, V>) unfiltered;\n",
        "1770": "      return filterFiltered(prev, Maps.<K>keyPredicateOnEntries(keyPredicate));\n",
        "1771": "    } else {\n",
        "1772": "      return new FilteredKeyMultimap<K, V>(unfiltered, keyPredicate);\n",
        "1773": "    }\n",
        "1774": "  }\n",
        "1775": "\n",
        "1776": "  /**\n",
        "1777": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "1778": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1779": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1780": "   *\n",
        "1781": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1782": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1783": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "1784": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1785": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1786": "   *\n",
        "1787": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1788": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1789": "   * filter will be removed from the underlying multimap.\n",
        "1790": "   *\n",
        "1791": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1792": "   * {@code unfiltered} is.\n",
        "1793": "   *\n",
        "1794": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1795": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1796": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1797": "   * faster to copy the filtered multimap and use the copy.\n",
        "1798": "   *\n",
        "1799": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "1800": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1801": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1802": "   * with equals.\n",
        "1803": "   *\n",
        "1804": "   * @since 14.0\n",
        "1805": "   */\n",
        "1806": "  @CheckReturnValue\n",
        "1807": "  public static <K, V> SetMultimap<K, V> filterKeys(\n",
        "1808": "      SetMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n",
        "1809": "    if (unfiltered instanceof FilteredKeySetMultimap) {\n",
        "1810": "      FilteredKeySetMultimap<K, V> prev = (FilteredKeySetMultimap<K, V>) unfiltered;\n",
        "1811": "      return new FilteredKeySetMultimap<K, V>(\n",
        "1812": "          prev.unfiltered(), Predicates.and(prev.keyPredicate, keyPredicate));\n",
        "1813": "    } else if (unfiltered instanceof FilteredSetMultimap) {\n",
        "1814": "      FilteredSetMultimap<K, V> prev = (FilteredSetMultimap<K, V>) unfiltered;\n",
        "1815": "      return filterFiltered(prev, Maps.<K>keyPredicateOnEntries(keyPredicate));\n",
        "1816": "    } else {\n",
        "1817": "      return new FilteredKeySetMultimap<K, V>(unfiltered, keyPredicate);\n",
        "1818": "    }\n",
        "1819": "  }\n",
        "1820": "\n",
        "1821": "  /**\n",
        "1822": "   * Returns a multimap containing the mappings in {@code unfiltered} whose keys\n",
        "1823": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1824": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1825": "   *\n",
        "1826": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1827": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1828": "   * its views. When adding a key that doesn't satisfy the predicate, the\n",
        "1829": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1830": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1831": "   *\n",
        "1832": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1833": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1834": "   * filter will be removed from the underlying multimap.\n",
        "1835": "   *\n",
        "1836": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1837": "   * {@code unfiltered} is.\n",
        "1838": "   *\n",
        "1839": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1840": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1841": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1842": "   * faster to copy the filtered multimap and use the copy.\n",
        "1843": "   *\n",
        "1844": "   * <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,\n",
        "1845": "   * as documented at {@link Predicate#apply}. Do not provide a predicate such\n",
        "1846": "   * as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent\n",
        "1847": "   * with equals.\n",
        "1848": "   *\n",
        "1849": "   * @since 14.0\n",
        "1850": "   */\n",
        "1851": "  @CheckReturnValue\n",
        "1852": "  public static <K, V> ListMultimap<K, V> filterKeys(\n",
        "1853": "      ListMultimap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {\n",
        "1854": "    if (unfiltered instanceof FilteredKeyListMultimap) {\n",
        "1855": "      FilteredKeyListMultimap<K, V> prev = (FilteredKeyListMultimap<K, V>) unfiltered;\n",
        "1856": "      return new FilteredKeyListMultimap<K, V>(\n",
        "1857": "          prev.unfiltered(), Predicates.and(prev.keyPredicate, keyPredicate));\n",
        "1858": "    } else {\n",
        "1859": "      return new FilteredKeyListMultimap<K, V>(unfiltered, keyPredicate);\n",
        "1860": "    }\n",
        "1861": "  }\n",
        "1862": "\n",
        "1863": "  /**\n",
        "1864": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values\n",
        "1865": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1866": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1867": "   *\n",
        "1868": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1869": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1870": "   * its views. When adding a value that doesn't satisfy the predicate, the\n",
        "1871": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1872": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1873": "   *\n",
        "1874": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1875": "   * the filtered multimap or its views, only mappings whose value satisfy the\n",
        "1876": "   * filter will be removed from the underlying multimap.\n",
        "1877": "   *\n",
        "1878": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1879": "   * {@code unfiltered} is.\n",
        "1880": "   *\n",
        "1881": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1882": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1883": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1884": "   * faster to copy the filtered multimap and use the copy.\n",
        "1885": "   *\n",
        "1886": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "1887": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "1888": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "1889": "   * inconsistent with equals.\n",
        "1890": "   *\n",
        "1891": "   * @since 11.0\n",
        "1892": "   */\n",
        "1893": "  @CheckReturnValue\n",
        "1894": "  public static <K, V> Multimap<K, V> filterValues(\n",
        "1895": "      Multimap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n",
        "1896": "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n",
        "1897": "  }\n",
        "1898": "\n",
        "1899": "  /**\n",
        "1900": "   * Returns a multimap containing the mappings in {@code unfiltered} whose values\n",
        "1901": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1902": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1903": "   *\n",
        "1904": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1905": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1906": "   * its views. When adding a value that doesn't satisfy the predicate, the\n",
        "1907": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1908": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1909": "   *\n",
        "1910": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1911": "   * the filtered multimap or its views, only mappings whose value satisfy the\n",
        "1912": "   * filter will be removed from the underlying multimap.\n",
        "1913": "   *\n",
        "1914": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1915": "   * {@code unfiltered} is.\n",
        "1916": "   *\n",
        "1917": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1918": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1919": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1920": "   * faster to copy the filtered multimap and use the copy.\n",
        "1921": "   *\n",
        "1922": "   * <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with\n",
        "1923": "   * equals</i>, as documented at {@link Predicate#apply}. Do not provide a\n",
        "1924": "   * predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is\n",
        "1925": "   * inconsistent with equals.\n",
        "1926": "   *\n",
        "1927": "   * @since 14.0\n",
        "1928": "   */\n",
        "1929": "  @CheckReturnValue\n",
        "1930": "  public static <K, V> SetMultimap<K, V> filterValues(\n",
        "1931": "      SetMultimap<K, V> unfiltered, final Predicate<? super V> valuePredicate) {\n",
        "1932": "    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n",
        "1933": "  }\n",
        "1934": "\n",
        "1935": "  /**\n",
        "1936": "   * Returns a multimap containing the mappings in {@code unfiltered} that\n",
        "1937": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1938": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1939": "   *\n",
        "1940": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1941": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1942": "   * its views. When adding a key/value pair that doesn't satisfy the predicate,\n",
        "1943": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1944": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1945": "   *\n",
        "1946": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1947": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1948": "   * filter will be removed from the underlying multimap.\n",
        "1949": "   *\n",
        "1950": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1951": "   * {@code unfiltered} is.\n",
        "1952": "   *\n",
        "1953": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1954": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1955": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1956": "   * faster to copy the filtered multimap and use the copy.\n",
        "1957": "   *\n",
        "1958": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "1959": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "1960": "   *\n",
        "1961": "   * @since 11.0\n",
        "1962": "   */\n",
        "1963": "  @CheckReturnValue\n",
        "1964": "  public static <K, V> Multimap<K, V> filterEntries(\n",
        "1965": "      Multimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "1966": "    checkNotNull(entryPredicate);\n",
        "1967": "    if (unfiltered instanceof SetMultimap) {\n",
        "1968": "      return filterEntries((SetMultimap<K, V>) unfiltered, entryPredicate);\n",
        "1969": "    }\n",
        "1970": "    return (unfiltered instanceof FilteredMultimap)\n",
        "1971": "        ? filterFiltered((FilteredMultimap<K, V>) unfiltered, entryPredicate)\n",
        "1972": "        : new FilteredEntryMultimap<K, V>(checkNotNull(unfiltered), entryPredicate);\n",
        "1973": "  }\n",
        "1974": "\n",
        "1975": "  /**\n",
        "1976": "   * Returns a multimap containing the mappings in {@code unfiltered} that\n",
        "1977": "   * satisfy a predicate. The returned multimap is a live view of\n",
        "1978": "   * {@code unfiltered}; changes to one affect the other.\n",
        "1979": "   *\n",
        "1980": "   * <p>The resulting multimap's views have iterators that don't support\n",
        "1981": "   * {@code remove()}, but all other methods are supported by the multimap and\n",
        "1982": "   * its views. When adding a key/value pair that doesn't satisfy the predicate,\n",
        "1983": "   * multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}\n",
        "1984": "   * methods throw an {@link IllegalArgumentException}.\n",
        "1985": "   *\n",
        "1986": "   * <p>When methods such as {@code removeAll()} and {@code clear()} are called on\n",
        "1987": "   * the filtered multimap or its views, only mappings whose keys satisfy the\n",
        "1988": "   * filter will be removed from the underlying multimap.\n",
        "1989": "   *\n",
        "1990": "   * <p>The returned multimap isn't threadsafe or serializable, even if\n",
        "1991": "   * {@code unfiltered} is.\n",
        "1992": "   *\n",
        "1993": "   * <p>Many of the filtered multimap's methods, such as {@code size()}, iterate\n",
        "1994": "   * across every key/value mapping in the underlying multimap and determine\n",
        "1995": "   * which satisfy the filter. When a live view is <i>not</i> needed, it may be\n",
        "1996": "   * faster to copy the filtered multimap and use the copy.\n",
        "1997": "   *\n",
        "1998": "   * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with\n",
        "1999": "   * equals</i>, as documented at {@link Predicate#apply}.\n",
        "2000": "   *\n",
        "2001": "   * @since 14.0\n",
        "2002": "   */\n",
        "2003": "  @CheckReturnValue\n",
        "2004": "  public static <K, V> SetMultimap<K, V> filterEntries(\n",
        "2005": "      SetMultimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2006": "    checkNotNull(entryPredicate);\n",
        "2007": "    return (unfiltered instanceof FilteredSetMultimap)\n",
        "2008": "        ? filterFiltered((FilteredSetMultimap<K, V>) unfiltered, entryPredicate)\n",
        "2009": "        : new FilteredEntrySetMultimap<K, V>(checkNotNull(unfiltered), entryPredicate);\n",
        "2010": "  }\n",
        "2011": "\n",
        "2012": "  /**\n",
        "2013": "   * Support removal operations when filtering a filtered multimap. Since a\n",
        "2014": "   * filtered multimap has iterators that don't support remove, passing one to\n",
        "2015": "   * the FilteredEntryMultimap constructor would lead to a multimap whose removal\n",
        "2016": "   * operations would fail. This method combines the predicates to avoid that\n",
        "2017": "   * problem.\n",
        "2018": "   */\n",
        "2019": "  private static <K, V> Multimap<K, V> filterFiltered(\n",
        "2020": "      FilteredMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2021": "    Predicate<Entry<K, V>> predicate = Predicates.and(multimap.entryPredicate(), entryPredicate);\n",
        "2022": "    return new FilteredEntryMultimap<K, V>(multimap.unfiltered(), predicate);\n",
        "2023": "  }\n",
        "2024": "\n",
        "2025": "  /**\n",
        "2026": "   * Support removal operations when filtering a filtered multimap. Since a filtered multimap has\n",
        "2027": "   * iterators that don't support remove, passing one to the FilteredEntryMultimap constructor would\n",
        "2028": "   * lead to a multimap whose removal operations would fail. This method combines the predicates to\n",
        "2029": "   * avoid that problem.\n",
        "2030": "   */\n",
        "2031": "  private static <K, V> SetMultimap<K, V> filterFiltered(\n",
        "2032": "      FilteredSetMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate) {\n",
        "2033": "    Predicate<Entry<K, V>> predicate = Predicates.and(multimap.entryPredicate(), entryPredicate);\n",
        "2034": "    return new FilteredEntrySetMultimap<K, V>(multimap.unfiltered(), predicate);\n",
        "2035": "  }\n",
        "2036": "\n",
        "2037": "  static boolean equalsImpl(Multimap<?, ?> multimap, @Nullable Object object) {\n",
        "2038": "    if (object == multimap) {\n",
        "2039": "      return true;\n",
        "2040": "    }\n",
        "2041": "    if (object instanceof Multimap) {\n",
        "2042": "      Multimap<?, ?> that = (Multimap<?, ?>) object;\n",
        "2043": "      return multimap.asMap().equals(that.asMap());\n",
        "2044": "    }\n",
        "2045": "    return false;\n",
        "2046": "  }\n",
        "2047": "\n",
        "2048": "  // TODO(jlevy): Create methods that filter a SortedSetMultimap.\n",
        "2049": "}\n",
        "2050": "\n"
    }
}