{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2008 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.util.concurrent;\n",
        "18": "\n",
        "19": "import static com.google.common.collect.Iterables.getOnlyElement;\n",
        "20": "import static com.google.common.truth.Truth.assertThat;\n",
        "21": "import static com.google.common.util.concurrent.Futures.allAsList;\n",
        "22": "import static com.google.common.util.concurrent.Futures.immediateFailedFuture;\n",
        "23": "import static com.google.common.util.concurrent.Futures.immediateFuture;\n",
        "24": "import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n",
        "25": "import static com.google.common.util.concurrent.TestPlatform.clearInterrupt;\n",
        "26": "\n",
        "27": "import com.google.common.annotations.GwtCompatible;\n",
        "28": "import com.google.common.base.Function;\n",
        "29": "import com.google.common.base.Functions;\n",
        "30": "import com.google.common.collect.Lists;\n",
        "31": "import com.google.common.testing.TestLogHandler;\n",
        "32": "\n",
        "33": "import junit.framework.AssertionFailedError;\n",
        "34": "import junit.framework.TestCase;\n",
        "35": "\n",
        "36": "import java.io.IOException;\n",
        "37": "import java.util.List;\n",
        "38": "import java.util.concurrent.CancellationException;\n",
        "39": "import java.util.concurrent.CountDownLatch;\n",
        "40": "import java.util.concurrent.ExecutionException;\n",
        "41": "import java.util.concurrent.Executor;\n",
        "42": "import java.util.concurrent.Future;\n",
        "43": "import java.util.concurrent.RejectedExecutionException;\n",
        "44": "import java.util.concurrent.TimeUnit;\n",
        "45": "import java.util.logging.LogRecord;\n",
        "46": "import java.util.logging.Logger;\n",
        "47": "\n",
        "48": "/**\n",
        "49": " * Unit tests for {@link Futures}.\n",
        "50": " *\n",
        "51": " * @author Nishant Thakkar\n",
        "52": " */\n",
        "53": "@SuppressWarnings(\"CheckReturnValue\")\n",
        "54": "@GwtCompatible(emulated = true)\n",
        "55": "public class FuturesTest extends TestCase {\n",
        "56": "  private static final Logger aggregateFutureLogger =\n",
        "57": "      Logger.getLogger(AggregateFuture.class.getName());\n",
        "58": "  private final TestLogHandler aggregateFutureLogHandler = new TestLogHandler();\n",
        "59": "\n",
        "60": "  private static final String DATA1 = \"data\";\n",
        "61": "  private static final String DATA2 = \"more data\";\n",
        "62": "  private static final String DATA3 = \"most data\";\n",
        "63": "\n",
        "64": "  @Override\n",
        "65": "  protected void setUp() throws Exception {\n",
        "66": "    super.setUp();\n",
        "67": "    aggregateFutureLogger.addHandler(aggregateFutureLogHandler);\n",
        "68": "  }\n",
        "69": "\n",
        "70": "  @Override\n",
        "71": "  protected void tearDown() throws Exception {\n",
        "72": "    /*\n",
        "73": "     * Clear interrupt for future tests.\n",
        "74": "     *\n",
        "75": "     * (Ideally we would perform interrupts only in threads that we create, but\n",
        "76": "     * it's hard to imagine that anything will break in practice.)\n",
        "77": "     */\n",
        "78": "    clearInterrupt();\n",
        "79": "    aggregateFutureLogger.removeHandler(aggregateFutureLogHandler);\n",
        "80": "    super.tearDown();\n",
        "81": "  }\n",
        "82": "\n",
        "83": "  public void testImmediateFuture() throws Exception {\n",
        "84": "    ListenableFuture<String> future = Futures.immediateFuture(DATA1);\n",
        "85": "\n",
        "86": "    // Verify that the proper object is returned without waiting\n",
        "87": "    assertSame(DATA1, future.get(0L, TimeUnit.MILLISECONDS));\n",
        "88": "  }\n",
        "89": "\n",
        "90": "  public void testMultipleImmediateFutures() throws Exception {\n",
        "91": "    ListenableFuture<String> future1 = Futures.immediateFuture(DATA1);\n",
        "92": "    ListenableFuture<String> future2 = Futures.immediateFuture(DATA2);\n",
        "93": "\n",
        "94": "    // Verify that the proper objects are returned without waiting\n",
        "95": "    assertSame(DATA1, future1.get(0L, TimeUnit.MILLISECONDS));\n",
        "96": "    assertSame(DATA2, future2.get(0L, TimeUnit.MILLISECONDS));\n",
        "97": "  }\n",
        "98": "\n",
        "99": "  public void testImmediateFailedFuture() throws Exception {\n",
        "100": "    Exception exception = new Exception();\n",
        "101": "    ListenableFuture<String> future =\n",
        "102": "        Futures.immediateFailedFuture(exception);\n",
        "103": "\n",
        "104": "    try {\n",
        "105": "      future.get(0L, TimeUnit.MILLISECONDS);\n",
        "106": "      fail(\"This call was supposed to throw an ExecutionException\");\n",
        "107": "    } catch (ExecutionException expected) {\n",
        "108": "      // This is good and expected\n",
        "109": "      assertSame(exception, expected.getCause());\n",
        "110": "    }\n",
        "111": "  }\n",
        "112": "\n",
        "113": "  public void testImmediateFailedFuture_cancellationException() throws Exception {\n",
        "114": "    CancellationException exception = new CancellationException();\n",
        "115": "    ListenableFuture<String> future =\n",
        "116": "        Futures.immediateFailedFuture(exception);\n",
        "117": "\n",
        "118": "    try {\n",
        "119": "      future.get(0L, TimeUnit.MILLISECONDS);\n",
        "120": "      fail(\"This call was supposed to throw an ExecutionException\");\n",
        "121": "    } catch (ExecutionException expected) {\n",
        "122": "      // This is good and expected\n",
        "123": "      assertSame(exception, expected.getCause());\n",
        "124": "      assertFalse(future.isCancelled());\n",
        "125": "    }\n",
        "126": "  }\n",
        "127": "\n",
        "128": "  private static class MyException extends Exception {\n",
        "129": "\n",
        "130": "  }\n",
        "131": "\n",
        "132": "  // Class hierarchy for generics sanity checks\n",
        "133": "  private static class Foo {\n",
        "134": "\n",
        "135": "  }\n",
        "136": "\n",
        "137": "  private static class FooChild extends Foo {\n",
        "138": "\n",
        "139": "  }\n",
        "140": "\n",
        "141": "  private static class Bar {\n",
        "142": "\n",
        "143": "  }\n",
        "144": "\n",
        "145": "  private static class BarChild extends Bar {\n",
        "146": "\n",
        "147": "  }\n",
        "148": "\n",
        "149": "  public void testTransform_genericsNull() throws Exception {\n",
        "150": "    ListenableFuture<?> nullFuture = Futures.immediateFuture(null);\n",
        "151": "    ListenableFuture<?> transformedFuture =\n",
        "152": "        Futures.transform(nullFuture, Functions.constant(null));\n",
        "153": "    assertNull(transformedFuture.get());\n",
        "154": "  }\n",
        "155": "\n",
        "156": "  public void testTransform_genericsHierarchy() throws Exception {\n",
        "157": "    ListenableFuture<FooChild> future = Futures.immediateFuture(null);\n",
        "158": "    final BarChild barChild = new BarChild();\n",
        "159": "    Function<Foo, BarChild> function = new Function<Foo, BarChild>() {\n",
        "160": "      @Override\n",
        "161": "      public BarChild apply(Foo unused) {\n",
        "162": "        return barChild;\n",
        "163": "      }\n",
        "164": "    };\n",
        "165": "    Bar bar = Futures.transform(future, function).get();\n",
        "166": "    assertSame(barChild, bar);\n",
        "167": "  }\n",
        "168": "\n",
        "169": "  public void testTransform_cancelPropagatesToInput() throws Exception {\n",
        "170": "    SettableFuture<Foo> input = SettableFuture.create();\n",
        "171": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "172": "      @Override\n",
        "173": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "174": "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n",
        "175": "      }\n",
        "176": "    };\n",
        "177": "    assertTrue(Futures.transform(input, function).cancel(false));\n",
        "178": "    assertTrue(input.isCancelled());\n",
        "179": "    assertFalse(input.wasInterrupted());\n",
        "180": "  }\n",
        "181": "\n",
        "182": "  public void testTransform_interruptPropagatesToInput() throws Exception {\n",
        "183": "    SettableFuture<Foo> input = SettableFuture.create();\n",
        "184": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "185": "      @Override\n",
        "186": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "187": "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n",
        "188": "      }\n",
        "189": "    };\n",
        "190": "    assertTrue(Futures.transform(input, function).cancel(true));\n",
        "191": "    assertTrue(input.isCancelled());\n",
        "192": "    assertTrue(input.wasInterrupted());\n",
        "193": "  }\n",
        "194": "\n",
        "195": "  public void testTransform_cancelPropagatesToAsyncOutput() throws Exception {\n",
        "196": "    ListenableFuture<Foo> immediate = Futures.immediateFuture(new Foo());\n",
        "197": "    final SettableFuture<Bar> secondary = SettableFuture.create();\n",
        "198": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "199": "      @Override\n",
        "200": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "201": "        return secondary;\n",
        "202": "      }\n",
        "203": "    };\n",
        "204": "    assertTrue(Futures.transform(immediate, function).cancel(false));\n",
        "205": "    assertTrue(secondary.isCancelled());\n",
        "206": "    assertFalse(secondary.wasInterrupted());\n",
        "207": "  }\n",
        "208": "\n",
        "209": "  public void testTransform_interruptPropagatesToAsyncOutput()\n",
        "210": "      throws Exception {\n",
        "211": "    ListenableFuture<Foo> immediate = Futures.immediateFuture(new Foo());\n",
        "212": "    final SettableFuture<Bar> secondary = SettableFuture.create();\n",
        "213": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "214": "      @Override\n",
        "215": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "216": "        return secondary;\n",
        "217": "      }\n",
        "218": "    };\n",
        "219": "    assertTrue(Futures.transform(immediate, function).cancel(true));\n",
        "220": "    assertTrue(secondary.isCancelled());\n",
        "221": "    assertTrue(secondary.wasInterrupted());\n",
        "222": "  }\n",
        "223": "\n",
        "224": "  public void testTransform_inputCancelButNotInterruptPropagatesToOutput() throws Exception {\n",
        "225": "    SettableFuture<String> f1 = SettableFuture.create();\n",
        "226": "    ListenableFuture<Object> f2 = Futures.transform(f1, Functions.identity());\n",
        "227": "    f1.cancel(true);\n",
        "228": "    assertTrue(f2.isCancelled());\n",
        "229": "    /*\n",
        "230": "     * We might like to propagate interruption, too, but it's not clear that it matters. For now, we\n",
        "231": "     * test for the behavior that we have today.\n",
        "232": "     */\n",
        "233": "    assertFalse(((AbstractFuture<?>) f2).wasInterrupted());\n",
        "234": "  }\n",
        "235": "\n",
        "236": "  public void testTransformAsync_cancelPropagatesToInput() throws Exception {\n",
        "237": "    SettableFuture<Foo> input = SettableFuture.create();\n",
        "238": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "239": "      @Override\n",
        "240": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "241": "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n",
        "242": "      }\n",
        "243": "    };\n",
        "244": "    assertTrue(Futures.transformAsync(input, function).cancel(false));\n",
        "245": "    assertTrue(input.isCancelled());\n",
        "246": "    assertFalse(input.wasInterrupted());\n",
        "247": "  }\n",
        "248": "\n",
        "249": "  public void testTransformAsync_interruptPropagatesToInput() throws Exception {\n",
        "250": "    SettableFuture<Foo> input = SettableFuture.create();\n",
        "251": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "252": "      @Override\n",
        "253": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "254": "        throw new AssertionFailedError(\"Unexpeted call to apply.\");\n",
        "255": "      }\n",
        "256": "    };\n",
        "257": "    assertTrue(Futures.transformAsync(input, function).cancel(true));\n",
        "258": "    assertTrue(input.isCancelled());\n",
        "259": "    assertTrue(input.wasInterrupted());\n",
        "260": "  }\n",
        "261": "\n",
        "262": "  public void testTransformAsync_cancelPropagatesToAsyncOutput() throws Exception {\n",
        "263": "    ListenableFuture<Foo> immediate = Futures.immediateFuture(new Foo());\n",
        "264": "    final SettableFuture<Bar> secondary = SettableFuture.create();\n",
        "265": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "266": "      @Override\n",
        "267": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "268": "        return secondary;\n",
        "269": "      }\n",
        "270": "    };\n",
        "271": "    assertTrue(Futures.transformAsync(immediate, function).cancel(false));\n",
        "272": "    assertTrue(secondary.isCancelled());\n",
        "273": "    assertFalse(secondary.wasInterrupted());\n",
        "274": "  }\n",
        "275": "\n",
        "276": "  public void testTransformAsync_interruptPropagatesToAsyncOutput()\n",
        "277": "      throws Exception {\n",
        "278": "    ListenableFuture<Foo> immediate = Futures.immediateFuture(new Foo());\n",
        "279": "    final SettableFuture<Bar> secondary = SettableFuture.create();\n",
        "280": "    AsyncFunction<Foo, Bar> function = new AsyncFunction<Foo, Bar>() {\n",
        "281": "      @Override\n",
        "282": "      public ListenableFuture<Bar> apply(Foo unused) {\n",
        "283": "        return secondary;\n",
        "284": "      }\n",
        "285": "    };\n",
        "286": "    assertTrue(Futures.transformAsync(immediate, function).cancel(true));\n",
        "287": "    assertTrue(secondary.isCancelled());\n",
        "288": "    assertTrue(secondary.wasInterrupted());\n",
        "289": "  }\n",
        "290": "\n",
        "291": "  public void testTransformAsync_inputCancelButNotInterruptPropagatesToOutput() throws Exception {\n",
        "292": "    SettableFuture<Foo> f1 = SettableFuture.create();\n",
        "293": "    final SettableFuture<Bar> secondary = SettableFuture.create();\n",
        "294": "    AsyncFunction<Foo, Bar> function =\n",
        "295": "        new AsyncFunction<Foo, Bar>() {\n",
        "296": "          @Override\n",
        "297": "          public ListenableFuture<Bar> apply(Foo unused) {\n",
        "298": "            return secondary;\n",
        "299": "          }\n",
        "300": "        };\n",
        "301": "    ListenableFuture<Bar> f2 = Futures.transformAsync(f1, function);\n",
        "302": "    f1.cancel(true);\n",
        "303": "    assertTrue(f2.isCancelled());\n",
        "304": "    /*\n",
        "305": "     * We might like to propagate interruption, too, but it's not clear that it matters. For now, we\n",
        "306": "     * test for the behavior that we have today.\n",
        "307": "     */\n",
        "308": "    assertFalse(((AbstractFuture<?>) f2).wasInterrupted());\n",
        "309": "  }\n",
        "310": "\n",
        "311": "  public void testTransform_rejectionPropagatesToOutput()\n",
        "312": "      throws Exception {\n",
        "313": "    SettableFuture<Foo> input = SettableFuture.create();\n",
        "314": "    ListenableFuture<String> transformed =\n",
        "315": "        Futures.transform(input, Functions.toStringFunction(), REJECTING_EXECUTOR);\n",
        "316": "    input.set(new Foo());\n",
        "317": "    try {\n",
        "318": "      transformed.get(5, TimeUnit.SECONDS);\n",
        "319": "      fail();\n",
        "320": "    } catch (ExecutionException expected) {\n",
        "321": "      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);\n",
        "322": "    }\n",
        "323": "  }\n",
        "324": "\n",
        "325": "  /**\n",
        "326": "   * Tests that the function is invoked only once, even if it throws an exception.\n",
        "327": "   */\n",
        "328": "  public void testTransformValueRemainsMemoized() throws Exception {\n",
        "329": "    class Holder {\n",
        "330": "\n",
        "331": "      int value = 2;\n",
        "332": "    }\n",
        "333": "    final Holder holder = new Holder();\n",
        "334": "\n",
        "335": "    // This function adds the holder's value to the input value.\n",
        "336": "    Function<Integer, Integer> adder = new Function<Integer, Integer>() {\n",
        "337": "      @Override\n",
        "338": "      public Integer apply(Integer from) {\n",
        "339": "        return from + holder.value;\n",
        "340": "      }\n",
        "341": "    };\n",
        "342": "\n",
        "343": "    // Since holder.value is 2, applying 4 should yield 6.\n",
        "344": "    assertEquals(6, adder.apply(4).intValue());\n",
        "345": "\n",
        "346": "    ListenableFuture<Integer> immediateFuture = Futures.immediateFuture(4);\n",
        "347": "    Future<Integer> transformedFuture = Futures.transform(immediateFuture, adder);\n",
        "348": "\n",
        "349": "    // The composed future also yields 6.\n",
        "350": "    assertEquals(6, transformedFuture.get().intValue());\n",
        "351": "\n",
        "352": "    // Repeated calls yield the same value even though the function's behavior\n",
        "353": "    // changes\n",
        "354": "    holder.value = 3;\n",
        "355": "    assertEquals(6, transformedFuture.get().intValue());\n",
        "356": "    assertEquals(7, adder.apply(4).intValue());\n",
        "357": "\n",
        "358": "    // Once more, with feeling.\n",
        "359": "    holder.value = 4;\n",
        "360": "    assertEquals(6, transformedFuture.get().intValue());\n",
        "361": "    assertEquals(8, adder.apply(4).intValue());\n",
        "362": "\n",
        "363": "    // Memoized get also retains the value.\n",
        "364": "    assertEquals(6, transformedFuture.get(1000, TimeUnit.SECONDS).intValue());\n",
        "365": "\n",
        "366": "    // Unsurprisingly, recomposing the future will return an updated value.\n",
        "367": "    assertEquals(8, Futures.transform(immediateFuture, adder).get().intValue());\n",
        "368": "\n",
        "369": "    // Repeating, with the timeout version\n",
        "370": "    assertEquals(8, Futures.transform(immediateFuture, adder).get(\n",
        "371": "        1000, TimeUnit.SECONDS).intValue());\n",
        "372": "  }\n",
        "373": "\n",
        "374": "  static class MyError extends Error {\n",
        "375": "\n",
        "376": "  }\n",
        "377": "\n",
        "378": "  static class MyRuntimeException extends RuntimeException {\n",
        "379": "\n",
        "380": "  }\n",
        "381": "\n",
        "382": "  // TODO(cpovirk): top-level class?\n",
        "383": "  static class ExecutorSpy implements Executor {\n",
        "384": "\n",
        "385": "    Executor delegate;\n",
        "386": "    boolean wasExecuted;\n",
        "387": "\n",
        "388": "    public ExecutorSpy(Executor delegate) {\n",
        "389": "      this.delegate = delegate;\n",
        "390": "    }\n",
        "391": "\n",
        "392": "    @Override\n",
        "393": "    public void execute(Runnable command) {\n",
        "394": "      delegate.execute(command);\n",
        "395": "      wasExecuted = true;\n",
        "396": "    }\n",
        "397": "  }\n",
        "398": "\n",
        "399": "  public void testTransform_Executor() throws Exception {\n",
        "400": "    Object value = new Object();\n",
        "401": "    ExecutorSpy spy = new ExecutorSpy(directExecutor());\n",
        "402": "\n",
        "403": "    assertFalse(spy.wasExecuted);\n",
        "404": "\n",
        "405": "    ListenableFuture<Object> future = Futures.transform(\n",
        "406": "        Futures.immediateFuture(value),\n",
        "407": "        Functions.identity(), spy);\n",
        "408": "\n",
        "409": "    assertSame(value, future.get());\n",
        "410": "    assertTrue(spy.wasExecuted);\n",
        "411": "  }\n",
        "412": "\n",
        "413": "  private static class FunctionSpy<I, O> implements Function<I, O> {\n",
        "414": "    private int applyCount;\n",
        "415": "    private final Function<I, O> delegate;\n",
        "416": "\n",
        "417": "    public FunctionSpy(Function<I, O> delegate) {\n",
        "418": "      this.delegate = delegate;\n",
        "419": "    }\n",
        "420": "\n",
        "421": "    @Override\n",
        "422": "    public O apply(I input) {\n",
        "423": "      applyCount++;\n",
        "424": "      return delegate.apply(input);\n",
        "425": "    }\n",
        "426": "\n",
        "427": "    void verifyCallCount(int expected) {\n",
        "428": "      assertThat(applyCount).isEqualTo(expected);\n",
        "429": "    }\n",
        "430": "  }\n",
        "431": "\n",
        "432": "  private static <I, O> FunctionSpy<I, O> spy(Function<I, O> delegate) {\n",
        "433": "    return new FunctionSpy<I, O>(delegate);\n",
        "434": "  }\n",
        "435": "\n",
        "436": "  private static <X extends Throwable, V> Function<X, V> unexpectedFunction() {\n",
        "437": "    return new Function<X, V>() {\n",
        "438": "      @Override\n",
        "439": "      public V apply(X t) {\n",
        "440": "        throw newAssertionError(\"Unexpected fallback\", t);\n",
        "441": "      }\n",
        "442": "    };\n",
        "443": "  }\n",
        "444": "\n",
        "445": "  private static class FutureFallbackSpy<V> implements FutureFallback<V> {\n",
        "446": "\n",
        "447": "    private int count;\n",
        "448": "    private final FutureFallback<V> delegate;\n",
        "449": "\n",
        "450": "    public FutureFallbackSpy(FutureFallback<V> delegate) {\n",
        "451": "      this.delegate = delegate;\n",
        "452": "    }\n",
        "453": "\n",
        "454": "    @Override\n",
        "455": "    public final ListenableFuture<V> create(Throwable t) throws Exception {\n",
        "456": "      count++;\n",
        "457": "      return delegate.create(t);\n",
        "458": "    }\n",
        "459": "\n",
        "460": "    void verifyCallCount(int expected) {\n",
        "461": "      assertThat(count).isEqualTo(expected);\n",
        "462": "    }\n",
        "463": "  }\n",
        "464": "\n",
        "465": "  private static <V> FutureFallbackSpy<V> spy(FutureFallback<V> delegate) {\n",
        "466": "    return new FutureFallbackSpy<V>(delegate);\n",
        "467": "  }\n",
        "468": "\n",
        "469": "  private static <V> FutureFallback<V> unexpectedFallback() {\n",
        "470": "    return new FutureFallback<V>() {\n",
        "471": "      @Override\n",
        "472": "      public ListenableFuture<V> create(Throwable t) {\n",
        "473": "        throw newAssertionError(\"Unexpected fallback\", t);\n",
        "474": "      }\n",
        "475": "    };\n",
        "476": "  }\n",
        "477": "\n",
        "478": "  private static class AsyncFunctionSpy<X extends Throwable, V> implements AsyncFunction<X, V> {\n",
        "479": "    private int count;\n",
        "480": "    private final AsyncFunction<X, V> delegate;\n",
        "481": "\n",
        "482": "    public AsyncFunctionSpy(AsyncFunction<X, V> delegate) {\n",
        "483": "      this.delegate = delegate;\n",
        "484": "    }\n",
        "485": "\n",
        "486": "    @Override\n",
        "487": "    public final ListenableFuture<V> apply(X t) throws Exception {\n",
        "488": "      count++;\n",
        "489": "      return delegate.apply(t);\n",
        "490": "    }\n",
        "491": "\n",
        "492": "    void verifyCallCount(int expected) {\n",
        "493": "      assertThat(count).isEqualTo(expected);\n",
        "494": "    }\n",
        "495": "  }\n",
        "496": "\n",
        "497": "  private static <X extends Throwable, V> AsyncFunctionSpy<X, V> spy(AsyncFunction<X, V> delegate) {\n",
        "498": "    return new AsyncFunctionSpy<X, V>(delegate);\n",
        "499": "  }\n",
        "500": "\n",
        "501": "  private static <X extends Throwable, V> AsyncFunction<X, V> unexpectedAsyncFunction() {\n",
        "502": "    return new AsyncFunction<X, V>() {\n",
        "503": "      @Override\n",
        "504": "      public ListenableFuture<V> apply(X t) {\n",
        "505": "        throw newAssertionError(\"Unexpected fallback\", t);\n",
        "506": "      }\n",
        "507": "    };\n",
        "508": "  }\n",
        "509": "\n",
        "510": "  /** Alternative to AssertionError(String, Throwable), which doesn't exist in GWT 2.6.1. */\n",
        "511": "  private static AssertionError newAssertionError(String message, Throwable cause) {\n",
        "512": "    AssertionError e = new AssertionError(message);\n",
        "513": "    e.initCause(cause);\n",
        "514": "    return e;\n",
        "515": "  }\n",
        "516": "\n",
        "517": "  public void testWithFallback_inputDoesNotRaiseException() throws Exception {\n",
        "518": "    FutureFallback<Integer> fallback = unexpectedFallback();\n",
        "519": "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n",
        "520": "    ListenableFuture<Integer> faultToleranteFuture = Futures.withFallback(originalFuture, fallback);\n",
        "521": "    assertEquals(7, faultToleranteFuture.get().intValue());\n",
        "522": "  }\n",
        "523": "\n",
        "524": "  public void testWithFallback_inputRaisesException() throws Exception {\n",
        "525": "    final RuntimeException raisedException = new RuntimeException();\n",
        "526": "    FutureFallbackSpy<Integer> fallback = spy(new FutureFallback<Integer>() {\n",
        "527": "      @Override\n",
        "528": "      public ListenableFuture<Integer> create(Throwable t) throws Exception {\n",
        "529": "        assertThat(t).isSameAs(raisedException);\n",
        "530": "        return Futures.immediateFuture(20);\n",
        "531": "      }\n",
        "532": "    });\n",
        "533": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n",
        "534": "    ListenableFuture<Integer> faultTolerantFuture = Futures.withFallback(failingFuture, fallback);\n",
        "535": "    assertEquals(20, faultTolerantFuture.get().intValue());\n",
        "536": "    fallback.verifyCallCount(1);\n",
        "537": "  }\n",
        "538": "\n",
        "539": "  public void testWithFallback_fallbackGeneratesRuntimeException() throws Exception {\n",
        "540": "    RuntimeException expectedException = new RuntimeException();\n",
        "541": "    runExpectedExceptionFallbackTest(expectedException, false);\n",
        "542": "  }\n",
        "543": "\n",
        "544": "  public void testWithFallback_fallbackGeneratesCheckedException() throws Exception {\n",
        "545": "    Exception expectedException = new Exception() {\n",
        "546": "    };\n",
        "547": "    runExpectedExceptionFallbackTest(expectedException, false);\n",
        "548": "  }\n",
        "549": "\n",
        "550": "  public void testWithFallback_fallbackGeneratesError() throws Exception {\n",
        "551": "    final Error error = new Error(\"deliberate\");\n",
        "552": "    FutureFallback<Integer> fallback = new FutureFallback<Integer>() {\n",
        "553": "      @Override\n",
        "554": "      public ListenableFuture<Integer> create(Throwable t) throws Exception {\n",
        "555": "        throw error;\n",
        "556": "      }\n",
        "557": "    };\n",
        "558": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "559": "    try {\n",
        "560": "      Futures.withFallback(failingFuture, fallback).get();\n",
        "561": "      fail(\"An Exception should have been thrown!\");\n",
        "562": "    } catch (ExecutionException expected) {\n",
        "563": "      assertSame(error, expected.getCause());\n",
        "564": "    }\n",
        "565": "  }\n",
        "566": "\n",
        "567": "  public void testWithFallback_fallbackReturnsRuntimeException() throws Exception {\n",
        "568": "    RuntimeException expectedException = new RuntimeException();\n",
        "569": "    runExpectedExceptionFallbackTest(expectedException, true);\n",
        "570": "  }\n",
        "571": "\n",
        "572": "  public void testWithFallback_fallbackReturnsCheckedException() throws Exception {\n",
        "573": "    Exception expectedException = new Exception() {\n",
        "574": "    };\n",
        "575": "    runExpectedExceptionFallbackTest(expectedException, true);\n",
        "576": "  }\n",
        "577": "\n",
        "578": "  private void runExpectedExceptionFallbackTest(\n",
        "579": "      final Exception expectedException, final boolean wrapInFuture) throws Exception {\n",
        "580": "    FutureFallbackSpy<Integer> fallback = spy(new FutureFallback<Integer>() {\n",
        "581": "      @Override\n",
        "582": "      public ListenableFuture<Integer> create(Throwable t) throws Exception {\n",
        "583": "        if (!wrapInFuture) {\n",
        "584": "          throw expectedException;\n",
        "585": "        } else {\n",
        "586": "          return Futures.immediateFailedFuture(expectedException);\n",
        "587": "        }\n",
        "588": "      }\n",
        "589": "    });\n",
        "590": "\n",
        "591": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "592": "\n",
        "593": "    ListenableFuture<Integer> faultToleranteFuture = Futures.withFallback(failingFuture, fallback);\n",
        "594": "    try {\n",
        "595": "      faultToleranteFuture.get();\n",
        "596": "      fail(\"An Exception should have been thrown!\");\n",
        "597": "    } catch (ExecutionException ee) {\n",
        "598": "      assertSame(expectedException, ee.getCause());\n",
        "599": "    }\n",
        "600": "    fallback.verifyCallCount(1);\n",
        "601": "  }\n",
        "602": "\n",
        "603": "  public void testWithFallback_fallbackNotReady() throws Exception {\n",
        "604": "    ListenableFuture<Integer> primary = immediateFailedFuture(new Exception());\n",
        "605": "    final SettableFuture<Integer> secondary = SettableFuture.create();\n",
        "606": "    FutureFallback<Integer> fallback = new FutureFallback<Integer>() {\n",
        "607": "      @Override\n",
        "608": "      public ListenableFuture<Integer> create(Throwable t) {\n",
        "609": "        return secondary;\n",
        "610": "      }\n",
        "611": "    };\n",
        "612": "    ListenableFuture<Integer> derived = Futures.withFallback(primary, fallback);\n",
        "613": "    secondary.set(1);\n",
        "614": "    assertEquals(1, (int) derived.get());\n",
        "615": "  }\n",
        "616": "\n",
        "617": "  public void testWithFallback_resultInterruptedBeforeFallback() throws Exception {\n",
        "618": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "619": "    FutureFallback<Integer> fallback = unexpectedFallback();\n",
        "620": "    ListenableFuture<Integer> derived = Futures.withFallback(primary, fallback);\n",
        "621": "    derived.cancel(true);\n",
        "622": "    assertTrue(primary.isCancelled());\n",
        "623": "    assertTrue(primary.wasInterrupted());\n",
        "624": "  }\n",
        "625": "\n",
        "626": "  public void testWithFallback_resultCancelledBeforeFallback() throws Exception {\n",
        "627": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "628": "    FutureFallback<Integer> fallback = unexpectedFallback();\n",
        "629": "    ListenableFuture<Integer> derived = Futures.withFallback(primary, fallback);\n",
        "630": "    derived.cancel(false);\n",
        "631": "    assertTrue(primary.isCancelled());\n",
        "632": "    assertFalse(primary.wasInterrupted());\n",
        "633": "  }\n",
        "634": "\n",
        "635": "  public void testWithFallback_nullInsteadOfFuture() throws Exception {\n",
        "636": "    ListenableFuture<Integer> inputFuture = immediateFailedFuture(new Exception());\n",
        "637": "    ListenableFuture<?> chainedFuture =\n",
        "638": "        Futures.withFallback(inputFuture, new FutureFallback<Integer>() {\n",
        "639": "          @Override\n",
        "640": "          public ListenableFuture<Integer> create(Throwable t) {\n",
        "641": "            return null;\n",
        "642": "          }\n",
        "643": "        });\n",
        "644": "    try {\n",
        "645": "      chainedFuture.get();\n",
        "646": "      fail();\n",
        "647": "    } catch (ExecutionException expected) {\n",
        "648": "      NullPointerException cause = (NullPointerException) expected.getCause();\n",
        "649": "      assertThat(cause).hasMessage(\"FutureFallback.create returned null instead of a Future. \"\n",
        "650": "          + \"Did you mean to return immediateFuture(null)?\");\n",
        "651": "    }\n",
        "652": "  }\n",
        "653": "\n",
        "654": "  // catchingAsync tests cloned from the old withFallback tests:\n",
        "655": "\n",
        "656": "  public void testCatchingAsync_inputDoesNotRaiseException() throws Exception {\n",
        "657": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "658": "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n",
        "659": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "660": "        Futures.catchingAsync(originalFuture, Throwable.class, fallback);\n",
        "661": "    assertEquals(7, faultToleranteFuture.get().intValue());\n",
        "662": "  }\n",
        "663": "\n",
        "664": "  public void testCatchingAsync_inputRaisesException() throws Exception {\n",
        "665": "    final RuntimeException raisedException = new RuntimeException();\n",
        "666": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "667": "      @Override\n",
        "668": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "669": "        assertThat(t).isSameAs(raisedException);\n",
        "670": "        return Futures.immediateFuture(20);\n",
        "671": "      }\n",
        "672": "    });\n",
        "673": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n",
        "674": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "675": "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n",
        "676": "    assertEquals(20, faultTolerantFuture.get().intValue());\n",
        "677": "    fallback.verifyCallCount(1);\n",
        "678": "  }\n",
        "679": "\n",
        "680": "  public void testCatchingAsync_fallbackGeneratesRuntimeException() throws Exception {\n",
        "681": "    RuntimeException expectedException = new RuntimeException();\n",
        "682": "    runExpectedExceptionCatchingAsyncTest(expectedException, false);\n",
        "683": "  }\n",
        "684": "\n",
        "685": "  public void testCatchingAsync_fallbackGeneratesCheckedException() throws Exception {\n",
        "686": "    Exception expectedException = new Exception() {\n",
        "687": "    };\n",
        "688": "    runExpectedExceptionCatchingAsyncTest(expectedException, false);\n",
        "689": "  }\n",
        "690": "\n",
        "691": "  public void testCatchingAsync_fallbackGeneratesError() throws Exception {\n",
        "692": "    final Error error = new Error(\"deliberate\");\n",
        "693": "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n",
        "694": "      @Override\n",
        "695": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "696": "        throw error;\n",
        "697": "      }\n",
        "698": "    };\n",
        "699": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "700": "    try {\n",
        "701": "      Futures.catchingAsync(failingFuture, Throwable.class, fallback).get();\n",
        "702": "      fail(\"An Exception should have been thrown!\");\n",
        "703": "    } catch (ExecutionException expected) {\n",
        "704": "      assertSame(error, expected.getCause());\n",
        "705": "    }\n",
        "706": "  }\n",
        "707": "\n",
        "708": "  public void testCatchingAsync_fallbackReturnsRuntimeException() throws Exception {\n",
        "709": "    RuntimeException expectedException = new RuntimeException();\n",
        "710": "    runExpectedExceptionCatchingAsyncTest(expectedException, true);\n",
        "711": "  }\n",
        "712": "\n",
        "713": "  public void testCatchingAsync_fallbackReturnsCheckedException() throws Exception {\n",
        "714": "    Exception expectedException = new Exception() {\n",
        "715": "    };\n",
        "716": "    runExpectedExceptionCatchingAsyncTest(expectedException, true);\n",
        "717": "  }\n",
        "718": "\n",
        "719": "  private void runExpectedExceptionCatchingAsyncTest(\n",
        "720": "      final Exception expectedException, final boolean wrapInFuture) throws Exception {\n",
        "721": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "722": "      @Override\n",
        "723": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "724": "        if (!wrapInFuture) {\n",
        "725": "          throw expectedException;\n",
        "726": "        } else {\n",
        "727": "          return Futures.immediateFailedFuture(expectedException);\n",
        "728": "        }\n",
        "729": "      }\n",
        "730": "    });\n",
        "731": "\n",
        "732": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "733": "\n",
        "734": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "735": "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n",
        "736": "    try {\n",
        "737": "      faultToleranteFuture.get();\n",
        "738": "      fail(\"An Exception should have been thrown!\");\n",
        "739": "    } catch (ExecutionException ee) {\n",
        "740": "      assertSame(expectedException, ee.getCause());\n",
        "741": "    }\n",
        "742": "    fallback.verifyCallCount(1);\n",
        "743": "  }\n",
        "744": "\n",
        "745": "  public void testCatchingAsync_fallbackNotReady() throws Exception {\n",
        "746": "    ListenableFuture<Integer> primary = immediateFailedFuture(new Exception());\n",
        "747": "    final SettableFuture<Integer> secondary = SettableFuture.create();\n",
        "748": "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n",
        "749": "      @Override\n",
        "750": "      public ListenableFuture<Integer> apply(Throwable t) {\n",
        "751": "        return secondary;\n",
        "752": "      }\n",
        "753": "    };\n",
        "754": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "755": "    secondary.set(1);\n",
        "756": "    assertEquals(1, (int) derived.get());\n",
        "757": "  }\n",
        "758": "\n",
        "759": "  public void testCatchingAsync_resultInterruptedBeforeFallback() throws Exception {\n",
        "760": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "761": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "762": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "763": "    derived.cancel(true);\n",
        "764": "    assertTrue(primary.isCancelled());\n",
        "765": "    assertTrue(primary.wasInterrupted());\n",
        "766": "  }\n",
        "767": "\n",
        "768": "  public void testCatchingAsync_resultCancelledBeforeFallback() throws Exception {\n",
        "769": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "770": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "771": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "772": "    derived.cancel(false);\n",
        "773": "    assertTrue(primary.isCancelled());\n",
        "774": "    assertFalse(primary.wasInterrupted());\n",
        "775": "  }\n",
        "776": "\n",
        "777": "  public void testCatchingAsync_nullInsteadOfFuture() throws Exception {\n",
        "778": "    ListenableFuture<Integer> inputFuture = immediateFailedFuture(new Exception());\n",
        "779": "    ListenableFuture<?> chainedFuture = Futures.catchingAsync(inputFuture, Throwable.class,\n",
        "780": "        new AsyncFunction<Throwable, Integer>() {\n",
        "781": "          @Override\n",
        "782": "          @SuppressWarnings(\"AsyncFunctionReturnsNull\")\n",
        "783": "          public ListenableFuture<Integer> apply(Throwable t) {\n",
        "784": "            return null;\n",
        "785": "          }\n",
        "786": "        });\n",
        "787": "    try {\n",
        "788": "      chainedFuture.get();\n",
        "789": "      fail();\n",
        "790": "    } catch (ExecutionException expected) {\n",
        "791": "      NullPointerException cause = (NullPointerException) expected.getCause();\n",
        "792": "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n",
        "793": "          + \"Did you mean to return immediateFuture(null)?\");\n",
        "794": "    }\n",
        "795": "  }\n",
        "796": "\n",
        "797": "  // catching tests cloned from the old withFallback tests:\n",
        "798": "\n",
        "799": "  public void testCatching_inputDoesNotRaiseException() throws Exception {\n",
        "800": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "801": "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n",
        "802": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "803": "        Futures.catching(originalFuture, Throwable.class, fallback);\n",
        "804": "    assertEquals(7, faultToleranteFuture.get().intValue());\n",
        "805": "  }\n",
        "806": "\n",
        "807": "  public void testCatching_inputRaisesException() throws Exception {\n",
        "808": "    final RuntimeException raisedException = new RuntimeException();\n",
        "809": "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n",
        "810": "      @Override\n",
        "811": "      public Integer apply(Throwable t) {\n",
        "812": "        assertThat(t).isSameAs(raisedException);\n",
        "813": "        return 20;\n",
        "814": "      }\n",
        "815": "    });\n",
        "816": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n",
        "817": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "818": "        Futures.catching(failingFuture, Throwable.class, fallback);\n",
        "819": "    assertEquals(20, faultTolerantFuture.get().intValue());\n",
        "820": "    fallback.verifyCallCount(1);\n",
        "821": "  }\n",
        "822": "\n",
        "823": "  public void testCatching_fallbackGeneratesRuntimeException() throws Exception {\n",
        "824": "    RuntimeException expectedException = new RuntimeException();\n",
        "825": "    runExpectedExceptionCatchingTest(expectedException);\n",
        "826": "  }\n",
        "827": "\n",
        "828": "  /*\n",
        "829": "   * catching() uses a plain Function, so there's no\n",
        "830": "   * testCatching_fallbackGeneratesCheckedException().\n",
        "831": "   */\n",
        "832": "\n",
        "833": "  public void testCatching_fallbackGeneratesError() throws Exception {\n",
        "834": "    final Error error = new Error(\"deliberate\");\n",
        "835": "    Function<Throwable, Integer> fallback = new Function<Throwable, Integer>() {\n",
        "836": "      @Override\n",
        "837": "      public Integer apply(Throwable t) {\n",
        "838": "        throw error;\n",
        "839": "      }\n",
        "840": "    };\n",
        "841": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "842": "    try {\n",
        "843": "      Futures.catching(failingFuture, Throwable.class, fallback).get();\n",
        "844": "      fail(\"An Exception should have been thrown!\");\n",
        "845": "    } catch (ExecutionException expected) {\n",
        "846": "      assertSame(error, expected.getCause());\n",
        "847": "    }\n",
        "848": "  }\n",
        "849": "\n",
        "850": "  /*\n",
        "851": "   * catching() uses a plain Function, so there's no testCatching_fallbackReturnsRuntimeException()\n",
        "852": "   * or testCatching_fallbackReturnsCheckedException().\n",
        "853": "   */\n",
        "854": "\n",
        "855": "  private void runExpectedExceptionCatchingTest(final RuntimeException expectedException)\n",
        "856": "      throws Exception {\n",
        "857": "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n",
        "858": "      @Override\n",
        "859": "      public Integer apply(Throwable t) {\n",
        "860": "        throw expectedException;\n",
        "861": "      }\n",
        "862": "    });\n",
        "863": "\n",
        "864": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "865": "\n",
        "866": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "867": "        Futures.catching(failingFuture, Throwable.class, fallback);\n",
        "868": "    try {\n",
        "869": "      faultToleranteFuture.get();\n",
        "870": "      fail(\"An Exception should have been thrown!\");\n",
        "871": "    } catch (ExecutionException ee) {\n",
        "872": "      assertSame(expectedException, ee.getCause());\n",
        "873": "    }\n",
        "874": "    fallback.verifyCallCount(1);\n",
        "875": "  }\n",
        "876": "\n",
        "877": "  // catching() uses a plain Function, so there's no testCatching_fallbackNotReady().\n",
        "878": "\n",
        "879": "  public void testCatching_resultInterruptedBeforeFallback() throws Exception {\n",
        "880": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "881": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "882": "    ListenableFuture<Integer> derived = Futures.catching(primary, Throwable.class, fallback);\n",
        "883": "    derived.cancel(true);\n",
        "884": "    assertTrue(primary.isCancelled());\n",
        "885": "    assertTrue(primary.wasInterrupted());\n",
        "886": "  }\n",
        "887": "\n",
        "888": "  public void testCatching_resultCancelledBeforeFallback() throws Exception {\n",
        "889": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "890": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "891": "    ListenableFuture<Integer> derived = Futures.catching(primary, Throwable.class, fallback);\n",
        "892": "    derived.cancel(false);\n",
        "893": "    assertTrue(primary.isCancelled());\n",
        "894": "    assertFalse(primary.wasInterrupted());\n",
        "895": "  }\n",
        "896": "\n",
        "897": "  // catching() uses a plain Function, so there's no testCatching_resultCancelledAfterFallback().\n",
        "898": "\n",
        "899": "  // catching() uses a plain Function, so there's no testCatching_nullInsteadOfFuture().\n",
        "900": "\n",
        "901": "  // Some tests of the exceptionType parameter:\n",
        "902": "\n",
        "903": "  public void testCatching_Throwable() throws Exception {\n",
        "904": "    Function<Throwable, Integer> fallback = functionReturningOne();\n",
        "905": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new IOException());\n",
        "906": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "907": "        Futures.catching(originalFuture, Throwable.class, fallback);\n",
        "908": "    assertEquals(1, (int) faultTolerantFuture.get());\n",
        "909": "  }\n",
        "910": "\n",
        "911": "  public void testCatchingAsync_Throwable() throws Exception {\n",
        "912": "    AsyncFunction<Throwable, Integer> fallback = asyncFunctionReturningOne();\n",
        "913": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new IOException());\n",
        "914": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "915": "        Futures.catchingAsync(originalFuture, Throwable.class, fallback);\n",
        "916": "    assertEquals(1, (int) faultTolerantFuture.get());\n",
        "917": "  }\n",
        "918": "\n",
        "919": "  public void testCatchingAsync_rejectionPropagatesToOutput() throws Exception {\n",
        "920": "    SettableFuture<String> input = SettableFuture.create();\n",
        "921": "    ListenableFuture<String> transformed =\n",
        "922": "        Futures.catching(input, Throwable.class, Functions.toStringFunction(), REJECTING_EXECUTOR);\n",
        "923": "    input.setException(new Exception());\n",
        "924": "    try {\n",
        "925": "      transformed.get(5, TimeUnit.SECONDS);\n",
        "926": "      fail();\n",
        "927": "    } catch (ExecutionException expected) {\n",
        "928": "      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);\n",
        "929": "    }\n",
        "930": "  }\n",
        "931": "\n",
        "932": "  private <X extends Throwable> Function<X, Integer> functionReturningOne() {\n",
        "933": "    return new Function<X, Integer>() {\n",
        "934": "      @Override\n",
        "935": "      public Integer apply(X t) {\n",
        "936": "        return 1;\n",
        "937": "      }\n",
        "938": "    };\n",
        "939": "  }\n",
        "940": "\n",
        "941": "  private <X extends Throwable> AsyncFunction<X, Integer> asyncFunctionReturningOne() {\n",
        "942": "    return new AsyncFunction<X, Integer>() {\n",
        "943": "      @Override\n",
        "944": "      public ListenableFuture<Integer> apply(X t) {\n",
        "945": "        return immediateFuture(1);\n",
        "946": "      }\n",
        "947": "    };\n",
        "948": "  }\n",
        "949": "\n",
        "950": "  private static <I, O> AsyncFunction<I, O> constantAsyncFunction(\n",
        "951": "      final ListenableFuture<O> output) {\n",
        "952": "    return new AsyncFunction<I, O>() {\n",
        "953": "      @Override\n",
        "954": "      public ListenableFuture<O> apply(I input) {\n",
        "955": "        return output;\n",
        "956": "      }\n",
        "957": "    };\n",
        "958": "  }\n",
        "959": "\n",
        "960": "  public void testTransform_genericsWildcard_AsyncFunction() throws Exception {\n",
        "961": "    ListenableFuture<?> nullFuture = immediateFuture(null);\n",
        "962": "    ListenableFuture<?> chainedFuture =\n",
        "963": "        Futures.transform(nullFuture, constantAsyncFunction(nullFuture));\n",
        "964": "    assertNull(chainedFuture.get());\n",
        "965": "  }\n",
        "966": "\n",
        "967": "  public void testTransform_genericsHierarchy_AsyncFunction() throws Exception {\n",
        "968": "    ListenableFuture<FooChild> future = Futures.immediateFuture(null);\n",
        "969": "    final BarChild barChild = new BarChild();\n",
        "970": "    AsyncFunction<Foo, BarChild> function =\n",
        "971": "        new AsyncFunction<Foo, BarChild>() {\n",
        "972": "          @Override\n",
        "973": "          public AbstractFuture<BarChild> apply(Foo unused) {\n",
        "974": "            AbstractFuture<BarChild> future = new AbstractFuture<BarChild>() {\n",
        "975": "            };\n",
        "976": "            future.set(barChild);\n",
        "977": "            return future;\n",
        "978": "          }\n",
        "979": "        };\n",
        "980": "    Bar bar = Futures.transform(future, function).get();\n",
        "981": "    assertSame(barChild, bar);\n",
        "982": "  }\n",
        "983": "\n",
        "984": "  public void testTransform_asyncFunction_error() throws InterruptedException {\n",
        "985": "    final Error error = new Error(\"deliberate\");\n",
        "986": "    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {\n",
        "987": "      @Override\n",
        "988": "      public ListenableFuture<Integer> apply(String input) {\n",
        "989": "        throw error;\n",
        "990": "      }\n",
        "991": "    };\n",
        "992": "    SettableFuture<String> inputFuture = SettableFuture.create();\n",
        "993": "    ListenableFuture<Integer> outputFuture = Futures.transform(inputFuture, function);\n",
        "994": "    inputFuture.set(\"value\");\n",
        "995": "    try {\n",
        "996": "      outputFuture.get();\n",
        "997": "      fail(\"should have thrown error\");\n",
        "998": "    } catch (ExecutionException e) {\n",
        "999": "      assertSame(error, e.getCause());\n",
        "1000": "    }\n",
        "1001": "  }\n",
        "1002": "\n",
        "1003": "  public void testTransform_asyncFunction_nullInsteadOfFuture() throws Exception {\n",
        "1004": "    ListenableFuture<?> inputFuture = immediateFuture(\"a\");\n",
        "1005": "    ListenableFuture<?> chainedFuture =\n",
        "1006": "        Futures.transform(inputFuture, constantAsyncFunction(null));\n",
        "1007": "    try {\n",
        "1008": "      chainedFuture.get();\n",
        "1009": "      fail();\n",
        "1010": "    } catch (ExecutionException expected) {\n",
        "1011": "      NullPointerException cause = (NullPointerException) expected.getCause();\n",
        "1012": "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n",
        "1013": "          + \"Did you mean to return immediateFuture(null)?\");\n",
        "1014": "    }\n",
        "1015": "  }\n",
        "1016": "\n",
        "1017": "  public void testTransformAsync_genericsWildcard_AsyncFunction() throws Exception {\n",
        "1018": "    ListenableFuture<?> nullFuture = immediateFuture(null);\n",
        "1019": "    ListenableFuture<?> chainedFuture =\n",
        "1020": "        Futures.transformAsync(nullFuture, constantAsyncFunction(nullFuture));\n",
        "1021": "    assertNull(chainedFuture.get());\n",
        "1022": "  }\n",
        "1023": "\n",
        "1024": "  public void testTransformAsync_genericsHierarchy_AsyncFunction() throws Exception {\n",
        "1025": "    ListenableFuture<FooChild> future = Futures.immediateFuture(null);\n",
        "1026": "    final BarChild barChild = new BarChild();\n",
        "1027": "    AsyncFunction<Foo, BarChild> function =\n",
        "1028": "        new AsyncFunction<Foo, BarChild>() {\n",
        "1029": "          @Override\n",
        "1030": "          public AbstractFuture<BarChild> apply(Foo unused) {\n",
        "1031": "            AbstractFuture<BarChild> future = new AbstractFuture<BarChild>() {\n",
        "1032": "            };\n",
        "1033": "            future.set(barChild);\n",
        "1034": "            return future;\n",
        "1035": "          }\n",
        "1036": "        };\n",
        "1037": "    Bar bar = Futures.transformAsync(future, function).get();\n",
        "1038": "    assertSame(barChild, bar);\n",
        "1039": "  }\n",
        "1040": "\n",
        "1041": "  public void testTransformAsync_asyncFunction_error() throws InterruptedException {\n",
        "1042": "    final Error error = new Error(\"deliberate\");\n",
        "1043": "    AsyncFunction<String, Integer> function = new AsyncFunction<String, Integer>() {\n",
        "1044": "      @Override\n",
        "1045": "      public ListenableFuture<Integer> apply(String input) {\n",
        "1046": "        throw error;\n",
        "1047": "      }\n",
        "1048": "    };\n",
        "1049": "    SettableFuture<String> inputFuture = SettableFuture.create();\n",
        "1050": "    ListenableFuture<Integer> outputFuture = Futures.transformAsync(inputFuture, function);\n",
        "1051": "    inputFuture.set(\"value\");\n",
        "1052": "    try {\n",
        "1053": "      outputFuture.get();\n",
        "1054": "      fail(\"should have thrown error\");\n",
        "1055": "    } catch (ExecutionException e) {\n",
        "1056": "      assertSame(error, e.getCause());\n",
        "1057": "    }\n",
        "1058": "  }\n",
        "1059": "\n",
        "1060": "  public void testTransformAsync_asyncFunction_nullInsteadOfFuture() throws Exception {\n",
        "1061": "    ListenableFuture<?> inputFuture = immediateFuture(\"a\");\n",
        "1062": "    ListenableFuture<?> chainedFuture =\n",
        "1063": "        Futures.transformAsync(inputFuture, constantAsyncFunction(null));\n",
        "1064": "    try {\n",
        "1065": "      chainedFuture.get();\n",
        "1066": "      fail();\n",
        "1067": "    } catch (ExecutionException expected) {\n",
        "1068": "      NullPointerException cause = (NullPointerException) expected.getCause();\n",
        "1069": "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n",
        "1070": "          + \"Did you mean to return immediateFuture(null)?\");\n",
        "1071": "    }\n",
        "1072": "  }\n",
        "1073": "\n",
        "1074": "  public void testDereference_genericsWildcard() throws Exception {\n",
        "1075": "    ListenableFuture<?> inner = Futures.immediateFuture(null);\n",
        "1076": "    ListenableFuture<ListenableFuture<?>> outer =\n",
        "1077": "        Futures.<ListenableFuture<?>>immediateFuture(inner);\n",
        "1078": "    ListenableFuture<?> dereferenced = Futures.dereference(outer);\n",
        "1079": "    assertNull(dereferenced.get());\n",
        "1080": "  }\n",
        "1081": "\n",
        "1082": "  public void testDereference_genericsHierarchy() throws Exception {\n",
        "1083": "    FooChild fooChild = new FooChild();\n",
        "1084": "    ListenableFuture<FooChild> inner = Futures.immediateFuture(fooChild);\n",
        "1085": "    ListenableFuture<ListenableFuture<FooChild>> outer = Futures.immediateFuture(inner);\n",
        "1086": "    ListenableFuture<Foo> dereferenced = Futures.<Foo>dereference(outer);\n",
        "1087": "    assertSame(fooChild, dereferenced.get());\n",
        "1088": "  }\n",
        "1089": "\n",
        "1090": "  public void testDereference_resultCancelsOuter() throws Exception {\n",
        "1091": "    ListenableFuture<ListenableFuture<Foo>> outer = SettableFuture.create();\n",
        "1092": "    ListenableFuture<Foo> dereferenced = Futures.dereference(outer);\n",
        "1093": "    dereferenced.cancel(true);\n",
        "1094": "    assertTrue(outer.isCancelled());\n",
        "1095": "  }\n",
        "1096": "\n",
        "1097": "  public void testDereference_resultCancelsInner() throws Exception {\n",
        "1098": "    ListenableFuture<Foo> inner = SettableFuture.create();\n",
        "1099": "    ListenableFuture<ListenableFuture<Foo>> outer = Futures.immediateFuture(inner);\n",
        "1100": "    ListenableFuture<Foo> dereferenced = Futures.dereference(outer);\n",
        "1101": "    dereferenced.cancel(true);\n",
        "1102": "    assertTrue(inner.isCancelled());\n",
        "1103": "  }\n",
        "1104": "\n",
        "1105": "  public void testDereference_outerCancelsResult() throws Exception {\n",
        "1106": "    ListenableFuture<ListenableFuture<Foo>> outer = SettableFuture.create();\n",
        "1107": "    ListenableFuture<Foo> dereferenced = Futures.dereference(outer);\n",
        "1108": "    outer.cancel(true);\n",
        "1109": "    assertTrue(dereferenced.isCancelled());\n",
        "1110": "  }\n",
        "1111": "\n",
        "1112": "  public void testDereference_innerCancelsResult() throws Exception {\n",
        "1113": "    ListenableFuture<Foo> inner = SettableFuture.create();\n",
        "1114": "    ListenableFuture<ListenableFuture<Foo>> outer = Futures.immediateFuture(inner);\n",
        "1115": "    ListenableFuture<Foo> dereferenced = Futures.dereference(outer);\n",
        "1116": "    inner.cancel(true);\n",
        "1117": "    assertTrue(dereferenced.isCancelled());\n",
        "1118": "  }\n",
        "1119": "\n",
        "1120": "  /**\n",
        "1121": "   * Runnable which can be called a single time, and only after {@link #expectCall} is called.\n",
        "1122": "   */\n",
        "1123": "  // TODO(cpovirk): top-level class?\n",
        "1124": "  static class SingleCallListener implements Runnable {\n",
        "1125": "\n",
        "1126": "    private boolean expectCall = false;\n",
        "1127": "    private final CountDownLatch calledCountDown =\n",
        "1128": "        new CountDownLatch(1);\n",
        "1129": "\n",
        "1130": "    @Override\n",
        "1131": "    public void run() {\n",
        "1132": "      assertTrue(\"Listener called before it was expected\", expectCall);\n",
        "1133": "      assertFalse(\"Listener called more than once\", wasCalled());\n",
        "1134": "      calledCountDown.countDown();\n",
        "1135": "    }\n",
        "1136": "\n",
        "1137": "    public void expectCall() {\n",
        "1138": "      assertFalse(\"expectCall is already true\", expectCall);\n",
        "1139": "      expectCall = true;\n",
        "1140": "    }\n",
        "1141": "\n",
        "1142": "    public boolean wasCalled() {\n",
        "1143": "      return calledCountDown.getCount() == 0;\n",
        "1144": "    }\n",
        "1145": "\n",
        "1146": "    public void waitForCall() throws InterruptedException {\n",
        "1147": "      assertTrue(\"expectCall is false\", expectCall);\n",
        "1148": "      calledCountDown.await();\n",
        "1149": "    }\n",
        "1150": "  }\n",
        "1151": "\n",
        "1152": "  public void testAllAsList() throws Exception {\n",
        "1153": "    // Create input and output\n",
        "1154": "    SettableFuture<String> future1 = SettableFuture.create();\n",
        "1155": "    SettableFuture<String> future2 = SettableFuture.create();\n",
        "1156": "    SettableFuture<String> future3 = SettableFuture.create();\n",
        "1157": "    @SuppressWarnings(\"unchecked\") // array is never modified\n",
        "1158": "        ListenableFuture<List<String>> compound =\n",
        "1159": "        Futures.allAsList(future1, future2, future3);\n",
        "1160": "\n",
        "1161": "    // Attach a listener\n",
        "1162": "    SingleCallListener listener = new SingleCallListener();\n",
        "1163": "    compound.addListener(listener, directExecutor());\n",
        "1164": "\n",
        "1165": "    // Satisfy each input and check the output\n",
        "1166": "    assertFalse(compound.isDone());\n",
        "1167": "    future1.set(DATA1);\n",
        "1168": "    assertFalse(compound.isDone());\n",
        "1169": "    future2.set(DATA2);\n",
        "1170": "    assertFalse(compound.isDone());\n",
        "1171": "    listener.expectCall();\n",
        "1172": "    future3.set(DATA3);\n",
        "1173": "    assertTrue(compound.isDone());\n",
        "1174": "    assertTrue(listener.wasCalled());\n",
        "1175": "\n",
        "1176": "    List<String> results = compound.get();\n",
        "1177": "    assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();\n",
        "1178": "  }\n",
        "1179": "\n",
        "1180": "  public void testAllAsList_emptyArray() throws Exception {\n",
        "1181": "    SingleCallListener listener = new SingleCallListener();\n",
        "1182": "    listener.expectCall();\n",
        "1183": "    @SuppressWarnings(\"unchecked\") // array is never modified\n",
        "1184": "        ListenableFuture<List<String>> compound = Futures.allAsList();\n",
        "1185": "    compound.addListener(listener, directExecutor());\n",
        "1186": "    assertTrue(compound.isDone());\n",
        "1187": "    assertTrue(compound.get().isEmpty());\n",
        "1188": "    assertTrue(listener.wasCalled());\n",
        "1189": "  }\n",
        "1190": "\n",
        "1191": "  public void testAllAsList_failure() throws Exception {\n",
        "1192": "    SingleCallListener listener = new SingleCallListener();\n",
        "1193": "    SettableFuture<String> future1 = SettableFuture.create();\n",
        "1194": "    SettableFuture<String> future2 = SettableFuture.create();\n",
        "1195": "    @SuppressWarnings(\"unchecked\") // array is never modified\n",
        "1196": "        ListenableFuture<List<String>> compound =\n",
        "1197": "        Futures.allAsList(future1, future2);\n",
        "1198": "    compound.addListener(listener, directExecutor());\n",
        "1199": "\n",
        "1200": "    listener.expectCall();\n",
        "1201": "    Throwable exception = new Throwable(\"failed1\");\n",
        "1202": "    future1.setException(exception);\n",
        "1203": "    assertTrue(compound.isDone());\n",
        "1204": "    assertTrue(listener.wasCalled());\n",
        "1205": "    future2.set(\"result2\");\n",
        "1206": "\n",
        "1207": "    try {\n",
        "1208": "      compound.get();\n",
        "1209": "      fail(\"Expected exception not thrown\");\n",
        "1210": "    } catch (ExecutionException e) {\n",
        "1211": "      assertSame(exception, e.getCause());\n",
        "1212": "    }\n",
        "1213": "  }\n",
        "1214": "\n",
        "1215": "  public void testAllAsList_cancelled() throws Exception {\n",
        "1216": "    SingleCallListener listener = new SingleCallListener();\n",
        "1217": "    SettableFuture<String> future1 = SettableFuture.create();\n",
        "1218": "    SettableFuture<String> future2 = SettableFuture.create();\n",
        "1219": "    @SuppressWarnings(\"unchecked\") // array is never modified\n",
        "1220": "        ListenableFuture<List<String>> compound =\n",
        "1221": "        Futures.allAsList(future1, future2);\n",
        "1222": "    compound.addListener(listener, directExecutor());\n",
        "1223": "\n",
        "1224": "    listener.expectCall();\n",
        "1225": "    future1.cancel(true);\n",
        "1226": "    assertTrue(compound.isDone());\n",
        "1227": "    assertTrue(listener.wasCalled());\n",
        "1228": "    future2.setException(new Throwable(\"failed2\"));\n",
        "1229": "\n",
        "1230": "    try {\n",
        "1231": "      compound.get();\n",
        "1232": "      fail(\"Expected exception not thrown\");\n",
        "1233": "    } catch (CancellationException e) {\n",
        "1234": "      // Expected\n",
        "1235": "    }\n",
        "1236": "  }\n",
        "1237": "\n",
        "1238": "  public void testAllAsList_resultCancelled() throws Exception {\n",
        "1239": "    SettableFuture<String> future1 = SettableFuture.create();\n",
        "1240": "    SettableFuture<String> future2 = SettableFuture.create();\n",
        "1241": "    @SuppressWarnings(\"unchecked\") // array is never modified\n",
        "1242": "        ListenableFuture<List<String>> compound =\n",
        "1243": "        Futures.allAsList(future1, future2);\n",
        "1244": "\n",
        "1245": "    future2.set(DATA2);\n",
        "1246": "    assertFalse(compound.isDone());\n",
        "1247": "    assertTrue(compound.cancel(false));\n",
        "1248": "    assertTrue(compound.isCancelled());\n",
        "1249": "    assertTrue(future1.isCancelled());\n",
        "1250": "    assertFalse(future1.wasInterrupted());\n",
        "1251": "  }\n",
        "1252": "\n",
        "1253": "  public void testAllAsList_resultCancelledInterrupted_withSecondaryListFuture()\n",
        "1254": "      throws Exception {\n",
        "1255": "    SettableFuture<String> future1 = SettableFuture.create();\n",
        "1256": "    SettableFuture<String> future2 = SettableFuture.create();\n",
        "1257": "    ListenableFuture<List<String>> compound =\n",
        "1258": "        Futures.allAsList(future1, future2);\n",
        "1259": "    // There was a bug where the event listener for the combined future would\n",
        "1260": "    // result in the sub-futures being cancelled without being interrupted.\n",
        "1261": "    ListenableFuture<List<String>> otherCompound =\n",
        "1262": "        Futures.allAsList(future1, future2);\n",
        "1263": "\n",
        "1264": "    assertTrue(compound.cancel(true));\n",
        "1265": "    assertTrue(future1.isCancelled());\n",
        "1266": "    assertTrue(future1.wasInterrupted());\n",
        "1267": "    assertTrue(future2.isCancelled());\n",
        "1268": "    assertTrue(future2.wasInterrupted());\n",
        "1269": "    assertTrue(otherCompound.isCancelled());\n",
        "1270": "  }\n",
        "1271": "\n",
        "1272": "  public void testAllAsList_resultCancelled_withSecondaryListFuture()\n",
        "1273": "      throws Exception {\n",
        "1274": "    SettableFuture<String> future1 = SettableFuture.create();\n",
        "1275": "    SettableFuture<String> future2 = SettableFuture.create();\n",
        "1276": "    ListenableFuture<List<String>> compound =\n",
        "1277": "        Futures.allAsList(future1, future2);\n",
        "1278": "    // This next call is \"unused,\" but it is an important part of the test. Don't remove it!\n",
        "1279": "    Futures.allAsList(future1, future2);\n",
        "1280": "\n",
        "1281": "    assertTrue(compound.cancel(false));\n",
        "1282": "    assertTrue(future1.isCancelled());\n",
        "1283": "    assertFalse(future1.wasInterrupted());\n",
        "1284": "    assertTrue(future2.isCancelled());\n",
        "1285": "    assertFalse(future2.wasInterrupted());\n",
        "1286": "  }\n",
        "1287": "\n",
        "1288": "  public void testAllAsList_resultInterrupted() throws Exception {\n",
        "1289": "    SettableFuture<String> future1 = SettableFuture.create();\n",
        "1290": "    SettableFuture<String> future2 = SettableFuture.create();\n",
        "1291": "    @SuppressWarnings(\"unchecked\") // array is never modified\n",
        "1292": "        ListenableFuture<List<String>> compound =\n",
        "1293": "        Futures.allAsList(future1, future2);\n",
        "1294": "\n",
        "1295": "    future2.set(DATA2);\n",
        "1296": "    assertFalse(compound.isDone());\n",
        "1297": "    assertTrue(compound.cancel(true));\n",
        "1298": "    assertTrue(compound.isCancelled());\n",
        "1299": "    assertTrue(future1.isCancelled());\n",
        "1300": "    assertTrue(future1.wasInterrupted());\n",
        "1301": "  }\n",
        "1302": "\n",
        "1303": "  /**\n",
        "1304": "   * Test the case where the futures are fulfilled prior to constructing the ListFuture.  There was\n",
        "1305": "   * a bug where the loop that connects a Listener to each of the futures would die on the last\n",
        "1306": "   * loop-check as done() on ListFuture nulled out the variable being looped over (the list of\n",
        "1307": "   * futures).\n",
        "1308": "   */\n",
        "1309": "  public void testAllAsList_doneFutures() throws Exception {\n",
        "1310": "    // Create input and output\n",
        "1311": "    SettableFuture<String> future1 = SettableFuture.create();\n",
        "1312": "    SettableFuture<String> future2 = SettableFuture.create();\n",
        "1313": "    SettableFuture<String> future3 = SettableFuture.create();\n",
        "1314": "\n",
        "1315": "    // Satisfy each input prior to creating compound and check the output\n",
        "1316": "    future1.set(DATA1);\n",
        "1317": "    future2.set(DATA2);\n",
        "1318": "    future3.set(DATA3);\n",
        "1319": "\n",
        "1320": "    @SuppressWarnings(\"unchecked\") // array is never modified\n",
        "1321": "        ListenableFuture<List<String>> compound =\n",
        "1322": "        Futures.allAsList(future1, future2, future3);\n",
        "1323": "\n",
        "1324": "    // Attach a listener\n",
        "1325": "    SingleCallListener listener = new SingleCallListener();\n",
        "1326": "    listener.expectCall();\n",
        "1327": "    compound.addListener(listener, directExecutor());\n",
        "1328": "\n",
        "1329": "    assertTrue(compound.isDone());\n",
        "1330": "    assertTrue(listener.wasCalled());\n",
        "1331": "\n",
        "1332": "    List<String> results = compound.get();\n",
        "1333": "    assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();\n",
        "1334": "  }\n",
        "1335": "\n",
        "1336": "  /**\n",
        "1337": "   * A single non-error failure is not logged because it is reported via the output future.\n",
        "1338": "   */\n",
        "1339": "  @SuppressWarnings(\"unchecked\")\n",
        "1340": "  public void testAllAsList_logging_exception() throws Exception {\n",
        "1341": "    try {\n",
        "1342": "      Futures.allAsList(immediateFailedFuture(new MyException())).get();\n",
        "1343": "      fail();\n",
        "1344": "    } catch (ExecutionException e) {\n",
        "1345": "      assertThat(e.getCause()).isInstanceOf(MyException.class);\n",
        "1346": "      assertEquals(\n",
        "1347": "          \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n",
        "1348": "    }\n",
        "1349": "  }\n",
        "1350": "\n",
        "1351": "  /**\n",
        "1352": "   * Ensure that errors are always logged.\n",
        "1353": "   */\n",
        "1354": "  @SuppressWarnings(\"unchecked\")\n",
        "1355": "  public void testAllAsList_logging_error() throws Exception {\n",
        "1356": "    try {\n",
        "1357": "      Futures.allAsList(immediateFailedFuture(new MyError())).get();\n",
        "1358": "      fail();\n",
        "1359": "    } catch (ExecutionException e) {\n",
        "1360": "      assertThat(e.getCause()).isInstanceOf(MyError.class);\n",
        "1361": "      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n",
        "1362": "      assertThat(logged).hasSize(1); // errors are always logged\n",
        "1363": "      assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);\n",
        "1364": "    }\n",
        "1365": "  }\n",
        "1366": "\n",
        "1367": "  /**\n",
        "1368": "   * All as list will log extra exceptions that have already occurred.\n",
        "1369": "   */\n",
        "1370": "  @SuppressWarnings(\"unchecked\")\n",
        "1371": "  public void testAllAsList_logging_multipleExceptions_alreadyDone() throws Exception {\n",
        "1372": "    try {\n",
        "1373": "      Futures.allAsList(immediateFailedFuture(new MyException()),\n",
        "1374": "          immediateFailedFuture(new MyException())).get();\n",
        "1375": "      fail();\n",
        "1376": "    } catch (ExecutionException e) {\n",
        "1377": "      assertThat(e.getCause()).isInstanceOf(MyException.class);\n",
        "1378": "      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n",
        "1379": "      assertThat(logged).hasSize(1); // the second failure is logged\n",
        "1380": "      assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\n",
        "1381": "    }\n",
        "1382": "  }\n",
        "1383": "\n",
        "1384": "  /**\n",
        "1385": "   * All as list will log extra exceptions that occur later.\n",
        "1386": "   */\n",
        "1387": "  @SuppressWarnings(\"unchecked\")\n",
        "1388": "  public void testAllAsList_logging_multipleExceptions_doneLater() throws Exception {\n",
        "1389": "    SettableFuture<Object> future1 = SettableFuture.create();\n",
        "1390": "    SettableFuture<Object> future2 = SettableFuture.create();\n",
        "1391": "    SettableFuture<Object> future3 = SettableFuture.create();\n",
        "1392": "    ListenableFuture<List<Object>> all = Futures.allAsList(future1, future2, future3);\n",
        "1393": "\n",
        "1394": "    future1.setException(new MyException());\n",
        "1395": "    future2.setException(new MyException());\n",
        "1396": "    future3.setException(new MyException());\n",
        "1397": "\n",
        "1398": "    try {\n",
        "1399": "      all.get();\n",
        "1400": "    } catch (ExecutionException e) {\n",
        "1401": "      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n",
        "1402": "      assertThat(logged).hasSize(2); // failures after the first are logged\n",
        "1403": "      assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\n",
        "1404": "      assertThat(logged.get(1).getThrown()).isInstanceOf(MyException.class);\n",
        "1405": "    }\n",
        "1406": "  }\n",
        "1407": "\n",
        "1408": "  /**\n",
        "1409": "   * The same exception happening on multiple futures should not be logged.\n",
        "1410": "   */\n",
        "1411": "  @SuppressWarnings(\"unchecked\")\n",
        "1412": "  public void testAllAsList_logging_same_exception() throws Exception {\n",
        "1413": "    try {\n",
        "1414": "      MyException sameInstance = new MyException();\n",
        "1415": "      Futures.allAsList(immediateFailedFuture(sameInstance),\n",
        "1416": "          immediateFailedFuture(sameInstance)).get();\n",
        "1417": "      fail();\n",
        "1418": "    } catch (ExecutionException e) {\n",
        "1419": "      assertThat(e.getCause()).isInstanceOf(MyException.class);\n",
        "1420": "      assertEquals(\n",
        "1421": "          \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n",
        "1422": "    }\n",
        "1423": "  }\n",
        "1424": "\n",
        "1425": "  public void testAllAsList_logging_seenExceptionUpdateRace() throws Exception {\n",
        "1426": "    final MyException sameInstance = new MyException();\n",
        "1427": "    SettableFuture<Object> firstFuture = SettableFuture.create();\n",
        "1428": "    final SettableFuture<Object> secondFuture = SettableFuture.create();\n",
        "1429": "    ListenableFuture<List<Object>> bulkFuture = allAsList(firstFuture, secondFuture);\n",
        "1430": "\n",
        "1431": "    bulkFuture.addListener(new Runnable() {\n",
        "1432": "      @Override\n",
        "1433": "      public void run() {\n",
        "1434": "        /*\n",
        "1435": "         * firstFuture just completed, but AggregateFuture hasn't yet had time to record the\n",
        "1436": "         * exception in seenExceptions. When we complete secondFuture with the same exception,\n",
        "1437": "         * we want for AggregateFuture to still detect that it's been previously seen.\n",
        "1438": "         */\n",
        "1439": "        secondFuture.setException(sameInstance);\n",
        "1440": "      }\n",
        "1441": "    }, directExecutor());\n",
        "1442": "    firstFuture.setException(sameInstance);\n",
        "1443": "\n",
        "1444": "    try {\n",
        "1445": "      bulkFuture.get();\n",
        "1446": "      fail();\n",
        "1447": "    } catch (ExecutionException expected) {\n",
        "1448": "      assertThat(expected.getCause()).isInstanceOf(MyException.class);\n",
        "1449": "      assertThat(aggregateFutureLogHandler.getStoredLogRecords()).isEmpty();\n",
        "1450": "    }\n",
        "1451": "  }\n",
        "1452": "\n",
        "1453": "  public void testAllAsList_logging_seenExceptionUpdateCancelRace() throws Exception {\n",
        "1454": "    final MyException subsequentFailure = new MyException();\n",
        "1455": "    SettableFuture<Object> firstFuture = SettableFuture.create();\n",
        "1456": "    final SettableFuture<Object> secondFuture = SettableFuture.create();\n",
        "1457": "    ListenableFuture<List<Object>> bulkFuture = allAsList(firstFuture, secondFuture);\n",
        "1458": "\n",
        "1459": "    bulkFuture.addListener(new Runnable() {\n",
        "1460": "      @Override\n",
        "1461": "      public void run() {\n",
        "1462": "        /*\n",
        "1463": "         * This is similar to the above test, but this time we're making sure that we recognize that\n",
        "1464": "         * the output Future is done early not because of an exception but because of a\n",
        "1465": "         * cancellation.\n",
        "1466": "         */\n",
        "1467": "        secondFuture.setException(subsequentFailure);\n",
        "1468": "      }\n",
        "1469": "    }, directExecutor());\n",
        "1470": "    firstFuture.cancel(false);\n",
        "1471": "\n",
        "1472": "    try {\n",
        "1473": "      bulkFuture.get();\n",
        "1474": "      fail();\n",
        "1475": "    } catch (CancellationException expected) {\n",
        "1476": "      assertThat(getOnlyElement(aggregateFutureLogHandler.getStoredLogRecords()).getThrown())\n",
        "1477": "          .isSameAs(subsequentFailure);\n",
        "1478": "    }\n",
        "1479": "  }\n",
        "1480": "\n",
        "1481": "  /**\n",
        "1482": "   * Different exceptions happening on multiple futures with the same cause should not be logged.\n",
        "1483": "   */\n",
        "1484": "  @SuppressWarnings(\"unchecked\")\n",
        "1485": "  public void testAllAsList_logging_same_cause() throws Exception {\n",
        "1486": "    try {\n",
        "1487": "      MyException exception1 = new MyException();\n",
        "1488": "      MyException exception2 = new MyException();\n",
        "1489": "      MyException exception3 = new MyException();\n",
        "1490": "\n",
        "1491": "      MyException sameInstance = new MyException();\n",
        "1492": "      exception1.initCause(sameInstance);\n",
        "1493": "      exception2.initCause(sameInstance);\n",
        "1494": "      exception3.initCause(exception2);\n",
        "1495": "      Futures.allAsList(immediateFailedFuture(exception1),\n",
        "1496": "          immediateFailedFuture(exception3)).get();\n",
        "1497": "      fail();\n",
        "1498": "    } catch (ExecutionException e) {\n",
        "1499": "      assertThat(e.getCause()).isInstanceOf(MyException.class);\n",
        "1500": "      assertEquals(\n",
        "1501": "          \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n",
        "1502": "    }\n",
        "1503": "  }\n",
        "1504": "\n",
        "1505": "  private static String createCombinedResult(Integer i, Boolean b) {\n",
        "1506": "    return \"-\" + i + \"-\" + b;\n",
        "1507": "  }\n",
        "1508": "\n",
        "1509": "  /*\n",
        "1510": "   * TODO(cpovirk): maybe pass around TestFuture instances instead of\n",
        "1511": "   * ListenableFuture instances\n",
        "1512": "   */\n",
        "1513": "\n",
        "1514": "  /**\n",
        "1515": "   * Non-Error exceptions are never logged.\n",
        "1516": "   */\n",
        "1517": "  @SuppressWarnings(\"unchecked\")\n",
        "1518": "  public void testSuccessfulAsList_logging_exception() throws Exception {\n",
        "1519": "    assertEquals(Lists.newArrayList((Object) null),\n",
        "1520": "        Futures.successfulAsList(\n",
        "1521": "            immediateFailedFuture(new MyException())).get());\n",
        "1522": "    assertEquals(\"Nothing should be logged\", 0,\n",
        "1523": "        aggregateFutureLogHandler.getStoredLogRecords().size());\n",
        "1524": "\n",
        "1525": "    // Not even if there are a bunch of failures.\n",
        "1526": "    assertEquals(Lists.newArrayList(null, null, null),\n",
        "1527": "        Futures.successfulAsList(\n",
        "1528": "            immediateFailedFuture(new MyException()),\n",
        "1529": "            immediateFailedFuture(new MyException()),\n",
        "1530": "            immediateFailedFuture(new MyException())).get());\n",
        "1531": "    assertEquals(\"Nothing should be logged\", 0,\n",
        "1532": "        aggregateFutureLogHandler.getStoredLogRecords().size());\n",
        "1533": "  }\n",
        "1534": "\n",
        "1535": "  /**\n",
        "1536": "   * Ensure that errors are always logged.\n",
        "1537": "   */\n",
        "1538": "  @SuppressWarnings(\"unchecked\")\n",
        "1539": "  public void testSuccessfulAsList_logging_error() throws Exception {\n",
        "1540": "    assertEquals(Lists.newArrayList((Object) null),\n",
        "1541": "        Futures.successfulAsList(\n",
        "1542": "            immediateFailedFuture(new MyError())).get());\n",
        "1543": "    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n",
        "1544": "    assertThat(logged).hasSize(1); // errors are always logged\n",
        "1545": "    assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);\n",
        "1546": "  }\n",
        "1547": "\n",
        "1548": "  // Mostly an example of how it would look like to use a list of mixed types\n",
        "1549": "\n",
        "1550": "  static AssertionFailedError failureWithCause(Throwable cause, String message) {\n",
        "1551": "    AssertionFailedError failure = new AssertionFailedError(message);\n",
        "1552": "    failure.initCause(cause);\n",
        "1553": "    return failure;\n",
        "1554": "  }\n",
        "1555": "\n",
        "1556": "  /**\n",
        "1557": "   * A future that throws a runtime exception from get.\n",
        "1558": "   */\n",
        "1559": "  static class BuggyFuture extends AbstractFuture<String> {\n",
        "1560": "\n",
        "1561": "    @Override\n",
        "1562": "    public String get() {\n",
        "1563": "      throw new RuntimeException();\n",
        "1564": "    }\n",
        "1565": "\n",
        "1566": "    @Override\n",
        "1567": "    public boolean set(String v) {\n",
        "1568": "      return super.set(v);\n",
        "1569": "    }\n",
        "1570": "  }\n",
        "1571": "\n",
        "1572": "  // This test covers a bug where an Error thrown from a callback could cause the TimeoutFuture to\n",
        "1573": "  // never complete when timing out.  Notably, nothing would get logged since the Error would get\n",
        "1574": "  // stuck in the ScheduledFuture inside of TimeoutFuture and nothing ever calls get on it.\n",
        "1575": "\n",
        "1576": "  // Simulate a timeout that fires before the call the SES.schedule returns but the future is\n",
        "1577": "  // already completed.\n",
        "1578": "\n",
        "1579": "  private static final Executor REJECTING_EXECUTOR =\n",
        "1580": "      new Executor() {\n",
        "1581": "        @Override\n",
        "1582": "        public void execute(Runnable runnable) {\n",
        "1583": "          throw new RejectedExecutionException();\n",
        "1584": "        }\n",
        "1585": "      };\n",
        "1586": "}\n"
    }
}