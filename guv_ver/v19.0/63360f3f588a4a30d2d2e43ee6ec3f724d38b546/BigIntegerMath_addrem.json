{
    "addition": {},
    "removed": {
        "1": "/*\n",
        "2": " * Copyright (C) 2011 The Guava Authors\n",
        "3": " *\n",
        "4": " * Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "5": " * you may not use this file except in compliance with the License.\n",
        "6": " * You may obtain a copy of the License at\n",
        "7": " *\n",
        "8": " * http://www.apache.org/licenses/LICENSE-2.0\n",
        "9": " *\n",
        "10": " * Unless required by applicable law or agreed to in writing, software\n",
        "11": " * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "12": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "13": " * See the License for the specific language governing permissions and\n",
        "14": " * limitations under the License.\n",
        "15": " */\n",
        "16": "\n",
        "17": "package com.google.common.math;\n",
        "18": "\n",
        "19": "import static com.google.common.base.Preconditions.checkArgument;\n",
        "20": "import static com.google.common.base.Preconditions.checkNotNull;\n",
        "21": "import static com.google.common.math.MathPreconditions.checkNonNegative;\n",
        "22": "import static com.google.common.math.MathPreconditions.checkPositive;\n",
        "23": "import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;\n",
        "24": "import static java.math.RoundingMode.CEILING;\n",
        "25": "import static java.math.RoundingMode.FLOOR;\n",
        "26": "import static java.math.RoundingMode.HALF_EVEN;\n",
        "27": "\n",
        "28": "import com.google.common.annotations.GwtCompatible;\n",
        "29": "import com.google.common.annotations.VisibleForTesting;\n",
        "30": "\n",
        "31": "import java.math.BigInteger;\n",
        "32": "import java.math.RoundingMode;\n",
        "33": "import java.util.ArrayList;\n",
        "34": "import java.util.List;\n",
        "35": "\n",
        "36": "/**\n",
        "37": " * A class for arithmetic on values of type {@code BigInteger}.\n",
        "38": " *\n",
        "39": " * <p>The implementations of many methods in this class are based on material from Henry S. Warren,\n",
        "40": " * Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).\n",
        "41": " *\n",
        "42": " * <p>Similar functionality for {@code int} and for {@code long} can be found in\n",
        "43": " * {@link IntMath} and {@link LongMath} respectively.\n",
        "44": " *\n",
        "45": " * @author Louis Wasserman\n",
        "46": " * @since 11.0\n",
        "47": " */\n",
        "48": "@GwtCompatible(emulated = true)\n",
        "49": "public final class BigIntegerMath {\n",
        "50": "  /**\n",
        "51": "   * Returns {@code true} if {@code x} represents a power of two.\n",
        "52": "   */\n",
        "53": "  public static boolean isPowerOfTwo(BigInteger x) {\n",
        "54": "    checkNotNull(x);\n",
        "55": "    return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1;\n",
        "56": "  }\n",
        "57": "\n",
        "58": "  /**\n",
        "59": "   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n",
        "60": "   *\n",
        "61": "   * @throws IllegalArgumentException if {@code x <= 0}\n",
        "62": "   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n",
        "63": "   *         is not a power of two\n",
        "64": "   */\n",
        "65": "  @SuppressWarnings(\"fallthrough\")\n",
        "66": "  // TODO(kevinb): remove after this warning is disabled globally\n",
        "67": "  public static int log2(BigInteger x, RoundingMode mode) {\n",
        "68": "    checkPositive(\"x\", checkNotNull(x));\n",
        "69": "    int logFloor = x.bitLength() - 1;\n",
        "70": "    switch (mode) {\n",
        "71": "      case UNNECESSARY:\n",
        "72": "        checkRoundingUnnecessary(isPowerOfTwo(x)); // fall through\n",
        "73": "      case DOWN:\n",
        "74": "      case FLOOR:\n",
        "75": "        return logFloor;\n",
        "76": "\n",
        "77": "      case UP:\n",
        "78": "      case CEILING:\n",
        "79": "        return isPowerOfTwo(x) ? logFloor : logFloor + 1;\n",
        "80": "\n",
        "81": "      case HALF_DOWN:\n",
        "82": "      case HALF_UP:\n",
        "83": "      case HALF_EVEN:\n",
        "84": "        if (logFloor < SQRT2_PRECOMPUTE_THRESHOLD) {\n",
        "85": "          BigInteger halfPower = SQRT2_PRECOMPUTED_BITS.shiftRight(\n",
        "86": "              SQRT2_PRECOMPUTE_THRESHOLD - logFloor);\n",
        "87": "          if (x.compareTo(halfPower) <= 0) {\n",
        "88": "            return logFloor;\n",
        "89": "          } else {\n",
        "90": "            return logFloor + 1;\n",
        "91": "          }\n",
        "92": "        }\n",
        "93": "        /*\n",
        "94": "         * Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n",
        "95": "         *\n",
        "96": "         * To determine which side of logFloor.5 the logarithm is, we compare x^2 to 2^(2 *\n",
        "97": "         * logFloor + 1).\n",
        "98": "         */\n",
        "99": "        BigInteger x2 = x.pow(2);\n",
        "100": "        int logX2Floor = x2.bitLength() - 1;\n",
        "101": "        return (logX2Floor < 2 * logFloor + 1) ? logFloor : logFloor + 1;\n",
        "102": "\n",
        "103": "      default:\n",
        "104": "        throw new AssertionError();\n",
        "105": "    }\n",
        "106": "  }\n",
        "107": "\n",
        "108": "  /*\n",
        "109": "   * The maximum number of bits in a square root for which we'll precompute an explicit half power\n",
        "110": "   * of two. This can be any value, but higher values incur more class load time and linearly\n",
        "111": "   * increasing memory consumption.\n",
        "112": "   */\n",
        "113": "  @VisibleForTesting static final int SQRT2_PRECOMPUTE_THRESHOLD = 256;\n",
        "114": "\n",
        "115": "  @VisibleForTesting static final BigInteger SQRT2_PRECOMPUTED_BITS =\n",
        "116": "      new BigInteger(\"16a09e667f3bcc908b2fb1366ea957d3e3adec17512775099da2f590b0667322a\", 16);\n",
        "117": "\n",
        "118": "  private static final double LN_10 = Math.log(10);\n",
        "119": "  private static final double LN_2 = Math.log(2);\n",
        "120": "\n",
        "121": "  /**\n",
        "122": "   * Returns {@code n!}, that is, the product of the first {@code n} positive\n",
        "123": "   * integers, or {@code 1} if {@code n == 0}.\n",
        "124": "   *\n",
        "125": "   * <p><b>Warning:</b> the result takes <i>O(n log n)</i> space, so use cautiously.\n",
        "126": "   *\n",
        "127": "   * <p>This uses an efficient binary recursive algorithm to compute the factorial\n",
        "128": "   * with balanced multiplies.  It also removes all the 2s from the intermediate\n",
        "129": "   * products (shifting them back in at the end).\n",
        "130": "   *\n",
        "131": "   * @throws IllegalArgumentException if {@code n < 0}\n",
        "132": "   */\n",
        "133": "  public static BigInteger factorial(int n) {\n",
        "134": "    checkNonNegative(\"n\", n);\n",
        "135": "\n",
        "136": "    // If the factorial is small enough, just use LongMath to do it.\n",
        "137": "    if (n < LongMath.factorials.length) {\n",
        "138": "      return BigInteger.valueOf(LongMath.factorials[n]);\n",
        "139": "    }\n",
        "140": "\n",
        "141": "    // Pre-allocate space for our list of intermediate BigIntegers.\n",
        "142": "    int approxSize = IntMath.divide(n * IntMath.log2(n, CEILING), Long.SIZE, CEILING);\n",
        "143": "    ArrayList<BigInteger> bignums = new ArrayList<BigInteger>(approxSize);\n",
        "144": "\n",
        "145": "    // Start from the pre-computed maximum long factorial.\n",
        "146": "    int startingNumber = LongMath.factorials.length;\n",
        "147": "    long product = LongMath.factorials[startingNumber - 1];\n",
        "148": "    // Strip off 2s from this value.\n",
        "149": "    int shift = Long.numberOfTrailingZeros(product);\n",
        "150": "    product >>= shift;\n",
        "151": "\n",
        "152": "    // Use floor(log2(num)) + 1 to prevent overflow of multiplication.\n",
        "153": "    int productBits = LongMath.log2(product, FLOOR) + 1;\n",
        "154": "    int bits = LongMath.log2(startingNumber, FLOOR) + 1;\n",
        "155": "    // Check for the next power of two boundary, to save us a CLZ operation.\n",
        "156": "    int nextPowerOfTwo = 1 << (bits - 1);\n",
        "157": "\n",
        "158": "    // Iteratively multiply the longs as big as they can go.\n",
        "159": "    for (long num = startingNumber; num <= n; num++) {\n",
        "160": "      // Check to see if the floor(log2(num)) + 1 has changed.\n",
        "161": "      if ((num & nextPowerOfTwo) != 0) {\n",
        "162": "        nextPowerOfTwo <<= 1;\n",
        "163": "        bits++;\n",
        "164": "      }\n",
        "165": "      // Get rid of the 2s in num.\n",
        "166": "      int tz = Long.numberOfTrailingZeros(num);\n",
        "167": "      long normalizedNum = num >> tz;\n",
        "168": "      shift += tz;\n",
        "169": "      // Adjust floor(log2(num)) + 1.\n",
        "170": "      int normalizedBits = bits - tz;\n",
        "171": "      // If it won't fit in a long, then we store off the intermediate product.\n",
        "172": "      if (normalizedBits + productBits >= Long.SIZE) {\n",
        "173": "        bignums.add(BigInteger.valueOf(product));\n",
        "174": "        product = 1;\n",
        "175": "        productBits = 0;\n",
        "176": "      }\n",
        "177": "      product *= normalizedNum;\n",
        "178": "      productBits = LongMath.log2(product, FLOOR) + 1;\n",
        "179": "    }\n",
        "180": "    // Check for leftovers.\n",
        "181": "    if (product > 1) {\n",
        "182": "      bignums.add(BigInteger.valueOf(product));\n",
        "183": "    }\n",
        "184": "    // Efficiently multiply all the intermediate products together.\n",
        "185": "    return listProduct(bignums).shiftLeft(shift);\n",
        "186": "  }\n",
        "187": "\n",
        "188": "  static BigInteger listProduct(List<BigInteger> nums) {\n",
        "189": "    return listProduct(nums, 0, nums.size());\n",
        "190": "  }\n",
        "191": "\n",
        "192": "  static BigInteger listProduct(List<BigInteger> nums, int start, int end) {\n",
        "193": "    switch (end - start) {\n",
        "194": "      case 0:\n",
        "195": "        return BigInteger.ONE;\n",
        "196": "      case 1:\n",
        "197": "        return nums.get(start);\n",
        "198": "      case 2:\n",
        "199": "        return nums.get(start).multiply(nums.get(start + 1));\n",
        "200": "      case 3:\n",
        "201": "        return nums.get(start).multiply(nums.get(start + 1)).multiply(nums.get(start + 2));\n",
        "202": "      default:\n",
        "203": "        // Otherwise, split the list in half and recursively do this.\n",
        "204": "        int m = (end + start) >>> 1;\n",
        "205": "        return listProduct(nums, start, m).multiply(listProduct(nums, m, end));\n",
        "206": "    }\n",
        "207": "  }\n",
        "208": "\n",
        "209": " /**\n",
        "210": "   * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and\n",
        "211": "   * {@code k}, that is, {@code n! / (k! (n - k)!)}.\n",
        "212": "   *\n",
        "213": "   * <p><b>Warning:</b> the result can take as much as <i>O(k log n)</i> space.\n",
        "214": "   *\n",
        "215": "   * @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}\n",
        "216": "   */\n",
        "217": "  public static BigInteger binomial(int n, int k) {\n",
        "218": "    checkNonNegative(\"n\", n);\n",
        "219": "    checkNonNegative(\"k\", k);\n",
        "220": "    checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n",
        "221": "    if (k > (n >> 1)) {\n",
        "222": "      k = n - k;\n",
        "223": "    }\n",
        "224": "    if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {\n",
        "225": "      return BigInteger.valueOf(LongMath.binomial(n, k));\n",
        "226": "    }\n",
        "227": "\n",
        "228": "    BigInteger accum = BigInteger.ONE;\n",
        "229": "\n",
        "230": "    long numeratorAccum = n;\n",
        "231": "    long denominatorAccum = 1;\n",
        "232": "\n",
        "233": "    int bits = LongMath.log2(n, RoundingMode.CEILING);\n",
        "234": "\n",
        "235": "    int numeratorBits = bits;\n",
        "236": "\n",
        "237": "    for (int i = 1; i < k; i++) {\n",
        "238": "      int p = n - i;\n",
        "239": "      int q = i + 1;\n",
        "240": "\n",
        "241": "      // log2(p) >= bits - 1, because p >= n/2\n",
        "242": "\n",
        "243": "      if (numeratorBits + bits >= Long.SIZE - 1) {\n",
        "244": "        // The numerator is as big as it can get without risking overflow.\n",
        "245": "        // Multiply numeratorAccum / denominatorAccum into accum.\n",
        "246": "        accum = accum\n",
        "247": "            .multiply(BigInteger.valueOf(numeratorAccum))\n",
        "248": "            .divide(BigInteger.valueOf(denominatorAccum));\n",
        "249": "        numeratorAccum = p;\n",
        "250": "        denominatorAccum = q;\n",
        "251": "        numeratorBits = bits;\n",
        "252": "      } else {\n",
        "253": "        // We can definitely multiply into the long accumulators without overflowing them.\n",
        "254": "        numeratorAccum *= p;\n",
        "255": "        denominatorAccum *= q;\n",
        "256": "        numeratorBits += bits;\n",
        "257": "      }\n",
        "258": "    }\n",
        "259": "    return accum\n",
        "260": "        .multiply(BigInteger.valueOf(numeratorAccum))\n",
        "261": "        .divide(BigInteger.valueOf(denominatorAccum));\n",
        "262": "  }\n",
        "263": "\n",
        "264": "  // Returns true if BigInteger.valueOf(x.longValue()).equals(x).\n",
        "265": "\n",
        "266": "  private BigIntegerMath() {}\n",
        "267": "}\n",
        "268": "\n"
    }
}