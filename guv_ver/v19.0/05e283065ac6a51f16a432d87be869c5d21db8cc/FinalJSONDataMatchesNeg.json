[{"func":{"oldfunccode":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_oldfunccode_05e283065ac6a51f16a432d87be869c5d21db8cc_1.txt","newfunccode":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_newfunccode_05e283065ac6a51f16a432d87be869c5d21db8cc_1.txt","newdoc":" Fail fast on a null.  We throw NPE here because the contract of Executor states that it\n Lock while we check state.  We must maintain the lock while adding the new pair so that\n another thread can't run the list out from under us. We only add to the list if we have not\n Execute the runnable immediately. Because of scheduling this may end up getting called before\n some of the previously added runnables, but we're OK with that.  If we want to change the\n contract to guarantee ordering among runnables we'd have to modify the logic here to allow\n throws NPE on null listener, so we propagate that contract up into the add method as well.\n yet started execution.\n it.\n","newJdoc":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_newfuncnewJdoc_05e283065ac6a51f16a432d87be869c5d21db8cc_1.txt","olddoc":" Fail fast on a null.  We throw NPE here because the contract of\n Executor states that it throws NPE on null listener, so we propagate\n Lock while we check state.  We must maintain the lock while adding the\n new pair so that another thread can't run the list out from under us.\n Execute the runnable immediately. Because of scheduling this may end up\n getting called before some of the previously added runnables, but we're\n OK with that.  If we want to change the contract to guarantee ordering\n that contract up into the add method as well.\n We only add to the list if we have not yet started execution.\n among runnables we'd have to modify the logic here to allow it.\n","oldJdoc":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_oldfuncoldJdoc_05e283065ac6a51f16a432d87be869c5d21db8cc_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v19.0/05e283065ac6a51f16a432d87be869c5d21db8cc/ExecutionList","pathinproj":"guava/src/com/google/common/util/concurrent/ExecutionList.java","addlines":[73,74],"dellines":[85,86],"addcode":["    checkNotNull(runnable, \"Runnable was null.\");\n","    checkNotNull(executor, \"Executor was null.\");\n"],"delcode":["    Preconditions.checkNotNull(runnable, \"Runnable was null.\");\n","    Preconditions.checkNotNull(executor, \"Executor was null.\");\n"],"methodSig":"public void add(Runnable runnable, Executor executor)"},"doc":{"oldfunccode":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_olddocfunccode_05e283065ac6a51f16a432d87be869c5d21db8cc_1.txt","newfunccode":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_newdocfunccode_05e283065ac6a51f16a432d87be869c5d21db8cc_1.txt","newdoc":"","newJdoc":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_newdocnewJdoc_05e283065ac6a51f16a432d87be869c5d21db8cc_1.txt","olddoc":"","oldJdoc":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_olddocJdoc_05e283065ac6a51f16a432d87be869c5d21db8cc_1.txt","path":"/home/pritish/Documents/IP work/guv_ver/v19.0/05e283065ac6a51f16a432d87be869c5d21db8cc/Futures","pathinproj":"guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java","addlines":[992,993,585,586,587,588,988,589,989,590,990,991],"dellines":[1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,601,1049,602,1050,603,1051,604,1052,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622],"addcode":["   * <p>This overload, which does not accept an executor, uses {@code\n","   * directExecutor}, a dangerous choice in some cases. See the discussion in\n","   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n","   * documentation. The documentation's warnings about \"lightweight listeners\"\n","   * refer here to the work done during {@code AsyncFunction.apply}, not to any\n","   * work done to complete the returned {@code Future}.\n","   * <p>This overload, which does not accept an executor, uses {@code\n","   * directExecutor}, a dangerous choice in some cases. See the discussion in\n","   * the {@link ListenableFuture#addListener ListenableFuture.addListener}\n","   * documentation. The documentation's warnings about \"lightweight listeners\"\n","   * refer here to the work done during {@code AsyncFunction.apply}, not to any\n","   * work done to complete the returned {@code Future}.\n"],"delcode":["   * <p>Note: If the derived {@code Future} is slow or heavyweight to create\n","   * (whether the {@code Future} itself is slow or heavyweight to complete is\n","   * irrelevant), consider {@linkplain #transform(ListenableFuture,\n","   * AsyncFunction, Executor) supplying an executor}. If you do not supply an\n","   * executor, {@code transform} will use a\n","   * {@linkplain MoreExecutors#directExecutor direct executor}, which carries\n","   * some caveats for heavier operations. For example, the call to {@code\n","   * function.apply} may run on an unpredictable or undesirable thread:\n","   *\n","   * <ul>\n","   * <li>If the input {@code Future} is done at the time {@code transform} is\n","   * called, {@code transform} will call {@code function.apply} inline.\n","   * <li>If the input {@code Future} is not yet done, {@code transform} will\n","   * schedule {@code function.apply} to be run by the thread that completes the\n","   * input {@code Future}, which may be an internal system thread such as an\n","   * RPC network thread.\n","   * </ul>\n","   *\n","   * <p>Also note that, regardless of which thread executes {@code\n","   * function.apply}, all other registered but unexecuted listeners are\n","   * prevented from running during its execution, even if those listeners are\n","   * to run in other executors.\n","   * <p>Note: If the derived {@code Future} is slow or heavyweight to create\n","   * (whether the {@code Future} itself is slow or heavyweight to complete is\n","   * irrelevant), consider {@linkplain #transform(ListenableFuture,\n","   * AsyncFunction, Executor) supplying an executor}. If you do not supply an\n","   * executor, {@code transform} will use a\n","   * {@linkplain MoreExecutors#directExecutor direct executor}, which carries\n","   * some caveats for heavier operations. For example, the call to {@code\n","   * function.apply} may run on an unpredictable or undesirable thread:\n","   *\n","   * <ul>\n","   * <li>If the input {@code Future} is done at the time {@code transform} is\n","   * called, {@code transform} will call {@code function.apply} inline.\n","   * <li>If the input {@code Future} is not yet done, {@code transform} will\n","   * schedule {@code function.apply} to be run by the thread that completes the\n","   * input {@code Future}, which may be an internal system thread such as an\n","   * RPC network thread.\n","   * </ul>\n","   *\n","   * <p>Also note that, regardless of which thread executes {@code\n","   * function.apply}, all other registered but unexecuted listeners are\n","   * prevented from running during its execution, even if those listeners are\n","   * to run in other executors.\n"],"methodSig":"public static ListenableFuture<O> transform(ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function)"},"id":1,"flag":1,"commit":"05e283065ac6a51f16a432d87be869c5d21db8cc"},{"func":{"oldfunccode":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_oldfunccode_05e283065ac6a51f16a432d87be869c5d21db8cc_2.txt","newfunccode":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_newfunccode_05e283065ac6a51f16a432d87be869c5d21db8cc_2.txt","newdoc":" Fail fast on a null.  We throw NPE here because the contract of Executor states that it\n Lock while we check state.  We must maintain the lock while adding the new pair so that\n another thread can't run the list out from under us. We only add to the list if we have not\n Execute the runnable immediately. Because of scheduling this may end up getting called before\n some of the previously added runnables, but we're OK with that.  If we want to change the\n contract to guarantee ordering among runnables we'd have to modify the logic here to allow\n throws NPE on null listener, so we propagate that contract up into the add method as well.\n yet started execution.\n it.\n Fail fast on a null.  We throw NPE here because the contract of Executor states that it\n Lock while we check state.  We must maintain the lock while adding the new pair so that\n another thread can't run the list out from under us. We only add to the list if we have not\n Execute the runnable immediately. Because of scheduling this may end up getting called before\n some of the previously added runnables, but we're OK with that.  If we want to change the\n contract to guarantee ordering among runnables we'd have to modify the logic here to allow\n throws NPE on null listener, so we propagate that contract up into the add method as well.\n yet started execution.\n it.\n","newJdoc":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_newfuncnewJdoc_05e283065ac6a51f16a432d87be869c5d21db8cc_2.txt","olddoc":" Fail fast on a null.  We throw NPE here because the contract of\n Executor states that it throws NPE on null listener, so we propagate\n Lock while we check state.  We must maintain the lock while adding the\n new pair so that another thread can't run the list out from under us.\n Execute the runnable immediately. Because of scheduling this may end up\n getting called before some of the previously added runnables, but we're\n OK with that.  If we want to change the contract to guarantee ordering\n that contract up into the add method as well.\n We only add to the list if we have not yet started execution.\n among runnables we'd have to modify the logic here to allow it.\n Fail fast on a null.  We throw NPE here because the contract of\n Executor states that it throws NPE on null listener, so we propagate\n Lock while we check state.  We must maintain the lock while adding the\n new pair so that another thread can't run the list out from under us.\n Execute the runnable immediately. Because of scheduling this may end up\n getting called before some of the previously added runnables, but we're\n OK with that.  If we want to change the contract to guarantee ordering\n that contract up into the add method as well.\n We only add to the list if we have not yet started execution.\n among runnables we'd have to modify the logic here to allow it.\n","oldJdoc":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_oldfuncoldJdoc_05e283065ac6a51f16a432d87be869c5d21db8cc_2.txt","path":"/home/pritish/Documents/IP work/guv_ver/v19.0/05e283065ac6a51f16a432d87be869c5d21db8cc/ExecutionList","pathinproj":"guava/src/com/google/common/util/concurrent/ExecutionList.java","addlines":[73,74],"dellines":[85,86],"addcode":["    checkNotNull(runnable, \"Runnable was null.\");\n","    checkNotNull(executor, \"Executor was null.\");\n"],"delcode":["    Preconditions.checkNotNull(runnable, \"Runnable was null.\");\n","    Preconditions.checkNotNull(executor, \"Executor was null.\");\n"],"methodSig":"public void add(Runnable runnable, Executor executor)"},"doc":{"oldfunccode":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_olddocfunccode_05e283065ac6a51f16a432d87be869c5d21db8cc_2.txt","newfunccode":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_newdocfunccode_05e283065ac6a51f16a432d87be869c5d21db8cc_2.txt","newdoc":"","newJdoc":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_newdocnewJdoc_05e283065ac6a51f16a432d87be869c5d21db8cc_2.txt","olddoc":"","oldJdoc":"05e283065ac6a51f16a432d87be869c5d21db8cc/Codes_neg/Match_olddocJdoc_05e283065ac6a51f16a432d87be869c5d21db8cc_2.txt","path":"/home/pritish/Documents/IP work/guv_ver/v19.0/05e283065ac6a51f16a432d87be869c5d21db8cc/Futures","pathinproj":"guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Futures.java","addlines":[336,337,338,339,484,485,486,487,488,489,334,335],"dellines":[352,353,354,355,500,501,502,503,504,505,350,351],"addcode":["   * <p>When selecting an executor, note that {@code directExecutor} is\n","   * dangerous in some cases. See the discussion in the {@link\n","   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n","   * The documentation's warnings about \"lightweight listeners\" refer here to\n","   * the work done during {@code FutureFallback.create}, not to any work done to\n","   * complete the returned {@code Future}.\n","   * <p>When selecting an executor, note that {@code directExecutor} is\n","   * dangerous in some cases. See the discussion in the {@link\n","   * ListenableFuture#addListener ListenableFuture.addListener} documentation.\n","   * The documentation's warnings about \"lightweight listeners\" refer here to\n","   * the work done during {@code FutureFallback.create}, not to any work done to\n","   * complete the returned {@code Future}.\n"],"delcode":["   * <p>When the execution of {@code fallback.create} is fast and lightweight\n","   * (though the {@code Future} it returns need not meet these criteria),\n","   * consider {@linkplain #withFallback(ListenableFuture, FutureFallback)\n","   * omitting the executor} or explicitly specifying {@code\n","   * directExecutor}. However, be aware of the caveats documented in the\n","   * link above.\n","   * <p>When the execution of {@code fallback.create} is fast and lightweight\n","   * (though the {@code Future} it returns need not meet these criteria),\n","   * consider {@linkplain #withFallback(ListenableFuture, FutureFallback)\n","   * omitting the executor} or explicitly specifying {@code\n","   * directExecutor}. However, be aware of the caveats documented in the\n","   * link above.\n"],"methodSig":"public static ListenableFuture<V> withFallback(ListenableFuture<? extends V> input, FutureFallback<? extends V> fallback, Executor executor)"},"id":1,"flag":1,"commit":"05e283065ac6a51f16a432d87be869c5d21db8cc"}]