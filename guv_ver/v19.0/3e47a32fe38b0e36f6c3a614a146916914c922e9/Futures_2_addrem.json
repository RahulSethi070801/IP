{
    "addition": {
        "22": "import static com.google.common.util.concurrent.Platform.isInstanceOfThrowableClass;\n",
        "76": "public final class Futures extends GwtFuturesCatchingSpecialization {\n",
        "363": "   * <b>To be deprecated:</b> Prefer {@link #catchingAsync(ListenableFuture,\n",
        "364": "   * Class, AsyncFunction) catchingAsync(input, Throwable.class,\n",
        "365": "   * fallbackImplementedAsAnAsyncFunction)}, usually replacing {@code\n",
        "366": "   * Throwable.class} with the specific type you want to handle.\n",
        "367": "   *\n",
        "368": "   * <p>Returns a {@code Future} whose result is taken from the given primary\n",
        "429": "   * <p>Also note that, regardless of which thread executes {@code\n",
        "446": "   * <b>To be deprecated:</b> Prefer {@link #catchingAsync(ListenableFuture,\n",
        "447": "   * Class, AsyncFunction, Executor) catchingAsync(input, Throwable.class,\n",
        "448": "   * fallbackImplementedAsAnAsyncFunction, executor)}, usually replacing {@code\n",
        "449": "   * Throwable.class} with the specific type you want to handle.\n",
        "450": "   *\n",
        "451": "   * <p>Returns a {@code Future} whose result is taken from the given primary\n",
        "511": "    return catchingAsync(\n",
        "512": "        input, Throwable.class, asAsyncFunction(fallback), executor);\n",
        "513": "  }\n",
        "514": "\n",
        "515": "  /**\n",
        "516": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "517": "   * primary input fails with the given {@code exceptionType}, from the result provided by the\n",
        "518": "   * {@code fallback}. {@link Function#apply} is not invoked until the primary input has failed, so\n",
        "519": "   * if the primary input succeeds, it is never invoked. If, during the invocation of {@code\n",
        "520": "   * fallback}, an exception is thrown, this exception is used as the result of the output {@code\n",
        "521": "   * Future}.\n",
        "522": "   *\n",
        "523": "   * <p>Usage example:\n",
        "524": "   *\n",
        "525": "   * <pre>   {@code\n",
        "526": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "527": "   *\n",
        "528": "   *   // Falling back to a zero counter in case an exception happens when\n",
        "529": "   *   // processing the RPC to fetch counters.\n",
        "530": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catching(\n",
        "531": "   *       fetchCounterFuture, FetchException.class,\n",
        "532": "   *       new Function<FetchException, Integer>() {\n",
        "533": "   *         public Integer apply(FetchException e) {\n",
        "534": "   *           return 0;\n",
        "535": "   *         }\n",
        "536": "   *       });}</pre>\n",
        "537": "   *\n",
        "538": "   * <p>Note: If the derived {@code fallback} is slow or heavyweight, consider {@linkplain\n",
        "539": "   * #catching(ListenableFuture, Class, Function, Executor) supplying an executor}. If you do not\n",
        "540": "   * supply an executor, {@code catching} will use a {@linkplain MoreExecutors#directExecutor direct\n",
        "541": "   * executor}, which carries some caveats for heavier operations. For example, the call to {@code\n",
        "542": "   * fallback.apply} may run on an unpredictable or undesirable thread:\n",
        "543": "   *\n",
        "544": "   * <ul>\n",
        "545": "   * <li>If the input {@code Future} is done at the time {@code catching} is called, {@code\n",
        "546": "   * catching} will call {@code fallback.apply} inline.\n",
        "547": "   * <li>If the input {@code Future} is not yet done, {@code catching} will schedule {@code\n",
        "548": "   * fallback.apply} to be run by the thread that completes the input {@code Future}, which may be\n",
        "549": "   * an internal system thread such as an RPC network thread.\n",
        "550": "   * </ul>\n",
        "551": "   *\n",
        "552": "   * <p>Also note that, regardless of which thread executes {@code fallback.apply}, all other\n",
        "553": "   * registered but unexecuted listeners are prevented from running during its execution, even if\n",
        "554": "   * those listeners are to run in other executors.\n",
        "555": "   *\n",
        "556": "   * @param input the primary input {@code Future}\n",
        "557": "   * @param fallback the {@link Function} implementation to be called if {@code input} fails with\n",
        "558": "   *     the expected exception type\n",
        "559": "   * @param exceptionType the exception type that triggers use of {@code fallback}\n",
        "560": "   * @since 19.0\n",
        "561": "   */\n",
        "562": "  @GwtIncompatible(\"AVAILABLE but requires exceptionType to be Throwable.class\")\n",
        "563": "  public static <V, X extends Throwable> ListenableFuture<V> catching(\n",
        "564": "      ListenableFuture<? extends V> input, Class<X> exceptionType,\n",
        "565": "      Function<? super X, ? extends V> fallback) {\n",
        "566": "    return catching(input, exceptionType, fallback, directExecutor());\n",
        "570": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "571": "   * primary input fails with the given {@code exceptionType}, from the result provided by the\n",
        "572": "   * {@code fallback}. {@link Function#apply} is not invoked until the primary input has failed, so\n",
        "573": "   * if the primary input succeeds, it is never invoked. If, during the invocation of {@code\n",
        "574": "   * fallback}, an exception is thrown, this exception is used as the result of the output {@code\n",
        "575": "   * Future}.\n",
        "576": "   *\n",
        "577": "   * <p>Usage example:\n",
        "578": "   *\n",
        "579": "   * <pre>   {@code\n",
        "580": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "581": "   *\n",
        "582": "   *   // Falling back to a zero counter in case an exception happens when\n",
        "583": "   *   // processing the RPC to fetch counters.\n",
        "584": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catching(\n",
        "585": "   *       fetchCounterFuture, FetchException.class,\n",
        "586": "   *       new Function<FetchException, Integer>() {\n",
        "587": "   *         public Integer apply(FetchException e) {\n",
        "588": "   *           return 0;\n",
        "589": "   *         }\n",
        "590": "   *       }, directExecutor());}</pre>\n",
        "591": "   *\n",
        "592": "   * <p>When the execution of {@code fallback.apply} is fast and lightweight, consider {@linkplain\n",
        "593": "   * #catching(ListenableFuture, Class, Function) omitting the executor} or explicitly specifying\n",
        "594": "   * {@link MoreExecutors#directExecutor() directExecutor()}. However, be aware of the caveats\n",
        "595": "   * documented in the link above.\n",
        "596": "   *\n",
        "597": "   * @param input the primary input {@code Future}\n",
        "598": "   * @param fallback the {@link Function} implementation to be called if {@code input} fails with\n",
        "599": "   *     the expected exception type\n",
        "600": "   * @param exceptionType the exception type that triggers use of {@code fallback}\n",
        "601": "   * @param executor the executor that runs {@code fallback} if {@code input} fails\n",
        "602": "   * @since 19.0\n",
        "604": "  @GwtIncompatible(\"AVAILABLE but requires exceptionType to be Throwable.class\")\n",
        "605": "  public static <V, X extends Throwable> ListenableFuture<V> catching(\n",
        "606": "      ListenableFuture<? extends V> input, Class<X> exceptionType,\n",
        "607": "      Function<? super X, ? extends V> fallback, Executor executor) {\n",
        "608": "    return catchingAsync(input, exceptionType, asAsyncFunction(fallback), executor);\n",
        "609": "  }\n",
        "610": "\n",
        "611": "  /**\n",
        "612": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "613": "   * primary input fails with the given {@code exceptionType}, from the result provided by the\n",
        "614": "   * {@code fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has\n",
        "615": "   * failed, so if the primary input succeeds, it is never invoked. If, during the invocation of\n",
        "616": "   * {@code fallback}, an exception is thrown, this exception is used as the result of the output\n",
        "617": "   * {@code Future}.\n",
        "618": "   *\n",
        "619": "   * <p>Usage examples:\n",
        "620": "   *\n",
        "621": "   * <pre>   {@code\n",
        "622": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "623": "   *\n",
        "624": "   *   // Falling back to a zero counter in case an exception happens when\n",
        "625": "   *   // processing the RPC to fetch counters.\n",
        "626": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n",
        "627": "   *       fetchCounterFuture, FetchException.class,\n",
        "628": "   *       new AsyncFunction<FetchException, Integer>() {\n",
        "629": "   *         public ListenableFuture<Integer> apply(FetchException e) {\n",
        "630": "   *           return immediateFuture(0);\n",
        "631": "   *         }\n",
        "632": "   *       });}</pre>\n",
        "633": "   *\n",
        "634": "   * <p>The fallback can also choose to propagate the original exception when desired:\n",
        "635": "   *\n",
        "636": "   * <pre>   {@code\n",
        "637": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "638": "   *\n",
        "639": "   *   // Falling back to a zero counter only in case the exception was a\n",
        "640": "   *   // TimeoutException.\n",
        "641": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n",
        "642": "   *       fetchCounterFuture, FetchException.class,\n",
        "643": "   *       new AsyncFunction<FetchException, Integer>() {\n",
        "644": "   *         public ListenableFuture<Integer> apply(FetchException e)\n",
        "645": "   *             throws FetchException {\n",
        "646": "   *           if (omitDataOnFetchFailure) {\n",
        "647": "   *             return immediateFuture(0);\n",
        "648": "   *           }\n",
        "649": "   *           throw e;\n",
        "650": "   *         }\n",
        "651": "   *       });}</pre>\n",
        "652": "   *\n",
        "653": "   * <p>Note: If the derived {@code fallback} is slow or heavyweight in <i>creating</i> its {@code\n",
        "654": "   * Future} (whether that derived {@code Future} itself is slow or heavyweight in <i>completing</i>\n",
        "655": "   * is irrelevant), consider {@linkplain #catchingAsync(ListenableFuture, Class, AsyncFunction,\n",
        "656": "   * Executor) supplying an executor}. If you do not supply an executor, {@code catchingAsync} will\n",
        "657": "   * use a {@linkplain MoreExecutors#directExecutor direct executor}, which carries some caveats for\n",
        "658": "   * heavier operations. For example, the call to {@code fallback.apply} may run on an unpredictable\n",
        "659": "   * or undesirable thread:\n",
        "660": "   *\n",
        "661": "   * <ul>\n",
        "662": "   * <li>If the input {@code Future} is done at the time {@code catchingAsync} is called, {@code\n",
        "663": "   * catchingAsync} will call {@code fallback.apply} inline.\n",
        "664": "   * <li>If the input {@code Future} is not yet done, {@code catchingAsync} will schedule {@code\n",
        "665": "   * fallback.apply} to be run by the thread that completes the input {@code Future}, which may be\n",
        "666": "   * an internal system thread such as an RPC network thread.\n",
        "667": "   * </ul>\n",
        "668": "   *\n",
        "669": "   * <p>Also note that, regardless of which thread executes {@code fallback.apply}, all other\n",
        "670": "   * registered but unexecuted listeners are prevented from running during its execution, even if\n",
        "671": "   * those listeners are to run in other executors.\n",
        "672": "   *\n",
        "673": "   * @param input the primary input {@code Future}\n",
        "674": "   * @param fallback the {@link AsyncFunction} implementation to be called if {@code input} fails\n",
        "675": "   *     with the expected exception type\n",
        "676": "   * @param exceptionType the exception type that triggers use of {@code fallback}\n",
        "677": "   * @since 19.0\n",
        "678": "   */\n",
        "679": "  @GwtIncompatible(\"AVAILABLE but requires exceptionType to be Throwable.class\")\n",
        "680": "  public static <V, X extends Throwable> ListenableFuture<V> catchingAsync(\n",
        "681": "      ListenableFuture<? extends V> input, Class<X> exceptionType,\n",
        "682": "      AsyncFunction<? super X, ? extends V> fallback) {\n",
        "683": "    return catchingAsync(input, exceptionType, fallback, directExecutor());\n",
        "684": "  }\n",
        "685": "\n",
        "686": "  /**\n",
        "687": "   * Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the\n",
        "688": "   * primary input fails with the given {@code exceptionType}, from the result provided by the\n",
        "689": "   * {@code fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has\n",
        "690": "   * failed, so if the primary input succeeds, it is never invoked. If, during the invocation of\n",
        "691": "   * {@code fallback}, an exception is thrown, this exception is used as the result of the output\n",
        "692": "   * {@code Future}.\n",
        "693": "   *\n",
        "694": "   * <p>Usage examples:\n",
        "695": "   *\n",
        "696": "   * <pre>   {@code\n",
        "697": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "698": "   *\n",
        "699": "   *   // Falling back to a zero counter in case an exception happens when\n",
        "700": "   *   // processing the RPC to fetch counters.\n",
        "701": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n",
        "702": "   *       fetchCounterFuture, FetchException.class,\n",
        "703": "   *       new AsyncFunction<FetchException, Integer>() {\n",
        "704": "   *         public ListenableFuture<Integer> apply(FetchException e) {\n",
        "705": "   *           return immediateFuture(0);\n",
        "706": "   *         }\n",
        "707": "   *       }, directExecutor());}</pre>\n",
        "708": "   *\n",
        "709": "   * <p>The fallback can also choose to propagate the original exception when desired:\n",
        "710": "   *\n",
        "711": "   * <pre>   {@code\n",
        "712": "   *   ListenableFuture<Integer> fetchCounterFuture = ...;\n",
        "713": "   *\n",
        "714": "   *   // Falling back to a zero counter only in case the exception was a\n",
        "715": "   *   // TimeoutException.\n",
        "716": "   *   ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(\n",
        "717": "   *       fetchCounterFuture, FetchException.class,\n",
        "718": "   *       new AsyncFunction<FetchException, Integer>() {\n",
        "719": "   *         public ListenableFuture<Integer> apply(FetchException e)\n",
        "720": "   *             throws FetchException {\n",
        "721": "   *           if (omitDataOnFetchFailure) {\n",
        "722": "   *             return immediateFuture(0);\n",
        "723": "   *           }\n",
        "724": "   *           throw e;\n",
        "725": "   *         }\n",
        "726": "   *       }, directExecutor());}</pre>\n",
        "727": "   *\n",
        "728": "   * <p>When the execution of {@code fallback.apply} is fast and lightweight (though the {@code\n",
        "729": "   * Future} it returns need not meet these criteria), consider {@linkplain\n",
        "730": "   * #catchingAsync(ListenableFuture, Class, AsyncFunction) omitting the executor} or explicitly\n",
        "731": "   * specifying {@link MoreExecutors#directExecutor() directExecutor()}. However, be aware of the\n",
        "732": "   * caveats documented in the link above.\n",
        "733": "   *\n",
        "734": "   * @param input the primary input {@code Future}\n",
        "735": "   * @param fallback the {@link AsyncFunction} implementation to be called if {@code input} fails\n",
        "736": "   *     with the expected exception type\n",
        "737": "   * @param exceptionType the exception type that triggers use of {@code fallback}\n",
        "738": "   * @param executor the executor that runs {@code fallback} if {@code input} fails\n",
        "739": "   * @since 19.0\n",
        "740": "   */\n",
        "741": "  @GwtIncompatible(\"AVAILABLE but requires exceptionType to be Throwable.class\")\n",
        "742": "  public static <V, X extends Throwable> ListenableFuture<V> catchingAsync(\n",
        "743": "      ListenableFuture<? extends V> input, Class<X> exceptionType,\n",
        "744": "      AsyncFunction<? super X, ? extends V> fallback, Executor executor) {\n",
        "745": "    return new CatchingFuture<V, X>(input, exceptionType, fallback, executor);\n",
        "746": "  }\n",
        "747": "\n",
        "748": "  static <V> AsyncFunction<Throwable, V> asAsyncFunction(final FutureFallback<V> fallback) {\n",
        "749": "    checkNotNull(fallback);\n",
        "750": "    return new AsyncFunction<Throwable, V>() {\n",
        "751": "      @Override\n",
        "752": "      public ListenableFuture<V> apply(Throwable t) throws Exception {\n",
        "753": "        return checkNotNull(fallback.create(t), \"FutureFallback.create returned null instead of a \"\n",
        "754": "            + \"Future. Did you mean to return immediateFuture(null)?\");\n",
        "755": "      }\n",
        "756": "    };\n",
        "757": "  }\n",
        "758": "\n",
        "759": "  static class CatchingFuture<V, X extends Throwable> extends AbstractFuture.TrustedFuture<V> {\n",
        "762": "    CatchingFuture(ListenableFuture<? extends V> input,\n",
        "763": "        final Class<X> exceptionType,\n",
        "764": "        final AsyncFunction<? super X, ? extends V> fallback,\n",
        "766": "      checkNotNull(exceptionType);\n",
        "767": "      checkNotNull(fallback);\n",
        "768": "\n",
        "787": "            if (isInstanceOfThrowableClass(throwable, exceptionType)) {\n",
        "788": "              @SuppressWarnings(\"unchecked\") // verified safe by isInstance\n",
        "789": "              X castThrowable = (X) throwable;\n",
        "790": "              ListenableFuture<? extends V> replacement = fallback.apply(castThrowable);\n",
        "791": "              checkNotNull(replacement, \"AsyncFunction.apply returned null instead of a Future. \"\n",
        "792": "                  + \"Did you mean to return immediateFuture(null)?\");\n",
        "793": "              setFuture(replacement);\n",
        "794": "            } else {\n",
        "795": "              setException(throwable);\n",
        "796": "            }\n",
        "996": "   * <p>Also note that, regardless of which thread executes {@code\n",
        "1134": "   * <p>Also note that, regardless of which thread executes {@code\n",
        "1208": "  static <I, O> AsyncFunction<I, O> asAsyncFunction(\n",
        "1210": "    checkNotNull(function);\n"
    },
    "removed": {
        "75": "public final class Futures {\n",
        "362": "   * Returns a {@code Future} whose result is taken from the given primary\n",
        "423": "   * <p>Also note that, regardless of which thread executes the {@code\n",
        "440": "   * Returns a {@code Future} whose result is taken from the given primary\n",
        "500": "    checkNotNull(fallback);\n",
        "501": "    return new FallbackFuture<V>(input, fallback, executor);\n",
        "505": "   * A future that falls back on a second, generated future, in case its\n",
        "506": "   * original future fails.\n",
        "508": "  private static class FallbackFuture<V> extends AbstractFuture.TrustedFuture<V> {\n",
        "511": "    FallbackFuture(ListenableFuture<? extends V> input,\n",
        "512": "        final FutureFallback<? extends V> fallback,\n",
        "532": "            ListenableFuture<? extends V> replacement = fallback.create(throwable);\n",
        "533": "            checkNotNull(replacement, \"FutureFallback.create returned null instead of a Future. \"\n",
        "534": "                + \"Did you mean to return immediateFuture(null)?\");\n",
        "535": "            setFuture(replacement);\n",
        "735": "   * <p>Also note that, regardless of which thread executes the {@code\n",
        "873": "   * <p>Also note that, regardless of which thread executes the {@code\n",
        "947": "  private static <I, O> AsyncFunction<I, O> asAsyncFunction(\n"
    }
}