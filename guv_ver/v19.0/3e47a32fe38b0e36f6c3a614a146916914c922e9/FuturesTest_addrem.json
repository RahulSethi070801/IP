{
    "addition": {
        "31": "import java.io.IOException;\n",
        "252": "  private static class FunctionSpy<I, O> implements Function<I, O> {\n",
        "253": "    private int applyCount;\n",
        "254": "    private final Function<I, O> delegate;\n",
        "255": "\n",
        "256": "    public FunctionSpy(Function<I, O> delegate) {\n",
        "257": "      this.delegate = delegate;\n",
        "258": "    }\n",
        "259": "\n",
        "260": "    @Override\n",
        "261": "    public O apply(I input) {\n",
        "262": "      applyCount++;\n",
        "263": "      return delegate.apply(input);\n",
        "264": "    }\n",
        "265": "\n",
        "266": "    void verifyCallCount(int expected) {\n",
        "267": "      assertThat(applyCount).is(expected);\n",
        "268": "    }\n",
        "269": "  }\n",
        "270": "\n",
        "271": "  private static <I, O> FunctionSpy<I, O> spy(Function<I, O> delegate) {\n",
        "272": "    return new FunctionSpy<I, O>(delegate);\n",
        "273": "  }\n",
        "274": "\n",
        "275": "  private static <X extends Throwable, V> Function<X, V> unexpectedFunction() {\n",
        "276": "    return new Function<X, V>() {\n",
        "277": "      @Override\n",
        "278": "      public V apply(X t) {\n",
        "279": "        throw new AssertionError(\"Unexpected fallback\", t);\n",
        "280": "      }\n",
        "281": "    };\n",
        "282": "  }\n",
        "283": "\n",
        "311": "      public ListenableFuture<V> create(Throwable t) {\n",
        "312": "        throw new AssertionError(\"Unexpected fallback\", t);\n",
        "313": "      }\n",
        "314": "    };\n",
        "315": "  }\n",
        "316": "\n",
        "317": "  private static class AsyncFunctionSpy<X extends Throwable, V> implements AsyncFunction<X, V> {\n",
        "318": "    private int count;\n",
        "319": "    private final AsyncFunction<X, V> delegate;\n",
        "320": "\n",
        "321": "    public AsyncFunctionSpy(AsyncFunction<X, V> delegate) {\n",
        "322": "      this.delegate = delegate;\n",
        "323": "    }\n",
        "324": "\n",
        "325": "    @Override\n",
        "326": "    public final ListenableFuture<V> apply(X t) throws Exception {\n",
        "327": "      count++;\n",
        "328": "      return delegate.apply(t);\n",
        "329": "    }\n",
        "330": "\n",
        "331": "    void verifyCallCount(int expected) {\n",
        "332": "      assertThat(count).is(expected);\n",
        "333": "    }\n",
        "334": "  }\n",
        "335": "\n",
        "336": "  private static <X extends Throwable, V> AsyncFunctionSpy<X, V> spy(AsyncFunction<X, V> delegate) {\n",
        "337": "    return new AsyncFunctionSpy<X, V>(delegate);\n",
        "338": "  }\n",
        "339": "\n",
        "340": "  private static <X extends Throwable, V> AsyncFunction<X, V> unexpectedAsyncFunction() {\n",
        "341": "    return new AsyncFunction<X, V>() {\n",
        "342": "      @Override\n",
        "343": "      public ListenableFuture<V> apply(X t) {\n",
        "486": "  // catchingAsync tests cloned from the old withFallback tests:\n",
        "487": "\n",
        "488": "  public void testCatchingAsync_inputDoesNotRaiseException() throws Exception {\n",
        "489": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "490": "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n",
        "491": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "492": "        Futures.catchingAsync(originalFuture, Throwable.class, fallback);\n",
        "493": "    assertEquals(7, faultToleranteFuture.get().intValue());\n",
        "494": "  }\n",
        "495": "\n",
        "496": "  public void testCatchingAsync_inputRaisesException() throws Exception {\n",
        "497": "    final RuntimeException raisedException = new RuntimeException();\n",
        "498": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "499": "      @Override\n",
        "500": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "501": "        assertThat(t).isSameAs(raisedException);\n",
        "502": "        return Futures.immediateFuture(20);\n",
        "503": "      }\n",
        "504": "    });\n",
        "505": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n",
        "506": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "507": "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n",
        "508": "    assertEquals(20, faultTolerantFuture.get().intValue());\n",
        "509": "    fallback.verifyCallCount(1);\n",
        "510": "  }\n",
        "511": "\n",
        "512": "  public void testCatchingAsync_fallbackGeneratesRuntimeException() throws Exception {\n",
        "513": "    RuntimeException expectedException = new RuntimeException();\n",
        "514": "    runExpectedExceptionCatchingAsyncTest(expectedException, false);\n",
        "515": "  }\n",
        "516": "\n",
        "517": "  public void testCatchingAsync_fallbackGeneratesCheckedException() throws Exception {\n",
        "518": "    Exception expectedException = new Exception() {\n",
        "519": "    };\n",
        "520": "    runExpectedExceptionCatchingAsyncTest(expectedException, false);\n",
        "521": "  }\n",
        "522": "\n",
        "523": "  public void testCatchingAsync_fallbackGeneratesError() throws Exception {\n",
        "524": "    final Error error = new Error(\"deliberate\");\n",
        "525": "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n",
        "526": "      @Override\n",
        "527": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "528": "        throw error;\n",
        "529": "      }\n",
        "530": "    };\n",
        "531": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "532": "    try {\n",
        "533": "      Futures.catchingAsync(failingFuture, Throwable.class, fallback).get();\n",
        "534": "      fail(\"An Exception should have been thrown!\");\n",
        "535": "    } catch (ExecutionException expected) {\n",
        "536": "      assertSame(error, expected.getCause());\n",
        "537": "    }\n",
        "538": "  }\n",
        "539": "\n",
        "540": "  public void testCatchingAsync_fallbackReturnsRuntimeException() throws Exception {\n",
        "541": "    RuntimeException expectedException = new RuntimeException();\n",
        "542": "    runExpectedExceptionCatchingAsyncTest(expectedException, true);\n",
        "543": "  }\n",
        "544": "\n",
        "545": "  public void testCatchingAsync_fallbackReturnsCheckedException() throws Exception {\n",
        "546": "    Exception expectedException = new Exception() {\n",
        "547": "    };\n",
        "548": "    runExpectedExceptionCatchingAsyncTest(expectedException, true);\n",
        "549": "  }\n",
        "550": "\n",
        "551": "  private void runExpectedExceptionCatchingAsyncTest(\n",
        "552": "      final Exception expectedException, final boolean wrapInFuture) throws Exception {\n",
        "553": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "554": "      @Override\n",
        "555": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "556": "        if (!wrapInFuture) {\n",
        "557": "          throw expectedException;\n",
        "558": "        } else {\n",
        "559": "          return Futures.immediateFailedFuture(expectedException);\n",
        "560": "        }\n",
        "561": "      }\n",
        "562": "    });\n",
        "563": "\n",
        "564": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "565": "\n",
        "566": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "567": "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n",
        "568": "    try {\n",
        "569": "      faultToleranteFuture.get();\n",
        "570": "      fail(\"An Exception should have been thrown!\");\n",
        "571": "    } catch (ExecutionException ee) {\n",
        "572": "      assertSame(expectedException, ee.getCause());\n",
        "573": "    }\n",
        "574": "    fallback.verifyCallCount(1);\n",
        "575": "  }\n",
        "576": "\n",
        "577": "  public void testCatchingAsync_fallbackNotReady() throws Exception {\n",
        "578": "    ListenableFuture<Integer> primary = immediateFailedFuture(new Exception());\n",
        "579": "    final SettableFuture<Integer> secondary = SettableFuture.create();\n",
        "580": "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n",
        "581": "      @Override\n",
        "582": "      public ListenableFuture<Integer> apply(Throwable t) {\n",
        "583": "        return secondary;\n",
        "584": "      }\n",
        "585": "    };\n",
        "586": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "587": "    secondary.set(1);\n",
        "588": "    assertEquals(1, (int) derived.get());\n",
        "589": "  }\n",
        "590": "\n",
        "591": "  public void testCatchingAsync_resultInterruptedBeforeFallback() throws Exception {\n",
        "592": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "593": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "594": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "595": "    derived.cancel(true);\n",
        "596": "    assertTrue(primary.isCancelled());\n",
        "597": "    assertTrue(primary.wasInterrupted());\n",
        "598": "  }\n",
        "599": "\n",
        "600": "  public void testCatchingAsync_resultCancelledBeforeFallback() throws Exception {\n",
        "601": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "602": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "603": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "604": "    derived.cancel(false);\n",
        "605": "    assertTrue(primary.isCancelled());\n",
        "606": "    assertFalse(primary.wasInterrupted());\n",
        "607": "  }\n",
        "608": "\n",
        "609": "  public void testCatchingAsync_nullInsteadOfFuture() throws Exception {\n",
        "610": "    ListenableFuture<Integer> inputFuture = immediateFailedFuture(new Exception());\n",
        "611": "    ListenableFuture<?> chainedFuture = Futures.catchingAsync(inputFuture, Throwable.class,\n",
        "612": "        new AsyncFunction<Throwable, Integer>() {\n",
        "613": "          @Override\n",
        "614": "          public ListenableFuture<Integer> apply(Throwable t) {\n",
        "615": "            return null;\n",
        "616": "          }\n",
        "617": "        });\n",
        "618": "    try {\n",
        "619": "      chainedFuture.get();\n",
        "620": "      fail();\n",
        "621": "    } catch (ExecutionException expected) {\n",
        "622": "      NullPointerException cause = (NullPointerException) expected.getCause();\n",
        "623": "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n",
        "624": "          + \"Did you mean to return immediateFuture(null)?\");\n",
        "625": "    }\n",
        "626": "  }\n",
        "627": "\n",
        "628": "  // catching tests cloned from the old withFallback tests:\n",
        "629": "\n",
        "630": "  public void testCatching_inputDoesNotRaiseException() throws Exception {\n",
        "631": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "632": "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n",
        "633": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "634": "        Futures.catching(originalFuture, Throwable.class, fallback);\n",
        "635": "    assertEquals(7, faultToleranteFuture.get().intValue());\n",
        "636": "  }\n",
        "637": "\n",
        "638": "  public void testCatching_inputRaisesException() throws Exception {\n",
        "639": "    final RuntimeException raisedException = new RuntimeException();\n",
        "640": "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n",
        "641": "      @Override\n",
        "642": "      public Integer apply(Throwable t) {\n",
        "643": "        assertThat(t).isSameAs(raisedException);\n",
        "644": "        return 20;\n",
        "645": "      }\n",
        "646": "    });\n",
        "647": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n",
        "648": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "649": "        Futures.catching(failingFuture, Throwable.class, fallback);\n",
        "650": "    assertEquals(20, faultTolerantFuture.get().intValue());\n",
        "651": "    fallback.verifyCallCount(1);\n",
        "652": "  }\n",
        "653": "\n",
        "654": "  public void testCatching_fallbackGeneratesRuntimeException() throws Exception {\n",
        "655": "    RuntimeException expectedException = new RuntimeException();\n",
        "656": "    runExpectedExceptionCatchingTest(expectedException);\n",
        "657": "  }\n",
        "658": "\n",
        "659": "  /*\n",
        "660": "   * catching() uses a plain Function, so there's no\n",
        "661": "   * testCatching_fallbackGeneratesCheckedException().\n",
        "662": "   */\n",
        "663": "\n",
        "664": "  public void testCatching_fallbackGeneratesError() throws Exception {\n",
        "665": "    final Error error = new Error(\"deliberate\");\n",
        "666": "    Function<Throwable, Integer> fallback = new Function<Throwable, Integer>() {\n",
        "667": "      @Override\n",
        "668": "      public Integer apply(Throwable t) {\n",
        "669": "        throw error;\n",
        "670": "      }\n",
        "671": "    };\n",
        "672": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "673": "    try {\n",
        "674": "      Futures.catching(failingFuture, Throwable.class, fallback).get();\n",
        "675": "      fail(\"An Exception should have been thrown!\");\n",
        "676": "    } catch (ExecutionException expected) {\n",
        "677": "      assertSame(error, expected.getCause());\n",
        "678": "    }\n",
        "679": "  }\n",
        "680": "\n",
        "681": "  /*\n",
        "682": "   * catching() uses a plain Function, so there's no testCatching_fallbackReturnsRuntimeException()\n",
        "683": "   * or testCatching_fallbackReturnsCheckedException().\n",
        "684": "   */\n",
        "685": "\n",
        "686": "  private void runExpectedExceptionCatchingTest(final RuntimeException expectedException)\n",
        "687": "      throws Exception {\n",
        "688": "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n",
        "689": "      @Override\n",
        "690": "      public Integer apply(Throwable t) {\n",
        "691": "        throw expectedException;\n",
        "692": "      }\n",
        "693": "    });\n",
        "694": "\n",
        "695": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "696": "\n",
        "697": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "698": "        Futures.catching(failingFuture, Throwable.class, fallback);\n",
        "699": "    try {\n",
        "700": "      faultToleranteFuture.get();\n",
        "701": "      fail(\"An Exception should have been thrown!\");\n",
        "702": "    } catch (ExecutionException ee) {\n",
        "703": "      assertSame(expectedException, ee.getCause());\n",
        "704": "    }\n",
        "705": "    fallback.verifyCallCount(1);\n",
        "706": "  }\n",
        "707": "\n",
        "708": "  // catching() uses a plain Function, so there's no testCatching_fallbackNotReady().\n",
        "709": "\n",
        "710": "  public void testCatching_resultInterruptedBeforeFallback() throws Exception {\n",
        "711": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "712": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "713": "    ListenableFuture<Integer> derived = Futures.catching(primary, Throwable.class, fallback);\n",
        "714": "    derived.cancel(true);\n",
        "715": "    assertTrue(primary.isCancelled());\n",
        "716": "    assertTrue(primary.wasInterrupted());\n",
        "717": "  }\n",
        "718": "\n",
        "719": "  public void testCatching_resultCancelledBeforeFallback() throws Exception {\n",
        "720": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "721": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "722": "    ListenableFuture<Integer> derived = Futures.catching(primary, Throwable.class, fallback);\n",
        "723": "    derived.cancel(false);\n",
        "724": "    assertTrue(primary.isCancelled());\n",
        "725": "    assertFalse(primary.wasInterrupted());\n",
        "726": "  }\n",
        "727": "\n",
        "728": "  // catching() uses a plain Function, so there's no testCatching_resultCancelledAfterFallback().\n",
        "729": "\n",
        "730": "  // catching() uses a plain Function, so there's no testCatching_nullInsteadOfFuture().\n",
        "731": "\n",
        "732": "  // Some tests of the exceptionType parameter:\n",
        "733": "\n",
        "734": "  public void testCatching_Throwable() throws Exception {\n",
        "735": "    Function<Throwable, Integer> fallback = functionReturningOne();\n",
        "736": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new IOException());\n",
        "737": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "738": "        Futures.catching(originalFuture, Throwable.class, fallback);\n",
        "739": "    assertEquals(1, (int) faultTolerantFuture.get());\n",
        "740": "  }\n",
        "741": "\n",
        "742": "  public void testCatchingAsync_Throwable() throws Exception {\n",
        "743": "    AsyncFunction<Throwable, Integer> fallback = asyncFunctionReturningOne();\n",
        "744": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new IOException());\n",
        "745": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "746": "        Futures.catchingAsync(originalFuture, Throwable.class, fallback);\n",
        "747": "    assertEquals(1, (int) faultTolerantFuture.get());\n",
        "748": "  }\n",
        "749": "\n",
        "750": "  private <X extends Throwable> Function<X, Integer> functionReturningOne() {\n",
        "751": "    return new Function<X, Integer>() {\n",
        "752": "      @Override\n",
        "753": "      public Integer apply(X t) {\n",
        "754": "        return 1;\n",
        "755": "      }\n",
        "756": "    };\n",
        "757": "  }\n",
        "758": "\n",
        "759": "  private <X extends Throwable> AsyncFunction<X, Integer> asyncFunctionReturningOne() {\n",
        "760": "    return new AsyncFunction<X, Integer>() {\n",
        "761": "      @Override\n",
        "762": "      public ListenableFuture<Integer> apply(X t) {\n",
        "763": "        return immediateFuture(1);\n",
        "764": "      }\n",
        "765": "    };\n",
        "766": "  }\n",
        "767": "\n"
    },
    "removed": {
        "278": "      public ListenableFuture<V> create(Throwable t) throws Exception {\n"
    }
}