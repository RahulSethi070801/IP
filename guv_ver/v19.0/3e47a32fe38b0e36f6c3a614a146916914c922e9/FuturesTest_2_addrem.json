{
    "addition": {
        "52": "import java.io.FileNotFoundException;\n",
        "542": "    spy.verifyCallCount(0);\n",
        "544": "    spy.verifyCallCount(1);\n",
        "546": "    spy.verifyCallCount(2);\n",
        "587": "    void verifyCallCount(int expected) {\n",
        "588": "      assertThat(applyCount).is(expected);\n",
        "592": "  private static <I, O> FunctionSpy<I, O> spy(Function<I, O> delegate) {\n",
        "593": "    return new FunctionSpy<I, O>(delegate);\n",
        "594": "  }\n",
        "595": "\n",
        "596": "  private static <X extends Throwable, V> Function<X, V> unexpectedFunction() {\n",
        "597": "    return new Function<X, V>() {\n",
        "598": "      @Override\n",
        "599": "      public V apply(X t) {\n",
        "600": "        throw new AssertionError(\"Unexpected fallback\", t);\n",
        "601": "      }\n",
        "602": "    };\n",
        "603": "  }\n",
        "604": "\n",
        "632": "      public ListenableFuture<V> create(Throwable t) {\n",
        "633": "        throw new AssertionError(\"Unexpected fallback\", t);\n",
        "634": "      }\n",
        "635": "    };\n",
        "636": "  }\n",
        "637": "\n",
        "638": "  private static class AsyncFunctionSpy<X extends Throwable, V> implements AsyncFunction<X, V> {\n",
        "639": "    private int count;\n",
        "640": "    private final AsyncFunction<X, V> delegate;\n",
        "641": "\n",
        "642": "    public AsyncFunctionSpy(AsyncFunction<X, V> delegate) {\n",
        "643": "      this.delegate = delegate;\n",
        "644": "    }\n",
        "645": "\n",
        "646": "    @Override\n",
        "647": "    public final ListenableFuture<V> apply(X t) throws Exception {\n",
        "648": "      count++;\n",
        "649": "      return delegate.apply(t);\n",
        "650": "    }\n",
        "651": "\n",
        "652": "    void verifyCallCount(int expected) {\n",
        "653": "      assertThat(count).is(expected);\n",
        "654": "    }\n",
        "655": "  }\n",
        "656": "\n",
        "657": "  private static <X extends Throwable, V> AsyncFunctionSpy<X, V> spy(AsyncFunction<X, V> delegate) {\n",
        "658": "    return new AsyncFunctionSpy<X, V>(delegate);\n",
        "659": "  }\n",
        "660": "\n",
        "661": "  private static <X extends Throwable, V> AsyncFunction<X, V> unexpectedAsyncFunction() {\n",
        "662": "    return new AsyncFunction<X, V>() {\n",
        "663": "      @Override\n",
        "664": "      public ListenableFuture<V> apply(X t) {\n",
        "829": "  // catchingAsync tests cloned from the old withFallback tests:\n",
        "830": "\n",
        "831": "  public void testCatchingAsync_inputDoesNotRaiseException() throws Exception {\n",
        "832": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "833": "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n",
        "834": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "835": "        Futures.catchingAsync(originalFuture, Throwable.class, fallback);\n",
        "836": "    assertEquals(7, faultToleranteFuture.get().intValue());\n",
        "837": "  }\n",
        "838": "\n",
        "839": "  public void testCatchingAsync_inputRaisesException() throws Exception {\n",
        "840": "    final RuntimeException raisedException = new RuntimeException();\n",
        "841": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "842": "      @Override\n",
        "843": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "844": "        assertThat(t).isSameAs(raisedException);\n",
        "845": "        return Futures.immediateFuture(20);\n",
        "846": "      }\n",
        "847": "    });\n",
        "848": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n",
        "849": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "850": "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n",
        "851": "    assertEquals(20, faultTolerantFuture.get().intValue());\n",
        "852": "    fallback.verifyCallCount(1);\n",
        "853": "  }\n",
        "854": "\n",
        "855": "  public void testCatchingAsync_fallbackGeneratesRuntimeException() throws Exception {\n",
        "856": "    RuntimeException expectedException = new RuntimeException();\n",
        "857": "    runExpectedExceptionCatchingAsyncTest(expectedException, false);\n",
        "858": "  }\n",
        "859": "\n",
        "860": "  public void testCatchingAsync_fallbackGeneratesCheckedException() throws Exception {\n",
        "861": "    Exception expectedException = new Exception() {\n",
        "862": "    };\n",
        "863": "    runExpectedExceptionCatchingAsyncTest(expectedException, false);\n",
        "864": "  }\n",
        "865": "\n",
        "866": "  public void testCatchingAsync_fallbackGeneratesError() throws Exception {\n",
        "867": "    final Error error = new Error(\"deliberate\");\n",
        "868": "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n",
        "869": "      @Override\n",
        "870": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "871": "        throw error;\n",
        "872": "      }\n",
        "873": "    };\n",
        "874": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "875": "    try {\n",
        "876": "      Futures.catchingAsync(failingFuture, Throwable.class, fallback).get();\n",
        "877": "      fail(\"An Exception should have been thrown!\");\n",
        "878": "    } catch (ExecutionException expected) {\n",
        "879": "      assertSame(error, expected.getCause());\n",
        "880": "    }\n",
        "881": "  }\n",
        "882": "\n",
        "883": "  public void testCatchingAsync_fallbackReturnsRuntimeException() throws Exception {\n",
        "884": "    RuntimeException expectedException = new RuntimeException();\n",
        "885": "    runExpectedExceptionCatchingAsyncTest(expectedException, true);\n",
        "886": "  }\n",
        "887": "\n",
        "888": "  public void testCatchingAsync_fallbackReturnsCheckedException() throws Exception {\n",
        "889": "    Exception expectedException = new Exception() {\n",
        "890": "    };\n",
        "891": "    runExpectedExceptionCatchingAsyncTest(expectedException, true);\n",
        "892": "  }\n",
        "893": "\n",
        "894": "  private void runExpectedExceptionCatchingAsyncTest(\n",
        "895": "      final Exception expectedException, final boolean wrapInFuture) throws Exception {\n",
        "896": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "897": "      @Override\n",
        "898": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "899": "        if (!wrapInFuture) {\n",
        "900": "          throw expectedException;\n",
        "901": "        } else {\n",
        "902": "          return Futures.immediateFailedFuture(expectedException);\n",
        "903": "        }\n",
        "904": "      }\n",
        "905": "    });\n",
        "906": "\n",
        "907": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "908": "\n",
        "909": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "910": "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n",
        "911": "    try {\n",
        "912": "      faultToleranteFuture.get();\n",
        "913": "      fail(\"An Exception should have been thrown!\");\n",
        "914": "    } catch (ExecutionException ee) {\n",
        "915": "      assertSame(expectedException, ee.getCause());\n",
        "916": "    }\n",
        "917": "    fallback.verifyCallCount(1);\n",
        "918": "  }\n",
        "919": "\n",
        "920": "  public void testCatchingAsync_fallbackNotReady() throws Exception {\n",
        "921": "    ListenableFuture<Integer> primary = immediateFailedFuture(new Exception());\n",
        "922": "    final SettableFuture<Integer> secondary = SettableFuture.create();\n",
        "923": "    AsyncFunction<Throwable, Integer> fallback = new AsyncFunction<Throwable, Integer>() {\n",
        "924": "      @Override\n",
        "925": "      public ListenableFuture<Integer> apply(Throwable t) {\n",
        "926": "        return secondary;\n",
        "927": "      }\n",
        "928": "    };\n",
        "929": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "930": "    secondary.set(1);\n",
        "931": "    assertEquals(1, (int) derived.get());\n",
        "932": "  }\n",
        "933": "\n",
        "934": "  public void testCatchingAsync_resultInterruptedBeforeFallback() throws Exception {\n",
        "935": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "936": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "937": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "938": "    derived.cancel(true);\n",
        "939": "    assertTrue(primary.isCancelled());\n",
        "940": "    assertTrue(primary.wasInterrupted());\n",
        "941": "  }\n",
        "942": "\n",
        "943": "  public void testCatchingAsync_resultCancelledBeforeFallback() throws Exception {\n",
        "944": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "945": "    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();\n",
        "946": "    ListenableFuture<Integer> derived = Futures.catchingAsync(primary, Throwable.class, fallback);\n",
        "947": "    derived.cancel(false);\n",
        "948": "    assertTrue(primary.isCancelled());\n",
        "949": "    assertFalse(primary.wasInterrupted());\n",
        "950": "  }\n",
        "951": "\n",
        "952": "  @GwtIncompatible(\"mocks\")\n",
        "953": "  @SuppressWarnings(\"unchecked\")\n",
        "954": "  public void testCatchingAsync_resultCancelledAfterFallback() throws Exception {\n",
        "955": "    final SettableFuture<Integer> secondary = SettableFuture.create();\n",
        "956": "    final RuntimeException raisedException = new RuntimeException();\n",
        "957": "    AsyncFunctionSpy<Throwable, Integer> fallback = spy(new AsyncFunction<Throwable, Integer>() {\n",
        "958": "      @Override\n",
        "959": "      public ListenableFuture<Integer> apply(Throwable t) throws Exception {\n",
        "960": "        assertThat(t).isSameAs(raisedException);\n",
        "961": "        return secondary;\n",
        "962": "      }\n",
        "963": "    });\n",
        "964": "\n",
        "965": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n",
        "966": "\n",
        "967": "    ListenableFuture<Integer> derived =\n",
        "968": "        Futures.catchingAsync(failingFuture, Throwable.class, fallback);\n",
        "969": "    derived.cancel(false);\n",
        "970": "    assertTrue(secondary.isCancelled());\n",
        "971": "    assertFalse(secondary.wasInterrupted());\n",
        "972": "    fallback.verifyCallCount(1);\n",
        "973": "  }\n",
        "974": "\n",
        "975": "  public void testCatchingAsync_nullInsteadOfFuture() throws Exception {\n",
        "976": "    ListenableFuture<Integer> inputFuture = immediateFailedFuture(new Exception());\n",
        "977": "    ListenableFuture<?> chainedFuture = Futures.catchingAsync(inputFuture, Throwable.class,\n",
        "978": "        new AsyncFunction<Throwable, Integer>() {\n",
        "979": "          @Override\n",
        "980": "          public ListenableFuture<Integer> apply(Throwable t) {\n",
        "981": "            return null;\n",
        "982": "          }\n",
        "983": "        });\n",
        "984": "    try {\n",
        "985": "      chainedFuture.get();\n",
        "986": "      fail();\n",
        "987": "    } catch (ExecutionException expected) {\n",
        "988": "      NullPointerException cause = (NullPointerException) expected.getCause();\n",
        "989": "      assertThat(cause).hasMessage(\"AsyncFunction.apply returned null instead of a Future. \"\n",
        "990": "          + \"Did you mean to return immediateFuture(null)?\");\n",
        "991": "    }\n",
        "992": "  }\n",
        "993": "\n",
        "994": "  // catching tests cloned from the old withFallback tests:\n",
        "995": "\n",
        "996": "  public void testCatching_inputDoesNotRaiseException() throws Exception {\n",
        "997": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "998": "    ListenableFuture<Integer> originalFuture = Futures.immediateFuture(7);\n",
        "999": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "1000": "        Futures.catching(originalFuture, Throwable.class, fallback);\n",
        "1001": "    assertEquals(7, faultToleranteFuture.get().intValue());\n",
        "1002": "  }\n",
        "1003": "\n",
        "1004": "  public void testCatching_inputRaisesException() throws Exception {\n",
        "1005": "    final RuntimeException raisedException = new RuntimeException();\n",
        "1006": "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n",
        "1007": "      @Override\n",
        "1008": "      public Integer apply(Throwable t) {\n",
        "1009": "        assertThat(t).isSameAs(raisedException);\n",
        "1010": "        return 20;\n",
        "1011": "      }\n",
        "1012": "    });\n",
        "1013": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(raisedException);\n",
        "1014": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "1015": "        Futures.catching(failingFuture, Throwable.class, fallback);\n",
        "1016": "    assertEquals(20, faultTolerantFuture.get().intValue());\n",
        "1017": "    fallback.verifyCallCount(1);\n",
        "1018": "  }\n",
        "1019": "\n",
        "1020": "  public void testCatching_fallbackGeneratesRuntimeException() throws Exception {\n",
        "1021": "    RuntimeException expectedException = new RuntimeException();\n",
        "1022": "    runExpectedExceptionCatchingTest(expectedException);\n",
        "1023": "  }\n",
        "1024": "\n",
        "1025": "  /*\n",
        "1026": "   * catching() uses a plain Function, so there's no\n",
        "1027": "   * testCatching_fallbackGeneratesCheckedException().\n",
        "1028": "   */\n",
        "1029": "\n",
        "1030": "  public void testCatching_fallbackGeneratesError() throws Exception {\n",
        "1031": "    final Error error = new Error(\"deliberate\");\n",
        "1032": "    Function<Throwable, Integer> fallback = new Function<Throwable, Integer>() {\n",
        "1033": "      @Override\n",
        "1034": "      public Integer apply(Throwable t) {\n",
        "1035": "        throw error;\n",
        "1036": "      }\n",
        "1037": "    };\n",
        "1038": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "1039": "    try {\n",
        "1040": "      Futures.catching(failingFuture, Throwable.class, fallback).get();\n",
        "1041": "      fail(\"An Exception should have been thrown!\");\n",
        "1042": "    } catch (ExecutionException expected) {\n",
        "1043": "      assertSame(error, expected.getCause());\n",
        "1044": "    }\n",
        "1045": "  }\n",
        "1046": "\n",
        "1047": "  /*\n",
        "1048": "   * catching() uses a plain Function, so there's no testCatching_fallbackReturnsRuntimeException()\n",
        "1049": "   * or testCatching_fallbackReturnsCheckedException().\n",
        "1050": "   */\n",
        "1051": "\n",
        "1052": "  private void runExpectedExceptionCatchingTest(final RuntimeException expectedException)\n",
        "1053": "      throws Exception {\n",
        "1054": "    FunctionSpy<Throwable, Integer> fallback = spy(new Function<Throwable, Integer>() {\n",
        "1055": "      @Override\n",
        "1056": "      public Integer apply(Throwable t) {\n",
        "1057": "        throw expectedException;\n",
        "1058": "      }\n",
        "1059": "    });\n",
        "1060": "\n",
        "1061": "    ListenableFuture<Integer> failingFuture = Futures.immediateFailedFuture(new RuntimeException());\n",
        "1062": "\n",
        "1063": "    ListenableFuture<Integer> faultToleranteFuture =\n",
        "1064": "        Futures.catching(failingFuture, Throwable.class, fallback);\n",
        "1065": "    try {\n",
        "1066": "      faultToleranteFuture.get();\n",
        "1067": "      fail(\"An Exception should have been thrown!\");\n",
        "1068": "    } catch (ExecutionException ee) {\n",
        "1069": "      assertSame(expectedException, ee.getCause());\n",
        "1070": "    }\n",
        "1071": "    fallback.verifyCallCount(1);\n",
        "1072": "  }\n",
        "1073": "\n",
        "1074": "  // catching() uses a plain Function, so there's no testCatching_fallbackNotReady().\n",
        "1075": "\n",
        "1076": "  public void testCatching_resultInterruptedBeforeFallback() throws Exception {\n",
        "1077": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "1078": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "1079": "    ListenableFuture<Integer> derived = Futures.catching(primary, Throwable.class, fallback);\n",
        "1080": "    derived.cancel(true);\n",
        "1081": "    assertTrue(primary.isCancelled());\n",
        "1082": "    assertTrue(primary.wasInterrupted());\n",
        "1083": "  }\n",
        "1084": "\n",
        "1085": "  public void testCatching_resultCancelledBeforeFallback() throws Exception {\n",
        "1086": "    SettableFuture<Integer> primary = SettableFuture.create();\n",
        "1087": "    Function<Throwable, Integer> fallback = unexpectedFunction();\n",
        "1088": "    ListenableFuture<Integer> derived = Futures.catching(primary, Throwable.class, fallback);\n",
        "1089": "    derived.cancel(false);\n",
        "1090": "    assertTrue(primary.isCancelled());\n",
        "1091": "    assertFalse(primary.wasInterrupted());\n",
        "1092": "  }\n",
        "1093": "\n",
        "1094": "  // catching() uses a plain Function, so there's no testCatching_resultCancelledAfterFallback().\n",
        "1095": "\n",
        "1096": "  // catching() uses a plain Function, so there's no testCatching_nullInsteadOfFuture().\n",
        "1097": "\n",
        "1098": "  // Some tests of the exceptionType parameter:\n",
        "1099": "\n",
        "1100": "  public void testCatching_Throwable() throws Exception {\n",
        "1101": "    Function<Throwable, Integer> fallback = functionReturningOne();\n",
        "1102": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new IOException());\n",
        "1103": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "1104": "        Futures.catching(originalFuture, Throwable.class, fallback);\n",
        "1105": "    assertEquals(1, (int) faultTolerantFuture.get());\n",
        "1106": "  }\n",
        "1107": "\n",
        "1108": "  @GwtIncompatible(\"non-Throwable exceptionType\")\n",
        "1109": "  public void testCatching_customTypeMatch() throws Exception {\n",
        "1110": "    Function<IOException, Integer> fallback = functionReturningOne();\n",
        "1111": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new FileNotFoundException());\n",
        "1112": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "1113": "        Futures.catching(originalFuture, IOException.class, fallback);\n",
        "1114": "    assertEquals(1, (int) faultTolerantFuture.get());\n",
        "1115": "  }\n",
        "1116": "\n",
        "1117": "  @GwtIncompatible(\"non-Throwable exceptionType\")\n",
        "1118": "  public void testCatching_customTypeNoMatch() throws Exception {\n",
        "1119": "    Function<IOException, Integer> fallback = functionReturningOne();\n",
        "1120": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new RuntimeException());\n",
        "1121": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "1122": "        Futures.catching(originalFuture, IOException.class, fallback);\n",
        "1123": "    try {\n",
        "1124": "      faultTolerantFuture.get();\n",
        "1125": "      fail();\n",
        "1126": "    } catch (ExecutionException expected) {\n",
        "1127": "      assertTrue(expected.getCause() instanceof RuntimeException);\n",
        "1128": "    }\n",
        "1129": "  }\n",
        "1130": "\n",
        "1131": "  public void testCatchingAsync_Throwable() throws Exception {\n",
        "1132": "    AsyncFunction<Throwable, Integer> fallback = asyncFunctionReturningOne();\n",
        "1133": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new IOException());\n",
        "1134": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "1135": "        Futures.catchingAsync(originalFuture, Throwable.class, fallback);\n",
        "1136": "    assertEquals(1, (int) faultTolerantFuture.get());\n",
        "1137": "  }\n",
        "1138": "\n",
        "1139": "  @GwtIncompatible(\"non-Throwable exceptionType\")\n",
        "1140": "  public void testCatchingAsync_customTypeMatch() throws Exception {\n",
        "1141": "    AsyncFunction<IOException, Integer> fallback = asyncFunctionReturningOne();\n",
        "1142": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new FileNotFoundException());\n",
        "1143": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "1144": "        Futures.catchingAsync(originalFuture, IOException.class, fallback);\n",
        "1145": "    assertEquals(1, (int) faultTolerantFuture.get());\n",
        "1146": "  }\n",
        "1147": "\n",
        "1148": "  @GwtIncompatible(\"non-Throwable exceptionType\")\n",
        "1149": "  public void testCatchingAsync_customTypeNoMatch() throws Exception {\n",
        "1150": "    AsyncFunction<IOException, Integer> fallback = asyncFunctionReturningOne();\n",
        "1151": "    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new RuntimeException());\n",
        "1152": "    ListenableFuture<Integer> faultTolerantFuture =\n",
        "1153": "        Futures.catchingAsync(originalFuture, IOException.class, fallback);\n",
        "1154": "    try {\n",
        "1155": "      faultTolerantFuture.get();\n",
        "1156": "      fail();\n",
        "1157": "    } catch (ExecutionException expected) {\n",
        "1158": "      assertTrue(expected.getCause() instanceof RuntimeException);\n",
        "1159": "    }\n",
        "1160": "  }\n",
        "1161": "\n",
        "1162": "  private <X extends Throwable> Function<X, Integer> functionReturningOne() {\n",
        "1163": "    return new Function<X, Integer>() {\n",
        "1164": "      @Override\n",
        "1165": "      public Integer apply(X t) {\n",
        "1166": "        return 1;\n",
        "1167": "      }\n",
        "1168": "    };\n",
        "1169": "  }\n",
        "1170": "\n",
        "1171": "  private <X extends Throwable> AsyncFunction<X, Integer> asyncFunctionReturningOne() {\n",
        "1172": "    return new AsyncFunction<X, Integer>() {\n",
        "1173": "      @Override\n",
        "1174": "      public ListenableFuture<Integer> apply(X t) {\n",
        "1175": "        return immediateFuture(1);\n",
        "1176": "      }\n",
        "1177": "    };\n",
        "1178": "  }\n",
        "1179": "\n"
    },
    "removed": {
        "541": "    assertEquals(0, spy.getApplyCount());\n",
        "543": "    assertEquals(1, spy.getApplyCount());\n",
        "545": "    assertEquals(2, spy.getApplyCount());\n",
        "572": "  @GwtIncompatible(\"used only in GwtIncompatible tests\")\n",
        "574": "\n",
        "588": "    public int getApplyCount() {\n",
        "589": "      return applyCount;\n",
        "620": "      public ListenableFuture<V> create(Throwable t) throws Exception {\n"
    }
}